var RxCoreMulti = (function() {
    RxCore = function () {
    'use strict';
    var globalscope = this;
    /* Andriy: aliases from old names */
    /* I simply do not want to change this in the code, just make aliases */
    var xmlurl = RxConfig.xmlurl;
    var xmlurldirect = RxConfig.xmlurldirect;
    var xmlurlmarkup = RxConfig.xmlurlmarkup;
    var opensessionurl = RxConfig.opensessionurl;
    var openMsessionurl = RxConfig.openMsessionurl;
    var openUsessionurl = RxConfig.openUsessionurl;
    var closesessionurl = RxConfig.closesessionurl;
    var xmlurlmarkupsave = RxConfig.xmlurlmarkupsave;
    var FileuploadURL = RxConfig.FileuploadURL;
    var PDFExportURL = RxConfig.PDFExportURL;
    var CanvasSaveUrl = RxConfig.CanvasSaveUrl;
    var UploadServerfolder = RxConfig.UploadServerfolder;
    var UploadServerfolderd = RxConfig.UploadServerfolderd;
    var xmlurlrel = RxConfig.xmlurlrel;
    var xmlurlrelmarkup = RxConfig.xmlurlrelmarkup;
    var uploadfolderURL = RxConfig.uploadfolderURL;
    var htmlviewerurl = RxConfig.htmlviewerurl;
    var splashscreen = RxConfig.splashscreen;
    var noteImgSrc = RxConfig.noteImgSrc;
    var bGetconfig = RxConfig.bGetconfig;
    var bUseID = RxConfig.bUseID;
    var configurationLocation = RxConfig.configurationLocation;

    /* Andriy: aliases fromc old names: end */

    var userInfoURL = '';
    var bUseCustomrelpath = false;
    var bUsecustomConfig = false;
    var xmlurlrelcustom = "";

    /* Andriy: added init state */

    var initialized = false;

    /* Andriy: end */

    var rxcoreversion = 27.8;
    var rxcontainer, canvas, context, canvaso, contexto, canvimg, cntximg, canvas3D, magcanvas, magctx;
    var scene, camera, renderer;
    /*var globalPlaneX = new THREE.Plane( new THREE.Vector3( 1, 0, 0 ), 0 );
    var globalPlaneY = new THREE.Plane( new THREE.Vector3( 0, 1, 0 ), 0 );
    var globalPlaneZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), 0 );
    var globalPlanes = [ globalPlaneX,globalPlaneY,globalPlaneZ ],*/
    var Empty = Object.freeze( [] );

    //var geometry, material, mesh;

    /* default offset for canvas */

    var defaultLayout = {
        offsetWidth:0,
        offsetHeight:0
    };

    var magnifysize = {
        width : 225,
        height : 150
    };

    var fixedScaleSize = {
        width : 1920,
        height : 1080
    };

    /* GUI Connector object variables*/
    var RxCore_GUI_Users = undefined;
    var RxCore_GUI_MarkupLayers = undefined;
    var Rxcore_GUI_exportComplete = undefined;
    var RxCore_GUI_FileInfo = undefined;
    var Rxcore_GUI_fileLoadComplete = undefined;
    var Rxcore_GUI_markupLoadComplete = undefined;
    var Rxcore_GUI_pageLoadComplete = undefined;
    var Rxcore_GUI_PDFRenderComplete = undefined;
    var RxCore_GUI_pagethumbs = undefined;
    var Rxcore_GUI_pagedimLoadComplete = undefined;
    var RxCore_GUI_VectorLayers = undefined;
    var RxCore_GUI_VectorBlocks = undefined;
    var RxCore_GUI_VectorBlocksLoaded = undefined;
    var RxCore_GUI_3DParts = undefined;
    var RxCore_GUI_Read3DComplete = undefined;
    var Rxcore_GUI_3DPartInfo = undefined;
    var RxCore_GUI_2DBlockID = undefined;
    var RxCore_GUI_2DBlockInfo = undefined;
    var RxCore_GUI_Markuplist = undefined;
    var RxCore_GUI_Stamps = undefined;
    var RxCore_GUI_CustomStamps = undefined;
    var RxCore_GUI_Symbols = undefined;
    var RxCore_GUI_Measurediag = undefined;
    var RxCore_GUI_Calibratediag = undefined;
    var RxCore_GUI_CalibrateComplete = undefined;
    var RxCore_GUI_Textdiag = undefined;
    var RxCore_GUI_TextInput = undefined;
    var RxCore_GUI_Notediag = undefined;
    var RxCore_GUI_State = undefined;
    var RxCore_GUI_Page = undefined;
    var RxCore_GUI_Markup = undefined;
    var RxCore_GUI_MarkupLink = undefined;
    var RxCore_GUI_MarkupUnselect = undefined;
    var RxCore_GUI_Upload = undefined;
    var RxCore_GUI_Download = undefined;
    var RxCore_GUI_Birdseye = undefined;
    var RxCore_GUI_Magnify = undefined;
    var RxCore_GUI_Resize = undefined;
    var RxCore_GUI_3DWalkthrough = undefined;
    var RxCore_GUI_CompareDiag = undefined;
    var RxCore_GUI_CompareAlign = undefined;
    var RxCore_GUI_Consolidate = undefined;
    var RxCore_GUI_Permissions = undefined;
    var RxCore_GUI_PDFBookmarks = undefined;
    var RxCore_GUI_PagePosition = undefined;
    var RxCore_GUI_PanUpdate = undefined;
    var RxCore_GUI_PanUpdated = undefined;
    var RxCore_GUI_ZoomUpdate = undefined;
    var RxCore_GUI_ZoomUpdated = undefined;
    var RxCore_GUI_MarkupSave = undefined;
    var RxCore_GUI_Ready = undefined;
    var RxCore_GUI_RotatePage = undefined;
    var RxCore_GUI_HasText = undefined;
    var RxCore_GUI_NumMathces = undefined;
    var RxCore_GUI_printpage = undefined;
    var RxCore_GUI_printCompare = undefined;
    var RxCore_GUI_CompareMeasure = undefined;
    var RxCore_GUI_markupdrawParams = undefined;
    var RxCore_GUI_MarkupAreaEdit = undefined;
    var RxCore_GUI_markupParamsError = undefined;
    var RxCore_GUI_getResponsHeaders = undefined;

    var canvasowidth = 0;
    var canvasoheight = 0;

    var dragdropfilename = "";

    var bIsMSIE = false;
    var szdispvalue = "initial";
    var szLicenCompanyFeature = "";


    var imagewidth = 0,
        imageheight = 0;
    var drotation = 0;
    var imageswitchfactor = 1.5;
    var imageloaded = false;
    var documentopen = false;
    var documentcompare = false;
    var doCompare = false;
    var compareMode = 0;
    //var markuploaded = false;
    //var bMarkupchanged = false;
    var bLicenseAquired = false;
    var bUseCompanyFeature = false;
    var bPDFExportfullPath = false;
    var bMarkupSavecheck = true;
    var bUseFixedScale = true;
    //var bUsemouseinput = true;
    var bPrintpageloaded = false;
    var bAbortPageload = false;
    var bUseCredentials = false;
    var bLimMarkupExtent = true;
    var bKeepVectorColor = false;
    var bMarkupPostOnly = false;
    var bSingleDocmode = false;
    var bDoReScaleOnSize = true;
    var bPDFZoomAllinit = false;
    var bSuspendDraw = false;
    var bRestrictPan = true;
    var bLimitZoomOut = true;
    var bScrollZoomOverlay = false;
    var bAnimatePDFrender = false;
    var bDisableMSIE11Eventcheck = false;
    var bAutoloadThumbnails = true;
    var bLabelsOff = false;
    var bmarkupLabels = true;

    var printWin = 0;
    var PDFExpWin = 0;
    var DocXMLPrint;
    var PaperWidth = 0;
    var PaperHeight = 0;
    var Paper;
    var PDFExportFileURL = "";
    var PrintPageURL = "printcanvas.htm";
    var LicenseID = "";
    var OEMFlag =  RxConfig.OemFlag || '';

    var backgroundColor = "#FFFFFF";

    var backgroundCustomColor = "#FF0000";
    var bCustomColor = false;

    var bMultiselect = false;


    var displayBGColor = "rgb(62,62,62)";
    var nScrollKeyNum = 17;
    var nMaximageArea = 64000000;
    var nMaximageAreaIPad = 5000000;
    var nLargePDF = 50;
    var bIsmobile = false;

    var overlayBGColor = '#0000ff';
    var overlayFGColor = '#ff8000';

    var bOpeninitialdoc = false;
    var OpeninitialdocURL = "";

    var initialDoc = {
        open : bOpeninitialdoc,
        url : OpeninitialdocURL,
        custom : false
    };

    var bMarkupcrated = false;
    var bNoteFocus = false;
    var bUseScrollKey = false;
    var bOrthoOn = false;
    var nOrthoDegree = 90;
    var nMarkupcreated = -1;
    var bMultimarkupadd = false;
    var bAnimateready = false;
    var bPDFtemprender = false;
    var bPDFtemprendermag = false;

    var lastTouchdata = -1;
    var Canvasheight = 0;
    var Canvaswidth = 0;

    var nlinestyleinterval = 0;
    var bAnimateLineStyle = false;
    //1 = metric, 2 = Imperial, 3 = System, 4=Custom
    var Unitofmeasure = 1;
    var Unitlabel = "mm";
    var AreaUnitlabel = "mm\u00B2";
    var MeasureScale = 1.0;
    var nCalibrateScale = 1.0;
    var nCalibrateMeasured = 0.0;
    var nCalibrateSet = 0.0;
    var nArrowSize = 20;
    var nPanlimit = 15;
    var nLabelTextsize = 12;
    var bUsemarkupbyref = false;
    var bUsemarkupbyrefEx = false;
    //mm = 1 meter = 1000 for metric units.
    var unitscale = 1;
    var fTextScale = 0.95;
    //1 = Millimeter, 2 = Centimeter, 3 = Decimeter, 4=Meter,5=Kilometer,6=Nautical Miles
    //1 = Inch,2=Feet,3=Yard,4=Mile,5=Nautical Miles
    var SubmeasureUnit = 1;
    var nFractionRes = 32; // 1/32
    var bUseFraction = true;

    // 0 = large 1=small
    var imagesize = 0;
    //array to hold markup objects
    var byrefmarkupfiles = [];


    //var markuplist = [];
    //var markupundolist = [];
    var markupprintlist = [];
    //var markupfiles = [];
    var Userlist = [];
    var Stamplist = [];
    var rotatepagearrs = [];
    var numUsers = 0;
    var Layerlist = [];
    var numLayers = 0;
    var configJSON = {};
    //var nummarkups = 0;
    //var curcontrol3D = 'orbitControl';

    //var SzNoteText = "";

    /* Andriy: start, reason: unused variables */
    /*
     //tool state flags
     var bZoomWindow = false;
     var bPan = false;
     var bMarkupEdit = false;
     var bCalibrate = false;
     var bMarkupHide = false;
     var bMarkuperase = false;
     var bMarkupText = false;
     var bMarkupNote = false;
     var bMarkupStamp = false;
     var bMarkupLine = false;
     var bMarkupArrow = false;
     var bMarkupShape = false;
     var bMarkupDimension = false;
     var bMarkupArea = false;
     var bMarkupMarker = false;
     var bMarkupOutline = true;
     var bMarkupEdged = false;
     var bMarkupFilled = false;
     var bMarkupHatched = false;
     var bMeasure = false;
     */
    /* Andriy: end, reason: unused variables */


    //global configuration variables
    var markuplayer = 1;
    var markupcolor = "#FF0000";
    var markupfillcolor = "#FF0000";
    var markuplinecolor = "#FF0000";
    var markuptextcolor = "#FF0000";

    var globaltransparency = 100;
    var signature = "Default";
    var DisplayName = "Default";
    var fontstylevalue = "Arial";

    var linewidthvalue = 4;
    //var Linestylevalue = "_______";
    var HatchStyle = 0;
    var fillstyle = 0;
    var nlinestyle = 0;

    var bCanChangeLayer = true;
    var bCanChangeSignature = false;
    var bCanConsolidate = false;
    var bSetGlobal = false;
    var readonlymode = false;

    //var bGetconfig = true;
    var bRefreshmarkup = false;
    var bReverseScale = false;
    //var bMarkupLocked = false;
    var bMarkupNoLabel = false;
    var bConsolidate = false;
    var bShowDiffonly = false;

    var locationSearchSet = false;
    var szLocationSearch = "";
    var szLatestresponseHeaders = "";
    var szdrawmode = 'xor';

    //this.szBlockLoadMask = "*";

    //global configuration variables

//global configuration variables

    var consolidateObj = {
        isactive : false,
        consolidatelist : [],
        add : function(markup,settings,last){
            var listobj = {markup : markup, settings : settings};
            this.consolidatelist.push(listobj);
            if(last){
                while(this.consolidatelist.length > 0){
                    var consitem = this.consolidatelist.pop();
                    consitem.markup.Consolidate(consitem.settings);

                }
            }

        }
    };

    //note image
    var noteimage = new Image();
    /* ANDRIY: start */
    //noteimage.src = 'images/note.png';
    if (noteImgSrc){
        noteimage.src = noteImgSrc;
    }

    // noteimage.src = '';
    /* ANDRIY: end */
    var TempID; //placeholder for notemarkup so that we can assign text from note dialog.

    var markupimage = new Image();
    markupimage.src = '';


    //hatch patterns
    //var hatchdiagforw = new Image();
    //hatchdiagforw.src = 'images/hatchdiagonalforward.png';


    var pattern = document.createElement('canvas');

    //hatch patterns

    //var display images;
    var splashimage = document.createElement('img'); //new Image();
    //var myimage = document.createElement('img');//new Image();
    //var myimagesmall = document.createElement('img');//new Image();
    //var myimagethumb = document.createElement('img');//new Image();
    //var Thumbnailpopup = "<p>No images loaded";
    //var Layerspopup = "<table><tr><td>Name</td><td>Color</td>State</td></tr></table>";

    //Document index.
    var nCurdocindex = 0;

    // The active tool instance.
    var tool;
    var tool_default = 'default';
    var szcurTool = 'default';
    // This object holds the implementation of each drawing tool.
    var tools = {};

    //var clock = new THREE.Clock();

    var DocObj;
    var CompareObj;
    //var SzMainImageSRC;
    //var SzSmallImageSRC;
    //var SzThumbImageSRC;

    // var DocumentObject = {}; //Document object
    // var PageObject = {}; //Document object

    var point = {}; //point object
    //var lineangle = {}; //line object
    /*Andriy: it's already declared below, var MarkupObject = {}; //General markup object
     var MarkupUndoObject = {}; //object for undo tracking */
    var OpenFiles = [];

    var CompareFiles = [];
    var OpenfileNames = [];


    var lineangle = function (startx, starty, endx, endy) {
        this.startx = startx;
        this.starty = starty;
        this.endx = endx;
        this.endy = endy;
        this.width = endx - startx;
        this.height = endy - starty;

        var rewidth = startx - endx;
        var reheight = starty - endy;

        this.angle = Math.atan2(this.height, this.width);
        this.reangle = Math.atan2(reheight, rewidth);
        this.rehangle = Math.atan2(this.height, rewidth);
        this.rewangle = Math.atan2(reheight, this.width);

    };




    var TouchPoint = function (TouchID, x, y) {
        this.pointID = TouchID;
        this.x = x;
        this.y = y;

    };

    var FontObject = function (FontName, Height, bold, italic) {
        var scope = this;

        this.fontName = FontName;
        this.height = Height;
        this.bold = bold;
        this.italic = italic;
        this.scale = 1;

        var scaledheigth = this.height * this.scale;

        if (bold) {
            this.fontstring = "bold " + this.height + "pt " + this.fontName;
            this.fontstringScaled = "bold " + scaledheigth + "pt " + this.fontName;
        } else if (italic) {
            this.fontstring = "italic " + this.height + "pt " + this.fontName;
            this.fontstringScaled = "italic " + scaledheigth + "pt " + this.fontName;
        } else {
            this.fontstring = "normal " + this.height + "pt " + this.fontName;
            this.fontstringScaled = "normal " + scaledheigth + "pt " + this.fontName;
        }




        this.setFontname = function (FontName) {
            this.fontName = FontName;
            updateFont();
        };
        this.setHeight = function (Height) {
            this.height = Height;
            updateFont();
        };

        this.setBold = function (bOnOff) {

            this.bold = bOnOff;

            if (bOnOff){
              this.italic = false;
            }

            updateFont();
        };
        this.setItalic = function (bOnOff) {
            this.italic = bOnOff;

            if(bOnOff){
              this.bold = false;
            }

            updateFont();
        };

        this.setScale = function(scale){
            this.scale = scale;
            updateFont();
        };


        function updateFont() {
            var scaledheigth = scope.height * scope.scale;
            if (scope.bold) {
                scope.fontstring = "bold " + scope.height + "pt " + scope.fontName;
                scope.fontstringScaled = "bold " + scaledheigth + "pt " + scope.fontName;
            } else if (scope.italic) {
                scope.fontstring = "italic " + scope.height + "pt " + scope.fontName;
                scope.fontstringScaled = "italic " + scaledheigth + "pt " + scope.fontName;
            } else {
                scope.fontstring = "normal " + scope.height + "pt " + scope.fontName;
                scope.fontstringScaled = "normal " + scaledheigth + "pt " + scope.fontName;

            }
        }

    };
    var defaultFont = new FontObject(fontstylevalue, 18, false, false);

    function createCORSRequest(method, url) {
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        if ("withCredentials" in xhr) {

          // Check if the XMLHttpRequest object has a "withCredentials" property.
          // "withCredentials" only exists on XMLHTTPRequest2 objects.
          xhr.open(method, url, true);

        } else if (typeof XDomainRequest != "undefined") {

          // Otherwise, check if XDomainRequest.
          // XDomainRequest only exists in IE, and is IE's way of making CORS requests.
          xhr = new XDomainRequest();
          xhr.open(method, url);

        } else {

          // Otherwise, CORS is not supported by the browser.
          xhr = null;

        }
        return xhr;
    }


    function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {

        // Check if none of the lines are of length 0
          if ((x1 === x2 && y1 === y2) || (x3 === x4 && y3 === y4)) {
              return false;
          }

         var denominator = ((y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1));

        // Lines are parallel
          if (denominator === 0) {
              return false;
          }

          var ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denominator;
          var ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denominator;

        // is the intersection along the segments
          if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
              return false;
          }

        // Return a object with the x and y coordinates of the intersection
          var x = x1 + ua * (x2 - x1);
          var y = y1 + ua * (y2 - y1);

          return {x, y};
      }


    function ortho_rotate(point){
        var centercanvX = (canvasowidth / 2);
        var centercanvY = (canvasoheight / 2);
        var CanvRotRad = 0;
        var transpoint = {x:point.x,y:point.y};

        switch(DocObj.pages[DocObj.currentpage].drotation){
            case 0:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                return transpoint;
                break;
            case 90:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
                break;
            case 270:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
                break;
            case 180:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                break;
        }

        var cosangle = Math.cos(CanvRotRad);
        var sinangle = Math.sin(CanvRotRad);

        var hw = point.x - centercanvX;
        var hh = point.y - centercanvY;

        var newx = (hw * cosangle) - (hh * sinangle);
        var newy = (hw * sinangle) + (hh * cosangle);

        transpoint = {x:newx,y:newy};
        transpoint.x = centercanvX + transpoint.x;
        transpoint.y = centercanvY + transpoint.y;

        return transpoint;

    }

    function snap_rotated(point){
        var centercanvX = (canvasowidth / 2);
        var centercanvY = (canvasoheight / 2);
        var CanvRotRad = 0;
        var transpoint = {found:point.found,x:point.x,y:point.y};
        var bnochange = false;


        switch(DocObj.pages[DocObj.currentpage].drotation){
            case 0:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                bnochange = true;
                //return transpoint;
                break;
            case 90:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
                break;
            case 270:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
                break;
            case 180:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                break;
        }

        var cosangle = Math.cos(CanvRotRad);
        var sinangle = Math.sin(CanvRotRad);

        var hw = transpoint.x - centercanvX;
        var hh = transpoint.y - centercanvY;

        var newx = (hw * cosangle) - (hh * sinangle);
        var newy = (hw * sinangle) + (hh * cosangle);

        if(bnochange){

        }else{
            transpoint.x = centercanvX + newx;
            transpoint.y = centercanvY + newy;
        }
        /*transpoint = {x:newx,y:newy};
        transpoint.x = centercanvX + transpoint.x;
        transpoint.y = centercanvY + transpoint.y;*/

        return transpoint;

    }

    function isObjectEqual(a, b) {
        // Create arrays of property names
        var aProps = Object.getOwnPropertyNames(a);
        var bProps = Object.getOwnPropertyNames(b);

        // If number of properties is different,
        // objects are not equivalent
        if (aProps.length != bProps.length) {
            return false;
        }

        for (var i = 0; i < aProps.length; i++) {
            var propName = aProps[i];

            // If values of same property are not equal,
            // objects are not equivalent
            if (a[propName] !== b[propName]) {
                return false;
            }
        }

        // If we made it this far, objects
        // are considered equivalent
        return true;
    }


    function rect_rotated(x1,y1,x2,y2){
        var centercanvX = (canvasowidth / 2);
        var centercanvY = (canvasoheight / 2);
        var CanvRotRad = 0;
        var transrect = {x1:x1,x2:x2,y1:y1,y2:y2};

        switch(DocObj.pages[DocObj.currentpage].drotation){
            case 0:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                return transrect;
                break;
            case 90:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation + 180) * (Math.PI / 180);
                //CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
                break;
            case 270:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation - 180) * (Math.PI / 180);
                //CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
                break;
            case 180:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                break;
        }

        var cosangle = Math.cos(CanvRotRad);
        var sinangle = Math.sin(CanvRotRad);

        var hw = x1 - centercanvX;
        var hh = y1 - centercanvY;

        var newx = (hw * cosangle) - (hh * sinangle);
        var newy = (hw * sinangle) + (hh * cosangle);

        var hw2 = x2 - centercanvX;
        var hh2 = y2 - centercanvY;

        var newx2 = (hw2 * cosangle) - (hh2 * sinangle);
        var newy2 = (hw2 * sinangle) + (hh2 * cosangle);


        transrect = {x1:newx,y1:newy, x2:newx2, y2:newy2};
        transrect.x1 = centercanvX + transrect.x1;
        transrect.y1 = centercanvY + transrect.y1;
        transrect.x2 = centercanvX + transrect.x2;
        transrect.y2 = centercanvY + transrect.y2;

        switch(DocObj.pages[DocObj.currentpage].drotation){
            case 90:
                var tempy = transrect.y2;
                transrect.y2 = transrect.y1;
                transrect.y1 = tempy;
                break;
            case 270:
                var tempx = transrect.x2;
                transrect.x2 = transrect.x1;
                transrect.x1 = tempx;
                break;
            case 180:
                tempy = transrect.y2;
                transrect.y2 = transrect.y1;
                transrect.y1 = tempy;
                tempx = transrect.x2;
                transrect.x2 = transrect.x1;
                transrect.x1 = tempx;
                break;
        }

        return transrect;

    }

    function mouse_rotated(x,y){
        var centercanvX = (canvasowidth / 2);
        var centercanvY = (canvasoheight / 2);
        var CanvRotRad = 0;
        var transpoint = {x:x,y:y};

        switch(DocObj.pages[DocObj.currentpage].drotation){
            case 0:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                return transpoint;
                break;
            case 90:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation + 180) * (Math.PI / 180);
                break;
            case 270:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation - 180) * (Math.PI / 180);
                break;
            case 180:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                break;
        }

        var cosangle = Math.cos(CanvRotRad);
        var sinangle = Math.sin(CanvRotRad);

        var hw = x - centercanvX;
        var hh = y - centercanvY;

        var newx = (hw * cosangle) - (hh * sinangle);
        var newy = (hw * sinangle) + (hh * cosangle);

        transpoint = {x:newx,y:newy};
        transpoint.x = centercanvX + transpoint.x;
        transpoint.y = centercanvY + transpoint.y;

        return transpoint;


    }

    function getrotpoint(width, height, x, y, anglerad){
        var cosangle = Math.cos(anglerad);
        var sinangle = Math.sin(anglerad);

        var hw = x - width;
        var hh = y - height;

        var newx = (hw * cosangle) - (hh * sinangle);
        var newy = (hw * sinangle) + (hh * cosangle);

        var transpoint = {x:newx, y:newy};
        transpoint.x = width + transpoint.x;
        transpoint.y = height + transpoint.y;
        return transpoint;

    }

    function rotate_pointrad(point, originX, originY, radians) {

        //var new_x_point = old_x_point * cos(Angle) - old_y_point * sin(Angle);
        //var new_y_point = old_y_point * cos(Angle) + old_x_point * sin(Angle);

        var transpx = point.x - originX;
        var transpy = point.y - originY;


        return {
            x: (Math.cos(radians) * (transpx) - Math.sin(radians) * (transpy)) + originX,
            y: (Math.sin(radians) * (transpx) + Math.cos(radians) * (transpy)) + originY
        };
    }

    function rotate_point(point, originX, originY, angle) {
        angle = angle * Math.PI / 180.0;
        return {
            x: Math.cos(angle) * (point.x-originX) - Math.sin(angle) * (point.y-originY) + originX,
            y: Math.sin(angle) * (point.x-originX) + Math.cos(angle) * (point.y-originY) + originY
        };
    }


    function setTransp(color, opacity) {
        var colors = color.split(",");
        var r = colors[0].split("(");
        r = r[1].trim();
        var g = colors[1].trim();
        var b = colors[2].trim();
        var alpha = colors[3].trim();

        return "rgba(" + r + "," + g + "," + b + "," + opacity / 100 + ")";


    }

    //Short code
    function matchRuleShort(str, rule) {
        return new RegExp("^" + rule.split("*").join(".*") + "$").test(str);
    }

    function rgbToHex(color) {
        var bg = color.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);

        function hex(x) {
            return ("0" + parseInt(x).toString(16)).slice(-2);
        }

        return "#" + hex(bg[1]) + hex(bg[2]) + hex(bg[3]);
    }

    function convertHex(hex, opacity) {
        hex = hex.replace('#', '');
        var r = parseInt(hex.substring(0, 2), 16);
        var g = parseInt(hex.substring(2, 4), 16);
        var b = parseInt(hex.substring(4, 6), 16);

        var result = 'rgba(' + r + ',' + g + ',' + b + ',' + opacity / 100 + ')';
        return result;
    }

    function convertHexrgb(hex) {
        hex = hex.replace('#', '');
        var r = parseInt(hex.substring(0, 2), 16);
        var g = parseInt(hex.substring(2, 4), 16);
        var b = parseInt(hex.substring(4, 6), 16);

        return {
            r : r,
            g : g,
            b : b
        };

    }

    function getBase64Image(img) {
        // Create an empty canvas element
        var canvas = document.createElement("canvas");
        canvas.width = img.width;
        canvas.height = img.height;

        // Copy the image contents to the canvas
        var ctx = canvas.getContext("2d");
        ctx.drawImage(img, 0, 0);

        // Get the data-URL formatted image
        // Firefox supports PNG and JPEG. You could check img.src to
        // guess the original format, but be aware the using "image/jpg"
        // will re-encode the image.
        var dataURL = canvas.toDataURL("image/png");
        dataURL = "<![CDATA[" + dataURL + "]]>";

        //return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
        return dataURL;

    }

    function getChildNodes(node) {
        var children = new Array();
        for(var child in node.childNodes) {
            if(node.childNodes[child].nodeType == 1) {
                children.push(node.childNodes[child]);
            }
        }
        return children;
    }

    function splitstring(context, text, maxwidth, resultarray){
        var test = text;
        var bNeedsplit = false;

        var metrics = context.measureText(test);
        while (metrics.width > maxwidth && test.length > 1) {
            // Determine how much of the word will fit
            test = test.substring(0, test.length - 1);
            metrics = context.measureText(test);
        }

        if (text != test) {
            resultarray.push(test);
            var remainer = text.substr(test.length);
            metrics = context.measureText(remainer);
            if(metrics.width > maxwidth){
                bNeedsplit = true;
            }else{
                bNeedsplit = false;
                resultarray.push(remainer);
            }

        }else{
            resultarray.push(test);
            bNeedsplit = false;

        }

        return {
           bNeedSplit : bNeedsplit,
           remainer : remainer,
           resultarray : resultarray
        };


    }

    function wrapText (context, text, x, y, maxWidth, lineHeight) {

        var bNeedsplit = true;
        var line = '',
            lineCount = 0,
            i,
            test,
            metrics;

        var crlines = text.split('\n');
        var words = [];
        var splitwords = [];

        for (var crn = 0;crn < crlines.length;crn++){
            line = '';
            lineCount = 0;
            i = 0;
            var metrics = context.measureText(crlines[crn]);
            if (metrics.width > maxWidth ){
                words = words.concat(crlines[crn].split(' '));
                words.push('\n');
            }else{
                words.push(crlines[crn]);
                words.push('\n');

            }


        }

        for (i = 0; i < words.length; i++) {

            if(words[i] != '\n'){
                var splitresult = splitstring(context, words[i], maxWidth,splitwords);

                while(splitresult.bNeedSplit){
                    splitresult = splitstring(context, splitresult.remainer, maxWidth,splitwords);
                }
            }else{
                splitwords.push(words[i]);
            }


        }

        var bConcat = true;
        for (i = 0; i < splitwords.length; i++) {
            if(splitwords[i] != '\n'){

                test = line + splitwords[i] + ' ';

                metrics = context.measureText(test);

                if (metrics.width > maxWidth && i > 0) {
                    context.fillText(line, x, y);
                    line = splitwords[i] + ' ';
                    y += lineHeight;
                    lineCount++;
                }
                else {
                    line = test;
                }

            }else{
                bConcat = false;
                context.fillText(line, x, y);
                line = '';
                y += lineHeight;

            }

        }

        /*context.fillText(line, x, y);
        y += lineHeight;*/

        //var words = text.split(' ');


    }



    function wordWrap(str, maxWidth) {
        var newLineStr = "\n";
        var done = false;
        var res = '';
        do {
            var found = false;
            // Inserts new line at first whitespace of the line
            for (var i = maxWidth - 1; i >= 0; i--) {
                if (testWhite(str.charAt(i))) {
                    res = res + [str.slice(0, i), newLineStr].join('');
                    str = str.slice(i + 1);
                    found = true;
                    break;
                }
            }
            // Inserts new line at maxWidth position, the word is too long to wrap
            if (!found) {
                res += [str.slice(0, maxWidth), newLineStr].join('');
                str = str.slice(maxWidth);
            }

            if (str.length < maxWidth)
                done = true;
        } while (!done);

        return res + str;
    }

    function testWhite(x) {
        var white = new RegExp(/^\s$/);
        return white.test(x.charAt(0));
    }

    point = function (x, y) {
        this.x = x;
        this.y = y;
    };

    var PaperSize = function (width, height) {
        this.width = width;
        this.height = height;
    };

    var Rectangle = function (x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    };

    var Users = function (Signature, DispName, Layer, Color) {
        this.Signature = Signature;
        this.DisplayName = DispName;
        this.Layer = Layer;
        this.Color = Color;
        this.display = true;

    };

    var Layers = function (Number, Color, Name, Display) {
        this.Layer = Number;
        //this.Name = "Layer " + Number;
        this.Name = Name;
        this.Color = Color;
        this.display = Display;

    };

    function GetDisplayName(sign) {
        var signfound = false;
        var displayname = 'default user';

        for (var i = 0; i < Userlist.length; i++) {
            if (Userlist[i].Signature == sign) {
                signfound = true;
                displayname = Userlist[i].DisplayName;

            }
        }
        return displayname;
    }

    function getSignState(sign){
        var signfound = false;
        var displaystate = true;

        for (var i = 0; i < Userlist.length; i++) {
            if (Userlist[i].Signature == sign) {
                signfound = true;
                displaystate = Userlist[i].display;

            }
        }
        return displaystate;

    }

    function getMarkupLayerColor(layer){
        var layerfound = false;
        var layerColor = '#FF0000';

        for (var i = 0; i < Layerlist.length; i++) {
            if (Layerlist[i].Layer == layer) {
                layerfound = true;
                layerColor = Layerlist[i].Color;

            }
        }

        return layerColor;

    }
    function getMarkupLayerState(layer){
        var layerfound = false;
        var displaystate = true;

        for (var i = 0; i < Layerlist.length; i++) {
            if (Layerlist[i].Layer == layer) {
                layerfound = true;
                displaystate = Layerlist[i].display;

            }
        }
        return displaystate;

    }


    function isEven(value) {
        return (value % 2 == 0);
        //    return true;
        //else
        //    return false;
    }

    function decimalToHex(d) {
        var hex = Number(d).toString(16);
        hex = "000000".substr(0, 6 - hex.length) + hex;
        hex = hex.toUpperCase();
        hex = "#" + hex;
        return hex;
    }

    function getDiagonal(width, height){
        var dimwsq = Math.pow(width, 2);
        var dimhsq = Math.pow(height, 2);
        var dimdiag = Math.sqrt((dimwsq + dimhsq));

        return dimdiag;

    }

    function MousePosradiusdrwext(centre, mousepos) {

        var bIswithin = false;

        var xdiff = Math.max(centre.x, mousepos.x) - Math.min(centre.x, mousepos.x);
        var ydiff = Math.max(centre.y, mousepos.y) - Math.min(centre.y, mousepos.y);

        var radius = getDiagonal(xdiff, ydiff);

        var radiusnegx = centre.x - radius;
        var radiusposx = centre.x + radius;
        var radiusnegy = centre.y - radius;
        var radiusposy = centre.y + radius;


        if(DocObj.pages[DocObj.currentpage].drotation == 0){

            if (radiusnegx > DocObj.pages[DocObj.currentpage].startx && radiusposx < DocObj.pages[DocObj.currentpage].endx){
                if(radiusnegy > DocObj.pages[DocObj.currentpage].starty && radiusposy < DocObj.pages[DocObj.currentpage].endy){
                    bIswithin = true;
                }

            }
            if (bIswithin){
                if (mousepos.x > DocObj.pages[DocObj.currentpage].startx && mousepos.x < DocObj.pages[DocObj.currentpage].endx) {
                    if (mousepos.y > DocObj.pages[DocObj.currentpage].starty && mousepos.y < DocObj.pages[DocObj.currentpage].endy) {
                        bIswithin = true;
                    }
                }
            }

        }else{
            var rotrect = DocObj.pages[DocObj.currentpage].rotatedRect();

            if (radiusnegx > rotrect.x && radiusposx < rotrect.w){
                if(radiusnegy > rotrect.y && radiusposy < rotrect.h){
                    bIswithin = true;
                }
            }
            if(bIswithin){
                if (mousepos.x > rotrect.x && mousepos.x < rotrect.w) {
                    if (mousepos.y > rotrect.y && mousepos.y < rotrect.h) {
                        bIswithin = true;
                    }
                }
            }
        }
        return bIswithin;
    }

    function MousePosdrwext(mousepos) {
        var bIswithin = false;

        if(DocObj.pages[DocObj.currentpage].drotation == 0){
            if (mousepos.x > DocObj.pages[DocObj.currentpage].startx && mousepos.x < DocObj.pages[DocObj.currentpage].endx) {
                if (mousepos.y > DocObj.pages[DocObj.currentpage].starty && mousepos.y < DocObj.pages[DocObj.currentpage].endy) {
                    bIswithin = true;
                }

            }

        }else{
            var rotrect = DocObj.pages[DocObj.currentpage].rotatedRect();

            if (mousepos.x > rotrect.x && mousepos.x < rotrect.w) {
                if (mousepos.y > rotrect.y && mousepos.y < rotrect.h) {
                    bIswithin = true;
                }

            }

        }
        return bIswithin;
    }

    function sqr(x) {
        return x * x;
    }

    function dist2(v, w) {
        return sqr(v.x - w.x) + sqr(v.y - w.y);
    }


    function compute2DPolygonCentroid(ptsorg){
        var pts = [];
        pts = ptsorg.slice();

        var centroid = {x:0, y:0};
        var signedArea = 0.0;
        var x0 = 0.0; // Current vertex X
        var y0 = 0.0; // Current vertex Y
        var x1 = 0.0; // Next vertex X
        var y1 = 0.0; // Next vertex Y
        var a = 0.0; // Partial signed area

        for (var i=0; i<pts.length-1; ++i){
            x0 = pts[i].x;
            y0 = pts[i].y;
            x1 = pts[i+1].x;
            y1 = pts[i+1].y;
            a = x0*y1 - x1*y0;
            signedArea += a;
            centroid.x += (x0 + x1)*a;
            centroid.y += (y0 + y1)*a;

        }
        // Do last vertex
        x0 = pts[i].x;
        y0 = pts[i].y;
        x1 = pts[0].x;
        y1 = pts[0].y;
        a = x0*y1 - x1*y0;
        signedArea += a;
        centroid.x += (x0 + x1)*a;
        centroid.y += (y0 + y1)*a;

        signedArea *= 0.5;
        centroid.x /= (6.0*signedArea);
        centroid.y /= (6.0*signedArea);
        return centroid;



    }
    function get_polygon_centroid(ptsorg) {

        var pts = [];
        pts = ptsorg.slice();

        var first = pts[0], last = pts[pts.length-1];
        if (first.x != last.x || first.y != last.y) pts.push(first);
        var twicearea=0,
            x=0, y=0,
            nPts = pts.length,
            p1, p2, f;
        for ( var i=0, j=nPts-1 ; i<nPts ; j=i++ ) {
            p1 = pts[i]; p2 = pts[j];
            f = p1.x*p2.y - p2.x*p1.y;
            twicearea += f;
            x += ( p1.x + p2.x ) * f;
            y += ( p1.y + p2.y ) * f;
        }
        f = twicearea * 3;
        return { x:x/f, y:y/f };
    }


    function distToSegmentSquared(p, v, w) {
        var l2 = dist2(v, w);
        if (l2 == 0) return dist2(p, v);
        var t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
        if (t < 0) return dist2(p, v);
        if (t > 1) return dist2(p, w);
        return dist2(p, {
            x:v.x + t * (w.x - v.x),
            y:v.y + t * (w.y - v.y)
        });
    }

    function distToSegment(p, v, w) {
        return Math.sqrt(distToSegmentSquared(p, v, w));
    }

    function areIntersecting(v1x1,v1y1,v1x2,v1y2,v2x1,v2y1,v2x2,v2y2){
        var a1 = v1y2 - v1y1;
        var b1 = v1x1 - v1x2;
        var c1 = (v1x2 * v1y1) - (v1x1 * v1y2);

        var d1 = (a1 * v2x1) + (b1 * v2y1) + c1;
        var d2 = (a1 * v2x2) + (b1 * v2y2) + c1;

        if (d1 > 0 && d2 > 0){
            return 0;
        }
        if (d1 < 0 && d2 < 0){
            return 0;
        }
        var a2 = v2y2 - v2y1;
        var b2 = v2x1 - v2x2;
        var c2 = (v2x2 * v2y1) - (v2x1 * v2y2);

        d1 = (a2 * v1x1) + (b2 * v1y1) + c2;
        d2 = (a2 * v1x2) + (b2 * v1y2) + c2;

        if (d1 > 0 && d2 > 0){
            return 0;
        }
        if (d1 < 0 && d2 < 0){
            return 0;
        }

        if ((a1 * b2) - (a2 * b1) == 0.0){
            return 2;
        }

        return 1;

    }

    function insidepolygonpoints(scalefactor,offsetx,offsety,mediax, mediay, mediah,path,mouse,startpoint){
        var intersections = 0;
        var rayx1 = startpoint.x;
        var rayy1 = startpoint.y;
        var rayx2 = mouse.x;
        var rayy2 = mouse.y;

        var sidex1 = 0;
        var sidey1 = 0;
        var sidex2 = 0;
        var sidey2 = 0;
        //var sides = 0;


        for (var counter = 0; counter < path.points.length; counter += 2) {

            sidex1 = ((path.points[counter] - mediax) * scalefactor);
            sidey1 = ((mediah - path.points[counter + 1]) * scalefactor);
            //close polygon if not closed
            if(counter + 3 < path.points.length){
                sidex2 = ((path.points[counter + 2] - mediax) * scalefactor);
                sidey2 = ((mediah - path.points[counter + 3]) * scalefactor);
            }else{
                sidex2 = ((path.points[0] - mediax) * scalefactor);
                sidey2 = ((mediah - path.points[1]) * scalefactor);

            }

            sidex1 += offsetx;
            sidey1 += offsety;
            sidex2 += offsetx;
            sidey2 += offsety;

            intersections += areIntersecting(rayx1,rayy1,rayx2,rayy2,sidex1,sidey1,sidex2,sidey2);
            //sides ++;

        }
        /*console.log(intersections);
        console.log('sides:' + sides);
        console.log(path.points.length);
        cntximg.strokeStyle = "black";
        cntximg.lineWidth = 2;
        cntximg.beginPath();
        cntximg.moveTo(rayx1,rayy1);
        cntximg.lineTo(rayx2,rayy2);
        cntximg.stroke();*/

        if(path.gotsubpath){
            for (var scount = 0; scount < path.subpaths.length; scount++) {
                for ( counter = 0; counter < path.subpaths[scount].points.length; counter += 2) {

                    sidex1 = ((path.subpaths[scount].points[counter] - mediax) * scalefactor);
                    sidey1 = ((mediah - path.subpaths[scount].points[counter + 1]) * scalefactor);
                    //close polygon if not closed
                    if(counter + 3 < path.subpaths[scount].points.length){
                        sidex2 = ((path.subpaths[scount].points[counter + 2] - mediax) * scalefactor);
                        sidey2 = ((mediah - path.subpaths[scount].points[counter + 3]) * scalefactor);
                    }else{
                        sidex2 = ((path.subpaths[scount].points[0] - mediax) * scalefactor);
                        sidey2 = ((mediah - path.subpaths[scount].points[1]) * scalefactor);

                    }

                    sidex1 += offsetx;
                    sidey1 += offsety;
                    sidex2 += offsetx;
                    sidey2 += offsety;

                    intersections += areIntersecting(rayx1,rayy1,rayx2,rayy2,sidex1,sidey1,sidex2,sidey2);

                }

            }
        }
        //console.log(intersections);
        /*if (!isEven(intersections)){
            cntximg.strokeStyle = "black";
            cntximg.lineWidth = 2;
            cntximg.beginPath();
            cntximg.moveTo(rayx1,rayy1);
            cntximg.lineTo(rayx2,rayy2);
            cntximg.stroke();
            cntximg.strokeStyle = "yellow";
            cntximg.lineWidth = 4;


        }*/

        return !isEven(intersections);

    }


    function insidepolygon(scalefactor,dx,dy,xoffset,yoffset,polygon,mouse,startpoint){
        var intersections = 0;
        var rayx1 = startpoint.x;
        var rayy1 = startpoint.y;
        var rayx2 = mouse.x;
        var rayy2 = mouse.y;

        for (var counter = 0; counter < polygon.length; counter++) {
            var sidex1 = (polygon[counter].x1 - xoffset) * scalefactor;
            sidex1 += dx;
            var sidey1 = (polygon[counter].y1 - yoffset) * scalefactor;
            sidey1 += dy;
            var sidex2 = (polygon[counter].x2 - xoffset) * scalefactor;
            sidex2 += dx;
            var sidey2 = (polygon[counter].y2 - yoffset) * scalefactor;
            sidey2 += dy;
            intersections += areIntersecting(rayx1,rayy1,rayx2,rayy2,sidex1,sidey1,sidex2,sidey2);
        }
        //console.log(intersections);
        //var within = (intersections == 0);
        return !isEven(intersections);
        //return (intersections == 0);

    }

    function getpolygonarea(points){

        var i = 0;
        var area = 0.0;
        var n = points.length;


        for (i = 0; i < n - 1; i++) {
            area += (points[i].x * points[i + 1].y) - (points[i + 1].x * points[i].y);
        }
        area += (points[n - 1].x * points[0].y) - (points[0].x * points[n - 1].y);
        return Math.abs(area / 2.0);


    }

    function msieversion() {

        //var ua = window.navigator.userAgent;
        //var msie = ua.indexOf("MSIE ");

        if (navigator.userAgent.match(/Trident.*rv\:11\./))  // If Internet Explorer, return version number
        {
            bIsMSIE = true;
            szdispvalue = "";
            //alert(parseInt(ua.substring(msie + 5, ua.indexOf(".", msie))));
        }
        else  // If another browser, return 0
        {
            bIsMSIE = false;
            szdispvalue = "initial";
            //alert('otherbrowser');
        }

        //bIsMSIE = false;
        //szdispvalue = "initial";
        //return false;
    }

    function createLayers() {
        Layerlist[0] = new Layers(0, "#ffffff", "Layer 0", true);
        Layerlist[1] = new Layers(1, "#ff0000", "Layer 1", true);
        Layerlist[2] = new Layers(2, "#0000ff", "Layer 2", true);
        Layerlist[3] = new Layers(3, "#008000", "Layer 3", true);
        Layerlist[4] = new Layers(4, "#ffff00", "Layer 4", true);
        Layerlist[5] = new Layers(5, "#a52a2a", "Layer 5", true);
        Layerlist[6] = new Layers(6, "#ffd700", "Layer 6", true); //gold
        Layerlist[7] = new Layers(7, "#fff5ee", "Layer 7", true);
        Layerlist[8] = new Layers(8, "#fff8dc", "Layer 8", true);
        Layerlist[9] = new Layers(9, "#fffacd", "Layer 9", true);
        Layerlist[10] = new Layers(10, "#ffffe0", "Layer 10", true);
        Layerlist[11] = new Layers(11, "#98fb98", "Layer 11", true);
        Layerlist[12] = new Layers(12, "#afeeee", "Layer 12", true);
        Layerlist[13] = new Layers(13, "#e0ffff", "Layer 13", true);
        Layerlist[14] = new Layers(14, "#e6e6fa", "Layer 14", true);
        Layerlist[15] = new Layers(15, "#dda0dd", "Layer 15", true);
        Layerlist[16] = new Layers(16, "#d3d3d3", "Layer 16", true);
        Layerlist[17] = new Layers(17, "#ffc0cb", "Layer 17", true);
        Layerlist[18] = new Layers(18, "#ffe4c4", "Layer 18", true);
        Layerlist[19] = new Layers(19, "#ffe4b5", "Layer 19", true);
        Layerlist[20] = new Layers(20, "#f0e68c", "Layer 20", true);
        Layerlist[21] = new Layers(21, "#90ee90", "Layer 21", true);
        Layerlist[22] = new Layers(22, "#20b2aa", "Layer 22", true);
        Layerlist[23] = new Layers(23, "#87cefa", "Layer 23", true);
        Layerlist[24] = new Layers(24, "#6495ed", "Layer 24", true);
        Layerlist[25] = new Layers(25, "#ee82ee", "Layer 25", true);
        Layerlist[26] = new Layers(26, "#c0c0c0", "Layer 26", true);
        Layerlist[27] = new Layers(27, "#f08080", "Layer 27", true);
        Layerlist[28] = new Layers(28, "#f4a460", "Layer 28", true);
        /*


         24 background-color: #ffa500
         25 background-color: #eee8aa
         26 background-color: #7fff00
         27 background-color: #48d1cc
         28 background-color: #87ceeb
         29 background-color: #7b68ee
         30 background-color: #da70d6
         31 background-color: #808080

         33 background-color: #ff4500
         34 background-color: #ff8c00

         36 background-color: #32cd32
         37 background-color: #8fbc8f
         38 background-color: #4169e1
         39 background-color: #6a5acd
         40 background-color: #ba55d3
         41 background-color: #696969
         42 background-color: #dc143c
         43 background-color: #d2691e
         44 background-color: #ff7f50

         46 background-color: #228b22
         47 background-color: #2e8b57

         49 background-color: #8a2be2
         50 background-color: #9932cc
         51 background-color: #2f4f4f
         52 background-color: #b22222
         53 background-color: #8b4513
         54 background-color: #a0522d
         55 background-color: #808000

         57 background-color: #008b8b
         58 background-color: #0000cd
         59 background-color: #483d8b
         60 background-color: #8b008b

         62 background-color: #8b0000
         63 background-color: #800000

         65 background-color: #556b2f
         66 background-color: #006400
         67 background-color: #191970
         68 background-color: #000080
         69 background-color: #4b0082
         70 background-color: #800080

         */
        Layerlist[29] = new Layers(29, "#000000", "Layer 29", true); //black


    }


    function getHatch(ctx, type, color) {

        //diagonal-forward = 0
        //diagonal-back = 1
        //diagonal-cross = 2
        //hatch-horizontal = 3
        //hatch-vertical = 4
        //hatch-cross = 5

        pattern.width = 16;
        pattern.height = 16;
        var pctx = pattern.getContext('2d');

        pctx.strokeStyle = color;
        pctx.lineWidth = 1;

        switch (type) {
            case 3:
                pctx.beginPath();
                pctx.moveTo(0.0, 10.0);
                pctx.lineTo(10.0, 0.0);
                pctx.moveTo(10.0, 16.0);
                pctx.lineTo(16.0, 10.0);
                pctx.moveTo(2.0, 16.0);
                pctx.lineTo(16.0, 2.0);
                pctx.moveTo(0.0, 2.0);
                pctx.lineTo(2.0, 0.0);
                pctx.stroke();
                break;
            case 2:
                pctx.beginPath();
                pctx.moveTo(0.0, 14.0);
                pctx.lineTo(2.0, 16.0);
                pctx.moveTo(0.0, 6.0);
                pctx.lineTo(10.0, 16.0);
                pctx.moveTo(2.0, 0.0);
                pctx.lineTo(16.0, 14.0);
                pctx.moveTo(10.0, 0.0);
                pctx.lineTo(16.0, 6.0);
                pctx.stroke();
                break;
            case 5:
                pctx.beginPath();
                pctx.moveTo(0.0, 10.0);
                pctx.lineTo(10.0, 0.0);
                pctx.moveTo(10.0, 16.0);
                pctx.lineTo(16.0, 10.0);
                pctx.moveTo(2.0, 16.0);
                pctx.lineTo(16.0, 2.0);
                pctx.moveTo(0.0, 2.0);
                pctx.lineTo(2.0, 0.0);

                pctx.moveTo(0.0, 14.0);
                pctx.lineTo(2.0, 16.0);
                pctx.moveTo(0.0, 6.0);
                pctx.lineTo(10.0, 16.0);
                pctx.moveTo(2.0, 0.0);
                pctx.lineTo(16.0, 14.0);
                pctx.moveTo(10.0, 0.0);
                pctx.lineTo(16.0, 6.0);
                pctx.stroke();


                break;
            case 0:
                pctx.beginPath();
                pctx.moveTo(0.0, 4.0);
                pctx.lineTo(16.0, 4.0);
                pctx.moveTo(0.0, 12.0);
                pctx.lineTo(16.0, 12.0);

                pctx.stroke();

                break;
            case 1:
                pctx.beginPath();
                pctx.moveTo(4.0, 0.0);
                pctx.lineTo(4.0, 16.0);
                pctx.moveTo(12.0, 0.0);
                pctx.lineTo(12.0, 16.0);

                pctx.stroke();

                break;
            case 4:
                pctx.beginPath();
                pctx.moveTo(0.0, 4.0);
                pctx.lineTo(16.0, 4.0);
                pctx.moveTo(0.0, 12.0);
                pctx.lineTo(16.0, 12.0);

                pctx.moveTo(4.0, 0.0);
                pctx.lineTo(4.0, 16.0);
                pctx.moveTo(12.0, 0.0);
                pctx.lineTo(12.0, 16.0);
                pctx.stroke();


                break;
        }


        var HatchPtrn = ctx.createPattern(pattern, "repeat");
        return HatchPtrn;

    }

    function getURLFile(s){
        var path = "";
        var sp = s.split('/');
        for (var i = 0; i < sp.length - 1; i++) {
            path += sp[i] + "/";
        }
        //var file = sp[sp.length-1];
        //alert(file);
        return sp[sp.length-1];

    }

    function getURLPath(s) {
        var path = "";

        if(s){
            var sp = s.split('/');
            for (var i = 0; i < sp.length - 1; i++) {
                path += sp[i] + "/";
            }

            if (bUseID){
                path = xmlurlrel;
            }
        }
        //var file = sp[sp.length-1];
        //alert(file);
        return path;
    }

    function getPath(s) {
        var path = "";
        var sp = s.split('\\');
        for (var i = 0; i < sp.length - 1; i++) {
            path += sp[i] + "\\";
        }
        //var file = sp[sp.length-1];
        //alert(file);
        if(!path) {
            path = s;
        }

        return path;

    }

    function getFileName(s) {
     var path = "";
     var file = "";
      if(s){
        if(s.indexOf('https://') > -1){
            file = getURLFile(s);
         }else if (s.indexOf('http://') > -1){
            file = getURLFile(s);
         }else{
            var sp = s.split('\\');
            for (var i = 0; i < sp.length - 1; i++) {
                    path += sp[i] + "\\";
                }
            file = sp[sp.length - 1];
            //alert(file);
         }
      }
     return file;

    }

    /*function getFileName(s) {
        var path = "";
        var file = "";
        var sp = s.split('\\');
        for (var i = 0; i < sp.length - 1; i++) {
            path += sp[i] + "\\";
        }
        file = sp[sp.length - 1];
        //alert(file);
        return file;

    }*/

    function addSlash(s) {
        var path = "";
        var sp = s.split('\\');
        for (var i = 0; i < sp.length; i++) {
            if (i < sp.length - 1) {
                path += sp[i] + "\\\\";
            } else {
                //path += sp[i];
            }

        }
        if(!path) {
            path = s;
        }

        return path;
    }


    function getAngleWithXAxis(r, x, y, onoff) {
        //ranges: -22.5 to 22.5, 22.5 to 67.5, 67.5 to 112.5, 112.5 to 157.5, 157.5 to 202.5, 202.5 to 247.5, 247.5 to 292.5,292.5 to 337.5

        var ranges = [
            {
                minX:r * Math.cos(22.5 * (Math.PI / 180)),
                maxX:r * Math.cos(0)
            },
            {
                minX:r * Math.cos(67.5 * (Math.PI / 180)),
                maxX:r * Math.cos(22.5 * (Math.PI / 180))
            },
            {
                minX:r * Math.cos(112.5 * (Math.PI / 180)),
                maxX:r * Math.cos(67.5 * (Math.PI / 180))
            },
            {
                minX:r * Math.cos(157.5 * (Math.PI / 180)),
                maxX:r * Math.cos(112.5 * (Math.PI / 180))
            },
            {
                minX:r * Math.cos(180 * (Math.PI / 180)),
                maxX:r * Math.cos(157.5 * (Math.PI / 180))
            },
            {
                minX:r * Math.cos(202.5 * (Math.PI / 180)),
                maxX:r * Math.cos(247.5 * (Math.PI / 180))
            },
            {
                minX:r * Math.cos(247.5 * (Math.PI / 180)),
                maxX:r * Math.cos(292.5 * (Math.PI / 180))
            },
            {
                minX:r * Math.cos(292.5 * (Math.PI / 180)),
                maxX:r * Math.cos(337.5 * (Math.PI / 180))
            }
        ];


        /*
         , Direction: {
         right: 'Right',
         topRight: 'TopRight',
         forward: 'Forward',
         topLeft: 'TopLeft',
         left: 'Left',
         bottomLeft: 'BottomLeft',
         backward: 'Backward',
         bottomRight: 'BottomRight'
         }

         */

        //this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };


        //var bonoff = (onoff == 1);

        var distance = Math.sqrt((Math.abs(x) * Math.abs(x)) + (Math.abs(y) * Math.abs(y)));


        var _endNormal = new THREE.Vector2(x, y).normalize();
        //we make all positions project on circle, as we multiply scale 'r'.
        var _end = _endNormal.clone().multiplyScalar(r);

        //console.log(_end.x);
        //console.log(_end.y);
        //so we only need to compare the 2 ranges in same quadrant
        if (_end.x >= 0 && _end.y >= 0) {
            //first quadrant
            if (distance > 50) {
                if (ranges[0].maxX >= _end.x && _end.x >= ranges[0].minX) {
                    //right

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = (onoff == 1);

                    //return 'Right';//this.Direction.right;
                } else if (ranges[1].maxX >= _end.x && _end.x >= ranges[1].minX) {
                    //top right
                    //DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.rollRight = onoff;
                    //console.log('top right');
                    //return 'TopRight';//this.Direction.topRight;
                } else if (ranges[2].maxX >= _end.x && _end.x >= ranges[2].minX) {
                    //forward
                    //console.log('forward');

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = (onoff == 1);


                    //return 'Forward';// this.Direction.forward;
                }

            } else {

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = (onoff == 1);

                //return 'Up';
            }
        } else if (_end.x <= 0 && _end.y >= 0) {
            //second quadrant
            if (distance > 50) {
                if (ranges[2].maxX >= _end.x && _end.x >= ranges[2].minX) {
                    //forward
                    //console.log('forward');

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = (onoff == 1);

                    //return 'Forward';//this.Direction.forward;
                } else if (ranges[3].maxX >= _end.x && _end.x >= ranges[3].minX) {
                    //top left
                    //DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.rollLeft = onoff;
                    //console.log('top left');
                    //return 'TopLeft';//this.Direction.topLeft;
                } else if (ranges[4].maxX >= _end.x && _end.x >= ranges[4].minX) {
                    //left
                    //console.log('left');

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = (onoff == 1);

                    //return 'Left';//this.Direction.left;
                }

            } else {

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = (onoff == 1);

                //return 'Up';
            }
        } else if (_end.x <= 0 && _end.y <= 0) {
            //third quadrant
            if (distance > 50) {
                if (ranges[4].maxX >= _end.x && _end.x >= ranges[4].minX) {
                    //left
                    //console.log('left');

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = (onoff == 1);

                    //return 'Left';// this.Direction.left;
                } else if (ranges[5].maxX >= _end.x && _end.x >= ranges[5].minX) {
                    //bottom left
                    //console.log('bottom left');
                    //return 'BottomLeft';// this.Direction.bottomLeft;
                } else if (ranges[6].maxX >= _end.x && _end.x >= ranges[6].minX) {
                    //backward
                    //console.log('backward');

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = (onoff == 1);
                    //return 'Backward';//this.Direction.backward;
                }
            } else {

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = (onoff == 1);

                //return 'Down';

            }
        } else if (_end.x >= 0 && _end.y <= 0) {
            //fourth quadrant
            if (distance > 50) {
                if (ranges[6].maxX >= _end.x && _end.x >= ranges[6].minX) {
                    //backward
                    //console.log('backward');

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = (onoff == 1);

                    //return 'Backward';// this.Direction.backward;
                } else if (ranges[7].maxX >= _end.x && _end.x >= ranges[7].minX) {
                    //bottom right
                    //console.log('bottom right');
                    //return 'BottomRight';// this.Direction.bottomRight;
                } else if (ranges[0].maxX >= _end.x && _end.x >= ranges[0].minX) {
                    //right
                    //console.log('right');

                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = (onoff == 1);

                    //return 'Right';// this.Direction.right;
                }

            } else {

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = (onoff == 1);

                //return 'Down';

            }
        }

        //}


    }

    function SetCalibration(val) {
        if (val) {
            if (nCalibrateSet != 0) {
                nCalibrateScale = nCalibrateMeasured / nCalibrateSet;
                nCalibrateScale = 1 / nCalibrateScale;
                setCalibratebtn();
                //var scaledropdwn = document.getElementById('scaledropdown');
                //scaledropdwn.children[0].value = 'Calibration';
                MeasureScale = nCalibrateScale;
            }


        } else {
            nCalibrateScale = 1;
        }

    }

    function SetUserMarkupdisplay(numuser, state) {
        var curmarkup = 0;
        Userlist[numuser].display = state;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            var layerdisplay = getMarkupLayerState(DocObj.markuplist[curmarkup].layer);

            if (DocObj.markuplist[curmarkup].signature == Userlist[numuser].Signature && layerdisplay) {

                DocObj.markuplist[curmarkup].display = Userlist[numuser].display;
            }

        }
        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }

    function SetLayerMarkupdisplay(numlayer, state) {
        var curmarkup = 0;
        Layerlist[numlayer].display = state;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {

            var signdisplay = getSignState(DocObj.markuplist[curmarkup].signature);

            if (DocObj.markuplist[curmarkup].layer == Layerlist[numlayer].Layer && signdisplay) {

                DocObj.markuplist[curmarkup].display = Layerlist[numlayer].display;
            }

        }
        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }


    function setSignature(sign) {
        signature = sign;

    }

    function SetLayer(layer) {

        markuplayer = layer;
        markupcolor = Layerlist[layer].Color;
        markuplinecolor = Layerlist[layer].Color;
        markuptextcolor = Layerlist[layer].Color;
        ChangeMarkupSelected(0);
    }


    function SetTempCal(val) {

        nCalibrateSet = val;


    }

    function GetTempID() {

        return DocObj.selectedmarkup;
    }

    /*function GetNoteText(markupobj){
     var notetext = SzNoteText;
     showNDialog(false);
     notetext = SzNoteText;
     SzNoteText = "";
     return notetext;
     }*/

    function getpage(pagenum) {
        DocObj.GotoPage(pagenum);
    }

    function getDocObj() {
        return DocObj;
    }

    function getUnitArea(value) {

        var dimValue = 0;
        var dpi = DocObj.pages[DocObj.currentpage].DPI;
        var DPmm = dpi / 25.4;
        var DPInch = dpi;


        //var mscale = MeasureScale;
        var mscale = DocObj.pages[DocObj.currentpage].getMeasureScale();
        if (mscale ==  undefined){
            mscale = MeasureScale;
        }

        //var unit = currentglobalunit;
        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            dpi = 72;
            DPmm = dpi / 25.4;
            DPInch = dpi;
        }

        var Dpmmsquare = DPmm * DPmm;
        var DPInchSquare = DPInch * DPInch;
        var measureScaleSquared = mscale * mscale;
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            var mainimagesquare = DocObj.pages[DocObj.currentpage].OriginalScale * DocObj.pages[DocObj.currentpage].OriginalScale;
        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            mainimagesquare = DocObj.pages[DocObj.currentpage].OriginalScale * DocObj.pages[DocObj.currentpage].OriginalScale;
        } else {
            mainimagesquare = DocObj.pages[DocObj.currentpage].MainImageScaling * DocObj.pages[DocObj.currentpage].MainImageScaling;
        }


        var dscalesquare = DocObj.pages[DocObj.currentpage].dscale * DocObj.pages[DocObj.currentpage].dscale;

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            dscalesquare = DocObj.pages[DocObj.currentpage].dscalevector * DocObj.pages[DocObj.currentpage].dscalevector;
        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            dscalesquare = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) * (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
        }

        //var scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
        //var scalefactorsquare = scalefactor * scalefactor;
        var orignalscalesquare = DocObj.pages[DocObj.currentpage].OriginalScale * DocObj.pages[DocObj.currentpage].OriginalScale;


        //dimValue = ((value  / mainimagesquare) / dscalesquare)*measureScaleSquared;//*scalefactorsquare;
        //change to make value independent of current zoom factor.
        dimValue = (value / mainimagesquare) * measureScaleSquared; //*scalefactorsquare;
        dimValue = dimValue / (unitscale * unitscale);


        if (dpi != 0) {
            switch (Unitofmeasure) {
                case 1:
                    dimValue = dimValue / Dpmmsquare;
                    break;
                case 2:
                    dimValue = dimValue / DPInchSquare;
                    break;
                case 3:
                    //dimValue = dimValue;
                    break;
            }


        } else {
            if (!DocObj.pages[DocObj.currentpage].usevectorxml) {
                dimValue = dimValue / orignalscalesquare;
            }

        }
        return dimValue;
    }

    function getScreenDim(length, munit){

        var pixelwidth = 0;
        var dpi = DocObj.pages[DocObj.currentpage].DPI;
        var DPmm = dpi / 25.4;
        var DPInch = dpi;

        /*if(DocObj.pages[DocObj.currentpage].usevectorxml){
            dpi = 0;
        }*/

        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            dpi = 72;
            DPmm = dpi / 25.4;
            DPInch = dpi;
        }

        length = length * unitscale;
        //length *= DocObj.pages[DocObj.currentpage].getdscale();

        //var mscale = MeasureScale;
        var mscale = DocObj.pages[DocObj.currentpage].getMeasureScale();
        if (mscale == undefined){
            mscale = MeasureScale;
        }



        if (DocObj.pages[DocObj.currentpage].usevectorxml || DocObj.pages[DocObj.currentpage].usepdfjs || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            //length = ((value / DocObj.pages[DocObj.currentpage].OriginalScale)) * mscale;
            pixelwidth = (length / mscale) * DocObj.pages[DocObj.currentpage].OriginalScale;
        } else {
            //length = ((value / DocObj.pages[DocObj.currentpage].MainImageScaling)) * mscale;
            pixelwidth = (length / mscale) * DocObj.pages[DocObj.currentpage].MainImageScaling;
        }



        //pixelwidth = pixelwidth * DPmm;

        if (dpi != 0) {
            switch (Unitofmeasure) {
                case 1:
                    //dimValue = dimValue / DPmm;
                    pixelwidth = pixelwidth * DPmm;
                    break;
                case 2:
                    //dimValue = dimValue / DPInch;
                    pixelwidth = pixelwidth * DPInch;
                    break;
                case 3:
                    //dimvalue= dimvalue;
                    break;
            }


        } else {
            /*if (!DocObj.pages[DocObj.currentpage].usevectorxml) {
                pixelwidth = pixelwidth * DocObj.pages[DocObj.currentpage].getdscale();

            }*/


        }

        return pixelwidth;

    }

    var gcd = function(a, b) {
        if (b < 0.0000001) return a;                // Since there is a limited precision we need to limit the value.

        return gcd(b, Math.floor(a % b));           // Discard any fractions due to limitations in precision.
    };

    function getUnitlengthRemainder(value){
        var dimValue = 0;
        var remainder = 0;
        var remainddec = 0;
        var dpi = DocObj.pages[DocObj.currentpage].DPI;
        var DPmm = dpi / 25.4;
        var DPInch = dpi;

        var mscale = DocObj.pages[DocObj.currentpage].getMeasureScale();
        if (mscale ==  undefined){
            mscale = MeasureScale;
        }

        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            dpi = 72;
            DPmm = dpi / 25.4;
            DPInch = dpi;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml || DocObj.pages[DocObj.currentpage].usepdfjs || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            dimValue = ((value / DocObj.pages[DocObj.currentpage].OriginalScale)) * mscale; // * scalefactor;
        } else {
            dimValue = ((value / DocObj.pages[DocObj.currentpage].MainImageScaling)) * mscale; // * scalefactor;
        }


        //dimValue = dimValue / unitscale;


        if (dpi != 0) {

            dimValue = dimValue / DPInch;


        } else {
            if (!DocObj.pages[DocObj.currentpage].usevectorxml) {
                dimValue = dimValue / DocObj.pages[DocObj.currentpage].OriginalScale;
            }


        }

        var rnddimValue = Math.floor(dimValue / unitscale);
        remainder = dimValue % unitscale;
        var rndrem = Math.floor(remainder);
        var remainddec = remainder - rndrem;

        remainddec = Math.round(remainddec * nFractionRes) / nFractionRes;

        var fractionlimit = 1 / nFractionRes;

        if (remainddec > fractionlimit){
            var len = remainddec.toString().length - 2;

            var nDenominator = Math.pow(10, len);
            var nNumerator = remainddec * nDenominator;

            var divisor = gcd(nNumerator, nDenominator);    // Should be 5

            nNumerator /= divisor;                         // Should be 687
            nDenominator /= divisor;                       // Should be 2000
            var nretnumerator = Math.floor(nNumerator);
            var nretdenominator = Math.floor(nDenominator);

        }else{

            nretnumerator = 0;
            nretdenominator = 0;

        }


        return {quot : rnddimValue, rem : rndrem, remdec : remainddec, numerator : nretnumerator, denominator : nretdenominator};
    }

    function getUnitlength(value) {
        var dimValue = 0;
        var remainder = 0;
        var dpi = DocObj.pages[DocObj.currentpage].DPI;
        var DPmm = dpi / 25.4;
        var DPInch = dpi;

        //var mscale = MeasureScale;

        var mscale = DocObj.pages[DocObj.currentpage].getMeasureScale();
        if (mscale ==  undefined){
            mscale = MeasureScale;
        }

        //var scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;

        //dimValue = ((value  / DocObj.pages[DocObj.currentpage].MainImageScaling) / DocObj.pages[DocObj.currentpage].dscale)*MeasureScale;// * scalefactor;
        //value without the scale factor to estblish value independent from zoom factor.
        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            dpi = 72;
            DPmm = dpi / 25.4;
            DPInch = dpi;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml || DocObj.pages[DocObj.currentpage].usepdfjs || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            dimValue = ((value / DocObj.pages[DocObj.currentpage].OriginalScale)) * mscale; // * scalefactor;
        } else {
            dimValue = ((value / DocObj.pages[DocObj.currentpage].MainImageScaling)) * mscale; // * scalefactor;
        }

        dimValue = dimValue / unitscale;
        remainder = dimValue % unitscale;


        if (dpi != 0) {
            switch (Unitofmeasure) {
                case 1:
                    dimValue = dimValue / DPmm;
                    break;
                case 2:
                    dimValue = dimValue / DPInch;
                    break;
                case 3:
                    //dimvalue= dimvalue;
                    break;
            }


        } else {
            if (!DocObj.pages[DocObj.currentpage].usevectorxml) {
                dimValue = dimValue / DocObj.pages[DocObj.currentpage].OriginalScale;
            }


        }
        return dimValue;
    }

    function MarkupUndo() {

        var found = false;
        var localmarkup = DocObj.markupundolist.pop();
        var undodeletobj;

        if (localmarkup != undefined) {
            var id = localmarkup.markupnumber;

            var curmarkup = 0;
            var curpoint = 0;


            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].markupnumber == id) {
                        DocObj.markuplist[curmarkup].PerformUndo(localmarkup);
                        found = true;
                    }
                }
            }
            if (!found) {
                //DocObj.markuplist.push(localmarkup);
                id = localmarkup.markupnumber;
                var undoMarkupdeletobj = new MarkupObject(localmarkup.type, localmarkup.subtype, localmarkup.alternative);
                undoMarkupdeletobj.savemetolistLoad(DocObj);

                //ft 08.08.2018 changed from separate index to direct array length

                //DocObj.markuplist[DocObj.nummarkups - 1].markupnumber = id;
                //DocObj.markuplist[DocObj.nummarkups - 1].PerformUndo(localmarkup);

                DocObj.markuplist[DocObj.markuplist.length - 1].markupnumber = id;
                DocObj.markuplist[DocObj.markuplist.length - 1].PerformUndo(localmarkup);

            }
        }
    }

    function displaydebuglabel(ctx, x, y, text) {
        var labelheight = 20;
        var labelwidth = 1;

        ctx.save();
        ctx.font = "10pt Arial";

        ctx.strokeStyle = "black";
        ctx.fillStyle = "rgba(113, 114, 118, 0.8)";
        ctx.lineWidth = 1;

        var labeltypewidth = ctx.measureText(text);
        var labetypesize = labeltypewidth.width;
        labelwidth = labetypesize;


        ctx.strokeRect(x, y + 30, labelwidth, labelheight);
        ctx.fillRect(x, y + 30, labelwidth, labelheight);

        ctx.fillStyle = "white";

        ctx.fillText(text, x + 3, y + 42);

        ctx.restore(); // restore context to what it was on entry

    }

    function MarkupPrintSave() {
        var curmarkup = 0;
        var undoobj;
        markupprintlist = [];
        //markupprintlist = DocObj.markuplist.slice(0);
        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {
                DocObj.markuplist[curmarkup].drawn = false;
                undoobj = new MarkupUndoObject(DocObj.markuplist[curmarkup].markupnumber);
                undoobj.SetUndoValues(DocObj.markuplist[curmarkup]);
                markupprintlist.push(undoobj);

            }
        }

    }


    function MarkupSaveStateGUID(GUID){
        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            for (var curmarkup = 0; curmarkup < OpenFiles[curdoc].markuplist.length; curmarkup++) {
                if (OpenFiles[curdoc].markuplist[curmarkup] != null) {
                    if(OpenFiles[curdoc].markuplist[curmarkup].getUniqueID() == GUID){
                        MarkupSaveState(OpenFiles[curdoc].markuplist[curmarkup].markupnumber);
                    }
                }
            }

        }


    }
    function MarkupSaveState(id) {
        var curmarkup = 0;
        var undoobj;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {
                if (DocObj.markuplist[curmarkup].markupnumber == id) {
                    undoobj = new MarkupUndoObject(id);
                    undoobj.SetUndoValues(DocObj.markuplist[curmarkup]);
                    DocObj.markupundolist.push(undoobj);

                    /*if (RxCore_GUI_Markup != undefined) {
                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[curmarkup], {created : false, modified : true, deleted : false});
                    }*/

                }
            }
        }

        //drawmarkupAll(cntximg);

    }
    function MarkupSaveStateByref(markupobj) {
        var undoobj = new MarkupUndoObject(markupobj.markupnumber);
        undoobj.SetUndoValues(markupobj);
        DocObj.markupundolist.push(undoobj);

    }

    //var MarkupDefaultFont = new FontObject("Helvetica",24,false,false);

    var MarkupUndoObject = function (id) {
        this.markupnumber = id;
        this.type = 0;
        this.subtype = 0;
        this.alternative = 0;
        this.consolidated = false;
        this.bRedact = false;
        this.bdelete = false;
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        this.xscaled = 0;
        this.yscaled = 0;
        this.wscaled = 0;
        this.hscaled = 0;
        this.rotatedrect = new Rectangle(0, 0, 0, 0);
        this.timestamp = 0;
        this.layer = 0;
        this.pagenumber = 0;
        this.layout = "Default";
        this.signature = "";
        this.color = "";
        this.transparency = 100;
        this.fillcolor = "rgba(255,0,0,1.0)";
        this.strokecolor = "rgba(255,0,0,1.0)";
        this.textcolor = "rgba(255,0,0,1.0)";
        this.markercolor = "rgba(255,0,0,1.0)";
        this.scaling = 0.0;
        this.xoffset = 0.0;
        this.yoffset = 0.0;
        this.scalingext = 0.0;
        this.xoffsetext = 0.0;
        this.yoffsetext = 0.0;
        this.rotation = 0.0;
        this.textrotate = 0;
        this.dimtext = "";
        this.linewidth = 0;
        this.textheight = 0;
        this.measuretextheight = 0;
        this.textwidth = 0;
        this.text = "";
        this.font = new FontObject("Helvetica", 24, false, false);
        //this.fontname = "";

        this.points = [];
        this.pointlist = [];
        this.numpoints = -1;



        this.SetUndoValues = function (MarkupObj) {
            var curpoint = 0;
            var tempx = 0;
            var tempy = 0;
            this.type = MarkupObj.type;
            this.subtype = MarkupObj.subtype;
            this.alternative = MarkupObj.alternative;
            this.bRedact = MarkupObj.bRedact;
            this.consolidated = MarkupObj.consolidated;
            this.display = MarkupObj.display;
            this.x = MarkupObj.x;
            this.y = MarkupObj.y;
            this.w = MarkupObj.w;
            this.h = MarkupObj.h;
            this.xscaled = MarkupObj.xscaled;
            this.yscaled = MarkupObj.yscaled;
            this.wscaled = MarkupObj.wscaled;
            this.hscaled = MarkupObj.hscaled;
            this.rotatedrect = MarkupObj.rotatedrect;
            this.timestamp = MarkupObj.timestamp;
            this.layer = MarkupObj.layer;
            this.pagenumber = MarkupObj.pagenumber;
            this.layout = MarkupObj.layout;
            this.signature = MarkupObj.signature;
            this.color = MarkupObj.color;

            this.transparency = MarkupObj.transparency;
            this.fillcolor = MarkupObj.fillcolor;
            this.strokecolor = MarkupObj.strokecolor;
            this.textcolor = MarkupObj.textcolor;
            this.markercolor = MarkupObj.markercolor;

            this.scaling = MarkupObj.scaling;
            this.xoffset = MarkupObj.xoffset;
            this.yoffset = MarkupObj.yoffset;
            this.scalingext = MarkupObj.scalingext;
            this.xoffsetext = MarkupObj.xoffsetext;
            this.yoffsetext = MarkupObj.yoffsetext;
            this.rotation = MarkupObj.rotation;
            this.textrotate = MarkupObj.textrotate;
            this.dimtext = MarkupObj.dimtext;
            this.linewidth = MarkupObj.linewidth;
            this.textheight = MarkupObj.textheight;
            this.measuretextheight = MarkupObj.measuretextheight;
            this.textwidth = MarkupObj.textwidth;
            this.text = MarkupObj.text;
            this.font = MarkupObj.font;
            //this.fontname = MarkupObj.fontname;

            for (curpoint = 0; curpoint < MarkupObj.points.length; curpoint++) {

                this.points[curpoint] = new point(MarkupObj.points[curpoint].x, MarkupObj.points[curpoint].y)

            }


            this.numpoints = this.points.length - 1;
            for (var i = 0; i < MarkupObj.pointlist.length; i++){
                this.pointlist[i] = [];
                for(var j=0;j<MarkupObj.pointlist[i].length;j++){

                    this.pointlist[i][j] = new point(MarkupObj.pointlist[i][j].x, MarkupObj.pointlist[i][j].y);

                }

            }



        };


    };



    var MarkupObject = function (type, subtype, alternative) {
        var markupobject = this;
        this.markupnumber = 0;
        this.type = type;
        this.subtype = subtype;
        this.alternative = alternative;
        this.bRedact = false;

        if (alternative >= 3) {
            this.hatchStyle = alternative - 3;
        } else {
            this.hatchprt = 0;
        }
        this.saved = false;
        this.firstpointrotAdjusted = false;
        this.markupID = 0;
        this.uniqueID = 0;
        this.locked = false;

        this.timestamp = new Date().getTime();
        this.layer = markuplayer;
        this.signature = signature;
        this.color = markupcolor;
        this.transparency = 100;
        this.labeltransparency = 100;
        this.consolidated = false;
        this.linkURL = "";
        this.imagehref = "";
        this.bhaveLink = false;
        this.bCanHaveLink = ((markupobject.type == 1 && markupobject.subtype == 2) || markupobject.type == 3 || markupobject.type == 4 || markupobject.type == 5 || markupobject.type == 9 || markupobject.type == 11);
        this.anglelengthsupport = (markupobject.type == 6 );
        this.widthHeightsupport = (markupobject.type == 3);
        this.setRadiusSupport = (markupobject.type == 4 && markupobject.subtype == 1);
        this.setPointSupport = (markupobject.type == 1 || markupobject.type == 8);
        this.editcurpoint = 0;
        this.bpointEdit = false;


        this.fillcolor = convertHex(markupfillcolor, this.transparency);
        this.selectSpaceColor = "rgba(191,58,209,0.6)";
        //rgb(255, 255, 153) yellow.
        this.selectSpaceStopColor = "rgba(255,255,255,0.3)";

        this.strokecolor = convertHex(markuplinecolor, 100);
        this.textcolor = convertHex(markuptextcolor, this.transparency);
        this.markercolor = convertHex(markupfillcolor, 30);
        this.labelfillcolor = "rgba(255,255,255,1)";

        this.orthoDrawAngle = 0;
        this.orthoDrawAngledeg = 0;


        this.pagenumber = 0;
        this.pagerotation = 0;
        this.documentName = DocObj.OriginalURL;
        this.layout = "Default";
        this.display = true;
        this.relativeWH = false;
        this.drawn = false;
        this.imageloaded = false;

        //General placement and scaling properties
        this.x = 0;
        this.y = 0;
        this.w = 0;
        this.h = 0;
        this.radius = 0;//only used for circles

        this.xscaled = 0;
        this.yscaled = 0;
        this.wscaled = 0;
        this.hscaled = 0;
        this.radiusScaled = 0;//only used for circles

        //for new dimension with leader offset.
        this.leaderoffset = 0;
        this.labelpos = {x:this.x,y:this.y,w:this.w,h:this.h};

        this.labeloffsetx = 0;
        this.labeloffsety = 0;
        this.labelRect = {x:0,y:0,w:0,h:0};


        this.rotatedrect = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        //Selection point areas for mouse manipulation

        this.LowerRightRect = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.LowerLeftRect = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.UpperLeftRect = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.UpperRightRect = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.RotmarkerRect = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);

        this.LowerRightRectRot = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.LowerLeftRectRot = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.UpperLeftRectRot = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.UpperRightRectRot = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
        this.RotmarkerRectRot = new Rectangle(this.xscaled, this.yscaled, this.wscaled, this.hscaled);

        //this.center = new point((this.w-this.x)/2,(this.h - this.y)/2);

        this.fixedscaleFactor = 1.0;
        this.scaling = 0.0;
        this.xoffset = 0.0;
        this.yoffset = 0.0;
        this.scalingext = 0.0;
        this.xoffsetext = 0.0;
        this.yoffsetext = 0.0;
        this.rotation = 0;
        this.textrotate = 0;
        this.bUsemouseinput = true; //if angle and length set by numric input check this in adjustforroation

        this.docdx = DocObj.pages[DocObj.currentpage].getdx();
        this.docdy = DocObj.pages[DocObj.currentpage].getdy();
        this.docdscale = DocObj.pages[DocObj.currentpage].getdscale();


        //measurement properties
        this.dimtext = "";
        this.customlabeltext = "";

        this.linewidth = linewidthvalue;
        //this.hatchStyle = HatchStyle;
        this.linestyle = nlinestyle;
        //this.linestyle = Linestylevalue.value;

        //General placement and scaling properties

        this.selected = false;
        this.spaceselected = false;
        this.lastselected = false;
        this.selectedit = false;
        this.firstpointset = false;
        //0 = no action, 1 = move, 2 = scale, 3=rotate, 4=move point,5=edit text, 6=dimension label, 7=polyline segment select, 8=move label
        this.editaction = 0;
        //0 = no corner, 1 = upper left, 2 = upper right, 3 = lower left, 4 = lover right,5=rotate marker
        this.scalecorner = 0;
        this.linesegment = {p1 : -1, p2 : -1};
        this.selectedpoint = -1;
        this.bispartofGroup = false;
        this.groupRect = {x:0, y:0, w:0, h:0};


        //text specific properties.
        this.textheight = 24;
        this.textwidth = 0;
        this.stampsmalltwidth = 0;
        this.stampsmalltheight = 0;
        this.measuretextheight = nLabelTextsize;
        this.bhasArrow = false;
        this.bisTextArrow = false;
        this.markupArrowConnected = null;
        this.textBoxConnected = null;
        this.busecustomlabel = false;


        this.carpos = 0;
        this.text = "";
        this.smalltext = "";
        this.cursorblink = true;
        this.fontname = "Helvetica";
        var bmpath = (type==1 && subtype ==3);
        //this.font = new FontObject("Helvetica", 24, false, false);
        this.font = new FontObject("Helvetica", (type == 7 || type == 8 || bmpath) ? nLabelTextsize : 24, false, false);
        this.arrowlength = nArrowSize + this.linewidth;
        //text specific properties.

        //properties for objects with multiple points, pencil polygon etc.
        this.pointlist = [];
        this.points = [];
        this.sides = [];
        this.numpoints = -1;
        this.customattributes = [];
        //properties for objects with multiple points, pencil polygon etc.

        //General variables
        var markersize = 20;
        var labelsize = {w:0,h:0};
        var markercolor = "rgba(255, 255, 0, 0.3)";
        var stampcolor = "rgba(255, 0, 0, 0.3)";


        var markerlinewidth = 15;
        var arrowangle = 22.5;
        var arrowlength = nArrowSize + this.linewidth;
        var arrowanglerad = arrowangle / (180 / Math.PI);



        //General variables

        //text specific variables
        var blinker;
        //text specific variables

        //variables for ovals and curves
        var kappa = .5522848;
        //variables for ovals and curves

        //square root scaling factors for area calculation
        //var dscalesqroot = Math.sqrt(DocObj.pages[this.pagenumber].dscale);
        //var mscaleroot = Math.sqrt(DocObj.pages[this.pagenumber].MainImageScaling);
        //square root scaling factors for area calculation
        this.PerformUndo = function (UndoObj) {
            var curpoint = 0;
            var tempx = 0;
            var tempy = 0;
            this.type = UndoObj.type;
            this.subtype = UndoObj.subtype;
            this.alternative = UndoObj.alternative;
            this.bRedact = UndoObj.bRedact;
            this.consolidated = UndoObj.consolidated;
            this.x = UndoObj.x;
            this.y = UndoObj.y;
            this.w = UndoObj.w;
            this.h = UndoObj.h;
            this.xscaled = UndoObj.xscaled;
            this.yscaled = UndoObj.yscaled;
            this.wscaled = UndoObj.wscaled;
            this.hscaled = UndoObj.hscaled;
            this.timestamp = UndoObj.timestamp;
            this.layer = UndoObj.layer;
            this.signature = UndoObj.signature;
            this.color = UndoObj.color;
            this.fillcolor = UndoObj.fillcolor;
            this.strokecolor = UndoObj.strokecolor;
            this.textcolor = UndoObj.textcolor;
            this.scaling = UndoObj.scaling;
            this.xoffset = UndoObj.xoffset;
            this.yoffset = UndoObj.yoffset;

            this.docdx = UndoObj.docdx;
            this.docdy = UndoObj.docdy;
            this.docdscale = UndoObj.docdscale;

            this.scalingext = UndoObj.scalingext;
            this.xoffsetext = UndoObj.xoffsetext;
            this.yoffsetext = UndoObj.yoffsetext;
            this.rotation = UndoObj.rotation;
            this.textrotate = UndoObj.textrotate;
            this.dimtext = UndoObj.dimtext;
            this.linewidth = UndoObj.linewidth;
            this.textheight = UndoObj.textheight;
            this.measuretextheight = UndoObj.measuretextheight;
            this.textwidth = UndoObj.textwidth;
            this.text = UndoObj.text;
            //this.fontname = UndoObj.fontname;
            this.font = UndoObj.font;
            this.editcurpoint = 0;
            this.points = UndoObj.points.slice();

            this.numpoints = UndoObj.points.length - 1;

            for (var i = 0; i < UndoObj.pointlist.length; i++){
                this.pointlist[i] = UndoObj.pointlist[i].slice();
            }

            if(UndoObj.bdelete){

                undoremovemarkup(UndoObj.markupnumber);
                //UndoObj
                //remove from docobj markuplist
            }

        };

        this.setselectedit = function(select){
            markupobject.selectedit = select;
        }


        this.setTextBoxArrowSelect = function(select){

            markupobject.selected = select;

        };

        this.setselect = function(select){

            /*var bmultipoint = (markupobject.type == 8 || markupobject.type == 1);
            if(bmultipoint){
                markupobject.selectedit = select;
            }else{
                markupobject.selected = select;
            }*/


            markupobject.selected = select;

            if (this.bhasArrow && markupobject.markupArrowConnected != null){
                //var arrowmobj = DocObj.getmarkupbynumber(markupobject.markupArrowConnected);
                //DocObj.markuplist[arrowmobj].setselect(select);
                markupobject.markupArrowConnected.setselect(select);
                return;
            }

            if(markupobject.bisTextArrow && markupobject.textBoxConnected != null){
                markupobject.textBoxConnected.setTextBoxArrowSelect(select);
                //markupobject.textBoxConnected.selected = select;
            }

            /*if(select){
                if (RxCore_GUI_Markup != undefined) {
                    RxCore_GUI_Markup.setMarkupSelected(markupobject, {created : false, modified : true, deleted : false});
                }

            }*/

        }

        this.settxtboxArrow = function(arrowmarkup){
            if (markupobject.type != 9 && markupobject.subtype != 1){
                return;
            }

            markupobject.bhasArrow = true;
            markupobject.markupArrowConnected = arrowmarkup;

            arrowmarkup.bisTextArrow = true;
            arrowmarkup.textBoxConnected = markupobject;


        };

        this.setLink = function(szURL,bhavelink){
          if (szURL != ""){
              markupobject.linkURL = szURL;
              markupobject.bhaveLink = bhavelink;

          }

        };

        this.getLink = function(){
            return {
                bCanHaveLink : markupobject.bCanHaveLink,
                link : markupobject.linkURL,
                bhavelink : markupobject.bhaveLink
            };
        };


        this.getUniqueID = function(){
            return markupobject.uniqueID;
        };

        this.setUniqueID = function(id){
            if(markupobject.uniqueID == 0 ){
                if (checkUniqueID(id)){
                    markupobject.uniqueID = id;
                }

            }

        };

        this.setRxUniqueID = function(){
            //call new server method to get GUID.
            getGUID(markupobject);
        };

        this.onRotate = function(){

        };

        this.SetFromStorage = function () {

        };


        this.calculateDrawAngle = function(rect){

            var angleRadians = Math.atan2(rect.h - rect.y, rect.w - rect.x);

            //normalize to remove negative values
            if (angleRadians < 0) angleRadians += 2 * Math.PI;

            markupobject.orthoDrawAngle = angleRadians;
            markupobject.orthoDrawAngledeg = markupobject.orthoDrawAngle * (180 / Math.PI);

            //markupobject.orthoDrawAngle = angleRadians * (180 / Math.PI);
            //calculateOrtho


        };

        this.calculateOrtho = function(bscale, corner, point){

            //angle = atan2(vector2.y, vector2.x) - atan2(vector1.y, vector1.x);
            //var angle = Math.atan2(this.h, this.w) - Math.atan2(this.y, this.x);
            var angleRadians = Math.atan2(this.h - this.y, this.w - this.x);
            var pageangle  = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
            //angleRadians += pageangle;

            /*if(bscale){
                switch(corner){
                    case 1 :
                        angleRadians = Math.atan2(point.y - this.y, point.x- this.x);
                        break;
                    case 4 :
                        angleRadians = Math.atan2(this.h - point.y, this.w- point.x);
                        break;
                }
            }*/

            if (angleRadians < 0) angleRadians += 2 * Math.PI;
            var degrees = angleRadians * (180 / Math.PI);

            switch(nOrthoDegree){
                case 90 :
                    if (degrees > 315){
                        //0
                        if (bscale && corner == 1){
                            this.y = this.h;
                        }else{
                            this.h = this.y;
                        }

                    }else if (degrees < 315 && degrees > 270){
                        //270
                        if (bscale && corner == 1){
                            this.x = this.w;
                        }else{
                            this.w = this.x;
                        }

                    }else if (degrees > 225 && degrees < 270){
                        //270
                        if (bscale && corner == 1){
                            this.x = this.w;
                        }else{
                            this.w = this.x;
                        }


                    }else if (degrees < 225 && degrees > 180){
                        //180
                        if (bscale && corner == 1){
                            this.y = this.h;
                        }else{
                            this.h = this.y;
                        }

                    }else if(degrees > 135 && degrees < 180){
                        //180
                        if (bscale && corner == 1){
                            this.y = this.h;
                        }else{
                            this.h = this.y;
                        }

                    }else if(degrees < 135 && degrees > 90){
                        //90
                        if (bscale && corner == 1){
                            this.x = this.w;
                        }else{
                            this.w = this.x;
                        }


                    }else if(degrees > 45 && degrees < 90){
                        //90
                        if (bscale && corner == 1){
                            this.x = this.w;
                        }else{
                            this.w = this.x;
                        }


                    }else if(degrees < 45){
                        //0
                        if (bscale && corner == 1){
                            this.y = this.h;
                        }else{
                            this.h = this.y;
                        }

                    }

                    break;
                case 45 :
                    break;
                case 15 :
                    break;


            }
            //console.log(degrees);



        };

        this.ClearAttributes = function(){

            this.customattributes = [];

        };


        this.ConsolidateList = function(settings,last){

            consolidateObj.add(markupobject,settings,last);

        };

        this.Consolidate = function(settings){
                //layer : markuplayer,
                //fillcolor : markupfillcolor,
                //linecolor : markuplinecolor,
                //textcolor : markuptextcolor,
                //changeStrokeColor : false,
                //changeTexColort : false,
                //changeLayer : true,
                //bperformed : false,
                //isactive : false,
                //signature : signature,

            //todo create undo save point.
            //MarkupSaveState(markupobject.markupnumber);
            MarkupSaveStateByref(markupobject);
            DocObj.bMarkupchanged = true;

            markupobject.consolidated = true;
            markupobject.signature = signature;

            if(settings.changeStrokeColor){
                markupobject.strokecolor = settings.strokecolor;
            }
            if(settings.changeTexColort){
                markupobject.textcolor = settings.textcolor;
            }
            if(settings.changeLayer){
                markupobject.layer = settings.layer;
                //todo change fill color if layer is changed.

            }



            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);


            if (RxCore_GUI_Markuplist != undefined) {
                RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist,DocObj.bActive);
            }


        };

        this.AddAttribute = function(szName,szValue){
            var extendobj = {
                name : szName,
                value : szValue
            };

            markupobject.customattributes.push(extendobj);

        };

        this.GetAttributes = function(){

            return markupobject.customattributes;

        };

        this.deleteAttribute = function(szName){
            var foundindex = -1;

            for (var i = 0;i < markupobject.customattributes.length;i++){

                if(markupobject.customattributes[i].name == szName){
                    foundindex = i;
                }
            }

            if (foundindex != -1){
                //splice to remove entry
                markupobject.customattributes.splice(foundindex, 1);

            }

        };


        this.findAttribute = function(szName, szValue){
            var found = false;
            for (var i = 0;i < markupobject.customattributes.length;i++){

                if(markupobject.customattributes[i].name == szName && markupobject.customattributes[i].value == szValue){
                    found = true;
                    //markupobject.customattributes[i].name = newszName;
                    //markupobject.customattributes[i].value = newszValue;
                }
            }
            return found;

        };

        this.updateAttribute = function(newszName,newszValue){

            for (var i = 0;i < markupobject.customattributes.length;i++){

                if(markupobject.customattributes[i].name == newszName){
                    markupobject.customattributes[i].name = newszName;
                    markupobject.customattributes[i].value = newszValue;
                }
            }
        };


        this.restorestampfontSize = function(){
            markupobject.font.setHeight(markupobject.w * 0.16);
            if (markupobject.alternative == 0){

                markupobject.stampsmalltheight = (markupobject.w * 0.08) - 4;
                if (markupobject.stampsmalltheight < 1) {
                    markupobject.stampsmalltheight = 1;
                }

                var combinedtextheight = markupobject.textheight + markupobject.stampsmalltheight + ((markupobject.h / 10) * 2);
                if (combinedtextheight > markupobject.h) {
                    //this.textheight = (this.h / 2) - ((this.h / 10) * 2);
                    markupobject.font.setHeight((markupobject.h / 2) - ((markupobject.h / 10) * 2));
                    markupobject.stampsmalltheight = (markupobject.textheight / 2) - 4;
                    if (markupobject.stampsmalltheight < 1) {
                        markupobject.stampsmalltheight = 1;
                    }
                }

            }else{
                if ((markupobject.w*0.6) >= markupobject.h){
                    //this.textheight = (this.h / 4);
                    markupobject.font.setHeight(markupobject.h / 4);
                }else{
                    //this.textheight = this.w * 0.16;
                    markupobject.font.setHeight(markupobject.w * 0.16);
                }

            }


        };

        this.SetfromXML = function (DocRef, xmlDoc, fileVersion) {
            var internalscale = 1;
            var bfixedScale = false;
            var bpageloaded = false;


            this.pagenumber = parseInt(xmlDoc.getElementsByTagName('View')[0].firstChild.nodeValue);


            var pageobject = DocRef.getPageObject(this.pagenumber);

            if(pageobject != undefined){
                var fixedscale = pageobject.fixedScale;
                bpageloaded = true;

            }else{

                pageobject = DocRef.getFirstLoadedPage();

            }

            /*if(!bpageloaded){
                return;
            }*/


            //<FileVersion>

            /*if (xmlDoc.getElementsByTagName('HaveLeader')[0] != undefined) {
                this.bhasArrow = (parseInt(xmlDoc.getElementsByTagName('HaveLeader')[0].firstChild.nodeValue) == 1);
            }
            if (this.bhasArrow){
                if (xmlDoc.getElementsByTagName('Entity')[0] != undefined)
                var arrow = xmlDoc.getElementsByTagName("Entity")[0];
                xmlDoc = getChildNodes(xmlDoc);

            }*/

            this.x = parseFloat(xmlDoc.getElementsByTagName('Rect')[0].attributes.getNamedItem('x').value);
            this.y = parseFloat(xmlDoc.getElementsByTagName('Rect')[0].attributes.getNamedItem('y').value);
            this.w = parseFloat(xmlDoc.getElementsByTagName('Rect')[0].attributes.getNamedItem('w').value);
            this.h = parseFloat(xmlDoc.getElementsByTagName('Rect')[0].attributes.getNamedItem('h').value);



            var bNewFileformat = (fileVersion == 'C360' || fileVersion == 'C365' || fileVersion == 'C366');
            var bNewestFileformat = (fileVersion == 'C366');

            if (pageobject.usepdfjs && bNewFileformat) {
                internalscale = pageobject.curpagescale * pageobject.dscalepdf;
            }
            if (pageobject.usevectorxml && bNewFileformat) {
                internalscale = pageobject.curpagescale * pageobject.dscalevector;
            }

            if (xmlDoc.getElementsByTagName('FixedScale')[0] != undefined) {
                bfixedScale = (parseFloat(xmlDoc.getElementsByTagName('FixedScale')[0].firstChild.nodeValue) == 1);
            }

            if (xmlDoc.getElementsByTagName('Redaction')[0] != undefined) {
                this.bRedact = (parseInt(xmlDoc.getElementsByTagName('Redaction')[0].firstChild.nodeValue) == 1);
            }

            if (this.h == 0 && this.w == 0) {
                if (this.type == 8 || this.type == 1 || this.type == 2 || this.type == 0) {

                } else {
                    return false;
                }
            }


            if (this.type == 8 || this.type == 1 || this.type == 2) {
                //skip size check
            } else {

            }

            this.bCanHaveLink = ((this.type == 1 && this.subtype == 2) || this.type == 3 || this.type == 4 || this.type == 5 || this.type == 9 || this.type == 11);
            if (xmlDoc.getElementsByTagName('HaveLink')[0] != undefined) {
                this.bhaveLink = (parseInt(xmlDoc.getElementsByTagName('HaveLink')[0].firstChild.nodeValue) == 1);

            }
            if (xmlDoc.getElementsByTagName('LinkURL')[0] != undefined) {
                if(xmlDoc.getElementsByTagName('LinkURL')[0].firstChild != null){
                    this.linkURL = xmlDoc.getElementsByTagName('LinkURL')[0].firstChild.nodeValue;
                }

            }

            /*if (xmlDoc.getElementsByTagName('HaveLeader')[0] != undefined) {
                this.bhasArrow = (parseInt(xmlDoc.getElementsByTagName('HaveLeader')[0].firstChild.nodeValue) == 1);
            }

            if (this.bhasArrow){
                if (xmlDoc.getElementsByTagName('LeaderReference')[0] != undefined) {
                    if(xmlDoc.getElementsByTagName('LeaderReference')[0].firstChild != null){
                        this.markupArrowConnected = parseInt(xmlDoc.getElementsByTagName('LeaderReference')[0].firstChild.nodeValue);
                    }

                }

            }*/


            if (xmlDoc.getElementsByTagName('Layer')[0] != undefined) {
                this.layer = xmlDoc.getElementsByTagName('Layer')[0].firstChild.nodeValue;
            }else{
                this.layer = markuplayer;
            }

            /*if (this.layer == 0) {
                this.layer = markuplayer;
            }*/

            this.timestamp = parseInt(xmlDoc.getElementsByTagName('TimeStamp')[0].firstChild.nodeValue);
            this.rotation = parseFloat(xmlDoc.getElementsByTagName('Rotation')[0].firstChild.nodeValue);
            //PageRotation

            if (xmlDoc.getElementsByTagName('Extended')[0] != undefined) {
                var extendedobjects = xmlDoc.getElementsByTagName('Extended')[0].childNodes;
                this.customattributes = [];

                for (var nodec = 0; nodec < extendedobjects.length; nodec++) {

                    if(extendedobjects[nodec].firstChild != null){
                        var attrname = extendedobjects[nodec].nodeName;
                        var attrvalue = extendedobjects[nodec].firstChild.nodeValue;

                        this.AddAttribute(attrname,attrvalue);

                    }

                }

            }
            if (xmlDoc.getElementsByTagName('Consolidated')[0] != undefined) {
                this.consolidated = (parseInt(xmlDoc.getElementsByTagName('Consolidated')[0].firstChild.nodeValue) == 1);
            }
            //
            if (xmlDoc.getElementsByTagName('TextRotation')[0] != undefined) {
                this.textrotate = parseFloat(xmlDoc.getElementsByTagName('TextRotation')[0].firstChild.nodeValue);
            }
            if (xmlDoc.getElementsByTagName('PageRotation')[0] != undefined) {
                this.pagerotation = parseFloat(xmlDoc.getElementsByTagName('PageRotation')[0].firstChild.nodeValue);
            }

            this.documentName = xmlDoc.getElementsByTagName('FileName')[0].firstChild.nodeValue;
            this.layout = xmlDoc.getElementsByTagName('Layout')[0].firstChild.nodeValue;
            //this.pagenumber = parseInt(xmlDoc.getElementsByTagName('View')[0].firstChild.nodeValue);
            if (xmlDoc.getElementsByTagName('Color')[0] != undefined) {
                this.color = xmlDoc.getElementsByTagName('Color')[0].firstChild.nodeValue;
            }
            if(xmlDoc.getElementsByTagName('Handle')[0] != undefined){
                this.markupID = parseInt(xmlDoc.getElementsByTagName('Handle')[0].firstChild.nodeValue);
            }


            if(xmlDoc.getElementsByTagName('UniqueID')[0] != undefined){
                this.uniqueID = xmlDoc.getElementsByTagName('UniqueID')[0].firstChild.nodeValue;


            }

            if(this.bhaveLink && this.uniqueID != "0"){
                this.locked = true;
            }

            if (xmlDoc.getElementsByTagName('DocOffsetX')[0] != undefined) {
                this.docdx = parseFloat(xmlDoc.getElementsByTagName('DocOffsetX')[0].firstChild.nodeValue);
            } else {
                this.docdx = pageobject.getdx();
            }

            if (xmlDoc.getElementsByTagName('DocOffsetY')[0] != undefined) {
                this.docdy = parseFloat(xmlDoc.getElementsByTagName('DocOffsetY')[0].firstChild.nodeValue);
            } else {
                this.docdy = pageobject.getdy();
            }

            if (xmlDoc.getElementsByTagName('DocScale')[0] != undefined) {
                this.docdscale = parseFloat(xmlDoc.getElementsByTagName('DocScale')[0].firstChild.nodeValue);
            } else {
                this.docdscale = pageobject.getdscale();
            }

            if (xmlDoc.getElementsByTagName('Transparency')[0] != undefined) {
                this.transparency = parseInt(xmlDoc.getElementsByTagName('Transparency')[0].firstChild.nodeValue);
            }
            if(this.type == 3 && this.subtype == 3){
                this.transparency = 30;
                this.fillcolor = setTransp(this.fillcolor,this.transparency);
            }


            if (xmlDoc.getElementsByTagName('LineColor')[0] != undefined) {
                this.strokecolor = xmlDoc.getElementsByTagName('LineColor')[0].firstChild.nodeValue;

                var isHex  = /^#[0-9A-F]{6}$/i.test(this.strokecolor);

                if(isHex){
                    this.strokecolor = convertHex(this.strokecolor,100);
                }else{
                    this.strokecolor = setTransp(this.strokecolor,100);
                }


            }

            if (xmlDoc.getElementsByTagName('TextColor')[0] != undefined) {
                this.textcolor = xmlDoc.getElementsByTagName('TextColor')[0].firstChild.nodeValue;
            }


            this.scaling = parseFloat(xmlDoc.getElementsByTagName('Scaling')[0].firstChild.nodeValue);

            if (xmlDoc.getElementsByTagName('FillColor')[0] != undefined) {
                this.fillcolor = xmlDoc.getElementsByTagName('FillColor')[0].firstChild.nodeValue;
                this.fillcolor = setTransp(this.fillcolor,this.transparency);
            }


            if (xmlDoc.getElementsByTagName('FontName')[0] != undefined) {
                this.fontname = xmlDoc.getElementsByTagName('FontName')[0].firstChild.nodeValue;
            }

            if (xmlDoc.getElementsByTagName('FontHeight')[0] != undefined) {
                this.textheight = xmlDoc.getElementsByTagName('FontHeight')[0].firstChild.nodeValue;
            }
            if (this.fontname != undefined || this.textheight != undefined) {
                this.font = new FontObject(this.fontname, this.textheight, false, false);
            }

            if (xmlDoc.getElementsByTagName('Font')[0] != undefined) {

                var facename = xmlDoc.getElementsByTagName('Font')[0].attributes.getNamedItem('facename').value;
                var height = parseFloat(xmlDoc.getElementsByTagName('Font')[0].attributes.getNamedItem('height').value);
                var bold = (parseInt(xmlDoc.getElementsByTagName('Font')[0].attributes.getNamedItem('bold').value) == 1);
                var italic = (parseInt(xmlDoc.getElementsByTagName('Font')[0].attributes.getNamedItem('italic').value) == 1);

                if(pageobject.usepdfjs || pageobject.usevectorxml){
                    if(this.type != 12){
                        if(bfixedScale && bNewFileformat){
                            height = Math.round(height*fixedscale);
                        }else{
                            height = Math.round(height*internalscale);
                        }
                    }
                }else{
                    if(this.type != 12){
                        if(bfixedScale){
                            height = Math.round((height*fixedscale)/this.scaling);
                            //fontNode.setAttribute("height", (DocObj.markuplist[curmarkup].font.height / fixedscale) * imagescale);
                        }else{
                            height = Math.round(height);
                            //fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height);
                        }

                    }else{
                        //fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height);
                        height = Math.round(height);
                    }


                }


                //this.font = new FontObject(facename, height, bold, italic);
                //var bispath = (this.type == 1 && this.subtype == 3);
                //this.font = new FontObject(facename, (this.type == 7 || this.type == 8 || bispath)? nLabelTextsize : height, bold, italic);
                this.font = new FontObject(facename, height, bold, italic);
                this.textheight = parseFloat(height);

            }


            if (pageobject.usepdfjs || pageobject.usevectorxml) {
                this.textheight *= internalscale; //changed to recreate correct textheight
            }


            this.signature = xmlDoc.getElementsByTagName('Signature')[0].firstChild.nodeValue;


            if (bNewFileformat) {
                if (pageobject.usepdfjs || pageobject.usevectorxml) {
                    this.scaling = internalscale;
                }

            }

            //this.scaling = DocObj.pages[DocObj.currentpage].dscale;
            this.xoffset = parseFloat(xmlDoc.getElementsByTagName('Xoffset')[0].firstChild.nodeValue);
            this.yoffset = parseFloat(xmlDoc.getElementsByTagName('Yoffset')[0].firstChild.nodeValue);

            if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {

                this.x = (this.x + this.xoffset) * internalscale;
                this.y = (this.y + this.yoffset) * internalscale;

                var bCircle = (this.type == 4 && this.subtype == 1 && bNewestFileformat);
                if (this.type == 0 || this.type == 1 || this.type == 2 || this.type == 6 || this.type == 7 || this.type == 8 || bCircle) {
                    this.w = (this.w + this.xoffset) * internalscale;
                    this.h = (this.h + this.yoffset) * internalscale;

                }else{
                    if(this.type == 10 && bfixedScale){
                        this.w *= fixedscale;
                        this.h *= fixedscale;
                    }else{
                        this.w *= internalscale;
                        this.h *= internalscale;
                    }
                }
            }

            if(this.type == 7){
                if (xmlDoc.getElementsByTagName('LeaderLineOffset')[0] != undefined) {
                    this.leaderoffset = xmlDoc.getElementsByTagName('LeaderLineOffset')[0].firstChild.nodeValue;
                    if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {
                        this.leaderoffset *= internalscale;
                    }
                }
            }

            if(this.type == 8){
                if (xmlDoc.getElementsByTagName('LabelOffsetX')[0] != undefined) {
                    this.labeloffsetx = xmlDoc.getElementsByTagName('LabelOffsetX')[0].firstChild.nodeValue;
                    if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {
                        this.labeloffsetx *= internalscale;
                    }
                }
                if (xmlDoc.getElementsByTagName('LabelOffsetY')[0] != undefined) {
                    this.labeloffsety = xmlDoc.getElementsByTagName('LabelOffsetY')[0].firstChild.nodeValue;
                    if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {
                        this.labeloffsety *= internalscale;
                    }
                }
                if (xmlDoc.getElementsByTagName('LabelColor')[0] != undefined) {
                    this.labelfillcolor = xmlDoc.getElementsByTagName('LabelColor')[0].firstChild.nodeValue;
                }

            }


            this.linewidth = xmlDoc.getElementsByTagName('LineWidth')[0].firstChild.nodeValue;

            /*if(this.type == 0 && this.subtype == 1){
                this.linewidth /= 10;
            }*/



            if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {
                if(bfixedScale){
                    this.linewidth *= fixedscale;
                }else{
                    this.linewidth *= internalscale;
                }

                this.arrowlength = nArrowSize + this.linewidth;
            }

            if(xmlDoc.getElementsByTagName('ArrowSize')[0] != undefined){
                var arrowsize = parseInt(xmlDoc.getElementsByTagName('ArrowSize')[0].firstChild.nodeValue);
                if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {

                    this.arrowlength = arrowsize + this.linewidth;
                }


            }


            if(xmlDoc.getElementsByTagName('LineStyle')[0] != undefined){
                this.linestyle = parseFloat(xmlDoc.getElementsByTagName('LineStyle')[0].firstChild.nodeValue);
            }

            this.text = xmlDoc.getElementsByTagName('Text')[0].firstChild.nodeValue;
            if (this.text == ".") {
                this.text = "";
            }

            if (xmlDoc.getElementsByTagName('SmallText')[0] != undefined) {
                this.smalltext = xmlDoc.getElementsByTagName('SmallText')[0].firstChild.nodeValue;
                if (this.smalltext == ".") {
                    this.smalltext = "";
                }
            }

            if (xmlDoc.getElementsByTagName('DimText')[0] != undefined && xmlDoc.getElementsByTagName('DimText')[0].firstChild != null) {
                this.dimtext = xmlDoc.getElementsByTagName('DimText')[0].firstChild.nodeValue;
                if (this.dimtext == ".") {
                    this.dimtext = "";
                }

            }else{
                this.dimtext = "";
            }


            if (xmlDoc.getElementsByTagName('CustomLabelText')[0] != undefined && xmlDoc.getElementsByTagName('CustomLabelText')[0].firstChild != null) {
                this.customlabeltext = xmlDoc.getElementsByTagName('CustomLabelText')[0].firstChild.nodeValue;
                if (this.customlabeltext == ".") {
                    this.customlabeltext = "";
                }

            }else{
                this.customlabeltext = "";
            }

            if (xmlDoc.getElementsByTagName('CustomLabelOn')[0] != undefined) {
                this.busecustomlabel = (parseInt(xmlDoc.getElementsByTagName('CustomLabelOn')[0].firstChild.nodeValue) == 1);
            }



            if (this.type == 1 || this.type == 2 || this.type == 8) {
                this.removepoints();
                if (xmlDoc.getElementsByTagName('Point').length != 0) {
                    var PointList = xmlDoc.getElementsByTagName('Point');
                    for (var i = 0; i < PointList.length; i++) {
                        var x = parseFloat(PointList[i].attributes.getNamedItem('x').value);
                        var y = parseFloat(PointList[i].attributes.getNamedItem('y').value);
                        if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {
                            x = (x + this.xoffset) * internalscale;
                            y = (y + this.yoffset) * internalscale;


                        }

                        markupobject.addpoint(x, y);
                    }
                    this.numpoints = PointList.length;
                    markupobject.findrectangle();
                    /*if (this.h == 0 && this.w == 0) {

                    }*/
                } else {
                    return false;
                }

            }

            if(this.type == 0 ){
                this.removepoints();
                if (xmlDoc.getElementsByTagName('Line').length != 0) {
                    var pointLines = xmlDoc.getElementsByTagName('Line');
                    for (i = 0; i < pointLines.length; i++) {
                        var linePoints = pointLines[i].getElementsByTagName('Point');
                        for (var j = 0; j < linePoints.length; j++) {
                            x = parseFloat(linePoints[j].attributes.getNamedItem('x').value);
                            y = parseFloat(linePoints[j].attributes.getNamedItem('y').value);
                            if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {
                                x = (x + this.xoffset) * internalscale;
                                y = (y + this.yoffset) * internalscale;
                            }
                            var tempPoint = new point(x,y);
                            this.points.push(tempPoint);


                            //this.pointlist[i][j].y = y;

                        }
                        this.pointlist.push(this.points);
                        this.points = [];
                    }

                    markupobject.findrectangle();

                }else{
                    return false;
                }

            }

            if (bNewFileformat && (pageobject.usepdfjs || pageobject.usevectorxml)) {
                this.xoffset *= internalscale;
                this.yoffset *= internalscale;
            }

            if (this.type == 12) {
                if(this.transparency == undefined){
                    this.transparency = 30;
                    this.fillcolor = setTransp(this.fillcolor,this.transparency);
                }

                if (this.subtype == 100) {
                    this.text = xmlDoc.getElementsByTagName('Text')[0].firstChild.nodeValue;
                }


                //this.textheight = this.w * 0.16;
                //this.font.setHeight(this.textheight);
                this.font.setFontname("Times New Roman");
                this.font.setBold(true);
                //ctx.font = "bold " + textstampscaled + "pt " + "Times New Roman";
                this.stampsmalltheight = (this.w * 0.08) - 4;
                var combinedtextheight = this.textheight + this.stampsmalltheight + ((this.h / 10) * 2);
                if (combinedtextheight > this.h) {
                    this.textheight = (this.h / 2) - ((this.h / 10) * 2);
                    this.stampsmalltheight = (this.textheight / 2) - 4;

                }


            }

            if (this.type == 11) {
                var createimage = new Image();
                if (xmlDoc.getElementsByTagName('Image')[0] != undefined && xmlDoc.getElementsByTagName('Image')[0].firstChild != null) {
                    if(xmlDoc.getElementsByTagName('Image')[0].firstChild.nodeValue != ""){
                        if (xmlDoc.getElementsByTagName('Image')[0].firstChild.nodeValue == "\n"){
                            var cdata = xmlDoc.getElementsByTagName('Image')[0].firstChild.nextSibling.nodeValue;
                        }else{
                            cdata = xmlDoc.getElementsByTagName('Image')[0].firstChild.nodeValue;
                            cdata = cdata.slice(9,cdata.length - 3);
                        }

                        //cdata = cdata.slice(cdata.length - 3);
                        //"<![CDATA[" + dataURL + "]]>";
                        //createimage.setAttribute('src',cdata);

                        markupobject.markupcdataload(createimage, cdata);
                        //createimage.addEventListener('load', markupobject.markupcdataload, false);
                        //createimage.src = cdata;
                        //this.image = createimage;
                        //markupobject.imageloaded = true;

                    }

                }else if (xmlDoc.getElementsByTagName('Imagehref')[0] != undefined && xmlDoc.getElementsByTagName('Imagehref')[0].firstChild != null) {
                    var imageurl = xmlDoc.getElementsByTagName('Imagehref')[0].firstChild.nodeValue;
                    markupobject.imagehref = imageurl;
                    markupobject.markupimageload(imageurl,createimage);
                    //createimage.src = imageurl;
                    //this.image = createimage;
                    //this.dimtext = "";
                }else{
                    this.type = 3;
                    this.subtype = 0;
                    this.alternative = 0;
                }

                //create image either from separate image or embedded data.
                //this.image = createimage;
            }
            //this.stampsmalltheight = this.textheight / 2;
            if(this.type == 12){
                markupobject.restorestampfontSize();
             }


            //<Points>
            /*if (xmlDoc.getElementsByTagName('DimText')[0].firstChild.length != 0){
             this.text = xmlDoc.getElementsByTagName('DimText')[0].firstChild.nodeValue;
             }*/

            /*this.x = xmlDoc.getElementsByTagName('Rect')[0].attributes['x'].value;
             this.y = xmlDoc.getElementsByTagName('Rect')[0].attributes['y'].value;
             this.w = xmlDoc.getElementsByTagName('Rect')[0].attributes['w'].value;
             this.h = xmlDoc.getElementsByTagName('Rect')[0].attributes['h'].value;*/
            /*
             Add function for getting points for polylines pencil etc.
             */
            return true;
        };


        this.markupcdataload = function(image, cdata){



            image.onload = function(ev){

                markupobject.image = image;
                markupobject.imageloaded = true;

                drawmarkupAll(cntximg);
                DrawMarkupSelected(context);

            };

            image.src = cdata;

        };

        this.markupimageload = function(imageURL, image){

            var oReq = new XMLHttpRequest();
            oReq.withCredentials = bUseCredentials;

            oReq.open("GET", imageURL, true);
            oReq.responseType = "blob";

            oReq.onload = function (oEvent) {
                var url = URL.createObjectURL(oReq.response);
                    if (url) {

                        markupobject.markupcdataload(image, url);
                        //image.src = url;
                        //markupobject.image = image;
                        //markupobject.imageloaded = true;

                        //drawmarkupAll(cntximg);
                        //DrawMarkupSelected(context);

                    }
            };
            oReq.send(null);


        };

        this.GetLinestyle = function (linestyle,ctx,scale) {

            switch (linestyle) {
                case 0:
                    break;
                case 1:
                    ctx.setLineDash([10*scale]);
                    break;
                case 2:
                    ctx.setLineDash([2*scale, 5*scale]);
                    break;
                case 3:
                    ctx.setLineDash([10*scale, 5*scale, 2*scale, 5*scale, 2*scale, 5*scale]);
                    break;
                case 4:
                    ctx.setLineDash([10*scale, 5*scale, 2*scale, 5*scale]);
                    break;
                case 5:
                    ctx.setLineDash([0, 15*scale, 15*scale, 0]);
                    break;
                case 6:
                    ctx.setLineDash([15*scale, 15*scale]);
                    break;

            }

        };


        this.GetDateTime = function (time) {

            var dDate = new Date(markupobject.timestamp);

            var day = dDate.getDate();
            var month = dDate.getMonth();
            month = month + 1;
            var year = dDate.getFullYear();
            //var hours = dDate.getHours();
            var hours = (dDate.getHours()<10?'0':'') + dDate.getHours();
            //var minutes = dDate.getMinutes();
            var minutes = (dDate.getMinutes()<10?'0':'') + dDate.getMinutes();
            //var seconds = dDate.getSeconds();
            var seconds = (dDate.getSeconds()<10?'0':'') + dDate.getSeconds();

            if (time) {
                return day + "." + month + "." + year + " " + hours + ":" + minutes + ":" + seconds;
            } else {
                return day + "." + month + "." + year;
            }

        };


        this.getdiag = function (width, height) {


            var dimwsq = Math.pow(width, 2);
            var dimhsq = Math.pow(height, 2);
            var dimdiag = Math.sqrt((dimwsq + dimhsq));

            return dimdiag;

        };



        this.onPanScale = function(){
            //move operation to markup object.

            /*var curscale = DocObj.pages[DocObj.currentpage].getdscale();
            var pagedx = DocObj.pages[DocObj.currentpage].getdx();
            var pagedy = DocObj.pages[DocObj.currentpage].getdy();

            var scalediff = (curscale / arrowmarkupobj.scaling);

            var changex = ((arrowmarkupobj.w - pagedx) / scalediff) + arrowmarkupobj.xoffset;
            var changey = ((arrowmarkupobj.h - pagedy) / scalediff) + arrowmarkupobj.yoffset;

            arrowmarkupobj.w = changex;
            arrowmarkupobj.h = changey;*/

        };


        this.setDimDrawme = function(){


            if(this.type == 6 || this.type == 7){
                var coords = {
                    x : this.x,
                    y : this.y,
                    w : this.w,
                    h : this.h,

                }
            }else if (this.type == 1 || this.type == 8){

                var point = this.getlastpoint();

                if (!point){
                    return {x:0, y:0 , w:0, h:0};
                }

                coords = {
                    x : point.x,
                    y : point.y,
                    w : point.x,
                    h : point.y,

                }
            }


            var rotation = DocObj.pages[DocObj.currentpage].drotation;

            var scalefactor = DocObj.pages[DocObj.currentpage].dscale; // markupobject.scaling;


            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector; // markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {

                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf); // markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale; // markupobject.scaling;
                if (DocObj.Type == 0) {
                    scalefactor = DocObj.pages[0].dscale; // markupobject.scaling;
                }

            }
            //var fixedscale = DocObj.pages[DocObj.currentpage].fixedScale;
            //markupobject.fixedscaleFactor =  scalefactor / DocObj.pages[DocObj.currentpage].fixedScale;

            scalefactor /= markupobject.scaling;

            var pagedx = 0;
            var pagedy = 0;

            if (DocObj.Type == 0) {
                var docdx = DocObj.pages[0].dx;
            } else {
                docdx = DocObj.pages[DocObj.currentpage].dx;
            }

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                pagedx = DocObj.pages[DocObj.currentpage].dxvector;
                pagedy = DocObj.pages[DocObj.currentpage].dyvector;


            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                pagedx = DocObj.pages[DocObj.currentpage].dxpdf;
                pagedy = DocObj.pages[DocObj.currentpage].dypdf;

            } else {
                pagedx = docdx;
                pagedy = DocObj.pages[DocObj.currentpage].dy;

            }


            var pagecorner = getPageRotCorner({x:pagedx, y:pagedy});
            var rotoffset = getPageRotCorner({x:this.xoffset, y:this.yoffset});



            switch(rotation){
                case 0:
                    if (this.type == 6 || this.type == 7){
                        coords.x = ((this.x - pagedx) / scalefactor) + this.xoffset;
                        coords.y = ((this.y - pagedy) / scalefactor) + this.yoffset;

                        coords.w = ((this.w - pagedx) / scalefactor) + this.xoffset;
                        coords.h = ((this.h - pagedy) / scalefactor) + this.yoffset;

                    }else if (this.type == 1 || this.type == 8){
                        coords.w = ((point.x - pagedx) / scalefactor) + this.xoffset;
                        coords.h = ((point.y - pagedy) / scalefactor) + this.yoffset;

                    }

                    break;
                case 90:

                    if (this.type == 6 || this.type == 7){
                        coords.x = ((this.x - pagecorner.x) / scalefactor) + rotoffset.y;
                        coords.y = ((this.y - pagecorner.y) / scalefactor) + rotoffset.x;

                        coords.w = ((this.w - pagecorner.x) / scalefactor) + rotoffset.x;
                        coords.h = ((this.h - pagecorner.y) / scalefactor) + rotoffset.y;

                    }else if (this.type == 1 || this.type == 8){

                        coords.w = ((point.x - pagecorner.x) / scalefactor) + rotoffset.x;
                        coords.h = ((point.y - pagecorner.y) / scalefactor) + rotoffset.y;

                    }




                    break;
                case 180:

                    if (this.type == 6 || this.type == 7){
                        coords.x = ((this.x - pagecorner.x) / scalefactor) + rotoffset.y;
                        coords.y = ((this.y - pagecorner.y) / scalefactor) + rotoffset.x;

                        coords.w = ((this.w - pagecorner.x) / scalefactor) + rotoffset.x;
                        coords.h = ((this.h - pagecorner.y) / scalefactor) + rotoffset.y;

                    }else if (this.type == 1 || this.type == 8){

                        coords.w = ((point.x - pagecorner.x) / scalefactor) + rotoffset.x;
                        coords.h = ((point.y - pagecorner.y) / scalefactor) + rotoffset.y;

                    }



                    break;
                case 270:

                    if (this.type == 6 || this.type == 7){
                        coords.x = ((this.x - pagecorner.x) / scalefactor) + rotoffset.y;
                        coords.y = ((this.y - pagecorner.y) / scalefactor) + rotoffset.x;

                        coords.w = ((this.w - pagecorner.x) / scalefactor) + rotoffset.x;
                        coords.h = ((this.h - pagecorner.y) / scalefactor) + rotoffset.y;

                    }else if (this.type == 1 || this.type == 8){

                        coords.w = ((point.x - pagecorner.x) / scalefactor) + rotoffset.x;
                        coords.h = ((point.y - pagecorner.y) / scalefactor) + rotoffset.y;

                    }


                    break;
            }

            var rotRad360 = 360 * (Math.PI / 180);

            var abswidthandheight = true;

            //coords.w = this.w * scalefactor;
            //coords.h = this.h * scalefactor;

            if (DocObj.Type == 0) {
                var docdx = DocObj.pages[0].dx;
            } else {
                docdx = DocObj.pages[DocObj.currentpage].dx;
            }
            /*switch (this.type) {
                case 6: //line arrow

                    coords.x += pagedx;
                    coords.y += pagedy;

                    coords.w += pagedx;
                    coords.h += pagedy;

                    //this.w = coords.w;
                    //this.h = coords.h;

                    //abswidthandheight = true;


                    break;
                case 7: //dimension line

                    coords.x += pagedx;
                    coords.y += pagedy;

                    //coords.w = (coords.w - this.xoffset) * scalefactor;
                    //coords.h = (coords.h - this.yoffset) * scalefactor;

                    coords.w += pagedx;
                    coords.h += pagedy;
                    //this.w = coords.w;
                    //this.h = coords.h;

                    //abswidthandheight = true;

                    break;
            }*/

            /*var CanvRotRad = (360 - DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);

            if (DocObj.pages[DocObj.currentpage].drotation != 0){

                var transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, coords.x, coords.y, CanvRotRad);
                coords.x = transpoint.x;
                coords.y = transpoint.y;

            }*/


            return coords;
        };

        this.SetDimensions = function (scalefactor, rotation, pagedx, pagedy) {
            //Calculate the scaled and rotated coordinates and store them.

            //var scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
            /*if (!markupobject.saved){
                rotation = 0;
            }*/

            var rotRad360 = 360 * (Math.PI / 180);

            var abswidthandheight = true;

            this.xscaled = (this.x - this.xoffset) * scalefactor;
            this.yscaled = (this.y - this.yoffset) * scalefactor;
            this.wscaled = this.w * scalefactor;
            this.hscaled = this.h * scalefactor;

            if (DocObj.Type == 0) {
                var docdx = DocObj.pages[0].dx;
            } else {
                docdx = DocObj.pages[DocObj.currentpage].dx;
            }


            switch (this.type) {
                case 0: //pencil, marker, eraser
                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;

                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    this.wscaled = (this.w - this.xoffset) * scalefactor;
                    this.hscaled = (this.h - this.yoffset) * scalefactor;
                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.wscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dyvector;

                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.wscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.wscaled += docdx;
                     //this.wscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/
                    this.wscaled += pagedx;
                    this.hscaled += pagedy;

                    abswidthandheight = true;


                    break;
                case 1: //polygon
                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;
                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;


                    this.wscaled = (this.w - this.xoffset) * scalefactor;
                    this.hscaled = (this.h - this.yoffset) * scalefactor;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.wscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.wscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dypdf;
                     }else{
                     this.wscaled += docdx;
                     //this.wscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/
                    this.wscaled += pagedx;
                    this.hscaled += pagedy;

                    abswidthandheight = true;

                    break;
                case 2:
                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;


                    this.wscaled = (this.w - this.xoffset) * scalefactor;
                    this.hscaled = (this.h - this.yoffset) * scalefactor;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.wscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.wscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.wscaled += docdx;
                     //this.wscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/
                    this.wscaled += pagedx;
                    this.hscaled += pagedy;


                    abswidthandheight = true;


                    break;


                case 3: //rectangle
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    abswidthandheight = false;

                    break;
                case 4: //oval
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    if (this.subtype == 1){

                        this.wscaled = (this.w - this.xoffset) * scalefactor;
                        this.hscaled = (this.h - this.yoffset) * scalefactor;

                        this.wscaled += pagedx;
                        this.hscaled += pagedy;

                        abswidthandheight = true;
                    }else{
                        abswidthandheight = false;
                    }

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/


                    break;
                case 5:
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/


                    abswidthandheight = false;


                    break;
                case 6: //line arrow

                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    this.wscaled = (this.w - this.xoffset) * scalefactor;
                    this.hscaled = (this.h - this.yoffset) * scalefactor;

                    this.wscaled += pagedx;
                    this.hscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     this.wscaled += DocObj.pages[this.pagenumber].dxvector;
                     this.hscaled += DocObj.pages[this.pagenumber].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;
                     this.wscaled += DocObj.pages[this.pagenumber].dxpdf;
                     this.hscaled += DocObj.pages[this.pagenumber].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;
                     this.wscaled += DocObj.pages[this.pagenumber].dx;
                     this.hscaled += DocObj.pages[this.pagenumber].dy;

                     }*/


                    abswidthandheight = true;


                    break;
                case 7: //dimension line

                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    this.wscaled = (this.w - this.xoffset) * scalefactor;
                    this.hscaled = (this.h - this.yoffset) * scalefactor;

                    this.wscaled += pagedx;
                    this.hscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     this.wscaled += DocObj.pages[this.pagenumber].dxvector;
                     this.hscaled += DocObj.pages[this.pagenumber].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;
                     this.wscaled += DocObj.pages[this.pagenumber].dxpdf;
                     this.hscaled += DocObj.pages[this.pagenumber].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;
                     this.wscaled += DocObj.pages[this.pagenumber].dx;
                     this.hscaled += DocObj.pages[this.pagenumber].dy;

                     }*/

                    abswidthandheight = true;


                    break;

                case 8:
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    this.wscaled = (this.w - this.xoffset) * scalefactor;
                    this.hscaled = (this.h - this.yoffset) * scalefactor;

                    this.wscaled += pagedx;
                    this.hscaled += pagedy;


                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.wscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.wscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.wscaled += docdx;
                     //this.wscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    abswidthandheight = true;


                    break;
                case 9: //text
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    if (this.subtype == 1 || this.subtype == 2){
                        abswidthandheight = false;
                    }else{
                        this.wscaled = this.textwidth; // * scalefactor;
                        this.hscaled = this.textheight * scalefactor;

                    }



                    //width and height determined by text and font set in draw function
                    abswidthandheight = false;
                    break;
                case 10:

                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    if(bUseFixedScale){
                        this.wscaled = this.w * markupobject.fixedscaleFactor;
                        this.hscaled = this.h * markupobject.fixedscaleFactor;

                    }else{
                        this.wscaled = this.w * scalefactor;
                        this.hscaled = this.h * scalefactor;

                    }


                    abswidthandheight = false;
                    break;
                //image
                case 11:
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    this.wscaled = this.w * scalefactor;
                    this.hscaled = this.h * scalefactor;

                    abswidthandheight = false;

                    break;

                case 12:
                    this.xscaled += pagedx;
                    this.yscaled += pagedy;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
                     this.xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){

                     this.xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                     }else{
                     this.xscaled += docdx;
                     //this.xscaled += DocObj.pages[DocObj.currentpage].dx;
                     this.yscaled += DocObj.pages[DocObj.currentpage].dy;

                     }*/

                    abswidthandheight = false;
                    break;


            }

            //var centerx = this.xscaled + (this.wscaled / 2);
            //var centery = this.yscaled + (this.hscaled / 2);
            var anglerad = rotation * (Math.PI / 180);
            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);

            this.rotatedrect.x = this.xscaled;
            this.rotatedrect.y = this.yscaled;
            this.rotatedrect.w = this.wscaled;
            this.rotatedrect.h = this.hscaled;


            /*if (markupobject.textrotate !=0 && this.type == 9){
             var textp = markupobject.getRotatedMarkup(this.xscaled,this.yscaled,this.rotatedrect.w,this.rotatedrect.h,markupobject.textrotate);
             this.rotatedrect.w = textp.x;
             this.rotatedrect.h = textp.y;
             }*/


            if (rotation != 0) {
                markupobject.setRotatedMarkuprect(centercanvX, centercanvY, abswidthandheight, anglerad);


            }

            if (this.type == 9 && this.subtype == 0 && this.textrotate != 0)  {

                if (rotation == 0) {
                    //this.rotatedrect.x = this.xscaled;
                    //this.rotatedrect.y = this.yscaled;
                    //this.rotatedrect.w = this.xscaled + this.wscaled;
                    //this.rotatedrect.h = this.yscaled - this.hscaled;
                    //markupobject.setRotatedMarkuprect(centercanvX, centercanvY,abswidthandheight, anglerad);

                }
                var txtx = Math.min(this.rotatedrect.x, this.rotatedrect.w);
                var txtw = Math.max(this.rotatedrect.x, this.rotatedrect.w);
                var txty = Math.min(this.rotatedrect.y, this.rotatedrect.h);
                var txth = Math.max(this.rotatedrect.y, this.rotatedrect.h);
                var rotatefactor = markupobject.textrotate - rotRad360;
                var textp = markupobject.getRotatedMarkup(this.rotatedrect.x, this.rotatedrect.y, this.rotatedrect.w, this.rotatedrect.h, rotatefactor);
                this.rotatedrect.w = textp.x;
                this.rotatedrect.h = textp.y;

                if (this.textrotate / (Math.PI / 180) == 180 && rotation == 0) {
                    rotatefactor = markupobject.textrotate;
                    textp = markupobject.getRotatedMarkup(this.rotatedrect.x, this.rotatedrect.y, this.rotatedrect.w, this.rotatedrect.h, rotatefactor);
                    this.rotatedrect.w = textp.x;
                    this.rotatedrect.h = textp.y;

                }

                /*var txtx = Math.min(this.rotatedrect.x,this.rotatedrect.w);
                 var txtw = Math.max(this.rotatedrect.x,this.rotatedrect.w);
                 var txty = Math.min(this.rotatedrect.y,this.rotatedrect.h);
                 var txth = Math.max(this.rotatedrect.y,this.rotatedrect.h);

                 rotwidth = txtw - txtx;
                 rotheight = txth - txty;

                 var rotwidtheight = markupobject.getMarkupSelectPointRot(this.rotatedrect.w, this.rotatedrect.h,markupobject.textrotate);
                 this.rotatedrect.w = this.rotatedrect.x + rotwidtheight.x;
                 this.rotatedrect.h = this.rotatedrect.y + rotwidtheight.y;*/


            }

            if (this.type == 9 && (this.subtype == 1 || this.subtype == 2)){
                if (rotation != 0) {

                    //markupobject.setRotatedMarkuprect(centercanvX, centercanvY, abswidthandheight,anglerad - (90 * (Math.PI / 180)));
                    //var textrectx1 = Math.min(this.rotatedrect.x, this.rotatedrect.w);
                    //var textrectx2 = Math.max(this.rotatedrect.x, this.rotatedrect.w);
                    //var textrecty1 = Math.min(this.rotatedrect.y, this.rotatedrect.h);
                    //var textrecty2 = Math.max(this.rotatedrect.y, this.rotatedrect.h);

                    //this.xscaled = textrectx1;
                    //this.yscaled = textrecty2;

                }

            }

            //this.getRotatedMarkuprect = function (centercanvX, centercanvY,abswidthandheight, anglerad){


            /*this.rotatedrect.x = this.xscaled;
             this.rotatedrect.y = this.yscaled;
             this.rotatedrect.w = this.wscaled;
             this.rotatedrect.h = this.hscaled;*/


        };

        this.PolygonArea = function () {
            var i = 0;
            var area = 0.0;
            var n = this.points.length;


            for (i = 0; i < n - 1; i++) {
                area += (this.points[i].x * this.points[i + 1].y) - (this.points[i + 1].x * this.points[i].y);
            }
            area += (this.points[n - 1].x * this.points[0].y) - (this.points[0].x * this.points[n - 1].y);
            return Math.abs(area / 2.0);
        };

        this.PolygonCentre = function (xy) {
            var centre = 0;
            var n = this.points.length;
            var i;
            if (xy == 'x') {
                if (n > 0) {
                    for (i = 0; i < n; i++) {
                        centre += this.points[i].x;
                    }
                    centre = centre / n;

                }
            } else {
                if (n > 0) {
                    for (i = 0; i < n; i++) {
                        centre += this.points[i].y;
                    }
                    centre = centre / n;

                }

            }
            return centre;
        };

        this.FindText = function (SearchExpr) {
            var found = false;
            var pos = this.text.search(SearchExpr);
            if (pos == -1) {
                found = false
            } else if (pos >= 0) {
                found = true;
            }
            return found;
        };

        this.RotateText = function () {

        };
        this.AdjustForRotation = function (save) {
            var CanvRotRad = (360 - DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
            var CanvRotRadOrig = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);
            var counter = 0;
            var lcounter = 0;
            var transpoint = new point();
            var absX = 0;
            var absY = 0;
            var ulx = 0;
            var uly = 0;

            if (DocObj.pages[DocObj.currentpage].drotation == 0) {
                return;

            }


            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:
                    return;
                    break;
                case 90:
                    absX = this.x;
                    absY = this.y + this.h;
                    ulx = this.x + this.w;
                    uly = this.y;
                    break;
                case 180:
                    absX = this.x;
                    absY = this.y;
                    ulx = this.x + this.w;
                    uly = this.y + this.h;
                    break;
                case 270:
                    absX = this.x + this.w;
                    absY = this.y;
                    ulx = this.x;
                    uly = this.y + this.h;
                    break;
            }


            switch (this.type) {
                case 0: //eraser, pencil, marker
                    //for each point
                    //markupobject.setinitRotatedMarkuppoint(centercanvX, centercanvY,abswidthandheight, CanvRotRad);
                    //set new this.x and new this.y

                    for (lcounter = 0; lcounter < this.pointlist.length; lcounter++) {
                        for (counter = 0; counter < this.pointlist[lcounter].length; counter++) {

                            transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.pointlist[lcounter][counter].x, this.pointlist[lcounter][counter].y, CanvRotRad);
                            this.pointlist[lcounter][counter].x = transpoint.x;
                            this.pointlist[lcounter][counter].y = transpoint.y;


                        }
                    }



                    markupobject.findrectangle();
                    break;
                case 1: //polygons
                    //for each point
                    /*for (counter = 0; counter < this.points.length; counter++) {
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[counter].x, this.points[counter].y, CanvRotRad);
                        this.points[counter].x = transpoint.x;
                        this.points[counter].y = transpoint.y;

                    }*/

                    //always start with point 0

                    if (!markupobject.firstpointset){
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[0].x, this.points[0].y, CanvRotRad);
                        this.points[0].x = transpoint.x;
                        this.points[0].y = transpoint.y;
                        markupobject.firstpointset = true;
                    }else{
                        //test always setting this.
                    }

                    var curpoint = this.points.length - 1;
                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[curpoint].x, this.points[curpoint].y, CanvRotRad);
                    this.points[curpoint].x = transpoint.x;
                    this.points[curpoint].y = transpoint.y;



                    markupobject.findrectangle();

                    break;
                case 2: //Poly curves
                    //for each point
                    for (counter = 0; counter < this.points.length; counter++) {
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[counter].x, this.points[counter].y, CanvRotRad);
                        this.points[counter].x = transpoint.x;
                        this.points[counter].y = transpoint.y;
                    }
                    markupobject.findrectangle();
                    break;
                case 3: //Rectangle


                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, ulx, uly, CanvRotRad);
                    this.x = transpoint.x;
                    this.y = transpoint.y;

                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, absX, absY, CanvRotRad);
                    this.w = transpoint.x - this.x;
                    this.h = transpoint.y - this.y;


                    break;
                case 4: //Oval


                    if (markupobject.subtype != 1){
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, ulx, uly, CanvRotRad);
                        this.x = transpoint.x;
                        this.y = transpoint.y;

                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, absX, absY, CanvRotRad);
                        this.w = transpoint.x - this.x;
                        this.h = transpoint.y - this.y;


                    }else{
                        if(!save){
                            transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRad);
                            this.x = transpoint.x;
                            this.y = transpoint.y;

                            transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.w, this.h, CanvRotRad);
                            this.w = transpoint.x;
                            this.h = transpoint.y;

                        }else{
                            transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRadOrig);
                            this.x = transpoint.x;
                            this.y = transpoint.y;

                        }

                    }

                    break;
                case 5: //Cloud

                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, ulx, uly, CanvRotRad);
                    this.x = transpoint.x;
                    this.y = transpoint.y;

                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, absX, absY, CanvRotRad);
                    this.w = transpoint.x - this.x;
                    this.h = transpoint.y - this.y;

                    break;
                case 6: //line arrow etc.

                    if(!save){
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRad);
                        this.x = transpoint.x;
                        this.y = transpoint.y;


                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.w, this.h, CanvRotRad);
                        this.w = transpoint.x;
                        this.h = transpoint.y;
                    }else{

                        if(bOrthoOn){
                            console.log(this.w, this.h);
                            transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.w, this.h, CanvRotRadOrig);
                            this.w = transpoint.x;
                            this.h = transpoint.y;
                            console.log(this.w, this.h);
                        }

                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRadOrig);
                        this.x = transpoint.x;
                        this.y = transpoint.y;

                    }

                    //markupobject.setinitRotatedMarkuppoint(centercanvX, centercanvY,abswidthandheight, CanvRotRad);
                    break;
                case 7: //dimension line.

                    if(!save){
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRad);
                        this.x = transpoint.x;
                        this.y = transpoint.y;

                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.w, this.h, CanvRotRad);
                        this.w = transpoint.x;
                        this.h = transpoint.y;

                    }else{

                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRadOrig);
                        this.x = transpoint.x;
                        this.y = transpoint.y;

                    }


                    break;
                case 8:
                    if (!this.firstpointrotAdjusted){
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[0].x, this.points[0].y, CanvRotRad);
                        this.points[0].x = transpoint.x;
                        this.points[0].y = transpoint.y;
                        this.firstpointrotAdjusted = true;
                    }
                    /*for (counter = 0; counter < this.points.length; counter++) {
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[counter].x, this.points[counter].y, CanvRotRad);
                        this.points[counter].x = transpoint.x;
                        this.points[counter].y = transpoint.y;
                    }*/
                    if(this.points.length == 2){

                        /*for (counter = 0; counter < this.points.length; counter++) {
                            transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[counter].x, this.points[counter].y, CanvRotRad);
                            this.points[counter].x = transpoint.x;
                            this.points[counter].y = transpoint.y;
                        }*/

                        /*var curpoint = this.points.length - 1;
                        var prevpoint = this.points.length - 2;
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[curpoint].x, this.points[curpoint].y, CanvRotRad);
                        this.points[curpoint].x = transpoint.x;
                        this.points[curpoint].y = transpoint.y;*/

                    }else{
                    }

                    var curpoint = this.points.length - 1;
                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.points[curpoint].x, this.points[curpoint].y, CanvRotRad);
                    this.points[curpoint].x = transpoint.x;
                    this.points[curpoint].y = transpoint.y;
                    markupobject.findrectangle();

                    break;
                case 9: //text markup
                    if (this.subtype == 1 || this.subtype == 2){
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, ulx, uly, CanvRotRad);
                        this.x = transpoint.x;
                        this.y = transpoint.y;

                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, absX, absY, CanvRotRad);
                        this.w = transpoint.x - this.x;
                        this.h = transpoint.y - this.y;

                    }else{
                        transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRad);
                        this.x = transpoint.x;
                        this.y = transpoint.y;

                        this.textrotate = CanvRotRad;

                    }
                    /*if (markupobject.textrotate !=0){
                     var textp = markupobject.getRotatedMarkup(this.x,this.y,this.x+this.w,this.y-this.h,markupobject.textrotate);
                     this.rotatedrect.w = textp2.x;
                     this.rotatedrect.h = textp2.y;
                     }*/

                    break;
                case 10: //note markup
                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRad);
                    this.x = transpoint.x;
                    this.y = transpoint.y;

                    break;
                case 11:
                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRad);
                    this.x = transpoint.x;
                    this.y = transpoint.y;

                    /*transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY,absX,absY, CanvRotRad);
                     this.w = transpoint.x - this.x;
                     this.h = transpoint.y - this.y;*/

                    break;

                case 12: //stamp markup

                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, ulx, uly, CanvRotRad);
                    this.x = transpoint.x;
                    this.y = transpoint.y;
                    this.textrotate = CanvRotRad;

                    transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, absX, absY, CanvRotRad);
                    this.w = transpoint.x - this.x;
                    this.h = transpoint.y - this.y;

                    break;
                default:
                    break;
            }


        };

        /* Andriy notify get markup listeners */

        /* Andriy nocallback */

        this.notify = function () {
            RxCore_GUI_Markuplist.notify();
        };

        this.addsides = function(){
            this.sides = [];
            if (this.points.length > 0){
                var side = {
                    x1 : this.points[0].x,
                    y1 : this.points[0].y,
                    x2 : this.points[0].x,
                    y2 : this.points[0].y
                };

                var counter = 0;
                //
                for (counter = 0; counter < this.points.length; counter++) {

                    if(counter == 0){
                        side = {
                            x1 : this.points[counter].x,
                            y1 : this.points[counter].y,
                            x2 : this.points[counter].x,
                            y2 : this.points[counter].y
                        };
                    }else if (counter > 0){
                        side.x2 = this.points[counter].x;
                        side.y2 = this.points[counter].y;
                        this.sides.push({x1:side.x1,y1:side.y1,x2:side.x2,y2:side.y2});
                        side.x1 = this.points[counter].x;
                        side.y1 = this.points[counter].y;

                    }
                }

                if( this.sides[0] != undefined){
                    side.x2 = this.sides[0].x1;
                    side.y2 = this.sides[0].y1;
                    this.sides.push({x1:side.x1,y1:side.y1,x2:side.x2,y2:side.y2});
                }
            }
        };

        this.savemetolistLoad = function(DocRef, last){

            markupobject.savemetolist(DocRef, !last,false,last);
            //markupobject.markupnumber = markupobject.markupID;

        };

        this.savemetolistDraw = function(){

            markupobject.savemetolist(DocObj,false,true);

        };

        this.savemetolist = function (DocRef,preventNotification,draw,last) {

            markupobject.saved = true;
            //
            var bisCircle = (markupobject.type == 4 && markupobject.subtype == 1);
            if(markupobject.type == 0 || markupobject.type == 6 || markupobject.type == 7 || markupobject.type == 9 || markupobject.type == 10 || markupobject.type == 11 || bisCircle){
                if (draw && markupobject.bUsemouseinput ){
                    markupobject.AdjustForRotation(true);
                }
                markupobject.bUsemouseinput = true;
            }

            markupobject.markupnumber = getlastmarkupnumber();
            DocRef.markupdraworder[DocRef.markupdraworder.length] = DocRef.markuplist.length;
            DocRef.markuplist[DocRef.markuplist.length] = markupobject;


                        //create undoboject where delete flag is true
                        if (draw){
                            var undoobj = new MarkupUndoObject(markupobject.markupnumber);
                            undoobj.SetUndoValues(markupobject);
                            undoobj.bdelete = true;
                            DocRef.markupundolist.push(undoobj);

                        }

            //DocObj.markuplist[markupobject.markupnumber].selected = true;

            DocRef.nummarkups++;
            if (RxCore_GUI_Markuplist != undefined) {
                RxCore_GUI_Markuplist.setMarkupList(DocRef.markuplist,DocRef.bActive, preventNotification);
            }
            if (last){
                if (Rxcore_GUI_markupLoadComplete != undefined) {
                    Rxcore_GUI_markupLoadComplete.loadComplete(DocRef.markuplist, DocRef.fileindex, DocRef.bActive);
                }

            }

            if (RxCore_GUI_pagethumbs != undefined) {
                RxCore_GUI_pagethumbs.setThumbnails(DocRef.thumbnails);
            }

        };

        this.rotate = function (x, y, corner) {

            var localx = x;
            var localy = y;

            var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);
            var rotRad360 = 360 * (Math.PI / 180);
            var negrotRad180 = -180 * (Math.PI / 180);
            var rotRad180 = 180 * (Math.PI / 180);
            var scalefactor = 0.0;


            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }
            /*var xscaled = this.x * scalefactor;
             var yscaled = this.y * scalefactor;
             var wscaled = this.w * scalefactor;
             var hscaled = this.h * scalefactor;*/

            var xscaled = (this.x - this.xoffset) * scalefactor;
            var yscaled = (this.y - this.yoffset) * scalefactor;
            var wscaled = this.w * scalefactor;
            var hscaled = this.h * scalefactor;

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                xscaled = xscaled + DocObj.pages[DocObj.currentpage].dxvector;
                yscaled = yscaled + DocObj.pages[DocObj.currentpage].dyvector;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                xscaled = xscaled + DocObj.pages[DocObj.currentpage].dxpdf;
                yscaled = yscaled + DocObj.pages[DocObj.currentpage].dypdf;

            } else {
                xscaled = xscaled + DocObj.pages[DocObj.currentpage].dx;
                yscaled = yscaled + DocObj.pages[DocObj.currentpage].dy;

            }
            var centerx = xscaled + (wscaled / 2);
            var centery = yscaled + (hscaled / 2);

            if (this.type == 9 && this.subtype == 0) {

                centerx = xscaled + (wscaled / 2);
                centery = yscaled - (hscaled / 2);
                var rotatefactor = 0;
                if (this.textrotate != 0) {
                    rotatefactor = rotRad360 - this.textrotate;
                    var textscaled = this.textheight * scalefactor;
                    var textwscaled = this.textwidth * scalefactor;
                    var rmcenter = markupobject.getMarkupSelectPointRot(textwscaled / 2, -(textscaled / 2), markupobject.textrotate);
                    centerx = xscaled + rmcenter.x;
                    centery = yscaled + rmcenter.y;

                }

            }

            var width = centerx - localx;
            var height = centery - localy;

            var temprot = Math.atan2(height, width);


            if (temprot < -(Math.PI * 0.5)) {
                temprot += Math.PI * 2;

            }




            var markupcenter = markupobject.getRotatedMarkup(centercanvX, centercanvY, centerx, centery, CanvRotRad);
            var markupxy = markupobject.getRotatedMarkup(centercanvX, centercanvY, xscaled, yscaled, CanvRotRad);


            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:
                    //localx = x;
                    //localy = y;
                    if (this.type == 9 && this.subtype == 0) {
                        markupobject.rotation = temprot - (Math.PI * 0.5) + rotatefactor;
                    } else {
                        markupobject.rotation = temprot - (Math.PI * 0.5);
                    }


                    break;
                case 90:
                    //localx = y;
                    //localy = -x;
                    width = localx - markupcenter.x;
                    height = localy - markupcenter.y;
                    temprot = Math.atan2(height, width);

                    if (this.type == 9 && this.subtype == 0) {
                        markupobject.rotation = temprot - (Math.PI * 0.5) + CanvRotRad + rotatefactor;
                    } else {
                        markupobject.rotation = temprot - (Math.PI * 0.5) + CanvRotRad;
                    }


                    break;
                case 180:
                    //localx = -x;
                    //localy = -y;
                    width = localx - markupcenter.x;
                    height = localy - markupcenter.y;
                    temprot = Math.atan2(height, width);


                    if (this.type == 9 && this.subtype == 0) {
                        markupobject.rotation = temprot - (Math.PI * 0.5) + rotatefactor;
                    } else {
                        markupobject.rotation = temprot - (Math.PI * 0.5);// + CanvRotRad;
                    }


                    break;
                case 270:
                    //localx = -y;
                    //localy = x;
                    width = localx - markupcenter.x;
                    height = localy - markupcenter.y;
                    temprot = Math.atan2(height, width);

                    if (this.type == 9 && this.subtype == 0) {
                        markupobject.rotation = temprot - (Math.PI * 0.5) + CanvRotRad + rotatefactor;
                    } else {
                        markupobject.rotation = temprot - (Math.PI * 0.5) + CanvRotRad;
                    }


                    break;
            }


            //rotation angle in radians
            //temprot = Math.atan2(height,width);

            //markupobject.rotation = temprot - (Math.PI*0.5) + CanvRotRad;
            switch (this.type) {
                case 0: //eraser, pencil, marker
                    //no rotation supported
                    markupobject.rotation = 0;
                    break;
                case 1: //polygons
                    //no rotation supported
                    markupobject.rotation = 0;
                    break;
                case 2: //Poly curves
                    //execute code block 2
                    markupobject.rotation = 0;
                    break;
                case 3: //Rectangle

                    break;
                case 4: //Oval
                    break;
                case 5: //Cloud
                    break;
                case 6: //line arrow etc.
                    //no rotation supported
                    markupobject.rotation = 0;
                    break;
                case 7: //dimension line.
                    //no rotation supported
                    markupobject.rotation = 0;
                    break;
                case 8:
                    //no rotation supported
                    markupobject.rotation = 0;
                    break;
                case 9: //text markup
                    break;
                case 12: //stamp markup
                    break;
                default:
                    break;
            }

            //var negrotRad180 = -180 * (Math.PI / 180);
            //var rotRad180 = 180 * (Math.PI / 180);


            if(markupobject.rotation < negrotRad180){
                markupobject.rotation += rotRad360;
            }

            if(markupobject.rotation > rotRad180){
                markupobject.rotation -= rotRad360;
            }


        };

        this.withinbounds = function (x, y) {
            var bwithin = false;
            var boundstartx = DocObj.pages[DocObj.currentpage].startx;
            var boundstarty = DocObj.pages[DocObj.currentpage].starty;
            var boundendx = DocObj.pages[DocObj.currentpage].endx;
            var boundendy = DocObj.pages[DocObj.currentpage].endy;

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                var scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;
            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }
            //scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
            var thisx = this.x * scalefactor;
            var thisy = this.y * scalefactor;
            var thisw = this.w * scalefactor;
            var thish = this.h * scalefactor;


            switch (this.type) {
                case 0: //eraser, pencil, marker
                    break;
                case 1: //polygons
                    break;
                case 2: //Poly curves
                    break;
                case 3: //Rectangle
                    thisx = this.xscaled;
                    thisy = this.yscaled;
                    thisw = this.xscaled + this.wscaled;
                    thish = this.yscaled + this.hscaled;
                    break;
                case 4: //Oval
                    thisx = this.xscaled;
                    thisy = this.yscaled;
                    thisw = this.xscaled + this.wscaled;
                    thish = this.yscaled + this.hscaled;

                    break;
                case 5: //Cloud
                    thisx = this.xscaled;
                    thisy = this.yscaled;
                    thisw = this.xscaled + this.wscaled;
                    thish = this.yscaled + this.hscaled;

                    break;
                case 6: //line arrow etc.
                    break;
                case 7: //dimension line.
                    break;
                case 8:
                    break;
                case 9: //text markup
                    if (this.subtype == 0){
                        thisx = this.xscaled;
                        thisy = this.yscaled;
                        thisw = this.xscaled + this.textwidth;
                        thish = this.yscaled - this.textheight;
                    }else if (this.subtype == 1 || this.subtype == 2){
                        thisx = this.xscaled;
                        thisy = this.yscaled;
                        thisw = this.xscaled + this.wscaled;
                        thish = this.yscaled + this.hscaled;
                    }




                    break;
                case 10: //text markup
                    thisx = this.xscaled;
                    thisy = this.yscaled;
                    thisw = this.xscaled + this.wscaled;
                    thish = this.yscaled + this.hscaled;

                    break;
                case 11: //image markup
                    thisx = this.xscaled;
                    thisy = this.yscaled;
                    thisw = this.xscaled + this.wscaled;
                    thish = this.yscaled + this.hscaled;
                    break;
                case 12: //stamp markup
                    thisx = this.xscaled;
                    thisy = this.yscaled;
                    thisw = this.xscaled + this.wscaled;
                    thish = this.yscaled + this.hscaled;

                    break;
                default:
                    break;

            }

            if (thisx + x > boundstartx) {
                if (thisy + y > boundstarty) {
                    if (thisw + x < boundendx) {
                        if (thish + y < boundendy) {
                            bwithin = true;
                        }
                    }
                }
            }
            return bwithin;

        };




        this.rotrect = function ( x, y, width, height){

            var tx = x + ((width - x) / 2);
            var ty = y + ((height - y) / 2);

            var ulrotpoint = markupobject.getMarkupSelectPointRot(-((width - x) / 2), -((height - y) / 2), markupobject.rotation);

            var lrrotpoint = markupobject.getMarkupSelectPointRot(((width - x) / 2), ((height - y) / 2), markupobject.rotation);

            var llrotpoint = markupobject.getMarkupSelectPointRot(-((width - x) / 2), ((height - y) / 2), markupobject.rotation);

            var urrotpoint = markupobject.getMarkupSelectPointRot(((width - x) / 2), -((height - y) / 2), markupobject.rotation);


            var minX = Math.min(tx + ulrotpoint.x, tx + lrrotpoint.x, tx + llrotpoint.x, tx + urrotpoint.x);
            var minY = Math.min(ty + ulrotpoint.y, ty + lrrotpoint.y, ty + llrotpoint.y, ty + urrotpoint.y);
            var maxX = Math.max(tx + ulrotpoint.x, tx + lrrotpoint.x, tx + llrotpoint.x, tx + urrotpoint.x);
            var maxY = Math.max(ty + ulrotpoint.y, ty + lrrotpoint.y, ty + llrotpoint.y, ty + urrotpoint.y);


            return {x : minX, y : minY, w : maxX - minX, h : maxY - minY};

        };


        this.setCurPoint = function(point){
            var bpolyline = (markupobject.type == 1 && (markupobject.subtype == 1 || markupobject.subtype == 3));

            if (bpolyline){
                if(markupobject.editcurpoint > 0){
                    markupobject.editcurpoint = point;
                }
            }else{
                if(markupobject.editcurpoint >= 0){
                    markupobject.editcurpoint = point;
                }
            }

            return markupobject.editcurpoint;

        };


        this.resetcupoint = function(){

            markupobject.editcurpoint = 0;

        };

        this.movePoints = function(x,y){
            var localx = x;
            var localy = y;
            var bMovepints = true;
            var bMovepintsx = true;
            var bMovepintsy = true;

            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:
                    localx = x;
                    localy = y;

                    break;
                case 90:
                    localx = y;
                    localy = -x;

                    break;
                case 180:
                    localx = -x;
                    localy = -y;

                    break;
                case 270:
                    localx = -y;
                    localy = x;

                    break;
            }


            var xscalepoint = 0;
            var yscalepoint = 0;

            var scalefactor = 0.0;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }


            var xscaled = this.x * scalefactor;
            var yscaled = this.y * scalefactor;
            var wscaled = this.w * scalefactor;
            var hscaled = this.h * scalefactor;


            var startx = DocObj.pages[DocObj.currentpage].startx;
            var endx = DocObj.pages[DocObj.currentpage].endx;
            var starty = DocObj.pages[DocObj.currentpage].starty;
            var endy = DocObj.pages[DocObj.currentpage].endy;


            var pcounter = 0;
            //var within = false;
            //wscaled = wscaled - localx;
            //hscaled = hscaled - localy;
            xscaled = xscaled - localx;
            yscaled = yscaled - localy;
            wscaled -= localx;
            hscaled -= localy;

            if (this.bispartofGroup){
                this.groupRect.x -= localx;
                this.groupRect.y -= localy;
                this.groupRect.w -= localx;
                this.groupRect.h -= localy;

            }

            if (bLimMarkupExtent) {
                if (this.bispartofGroup){
                    if (this.groupRect.x - localx < startx || this.groupRect.x - localx > endx) {
                        xscaled = xscaled + localx;

                        this.groupRect.x += localx;
                        this.groupRect.w += localx;

                        wscaled += localx;
                        bMovepints = false;
                        bMovepintsx = false;
                    }
                    if (this.groupRect.y - localy < starty || this.groupRect.y - localy > endy) {
                        yscaled = yscaled + localy;
                        hscaled += localy;
                        this.groupRect.y += localy;
                        this.groupRect.h += localy;


                        bMovepints = false;
                        bMovepintsy = false;
                    }

                }else{
                    if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                        xscaled = xscaled + localx;
                        wscaled += localx;
                        bMovepints = false;
                        bMovepintsx = false;

                    }
                    if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                        yscaled = yscaled + localy;
                        hscaled += localy;
                        bMovepints = false;
                        bMovepintsy = false;
                    }

                }
            }

            //set new this.x and new this.y

            if (bLimMarkupExtent) {
                if (this.bispartofGroup){
                    if (this.groupRect.w - localx < startx || this.groupRect.w - localx > endx) {
                        wscaled += localx;
                        xscaled = xscaled + localx;
                        this.groupRect.x += localx;
                        this.groupRect.w += localx;
                        bMovepints = false;
                        bMovepintsx = false;

                    }
                    if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                        hscaled += localy;
                        yscaled = yscaled + localy;
                        this.groupRect.y += localy;
                        this.groupRect.h += localy;

                        bMovepints = false;
                        bMovepintsy = false;
                    }

                }else{
                    if (this.wscaled - localx < startx || this.wscaled - localx > endx) {
                        wscaled += localx;
                        xscaled = xscaled + localx;
                        bMovepints = false;
                        bMovepintsx = false;

                    }
                    if (this.hscaled - localy < starty || this.hscaled - localy > endy) {
                        hscaled += localy;
                        yscaled = yscaled + localy;
                        bMovepints = false;
                        bMovepintsy = false;
                    }

                }


            }
            this.x = xscaled / scalefactor;
            this.y = yscaled / scalefactor;

            this.w = wscaled / scalefactor;
            this.h = hscaled / scalefactor;

            xscalepoint = 0;
            yscalepoint = 0;


            //set new this.x and new this.y


            for (pcounter = 0; pcounter < this.points.length; pcounter++) {

                if(bMovepintsx){
                    xscalepoint = this.points[pcounter].x * scalefactor;
                    xscalepoint -= localx;
                    this.points[pcounter].x = xscalepoint / scalefactor;
                }
                if(bMovepintsy){
                    yscalepoint = this.points[pcounter].y * scalefactor;
                    yscalepoint -= localy;
                    this.points[pcounter].y = yscalepoint / scalefactor;
                }



            }
            this.findrectangle();


            /*if (bMovepints) {
                for (pcounter = 0; pcounter < this.points.length; pcounter++) {
                    xscalepoint = this.points[pcounter].x * scalefactor;
                    yscalepoint = this.points[pcounter].y * scalefactor;
                    xscalepoint -= localx;
                    yscalepoint -= localy;

                    this.points[pcounter].x = xscalepoint / scalefactor;
                    this.points[pcounter].y = yscalepoint / scalefactor;
                }
                this.findrectangle();
            }else {
                this.findrectangle();
            }*/
            //this.findrectangle();
        };


        this.moveShape = function(x,y) {
            var localx = x;
            var localy = y;
            //var bMovepints = true;
            //var bMovepintsx = true;
            //var bMovepintsy = true;

            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:
                    localx = x;
                    localy = y;

                    break;
                case 90:
                    localx = y;
                    localy = -x;

                    break;
                case 180:
                    localx = -x;
                    localy = -y;

                    break;
                case 270:
                    localx = -y;
                    localy = x;

                    break;
            }

            var xscalepoint = 0;
            var yscalepoint = 0;

            var scalefactor = 0.0;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }

            //        scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
            var xscaled = this.x * scalefactor;
            var yscaled = this.y * scalefactor;
            var wscaled = this.w * scalefactor;
            var hscaled = this.h * scalefactor;

            var startx = DocObj.pages[DocObj.currentpage].startx;
            var endx = DocObj.pages[DocObj.currentpage].endx;
            var starty = DocObj.pages[DocObj.currentpage].starty;
            var endy = DocObj.pages[DocObj.currentpage].endy;


            xscaled = xscaled - localx;
            yscaled = yscaled - localy;

            if (this.bispartofGroup){


                this.groupRect.x -= localx;
                this.groupRect.y -= localy;
                this.groupRect.w -= localx;
                this.groupRect.h -= localy;

            }

            if (markupobject.rotation != 0){
                var rrect = markupobject.rotrect(this.xscaled, this.yscaled,this.xscaled + this.wscaled, this.yscaled + this.hscaled);
            }else{
                rrect = {x: this.xscaled, y : this.yscaled,w : this.wscaled, h : this.hscaled};
            }


            if (bLimMarkupExtent) {
                /*if (markupobject.rotation != 0){


                }else{
                    if ((this.xscaled - localx) < startx || (this.xscaled + localx) > endx) {
                        xscaled = xscaled + localx;

                    }
                    if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                        yscaled = yscaled + localy;
                    }

                }*/
                if (this.bispartofGroup){
                    if ((this.groupRect.x - localx) < startx || (this.groupRect.x + localx) > endx) {
                        xscaled = xscaled + localx;
                        this.groupRect.x += localx;
                        this.groupRect.w += localx;
                    }

                    if (this.groupRect.y - localy < starty || this.groupRect.y - localy > endy) {
                        yscaled = yscaled + localy;
                        this.groupRect.y += localy;
                        this.groupRect.h += localy;
                    }

                }else{
                    if ((rrect.x - localx) < startx || (rrect.x + localx) > endx) {
                        xscaled = xscaled + localx;
                    }

                    if (rrect.y - localy < starty || rrect.y - localy > endy) {
                        yscaled = yscaled + localy;
                    }

                }

            }

            //set new this.x and new this.y
            this.x = xscaled / scalefactor;
            this.y = yscaled / scalefactor;


            if (bLimMarkupExtent) {


                /*if (markupobject.rotation != 0){
                    if ((this.rotatedrect.x + this.rotatedrect.w) - localx < startx || (this.rotatedrect.x + this.rotatedrect.w) - localx > endx) {
                        xscaled = xscaled + localx;

                    }
                    if ((this.rotatedrect.y + this.rotatedrect.h) - localy < starty || (this.rotatedrect.y + this.rotatedrect.h) - localy > endy) {
                        yscaled = yscaled + localy;
                    }

                }else{

                }*/

                if (this.bispartofGroup){
                    if (this.groupRect.w - localx < startx || this.groupRect.w - localx > endx) {
                        xscaled = xscaled + localx;
                        this.groupRect.x += localx;
                        this.groupRect.w += localx;


                    }
                    if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                        yscaled = yscaled + localy;
                        this.groupRect.y += localy;
                        this.groupRect.h += localy;

                    }

                }else{
                    if ((rrect.x + rrect.w) - localx < startx || (rrect.x + rrect.w) - localx > endx) {
                        xscaled = xscaled + localx;

                    }
                    if ((rrect.y + rrect.h) - localy < starty || (rrect.y + rrect.h) - localy > endy) {
                        yscaled = yscaled + localy;
                    }

                }


                this.x = xscaled / scalefactor;
                this.y = yscaled / scalefactor;

            }

        };

        this.move = function (x, y) {

            if (this.type == 3 || this.type == 5 || (this.type == 4 && this.subtype == 0) || this.type == 10 || this.type == 11 || this.type == 12){
                markupobject.moveShape(x,y);
                return;
            }

            var bspace = (this.type == 8 || this.subtype == 1);

            if (this.type == 1 || this.type == 8){
                if(!bspace){
                    markupobject.movePoints(x,y);
                }
                return;
            }

            var localx = x;
            var localy = y;
            var bMovepints = true;
            var bMovepintsx = true;
            var bMovepintsy = true;

            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:
                    localx = x;
                    localy = y;

                    break;
                case 90:
                    localx = y;
                    localy = -x;

                    break;
                case 180:
                    localx = -x;
                    localy = -y;

                    break;
                case 270:
                    localx = -y;
                    localy = x;

                    break;
            }


            var xscalepoint = 0;
            var yscalepoint = 0;

            var scalefactor = 0.0;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }

            //        scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
            var xscaled = this.x * scalefactor;
            var yscaled = this.y * scalefactor;
            var wscaled = this.w * scalefactor;
            var hscaled = this.h * scalefactor;



            //this.xscaled = (this.x - this.xoffset) * scalefactor;
            //this.yscaled = (this.y - this.yoffset) * scalefactor;


            //var pageobjdim = DocObj.pages[DocObj.currentpage].getpagerect();

            var startx = DocObj.pages[DocObj.currentpage].startx;
            var endx = DocObj.pages[DocObj.currentpage].endx;
            var starty = DocObj.pages[DocObj.currentpage].starty;
            var endy = DocObj.pages[DocObj.currentpage].endy;

            /*if (this.bispartofGroup){

            }else{

            }*/


            switch (this.type) {
                case 0: //eraser, pencil, marker
                    var counter = 0;
                    var lcounter = 0;
                    //var within = false;

                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;
                    wscaled -= localx;
                    hscaled -= localy;

                    /*if (bLimMarkupExtent){
                     if((this.xscaled - localx) < DocObj.pages[DocObj.currentpage].startx || (this.xscaled - localx) > DocObj.pages[DocObj.currentpage].endx){
                     xscaled = xscaled + localx;
                     wscaled += localx;
                     bMovepints = false;

                     }
                     if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                     yscaled = yscaled + localy;
                     hscaled += localy;
                     bMovepints = false;
                     }
                     }*/

                    //set new this.x and new this.y

                    /*if (bLimMarkupExtent){
                     if(this.wscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.wscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                     xscaled += localx;
                     wscaled += localx;
                     bMovepints = false;

                     }
                     if(this.hscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.hscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                     yscaled += localy;
                     hscaled += localy;
                     bMovepints = false;
                     }
                     }*/

                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;

                    if (this.subtype == 1 || this.subtype == 0) {
                        this.w = wscaled / scalefactor;
                        this.h = hscaled / scalefactor;

                        //set new this.x and new this.y
                        if (bMovepints) {
                            for (lcounter = 0; lcounter < this.pointlist.length; lcounter++) {
                                for (counter = 0; counter < this.pointlist[lcounter].length; counter++) {
                                    xscalepoint = this.pointlist[lcounter][counter].x * scalefactor;
                                    yscalepoint = this.pointlist[lcounter][counter].y * scalefactor;
                                    xscalepoint = xscalepoint - localx;
                                    yscalepoint = yscalepoint - localy;
                                    /*if (bLimMarkupExtent){
                                     if(xscalepoint < DocObj.pages[DocObj.currentpage].startx || xscalepoint > DocObj.pages[DocObj.currentpage].endx){
                                     xscalepoint += localx;

                                     }
                                     if(yscalepoint <DocObj.pages[DocObj.currentpage].starty || yscalepoint > DocObj.pages[DocObj.currentpage].endy){
                                     yscalepoint += localy;
                                     }
                                     }*/

                                    this.pointlist[lcounter][counter].x = xscalepoint / scalefactor;
                                    this.pointlist[lcounter][counter].y = yscalepoint / scalefactor;

                                }
                            }


                        } else {
                            this.findrectangle();
                        }
                        //this.findrectangle();
                    }
                    break;

                case 2: //Poly curves
                    var curcounter = 0;
                    //var within = false;
                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;
                    wscaled -= localx;
                    hscaled -= localy;

                    if (bLimMarkupExtent) {
                        if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                            xscaled = xscaled + localx;
                            wscaled += localx;
                            bMovepints = false;

                        }
                        if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                            yscaled = yscaled + localy;
                            hscaled += localy;
                            bMovepints = false;
                        }
                    }


                    if (bLimMarkupExtent) {
                        if (wscaled < startx || wscaled > endx) {
                            xscaled += localx;
                            wscaled += localx;
                            bMovepints = false;

                        }
                        if (this.hscaled - localy < starty || this.hscaled - localy > endy) {
                            yscaled += localy;
                            hscaled += localy;
                            bMovepints = false;
                        }
                    }
                    //set new this.x and new this.y
                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;

                    this.w = wscaled / scalefactor;
                    this.h = hscaled / scalefactor;


                    //set new this.x and new this.y
                    if (bMovepints) {
                        for (curcounter = 0; curcounter < this.points.length; curcounter++) {
                            xscalepoint = this.points[curcounter].x * scalefactor;
                            yscalepoint = this.points[curcounter].y * scalefactor;
                            xscalepoint -= localx;
                            yscalepoint -= localy;
                            /*if (bLimMarkupExtent){
                             if(xscalepoint < DocObj.pages[DocObj.currentpage].startx || xscalepoint > DocObj.pages[DocObj.currentpage].endx){
                             xscalepoint += localx;


                             }
                             if(yscalepoint <DocObj.pages[DocObj.currentpage].starty || yscalepoint > DocObj.pages[DocObj.currentpage].endy){
                             yscalepoint += localy;

                             }
                             }*/

                            this.points[curcounter].x = xscalepoint / scalefactor;
                            this.points[curcounter].y = yscalepoint / scalefactor;

                        }

                    } else {
                        this.findrectangle();
                    }

                    break;

                case 4: //Oval

                    if (this.bispartofGroup){
                        this.groupRect.x -= localx;
                        this.groupRect.y -= localy;
                        this.groupRect.w -= localx;
                        this.groupRect.h -= localy;
                    }

                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;

                    var xscaledactual = (this.x - this.xoffset) * scalefactor;
                    var yscaledactual = (this.y - this.yoffset) * scalefactor;

                    xscaledactual += startx;
                    yscaledactual += starty;

                    xscaledactual -= localx;
                    yscaledactual -= localy;

                    if(this.subtype == 1){

                        wscaled -= localx;
                        hscaled -= localy;

                        var xdiff = Math.max(xscaled, wscaled) - Math.min(xscaled, wscaled);
                        var ydiff = Math.max(yscaled, hscaled) - Math.min(yscaled, hscaled);

                        var radius = markupobject.getdiag(xdiff, ydiff);

                        if (bLimMarkupExtent) {
                            if (this.bispartofGroup){
                                if ((this.groupRect.x - localx) < startx || (this.groupRect.x - localx) > endx) {
                                    xscaled += localx;
                                    wscaled += localx;
                                    this.groupRect.x += localx;
                                    this.groupRect.w += localx;
                                }

                                if (this.groupRect.y - localy < starty || this.groupRect.y - localy > endy) {
                                    yscaled += localy;
                                    hscaled += localy;
                                    this.groupRect.y += localy;
                                    this.groupRect.h += localy;
                                }

                                if (this.groupRect.w - localx < startx || this.groupRect.w - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled += localx;
                                    this.groupRect.x += localx;
                                    this.groupRect.w += localx;


                                }
                                if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled += localy;
                                    this.groupRect.y += localy;
                                    this.groupRect.h += localy;

                                }


                            }else{
                                if ((xscaledactual - radius) < startx || (xscaledactual + radius) > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled += localx;
                                    //yscaled = yscaled + localy;
                                }
                                if ((yscaledactual - radius) < starty || (yscaledactual + radius) > endy) {
                                    //xscaled = xscaled + localx;
                                    yscaled = yscaled + localy;
                                    hscaled += localy;
                                }

                            }


                        }

                        this.w = wscaled / scalefactor;
                        this.h = hscaled / scalefactor;

                        this.x = xscaled / scalefactor;
                        this.y = yscaled / scalefactor;


                    }else{

                        if (markupobject.rotation != 0){
                            var rrect = markupobject.rotrect(this.xscaled, this.yscaled,this.xscaled + this.wscaled, this.yscaled + this.hscaled);
                        }else{
                            rrect = {x: this.xscaled, y : this.yscaled,w : this.wscaled, h : this.hscaled};
                        }


                        if (bLimMarkupExtent) {
                            if (this.bispartofGroup){
                                if ((this.groupRect.x - localx) < startx || (this.groupRect.x + localx) > endx) {
                                    xscaled = xscaled + localx;
                                    this.groupRect.x += localx;
                                    this.groupRect.w += localx;
                                }

                                if (this.groupRect.y - localy < starty || this.groupRect.y - localy > endy) {
                                    yscaled = yscaled + localy;
                                    this.groupRect.y += localy;
                                    this.groupRect.h += localy;
                                }


                            }else{
                                if (rrect.x - localx < startx || rrect.x - localx > endx) {
                                    xscaled = xscaled + localx;

                                }
                                if (rrect.y - localy < starty || rrect.y - localy > endy) {
                                    yscaled = yscaled + localy;
                                }
                            }


                        }

                        //set new this.x and new this.y
                        this.x = xscaled / scalefactor;
                        this.y = yscaled / scalefactor;

                        if (bLimMarkupExtent) {

                            if (this.bispartofGroup){
                                if (this.groupRect.w - localx < startx || this.groupRect.w - localx > endx) {
                                    xscaled = xscaled + localx;
                                    this.groupRect.x += localx;
                                    this.groupRect.w += localx;


                                }
                                if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                                    yscaled = yscaled + localy;
                                    this.groupRect.y += localy;
                                    this.groupRect.h += localy;

                                }
                            }else{
                                if ((rrect.x + rrect.w) - localx < startx || (rrect.x + rrect.w) - localx > endx) {
                                    xscaled = xscaled + localx;

                                }
                                if ((rrect.y + rrect.h) - localy < starty || (rrect.y + rrect.h) - localy > endy) {
                                    yscaled = yscaled + localy;
                                }

                            }
                            this.x = xscaled / scalefactor;
                            this.y = yscaled / scalefactor;

                        }
                    }



                    break;

                case 6: //line arrow etc.

                    if (this.subtype == 6){
                        break;
                    }

                    if (this.bispartofGroup){
                        this.groupRect.x -= localx;
                        this.groupRect.y -= localy;
                        this.groupRect.w -= localx;
                        this.groupRect.h -= localy;
                    }


                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;
                    if (bLimMarkupExtent) {

                        if (this.bispartofGroup){
                            if (this.groupRect.x - localx < startx || this.groupRect.x - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;
                                this.groupRect.x += localx;
                                this.groupRect.w += localx;


                            }
                            if (this.groupRect.y - localy < starty || this.groupRect.y - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;

                                this.groupRect.y += localy;
                                this.groupRect.h += localy;
                            }

                        }else{
                            if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;

                            }
                            if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;

                            }

                        }

                    }

                    //set new this.x and new this.y

                    wscaled -= localx;
                    hscaled -= localy;
                    if (bLimMarkupExtent) {

                        if (this.bispartofGroup){
                            if (this.groupRect.w - localx < startx || this.groupRect.w - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;

                                this.groupRect.x += localx;
                                this.groupRect.w += localx;

                            }
                            if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;

                                this.groupRect.y += localy;
                                this.groupRect.h += localy;

                            }

                        }else{
                            if (this.wscaled - localx < startx || this.wscaled - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;

                            }
                            if (this.hscaled - localy < starty || this.hscaled - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;

                            }

                        }
                    }
                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;

                    this.w = wscaled / scalefactor;
                    this.h = hscaled / scalefactor;


                    break;
                case 7: //dimension line.

                    if (this.bispartofGroup){
                        this.groupRect.x -= localx;
                        this.groupRect.y -= localy;
                        this.groupRect.w -= localx;
                        this.groupRect.h -= localy;
                    }


                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;
                    if (bLimMarkupExtent) {

                        if (this.bispartofGroup){
                            if (this.groupRect.x - localx < startx || this.groupRect.x - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;
                                this.groupRect.x += localx;
                                this.groupRect.w += localx;

                            }
                            if (this.groupRect.y - localy < starty || this.groupRect.y - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;
                                this.groupRect.y += localy;
                                this.groupRect.h += localy;
                            }

                        }else{
                            if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;


                            }
                            if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;

                            }

                        }

                    }

                    //set new this.x and new this.y

                    wscaled -= localx;
                    hscaled -= localy;
                    if (bLimMarkupExtent) {
                        if (this.bispartofGroup){
                            if (this.groupRect.w - localx < startx || this.groupRect.w - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;
                                this.groupRect.x += localx;
                                this.groupRect.w += localx;

                            }
                            if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;
                                this.groupRect.y += localy;
                                this.groupRect.h += localy;

                            }

                        }else{
                            if (this.wscaled - localx < startx || this.wscaled - localx > endx) {
                                wscaled += localx;
                                xscaled += localx;

                            }
                            if (this.hscaled - localy < starty || this.hscaled - localy > endy) {
                                hscaled += localy;
                                yscaled += localy;
                            }

                        }
                    }
                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;

                    this.w = wscaled / scalefactor;
                    this.h = hscaled / scalefactor;
                    break;


                case 9: //text markup



                    var textwscaled = this.textwidth * scalefactor;

                    if (this.bispartofGroup){
                        this.groupRect.x -= localx;
                        this.groupRect.y -= localy;
                        this.groupRect.w -= localx;
                        this.groupRect.h -= localy;
                    }

                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;

                    var switchval = wscaled;
                    switch (this.textrotate / (Math.PI / 180)) {
                        case 0:

                            break;
                        case 90:
                            wscaled = hscaled;
                            hscaled = switchval;
                            break;
                        case 180:

                            break;
                        case 270:
                            wscaled = hscaled;
                            hscaled = switchval;

                            break;

                    }


                    if (markupobject.rotation != 0){
                        rrect = markupobject.rotrect(this.xscaled, this.yscaled,this.xscaled + wscaled, this.yscaled + hscaled);
                    }else{
                        rrect = {x: this.xscaled, y : this.yscaled,w : wscaled, h : hscaled};
                    }


                    if (bLimMarkupExtent) {
                        if (this.bispartofGroup){
                            if ((this.groupRect.x - localx) < startx || (this.groupRect.x + localx) > endx) {
                                xscaled = xscaled + localx;
                                this.groupRect.x += localx;
                                this.groupRect.w += localx;


                            }

                            if ((this.groupRect.y - localy) < starty || (this.groupRect.y - localy) > endy) {
                                yscaled = yscaled + localy;
                                this.groupRect.y += localy;
                                this.groupRect.h += localy;

                            }


                        }else{
                            if (rrect.x - localx < startx || rrect.x - localx > endx) {
                                xscaled += localx;

                            }
                            if (rrect.y - localy < starty || rrect.y - localy > endy) {
                                yscaled += localy;

                            }

                        }

                    }


                    if (bLimMarkupExtent) {
                        if (this.bispartofGroup){
                            if (this.groupRect.w - localx < startx || this.groupRect.w - localx > endx) {
                                xscaled = xscaled + localx;
                                this.groupRect.x += localx;
                                this.groupRect.w += localx;

                            }
                        }else{
                            if ((rrect.x + rrect.w) - localx < startx || (rrect.x + rrect.w) - localx > endx) {
                                xscaled = xscaled + localx;


                            }
                        }

                        if(this.subtype == 1 || this.subtype == 2){

                            if (this.bispartofGroup){
                                if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                                    yscaled = yscaled + localy;
                                    this.groupRect.y += localy;
                                    this.groupRect.h += localy;

                                }

                            }else{
                                if ((rrect.y + rrect.h) - localy < starty || (rrect.y + rrect.h) - localy > endy) {
                                    yscaled = yscaled + localy;

                                }

                            }

                        }else{
                            if (this.bispartofGroup){
                                if (this.groupRect.h - localy < starty || this.groupRect.h - localy > endy) {
                                    yscaled = yscaled + localy;
                                    this.groupRect.y += localy;
                                    this.groupRect.h += localy;

                                }

                            }else{
                                if ((rrect.y - rrect.h) - localy < starty || (rrect.y - rrect.h) - localy > endy) {
                                    yscaled = yscaled + localy;
                                }

                            }

                        }

                    }


                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;

                    if (this.bhasArrow && this.markupArrowConnected != null){


                        this.markupArrowConnected.setTextboxConnectionPoint(this.x, this.y, this.w, this.h);


                    }


                    break;
                case 10:
                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;

                    if (markupobject.rotation != 0){
                       rrect = markupobject.rotrect(this.xscaled, this.yscaled,this.xscaled + this.wscaled, this.yscaled + this.hscaled);
                    }else{
                        rrect = {x: this.xscaled, y : this.yscaled,w : this.wscaled, h : this.hscaled};
                    }

                    if (bLimMarkupExtent) {
                        if ((rrect.x - localx) < startx || (rrect.x + localx) > endx) {
                            xscaled = xscaled + localx;

                        }
                        if (rrect.y - localy < starty || rrect.y - localy > endy) {
                            yscaled = yscaled + localy;
                        }
                    }

                    //set new this.x and new this.y


                    if (bLimMarkupExtent) {

                        if ((rrect.x + rrect.w) - localx < startx || (rrect.x + rrect.w) - localx > endx) {
                            xscaled = xscaled + localx;

                        }
                        if ((rrect.y + rrect.h) - localy < starty || (rrect.y + rrect.h) - localy > endy) {
                            yscaled = yscaled + localy;
                        }

                    }
                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;

                    break;
                case 11:
                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;

                    if (markupobject.rotation != 0){
                        rrect = markupobject.rotrect(this.xscaled, this.yscaled,this.xscaled + this.wscaled, this.yscaled + this.hscaled);
                    }else{
                        rrect = {x: this.xscaled, y : this.yscaled,w : this.wscaled, h : this.hscaled};
                    }


                    if (bLimMarkupExtent) {
                        if ((rrect.x - localx) < startx || (rrect.x + localx) > endx) {
                            xscaled = xscaled + localx;

                        }
                        if (rrect.y - localy < starty || rrect.y - localy > endy) {
                            yscaled = yscaled + localy;
                        }
                    }

                    //set new this.x and new this.y


                    if (bLimMarkupExtent) {

                        if ((rrect.x + rrect.w) - localx < startx || (rrect.x + rrect.w) - localx > endx) {
                            xscaled = xscaled + localx;

                        }
                        if ((rrect.y + rrect.h) - localy < starty || (rrect.y + rrect.h) - localy > endy) {
                            yscaled = yscaled + localy;
                        }

                    }

                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;

                    break;

                case 12: //stamp markup
                    xscaled = xscaled - localx;
                    yscaled = yscaled - localy;

                    if (markupobject.rotation != 0){
                        rrect = markupobject.rotrect(this.xscaled, this.yscaled,this.xscaled + this.wscaled, this.yscaled + this.hscaled);
                    }else{
                        rrect = {x: this.xscaled, y : this.yscaled,w : this.wscaled, h : this.hscaled};
                    }


                    if (bLimMarkupExtent) {
                        if (rrect.x - localx < startx || rrect.x - localx > endx) {
                            xscaled += localx;
                        }
                        if (rrect.y - localy < starty || rrect.y - localy > endy) {
                            yscaled += localy;
                        }
                    }

                    if (bLimMarkupExtent) {
                        if ((rrect.x + rrect.w) - localx < startx || (rrect.x + rrect.w) - localx > endx) {
                            xscaled = xscaled + localx;

                        }
                        if ((rrect.y + rrect.h) - localy < starty || (rrect.y + rrect.h) - localy > endy) {
                            yscaled = yscaled + localy;
                        }

                    }
                    this.x = xscaled / scalefactor;
                    this.y = yscaled / scalefactor;


                    break;
                default:
                    break;
            }

            /*if (!this.withinbounds(localx,localy) && bLimMarkupExtent){
             this.x = restorex;
             this.y =  restorey;
             this.w = restorew;
             this.h = restoreh;
             }*/

        };

        this.setTextboxConnectionPoint = function(x,y,w,h){

            var bisarrowtextbox = (markupobject.type == 6 && markupobject.subtype == 6);

            if(!bisarrowtextbox){
                return;
            }

            //left side center
            if(this.x < x){
                markupobject.w = x;
                markupobject.h = y + (h * 0.5);
            }else if (x < this.x && this.x < (x + w)){
                if( y > this.y){
                    markupobject.w = x + (w * 0.5);
                    markupobject.h = y;
                }else if (y < this.y){
                    markupobject.w = x + (w * 0.5);
                    markupobject.h = y + h;
                }

            }else if(this.x > x){
                markupobject.w = x + w;
                markupobject.h = y + (h * 0.5);
            }

        };

        this.movelabel = function(x,y){

            var localx = x;
            var localy = y;
            var tempx = 0;
            var tempy = 0;


            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:

                    localx = x;
                    localy = y;

                    break;
                case 90:
                    localx = y;
                    localy = -x;

                    break;
                case 180:
                    localx = -x;
                    localy = -y;

                    break;
                case 270:
                    localx = -y;
                    localy = x;

                    break;
            }

            /*if (x > this.xscaled && x < this.wscaled) {
                if (y > this.yscaled && y < this.hscaled) {
                    within = true;
                    this.editaction = 1;
                }
            }*/
            var scalefactor;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }

            var labeloffsetxscaled = markupobject.labeloffsetx * scalefactor;
            var labeloffsetyscaled = markupobject.labeloffsety * scalefactor;


            var bmoveright = (markupobject.labeloffsetx < (markupobject.labeloffsetx - localx));
            var bmoveleft = (markupobject.labeloffsetx > (markupobject.labeloffsetx - localx));
            var bmoveup = (markupobject.labeloffsety > (markupobject.labeloffsety - localy));
            var bmovedown = (markupobject.labeloffsety < (markupobject.labeloffsety - localy));
            var bleftext = (markupobject.labelRect.x > markupobject.xscaled);
            var brightext = ((markupobject.labelRect.x + markupobject.labelRect.w) < markupobject.wscaled);
            var btopext = (markupobject.labelRect.y > markupobject.yscaled);
            var bbottomext = ((markupobject.labelRect.y + markupobject.labelRect.h) < markupobject.hscaled);

            if((bleftext || bmoveright) && (brightext || bmoveleft)){
                if((btopext || bmovedown) && (bbottomext || bmoveup)){

                    labeloffsetxscaled -= localx;
                    labeloffsetyscaled -= localy;


                    markupobject.labeloffsetx = labeloffsetxscaled / scalefactor;
                    markupobject.labeloffsety = labeloffsetyscaled / scalefactor;

                    //markupobject.labeloffsetx = (markupobject.labeloffsetx / scalefactor) - localx;
                    //markupobject.labeloffsety = (markupobject.labeloffsety / scalefactor) - localy;
                    //markupobject.labeloffsetx -= localx;
                    //markupobject.labeloffsety -= localy;

                }

            }


            /*if(markupobject.labelRect.x > markupobject.xscaled && (markupobject.labelRect.x + markupobject.labelRect.w) < markupobject.wscaled && (localx > 0)){
                if(markupobject.labelRect.y > markupobject.yscaled && (markupobject.labelRect.y + markupobject.labelRect.h) < markupobject.hscaled){
                    markupobject.labeloffsetx -= localx;
                    markupobject.labeloffsety -= localy;
                }
            }*/


        };

        this.dimextend = function(x,y){
            //method only for dimensions.

            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);

            var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

            switch(DocObj.pages[DocObj.currentpage].drotation){
                case 0:
                    CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                    break;
                case 90:
                    CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation + 180) * (Math.PI / 180);
                    break;
                case 270:
                    CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation - 180) * (Math.PI / 180);
                    break;
                case 180:
                    CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                    break;
            }

            //var orgmousepoint = {x:x,y:y};
            //var pagerotation = DocObj.pages[DocObj.currentpage].drotation;

            if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                var rotmousepoint = markupobject.getRotatedMarkup(centercanvX, centercanvY, x, y, CanvRotRad);
                x = rotmousepoint.x;
                y = rotmousepoint.y;
            }

            var scalefactor;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }


            var mp = {
                x:x,
                y:y
            };

            var lp1 = {
                x:this.xscaled,
                y:this.yscaled
            };

            var lp2 = {
                x:this.wscaled,
                y:this.hscaled
            };


            var side = ((mp.x - lp1.x)*(lp2.y - lp1.y))-((mp.y - lp1.y)*( lp2.x - lp1.x));
            //console.log(side);


            var linedistance = distToSegment(mp, lp1, lp2);

            if (side > 0){
                markupobject.leaderoffset = -(linedistance / scalefactor);
            }else{
                markupobject.leaderoffset = (linedistance / scalefactor);
            }


            if (linedistance < 1){
                markupobject.leaderoffset = 0;
                //console.log('can get to 0');
            };

            //this.setDimOffset

            /*if (distToSegment(mp, lp1, lp2) < 10) {
                within = true;
                this.editaction = 1;
            }*/

        };

        this.setSize = function(size){

            //markupobject.scale(size.width,size.height, 4, context);

            //current size

            //var wscaled = this.w * scalefactor;
            //var hscaled = this.h * scalefactor;

            wscaled = size.width;
            hscaled = size.height;

            if (bLimMarkupExtent) {
                if ((this.xscaled + wscaled) < startx || (this.xscaled + wscaled) > endx) {
                    wscaled = this.w * scalefactor;

                }
                if ((this.yscaled + hscaled) < starty || (this.yscaled + hscaled) > endy) {
                    hscaled = this.h * scalefactor;
                }

            }

            this.w = wscaled / scalefactor;
            this.h = hscaled / scalefactor;


        };

        this.scale = function (x, y, corner, ctx) {
            var localx = x;
            var localy = y;
            var tempx = 0;
            var tempy = 0;


            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:

                    localx = x;
                    localy = y;

                    break;
                case 90:
                    localx = y;
                    localy = -x;

                    break;
                case 180:
                    localx = -x;
                    localy = -y;

                    break;
                case 270:
                    localx = -y;
                    localy = x;

                    break;
            }


            if (markupobject.rotation != 0){
                tempx = localx;
                tempy = localy;

                var calcrot = -markupobject.rotation;

                localx = (tempx*Math.cos(calcrot))-(tempy*Math.sin(calcrot));
                localy = (tempx*Math.sin(calcrot))+(tempy*Math.cos(calcrot));

            }

            //var pageobjdim = DocObj.pages[DocObj.currentpage].getpagerect();

            var startx = DocObj.pages[DocObj.currentpage].startx;
            var endx = DocObj.pages[DocObj.currentpage].endx;
            var starty = DocObj.pages[DocObj.currentpage].starty;
            var endy = DocObj.pages[DocObj.currentpage].endy;


            /*var startx = pageobjdim.x;
            var endx = pageobjdim.x + pageobjdim.w;
            var starty = pageobjdim.y;
            var endy = pageobjdim.y + pageobjdim.h;*/
            /*
             Andriy: Unused variables

             var xscalepoint = 0;
             var yscalepoint = 0;*/

            var scalefactor;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }

            //var scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;

            //var scalefactor = dscale / this.scaling;

            var xscaled = this.x * scalefactor;
            var yscaled = this.y * scalefactor;
            var wscaled = this.w * scalefactor;
            var hscaled = this.h * scalefactor;

            /*
             Unused variables
             var restorex = this.x;
             var restorey = this.y;
             var restorew = this.w;
             var restoreh = this.h;*/


            switch (this.type) {
                case 0: //pencil, marker, eraser, (currently not in use)
                    //var scalefactor = dscale / this.scaling;
                    //var counter = 0;
                    /*for (counter=0;counter<this.points.length;counter++){
                     xscalepoint = this.points[counter].x * scalefactor;
                     yscalepoint = this.points[counter].y * scalefactor;
                     this.points[counter].x = xscalepoint - localx;
                     this.points[counter].y = yscalepoint - localy;
                     }*/
                    //var xscaled = this.x * scalefactor;
                    //var yscaled = this.y * scalefactor;
                    //var wscaled = this.w * scalefactor;
                    //var hscaled = this.h * scalefactor;

                    //wscaled -= localx;
                    //hscaled -= localy;

                    //this.w = wscaled/scalefactor;
                    //this.h = hscaled/scalefactor;
                    break;
                case 1: //polygon, (currently not in use)

                    break;
                case 2: //polycurves, (currently not in use)

                    break;

                case 3: //rectangle
                    switch (corner) {
                        case 4:

                            wscaled -= localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled + localx;

                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                }

                            }

                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 1:
                            xscaled -= localx;
                            yscaled -= localy;
                            wscaled += localx;
                            hscaled += localy;

                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled - localx;
                                    xscaled = xscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }


                            }

                            this.x = xscaled / scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 3:
                            xscaled -= localx;
                            //yscaled -= localy;
                            wscaled += localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;

                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                /*if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                                 yscaled = yscaled + localy;
                                 //hscaled = hscaled - localy;
                                 }*/
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                    yscaled = yscaled - localy;
                                }


                            }
                            this.x = xscaled / scalefactor;
                            //this.y = yscaled/scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 2:
                            //xscaled -= localx;
                            yscaled -= localy;
                            wscaled -= localx;
                            hscaled += localy;
                            if (bLimMarkupExtent) {
                                /*if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                                 xscaled = xscaled + localx;
                                 wscaled = wscaled - localx;

                                 }*/
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled - localx;
                                    wscaled = wscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled - localy;
                                    yscaled = yscaled + localy;
                                }


                            }
                            //this.x = xscaled/scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;

                    }


                    break;
                case 4: //Oval
                    switch (corner) {
                        case 4:

                        if(this.subtype == 1){

                            var wscaledactual = (this.w - this.xoffset) * scalefactor;
                            var hscaledactual = (this.h - this.yoffset) * scalefactor;
                            wscaledactual += startx;
                            hscaledactual += starty;

                            wscaledactual -= localx;
                            hscaledactual -= localy;

                            wscaled -= localx;
                            hscaled -= localy;

                            var xdiff = Math.max(this.xscaled, this.wscaled) - Math.min(this.xscaled, this.wscaled);
                            var ydiff = Math.max(this.yscaled, this.hscaled) - Math.min(this.yscaled, this.hscaled);

                            var newxdiff = Math.max(this.xscaled, wscaledactual) - Math.min(this.xscaled, wscaledactual);
                            var newydiff = Math.max(this.yscaled, hscaledactual) - Math.min(this.yscaled, hscaledactual);

                            var oldradius = markupobject.getdiag(xdiff, ydiff);
                            var curradius = markupobject.getdiag(newxdiff, newydiff);
                            //add 10 percent to prevent moving outside.
                            //oldradius = oldradius + (oldradius * 0.1);


                            if (bLimMarkupExtent) {

                                if ((this.xscaled - curradius) < startx || (this.xscaled + curradius) > endx) {
                                    wscaled = wscaled + localx;
                                    hscaled = hscaled + localy;


                                    if(curradius < oldradius){
                                        //proceed
                                    }else{

                                    }
                                }
                                if ((this.yscaled - curradius) < starty || (this.yscaled + curradius) > endy) {
                                    wscaled = wscaled + localx;
                                    hscaled = hscaled + localy;

                                    if(curradius < oldradius){
                                        //proceed
                                    }else{

                                    }
                                }

                            }

                            markupobject.radiusCallback(this.x, this.y, this.w, this.h, true);
                            //this.radiusCallback = function(x,y, w, h, useabs){
                        }else{
                            wscaled -= localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled + localx;

                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                }

                            }



                        }
                        this.w = wscaled / scalefactor;
                        this.h = hscaled / scalefactor;

                            break;
                        case 1:
                            xscaled -= localx;
                            yscaled -= localy;
                            wscaled += localx;
                            hscaled += localy;

                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled -= localx;

                                }
                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled -= localy;
                                }

                            }

                            this.x = xscaled / scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;


                            break;
                        case 3:
                            xscaled -= localx;
                            //yscaled -= localy;
                            wscaled += localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;

                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                /*if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                                 yscaled = yscaled + localy;
                                 //hscaled = hscaled - localy;
                                 }*/
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                    yscaled = yscaled - localy;
                                }


                            }
                            this.x = xscaled / scalefactor;
                            //this.y = yscaled/scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 2:
                            //xscaled -= localx;
                            yscaled -= localy;
                            wscaled -= localx;
                            hscaled += localy;
                            if (bLimMarkupExtent) {
                                /*if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                                 xscaled = xscaled + localx;
                                 wscaled = wscaled - localx;

                                 }*/
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled - localx;
                                    wscaled = wscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled - localy;
                                    yscaled = yscaled + localy;
                                }


                            }
                            //this.x = xscaled/scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;

                    }
                    /*if(corner == 4){
                     wscaled -= localx;
                     hscaled -= localy;

                     if (bLimMarkupExtent){
                     if((this.xscaled + this.wscaled) - localx < DocObj.pages[DocObj.currentpage].startx || (this.xscaled + this.wscaled) - localx > DocObj.pages[DocObj.currentpage].endx){
                     wscaled = wscaled + localx;

                     }
                     if((this.yscaled + this.hscaled)-localy <DocObj.pages[DocObj.currentpage].starty || (this.yscaled + this.hscaled)-localy > DocObj.pages[DocObj.currentpage].endy){
                     hscaled = hscaled + localy;
                     }

                     }

                     this.w = wscaled/scalefactor;
                     this.h = hscaled/scalefactor;

                     }
                     if (corner == 1){
                     xscaled -= localx;
                     yscaled -= localy;
                     wscaled += localx;
                     hscaled += localy;

                     if (bLimMarkupExtent){
                     if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                     xscaled = xscaled + localx;

                     }
                     if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                     yscaled = yscaled + localy;
                     }

                     }

                     this.x = xscaled/scalefactor;
                     this.y = yscaled/scalefactor;
                     this.w = wscaled/scalefactor;
                     this.h = hscaled/scalefactor;

                     }*/

                    break;
                case 5: //Cloud
                    /*if(corner == 4){
                     wscaled -= localx;
                     hscaled -= localy;
                     if (bLimMarkupExtent){
                     if((this.xscaled + this.wscaled) - localx < DocObj.pages[DocObj.currentpage].startx || (this.xscaled + this.wscaled) - localx > DocObj.pages[DocObj.currentpage].endx){
                     wscaled = wscaled + localx;

                     }
                     if((this.yscaled + this.hscaled)-localy <DocObj.pages[DocObj.currentpage].starty || (this.yscaled + this.hscaled)-localy > DocObj.pages[DocObj.currentpage].endy){
                     hscaled = hscaled + localy;
                     }

                     }

                     this.w = wscaled/scalefactor;
                     this.h = hscaled/scalefactor;

                     }
                     if (corner == 1){
                     xscaled -= localx;
                     yscaled -= localy;
                     wscaled += localx;
                     hscaled += localy;

                     if (bLimMarkupExtent){
                     if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                     xscaled = xscaled + localx;

                     }
                     if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                     yscaled = yscaled + localy;
                     }

                     }

                     this.x = xscaled/scalefactor;
                     this.y = yscaled/scalefactor;
                     this.w = wscaled/scalefactor;
                     this.h = hscaled/scalefactor;

                     }*/
                    switch (corner) {
                        case 4:
                            wscaled -= localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled + localx;

                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                }

                            }

                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            /*if(wscaled/scalefactor < 0){
                             var x2 = this.x + wscaled/scalefactor;
                             tempx = this.x;
                             this.x += wscaled/scalefactor;
                             x2 = tempx;
                             this.w = x2 - tempx;
                             }else{
                             this.w = wscaled/scalefactor;
                             }
                             if(hscaled/scalefactor < 0){
                             var y2 = this.y + hscaled/scalefactor;
                             tempy = this.y;
                             this.y += hscaled/scalefactor;
                             this.h = y2 - tempy;
                             }else{
                             this.h = hscaled/scalefactor;
                             }*/

                            //console.log(this.w);
                            //console.log(this.x);


                            break;
                        case 1:
                            xscaled -= localx;
                            yscaled -= localy;
                            wscaled += localx;
                            hscaled += localy;

                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled -= localx;

                                }
                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled -= localy;
                                }

                            }

                            this.x = xscaled / scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;


                            /*if(this.w < 0){
                             tempx = this.x;
                             this.x += this.w;
                             this.w = this.x - tempx;
                             }
                             if(this.h < 0){
                             tempy = this.y;
                             this.y += this.h;
                             this.h = this.y - tempy;
                             }*/


                            break;
                        case 3:
                            xscaled -= localx;
                            //yscaled -= localy;
                            wscaled += localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;

                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                /*if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                                 yscaled = yscaled + localy;
                                 //hscaled = hscaled - localy;
                                 }*/
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                    yscaled = yscaled - localy;
                                }


                            }
                            this.x = xscaled / scalefactor;
                            //this.y = yscaled/scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            /*if(this.w < 0){
                             tempx = this.x;
                             this.x += this.w;
                             this.w = this.x - tempx;
                             }
                             if(this.h < 0){
                             tempy = this.y;
                             this.y += this.h;
                             this.h = this.y - tempy;
                             }*/


                            break;
                        case 2:
                            //xscaled -= localx;
                            yscaled -= localy;
                            wscaled -= localx;
                            hscaled += localy;
                            if (bLimMarkupExtent) {
                                /*if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                                 xscaled = xscaled + localx;
                                 wscaled = wscaled - localx;

                                 }*/
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled - localx;
                                    wscaled = wscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled - localy;
                                    yscaled = yscaled + localy;
                                }


                            }
                            //this.x = xscaled/scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            /*if(this.w < 0){
                             tempx = this.x;
                             this.x += this.w;
                             this.w = this.x - tempx;
                             }
                             if(this.h < 0){
                             tempy = this.y;
                             this.y += this.h;
                             this.h = this.y - tempy;
                             }*/

                            break;

                    }
                    break;

                case 6: //line arrow etc.

                    if (corner == 4) {
                        if (this.subtype == 6){
                            return;
                        }

                        wscaled -= localx;
                        hscaled -= localy;


                        if (bLimMarkupExtent) {
                            if (this.wscaled - localx < startx || this.wscaled - localx > endx) {
                                wscaled = wscaled + localx;

                            }
                            if (this.hscaled - localy < starty || this.hscaled - localy > endy) {
                                hscaled = hscaled + localy;
                            }

                        }

                        this.w = wscaled / scalefactor;
                        this.h = hscaled / scalefactor;



                    }
                    if (corner == 1) {
                        xscaled -= localx;
                        yscaled -= localy;
                        if (bLimMarkupExtent) {
                            if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                xscaled = xscaled + localx;

                            }
                            if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                yscaled = yscaled + localy;
                            }

                        }

                        this.x = xscaled / scalefactor;
                        this.y = yscaled / scalefactor;
                    }

                    if (this.subtype == 6){

                        //textBoxConnected
                        if(this.textBoxConnected != null){
                            this.setTextboxConnectionPoint(this.textBoxConnected.x, this.textBoxConnected.y, this.textBoxConnected.w, this.textBoxConnected.h);
                        }

                    }


                    markupobject.lengthangleCallback(this.x, this.y, this.w, this.h, DocObj.pages[DocObj.currentpage].drotation);
                    //this.lengthangleCallback = function(x, y, w, h, drotation)
                    //var point = {x : localx, y : localy};

                    if(bOrthoOn){
                        markupobject.calculateOrtho(true, corner, {x : localx, y : localy});
                    }


                    /*wscaled = wscaled - x;
                     hscaled = hscaled - y;

                     this.w = wscaled/scalefactor;
                     this.h = hscaled/scalefactor;*/
                    break;
                case 7: //dimension line.

                    if (corner == 4) {
                        wscaled -= localx;
                        hscaled -= localy;
                        if (bLimMarkupExtent) {
                            if (this.wscaled - localx < startx || this.wscaled - localx > endx) {
                                wscaled = wscaled + localx;

                            }
                            if (this.hscaled - localy < starty || this.hscaled - localy > endy) {
                                hscaled = hscaled + localy;
                            }

                        }

                        this.w = wscaled / scalefactor;
                        this.h = hscaled / scalefactor;


                    }
                    if (corner == 1) {
                        xscaled -= localx;
                        yscaled -= localy;
                        if (bLimMarkupExtent) {
                            if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                xscaled = xscaled + localx;

                            }
                            if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                yscaled = yscaled + localy;
                            }

                        }

                        this.x = xscaled / scalefactor;
                        this.y = yscaled / scalefactor;
                    }


                    if(bOrthoOn){
                        markupobject.calculateOrtho(true, corner, {x : localx, y : localy});
                    }

                    /*wscaled = wscaled - x;
                     hscaled = hscaled - y;


                     this.w = wscaled/scalefactor;
                     this.h = hscaled/scalefactor;*/

                    //var dimwidth = this.w - this.x;
                    //var dimheight = this.h - this.y;
                    //var dimdiag = markupobject.getdiag(dimwidth, dimheight);


                    /*var dimwsq = Math.pow(dimwidth,2);
                     var dimhsq = Math.pow(dimheight,2);
                     var dimdiag = Math.sqrt((dimwsq+dimhsq));*/


                    markupobject.setdimvalue(this.x,this.y,this.w,this.h);

                    //this.dimtext = getUnitlength(dimdiag);
                    //this.dimtext = this.dimtext.toFixed(2);
                    //this.dimtext = this.dimtext + " " + Unitlabel;




                    break;
                case 8:
                    //not implemented for area markup.
                    break;
                case 9: //text markup
                    if(this.subtype == 1 || this.subtype == 2){
                        switch (corner) {
                            case 4:
                                wscaled -= localx;
                                hscaled -= localy;
                                if (bLimMarkupExtent) {
                                    if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                        wscaled = wscaled + localx;

                                    }
                                    if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                        hscaled = hscaled + localy;
                                    }

                                }

                                if (wscaled < 0) {
                                    wscaled = 1;
                                }
                                if (hscaled < 0) {
                                    hscaled = 1;
                                }


                                this.w = wscaled / scalefactor;
                                this.h = hscaled / scalefactor;

                                break;
                            case 1:
                                xscaled -= localx;
                                yscaled -= localy;
                                wscaled += localx;
                                hscaled += localy;

                                if (bLimMarkupExtent) {
                                    if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                        xscaled = xscaled + localx;
                                        wscaled = wscaled - localx;
                                    }
                                    if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                        wscaled = wscaled - localx;
                                        xscaled = xscaled + localx;
                                    }

                                    if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                        yscaled = yscaled + localy;
                                        hscaled = hscaled - localy;
                                    }
                                    if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                        yscaled = yscaled + localy;
                                        hscaled = hscaled - localy;
                                    }


                                }

                                if (wscaled < 0) {
                                    wscaled = 1;
                                }
                                if (hscaled < 0) {
                                    hscaled = 1;
                                }


                                this.x = xscaled / scalefactor;
                                this.y = yscaled / scalefactor;
                                this.w = wscaled / scalefactor;
                                this.h = hscaled / scalefactor;

                                break;
                            case 3:
                                xscaled -= localx;
                                //yscaled -= localy;
                                wscaled += localx;
                                hscaled -= localy;
                                if (bLimMarkupExtent) {
                                    if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                        xscaled = xscaled + localx;
                                        wscaled = wscaled - localx;

                                    }
                                    if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                        xscaled = xscaled + localx;
                                        wscaled = wscaled - localx;
                                    }
                                    /*if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                                     yscaled = yscaled + localy;
                                     //hscaled = hscaled - localy;
                                     }*/
                                    if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                        hscaled = hscaled + localy;
                                        yscaled = yscaled - localy;
                                    }


                                }
                                if (wscaled < 0) {
                                    wscaled = 1;
                                }
                                if (hscaled < 0) {
                                    hscaled = 1;
                                }

                                this.x = xscaled / scalefactor;
                                //this.y = yscaled/scalefactor;
                                this.w = wscaled / scalefactor;
                                this.h = hscaled / scalefactor;

                                break;
                            case 2:
                                //xscaled -= localx;
                                yscaled -= localy;
                                wscaled -= localx;
                                hscaled += localy;
                                if (bLimMarkupExtent) {
                                    /*if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                                     xscaled = xscaled + localx;
                                     wscaled = wscaled - localx;

                                     }*/
                                    if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                        xscaled = xscaled - localx;
                                        wscaled = wscaled + localx;
                                    }

                                    if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                        yscaled = yscaled + localy;
                                        hscaled = hscaled - localy;
                                    }
                                    if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                        hscaled = hscaled - localy;
                                        yscaled = yscaled + localy;
                                    }


                                }
                                if (wscaled < 0) {
                                    wscaled = 1;
                                }
                                if (hscaled < 0) {
                                    hscaled = 1;
                                }


                                //this.x = xscaled/scalefactor;
                                this.y = yscaled / scalefactor;
                                this.w = wscaled / scalefactor;
                                this.h = hscaled / scalefactor;



                                break;

                        }
                    }else{
                        var textscaled = this.textheight * scalefactor;
                        var textwscaled = this.textwidth * scalefactor;

                        switch (this.textrotate / (Math.PI / 180)) {
                            case 0:

                                break;
                            case 90:

                                break;
                            case 180:

                                break;
                            case 270:
                                localx = -y;
                                localy = x;

                                //localy = -localy;
                                break;
                        }


                        textscaled = textscaled - (localy * 0.25);
                        textwscaled = textwscaled - (localx * 0.25);

                        wscaled -= (localx * 0.25);
                        hscaled -= (localy * 0.25);
                        this.font.setHeight(textscaled / scalefactor);

                        ctx.font = this.font.fontstring;
                        var dimt = ctx.measureText(this.text);
                        var dimtextwidth = dimt.width;


                        if (bLimMarkupExtent) {
                            if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                wscaled = wscaled + localx;
                                textwscaled = textwscaled + localx;
                                textscaled = textscaled + localy;


                            }
                            if ((this.yscaled - this.hscaled) - localy < starty || (this.yscaled - this.hscaled) - localy > endy) {
                                hscaled = hscaled + localy;
                                textscaled = textscaled + localy;

                            }


                        }


                        this.w = wscaled / scalefactor;
                        this.h = hscaled / scalefactor;

                        this.textheight = textscaled / scalefactor;
                        this.textwidth = textwscaled / scalefactor;
                    }

                    if (this.bhasArrow && this.markupArrowConnected != null){

                        //var arrowmobj = DocObj.getmarkupbynumber(this.markupArrowConnected);
                        //DocObj.markuplist[arrowmobj].setTextboxConnectionPoint(this.x, this.y, this.w, this.h);
                        this.markupArrowConnected.setTextboxConnectionPoint(this.x, this.y, this.w, this.h);

                    }



                    break;
                case 11:
                    switch (corner) {
                        case 4:
                            wscaled -= localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled + localx;

                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                }

                            }

                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 1:
                            xscaled -= localx;
                            yscaled -= localy;
                            wscaled += localx;
                            hscaled += localy;

                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled - localx;
                                    xscaled = xscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }


                            }

                            this.x = xscaled / scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 3:
                            xscaled -= localx;
                            //yscaled -= localy;
                            wscaled += localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;

                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                /*if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                                 yscaled = yscaled + localy;
                                 //hscaled = hscaled - localy;
                                 }*/
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                    yscaled = yscaled - localy;
                                }


                            }
                            this.x = xscaled / scalefactor;
                            //this.y = yscaled/scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 2:
                            //xscaled -= localx;
                            yscaled -= localy;
                            wscaled -= localx;
                            hscaled += localy;
                            if (bLimMarkupExtent) {
                                /*if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                                 xscaled = xscaled + localx;
                                 wscaled = wscaled - localx;

                                 }*/
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled - localx;
                                    wscaled = wscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled - localy;
                                    yscaled = yscaled + localy;
                                }


                            }
                            //this.x = xscaled/scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;

                    }


                    break;

                case 12: //stamp markup
                    //var textstampscaled = this.textheight * scalefactor;
                    //var textwstampscaled = this.textwidth * scalefactor;
                    //var textsmallscaled = this.stampsmalltheight * scalefactor;
                    switch (corner) {
                        case 4:
                            wscaled -= localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled + localx;

                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                }

                            }
                            if (wscaled < 0) {
                                wscaled = 1;
                            }
                            if (hscaled < 0) {
                                hscaled = 1;
                            }

                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 1:
                            xscaled -= localx;
                            yscaled -= localy;
                            wscaled += localx;
                            hscaled += localy;

                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    wscaled = wscaled - localx;
                                    xscaled = xscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }


                            }
                            if (wscaled < 0) {
                                wscaled = 1;
                            }
                            if (hscaled < 0) {
                                hscaled = 1;
                            }

                            this.x = xscaled / scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 3:
                            xscaled -= localx;
                            //yscaled -= localy;
                            wscaled += localx;
                            hscaled -= localy;
                            if (bLimMarkupExtent) {
                                if (this.xscaled - localx < startx || this.xscaled - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;

                                }
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled + localx;
                                    wscaled = wscaled - localx;
                                }
                                /*if(this.yscaled - localy <DocObj.pages[DocObj.currentpage].starty || this.yscaled - localy > DocObj.pages[DocObj.currentpage].endy){
                                 yscaled = yscaled + localy;
                                 //hscaled = hscaled - localy;
                                 }*/
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled + localy;
                                    yscaled = yscaled - localy;
                                }


                            }
                            if (wscaled < 0) {
                                wscaled = 1;
                            }
                            if (hscaled < 0) {
                                hscaled = 1;
                            }

                            this.x = xscaled / scalefactor;
                            //this.y = yscaled/scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;
                        case 2:
                            //xscaled -= localx;
                            yscaled -= localy;
                            wscaled -= localx;
                            hscaled += localy;
                            if (bLimMarkupExtent) {
                                /*if(this.xscaled - localx < DocObj.pages[DocObj.currentpage].startx || this.xscaled - localx > DocObj.pages[DocObj.currentpage].endx){
                                 xscaled = xscaled + localx;
                                 wscaled = wscaled - localx;

                                 }*/
                                if ((this.xscaled + this.wscaled) - localx < startx || (this.xscaled + this.wscaled) - localx > endx) {
                                    xscaled = xscaled - localx;
                                    wscaled = wscaled + localx;
                                }

                                if (this.yscaled - localy < starty || this.yscaled - localy > endy) {
                                    yscaled = yscaled + localy;
                                    hscaled = hscaled - localy;
                                }
                                if ((this.yscaled + this.hscaled) - localy < starty || (this.yscaled + this.hscaled) - localy > endy) {
                                    hscaled = hscaled - localy;
                                    yscaled = yscaled + localy;
                                }


                            }
                            if (wscaled < 0) {
                                wscaled = 1;
                            }
                            if (hscaled < 0) {
                                hscaled = 1;
                            }

                            //this.x = xscaled/scalefactor;
                            this.y = yscaled / scalefactor;
                            this.w = wscaled / scalefactor;
                            this.h = hscaled / scalefactor;

                            break;

                    }

                    /*wscaled -= localx;
                     hscaled -= localy;

                     if (bLimMarkupExtent){
                     if((this.xscaled + this.wscaled) - localx < DocObj.pages[DocObj.currentpage].startx || (this.xscaled + this.wscaled) - localx > DocObj.pages[DocObj.currentpage].endx){
                     wscaled = wscaled + localx;

                     }
                     if((this.yscaled + this.hscaled)-localy <DocObj.pages[DocObj.currentpage].starty || (this.yscaled + this.hscaled)-localy > DocObj.pages[DocObj.currentpage].endy){
                     hscaled = hscaled + localy;
                     }

                     }


                     this.w = wscaled/scalefactor;
                     this.h = hscaled/scalefactor;*/

                    //this.textheight = this.w * 0.16;
                    this.font.setHeight(this.w * 0.16);
                    if (this.alternative == 0){

                        this.stampsmalltheight = (this.w * 0.08) - 4;
                        if (this.stampsmalltheight < 1) {
                            this.stampsmalltheight = 1;
                        }

                        var combinedtextheight = this.textheight + this.stampsmalltheight + ((this.h / 10) * 2);
                        if (combinedtextheight > this.h) {
                            //this.textheight = (this.h / 2) - ((this.h / 10) * 2);
                            this.font.setHeight((this.h / 2) - ((this.h / 10) * 2));
                            this.stampsmalltheight = (this.textheight / 2) - 4;
                            if (this.stampsmalltheight < 1) {
                                this.stampsmalltheight = 1;
                            }
                        }

                    }else{
                        if ((this.w*0.6) >= this.h){
                            //this.textheight = (this.h / 4);
                            this.font.setHeight(this.h / 4);
                        }else{
                            //this.textheight = this.w * 0.16;
                            this.font.setHeight(this.w * 0.16);
                        }

                    }

                    /*if (this.h < 40){
                     this.stampsmalltheight = 1;
                     this.textheight = 1;

                     }*/
                    //recalculate text size for stampe here.


                    break;


                default:
                //code to be executed if n is different from case 1 and 2


            }
            /* if (!this.withinbounds(localx,localy) && bLimMarkupExtent){
             this.x = restorex;
             this.y = restorey;
             this.w = restorew;
             this.h = restoreh;
             }*/


        };


        //rotated rectangle for shapes
        this.rotatedRectangle = function(){


            var minx = this.rotatedrect.x;
            var miny = this.rotatedrect.y;
            var maxx = this.rotatedrect.w;
            var maxy = this.rotatedrect.w;


        };

        //functions for polygons, pencil, polycurves
        this.findrectangle = function () {
            var counter = 0;
            var lcounter = 0;

            if (this.type == 0){
                var minx = this.pointlist[0][0].x;
                var miny = this.pointlist[0][0].y;
                var maxx = this.pointlist[0][0].x;
                var maxy = this.pointlist[0][0].y;

                for (lcounter = 0; lcounter < this.pointlist.length; lcounter++) {
                    for (counter = 0; counter < this.pointlist[lcounter].length; counter++) {
                        if (this.pointlist[lcounter][counter].x < minx) {
                            minx = this.pointlist[lcounter][counter].x;
                        }
                        if (this.pointlist[lcounter][counter].y < miny) {
                            miny = this.pointlist[lcounter][counter].y;
                        }
                        if (this.pointlist[lcounter][counter].x > maxx) {
                            maxx = this.pointlist[lcounter][counter].x;
                        }
                        if (this.pointlist[lcounter][counter].y > maxy) {
                            maxy = this.pointlist[lcounter][counter].y;
                        }
                    }

                }

            }else{
                minx = this.points[0].x;
                miny = this.points[0].y;
                maxx = this.points[0].x;
                maxy = this.points[0].y;

                for (counter = 0; counter < this.points.length; counter++) {
                    if (this.points[counter].x < minx) {
                        minx = this.points[counter].x;
                    }
                    if (this.points[counter].y < miny) {
                        miny = this.points[counter].y;
                    }
                    if (this.points[counter].x > maxx) {
                        maxx = this.points[counter].x;
                    }
                    if (this.points[counter].y > maxy) {
                        maxy = this.points[counter].y;
                    }
                }
            }

            this.x = minx;
            this.y = miny;
            this.w = maxx;
            this.h = maxy;

            this.xscaled = this.x;
            this.yscaled = this.y;
            this.wscaled = this.w;
            this.hscaled = this.h;

            if((this.type == 1 && this.subtype == 2) || this.type == 8){
                this.addsides();
            }


            //alert(x);
        };


        this.removepoints = function(){

            this.pointlist = [];
            this.points = [];
            this.sides = [];

        };

        this.addpoint = function (x, y) {

            //this.points.push(new point(x, y));
            this.points.push({x:x, y:y});

        };

        this.addline = function(){
            this.pointlist.push(markupobject.points);
            this.points = [];
            //this.points.push(new point(x, y));
        };


        this.snapToCorner = function(x,y,corner){
            var snappoint = markupobject.getsnappoint(x,y);
            //use to edit end points of  of dimensions and arrows.
            if (corner == 1){
                this.x = snappoint.x;
                this.y = snappoint.y;
            }else if(corner == 4){
                this.w = snappoint.x;
                this.h = snappoint.y;
            }

        };

        this.snapTo = function(x,y,point){
            var snappoint = markupobject.getsnappoint(x,y);

            if (point >= 0 && point <= this.points.length - 1) {
                this.points[point].x = snappoint.x;//((x - pagedx) / scalefactor) + this.xoffset;
                this.points[point].y = snappoint.y;//((y - pagedy) / scalefactor) + this.yoffset;

            }



        };
        this.getsnappoint = function(x,y){

            var pagedx = 0;
            var pagedy = 0;

            if (DocObj.Type == 0) {
                var docdx = DocObj.pages[0].dx;
            } else {
                docdx = DocObj.pages[DocObj.currentpage].dx;
            }

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                pagedx = DocObj.pages[DocObj.currentpage].dxvector;
                pagedy = DocObj.pages[DocObj.currentpage].dyvector;


            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                pagedx = DocObj.pages[DocObj.currentpage].dxpdf;
                pagedy = DocObj.pages[DocObj.currentpage].dypdf;

            } else {
                pagedx = docdx;
                pagedy = DocObj.pages[DocObj.currentpage].dy;

            }

            var scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }

            return {
                x : ((x - pagedx) / scalefactor) + this.xoffset,
                y : ((y - pagedy) / scalefactor) + this.yoffset
            };



        };

        this.editpoint = function (x, y, point) {



            var localx = x;
            var localy = y;

            var scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }

            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:
                    localx = x;
                    localy = y;

                    break;
                case 90:
                    localx = y;
                    localy = -x;

                    break;
                case 180:
                    localx = -x;
                    localy = -y;

                    break;
                case 270:
                    localx = -y;
                    localy = x;

                    break;
            }

            if (point >= 0 && point <= this.points.length - 1) {
                var xscalepoint = 0.0;
                var yscalepoint = 0.0;
                xscalepoint = this.points[point].x * scalefactor;
                yscalepoint = this.points[point].y * scalefactor;
                xscalepoint = xscalepoint - localx;
                yscalepoint = yscalepoint - localy;
                this.points[point].x = xscalepoint / scalefactor;
                this.points[point].y = yscalepoint / scalefactor;
                this.findrectangle();
            }


        };


        this.deletepoint = function(point){

               //var index = array.indexOf(5);
              if (point >= 0 && point <= this.points.length - 1) {
                this.points.splice(point, 1);
              }
              this.selectedpoint = -1;
        };

        this.insertpoint = function(){

            var bfirstpoint = (markupobject.linesegment.p1 >= 0 && markupobject.linesegment.p1 <= this.points.length - 1);
            var bsecondpoint = (markupobject.linesegment.p2 >= 0 && markupobject.linesegment.p2 <= this.points.length - 1);

            if(bfirstpoint && bsecondpoint){
                var x0 = this.points[markupobject.linesegment.p1].x;
                var y0 = this.points[markupobject.linesegment.p1].y;
                var x1 = this.points[markupobject.linesegment.p2].x;
                var y1 = this.points[markupobject.linesegment.p2].y;

                var midX=x0+(x1-x0)*0.50;
                var midY=y0+(y1-y0)*0.50;

                if (markupobject.linesegment.p2 != 0){
                    this.points.splice(markupobject.linesegment.p2, 0, {x:midX, y:midY});
                }else{
                    this.points.push({x:midX, y:midY});
                }


            }

        };

        this.movepoint = function (x, y, point) {

            if (point >= 0 && point <= this.points.length - 1) {
                this.points[point].x = x;
                this.points[point].y = y;

            }

        };

        this.setlastpoint = function (x, y) {
            this.points[this.points.length - 1].x = x;
            this.points[this.points.length - 1].y = y;

            this.findrectangle();
        };

        this.getlastpoint = function(){

            if (this.points.length > 0){
                return {
                    x : this.points[this.points.length - 1].x,
                    y : this.points[this.points.length - 1].y
                };

            }else{
                return false;
            }

        };


        this.startdraw = function (ctx) {
            ctx.beginPath();
            ctx.moveTo(this.points[this.points.length - 1].x, this.points[this.points.length - 1].y);

        };

        // common drawing functions

        this.displayurl = function (ctx, x, y) {

            var labelwidth = 1;
            var labelheight = 20;


            var labelType = markupobject.linkURL;
            ctx.save();
            ctx.font = "10pt Arial";

            var labeltypewidth = ctx.measureText(labelType);
            var labetypesize = labeltypewidth.width;

            if (labetypesize > labelwidth) {
                labelwidth = labetypesize;
            }


            labelwidth += 10;

            ctx.strokeStyle = "black";
            ctx.fillStyle = "rgba(113, 114, 118, 0.8)";
            ctx.lineWidth = 1;

            ctx.strokeRect(x, y + 30, labelwidth, labelheight);
            ctx.fillRect(x, y + 30, labelwidth, labelheight);

            ctx.fillStyle = "white";

            ctx.fillText(labelType, x + 3, y + 42);

            ctx.restore();






        };

        this.displaylabel = function (ctx, x, y) {
            if(!bmarkupLabels){
                return;
            }

            var labelType = "";

            var labelSign = GetDisplayName(this.signature);
            //var labelLayer = "Markup Layer " + this.layer;
            var labelLayer = Layerlist[this.layer].Name;
            var labeldate = this.GetDateTime(true);
            var notetext = "";
            var labelwidth = 1;
            var labelheight = (10 * 4) + 10;
            var noteBool = false;



            ctx.save();
            ctx.font = "10pt Arial";
            switch (this.type) {
                case 0:
                    if (this.subtype == 0) {
                        labelType = "Freehand pen";
                    }
                    if (this.subtype == 1) {
                        labelType = "Eraser";
                    }

                    break;
                case 1:
                    if (this.subtype == 1) {
                        labelType = "Polyline";
                    }
                    if (this.subtype == 2) {
                        labelType = "Polygon";
                    }
                    if (this.subtype == 3) {
                        labelType = "Measure Path";
                    }

                    break;
                case 2:
                    labelType = "Polycurve";
                    break;
                case 3:
                    if (this.subtype == 0) {
                        labelType = "Rectangle";
                    }
                    if (this.subtype == 1) {
                        labelType = "Rounded Rectangle";
                    }
                    break;
                case 4:
                    if (this.subtype == 0){
                        labelType = "Oval";
                    }
                    if (this.subtype == 1){
                        labelType = "Circle";
                    }
                    break;
                case 5:
                    labelType = "Revision Cloud";
                    break;
                case 6:
                    if (this.subtype == 9) {
                       labelType = "Line";
                    }else{
                       labelType = "Arrow";
                    }
                    break;
                case 7:
                    labelType = "Dimension Line";
                    break;
                case 8:

                    if(this.subtype == 1){
                        labelType = "Space";
                    }else{
                        labelType = "Area";
                    }
                    break;
                case 9:
                    labelType = "Text";
                    notetext = this.text;
                    var labelnotewidth = ctx.measureText(notetext);
                    var labelnotesize = labelnotewidth.width;
                    /*if (labelnotesize > labelwidth) {
                        labelwidth = labelnotesize;
                    }
                    labelheight = (10 * 4) + 10;
                    noteBool = true;*/
                    break;
                case 11:
                    labelType = "Image";
                    break;

                case 10:
                    labelType = "Note";
                    if (this.text != undefined){
                      notetext = this.text;
                    }else{
                      notetext = "";
                    }


                    var disptext = wordWrap(notetext,30);
                    var textarray = disptext.split('\n');

                    labelnotewidth = 0;
                    for (var i = 0; i < textarray.length; i++) {
                        if (ctx.measureText(textarray[i]) > labelnotewidth) {
                            labelnotewidth = ctx.measureText(textarray[i]);
                        }
                    }
                    //labelnotewidth = ctx.measureText(notetext);
                    labelnotesize = labelnotewidth.width;
                    if (labelnotesize > labelwidth) {
                        labelwidth = labelnotesize;
                    }
                    labelheight = (10 * 5) + 10;
                    noteBool = true;
                    break;
                case 12:
                    labelType = "Stamp";
                    break;
            }

            var labeltypewidth = ctx.measureText(labelType);
            var labetypesize = labeltypewidth.width;


            if (labetypesize > labelwidth) {
                labelwidth = labetypesize;
            }

            var labelSignwidth = ctx.measureText(labelSign);
            var labelsignsize = labelSignwidth.width;

            if (labelsignsize > labelwidth) {
                labelwidth = labelsignsize;
            }

            var labelLayerwidth = ctx.measureText(labelLayer);
            var labellayersize = labelLayerwidth.width;

            if (labellayersize > labelwidth) {
                labelwidth = labellayersize;
            }

            var labeldatewidth = ctx.measureText(labeldate);
            var labeldatesize = labeldatewidth.width;

            if (labeldatesize > labelwidth) {
                labelwidth = labeldatesize;
            }


            if (this.type != 10) {
                labelwidth += 10;

                ctx.strokeStyle = "black";
                ctx.fillStyle = "rgba(113, 114, 118, 0.8)";
                ctx.lineWidth = 1;

                ctx.strokeRect(x, y + 30, labelwidth, labelheight);
                ctx.fillRect(x, y + 30, labelwidth, labelheight);

                ctx.fillStyle = "white";

                ctx.fillText(labelType, x + 3, y + 42);
                ctx.fillText(labelSign, x + 3, y + 54);
                ctx.fillText(labelLayer, x + 3, y + 66);
                ctx.fillText(labeldate, x + 3, y + 78);
                if (noteBool) {
                    ctx.fillText(notetext, x + 3, y + 90);
                }
            } else {

                if (labelwidth < 200) {
                    labelwidth = 200;
                } else {
                    labelwidth += 10;
                }

                labelheight = 150;

                ctx.strokeStyle = "black";
                ctx.fillStyle = "rgba(255, 255, 0, 0.8)";
                ctx.lineWidth = 1;

                ctx.strokeRect(x, y + 30, labelwidth, labelheight);
                ctx.fillRect(x, y + 30, labelwidth, labelheight);

                ctx.fillStyle = "black";

                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y + 30, labelwidth, labelheight);
                ctx.clip();


                ctx.fillText(labelSign, x + 5, y + 46);
                ctx.fillText(labeldate, x + 5, y + 60);
                ctx.fillText(labelLayer, x + 5, y + 74);

                //ctx.fillText(labelLayer, x+3 , y+66);
                if (noteBool) {
                    var ystart = y + 100;

                    for (i = 0; i < textarray.length; i++) {
                        ctx.fillText(textarray[i], x + 5, ystart);
                        ystart += 12;
                    }
                    //ctx.fillText(notetext, x+3 , y+100);
                }
                ctx.restore();
            }

            ctx.restore(); // restore context to what it was on entry

        };

        this.Rect = function (ctx, x, y, width, height, linewidth, fill, stroke, fillcolor, strokecolor) {
            ctx.save(); // save the context so we don't mess up others

            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;
            ctx.lineWidth = linewidth;


            if (markupobject.rotation != 0 && markupobject.type != 9) {
                var tx = x + (width / 2);
                var ty = y + (height / 2);
                ctx.translate(tx, ty);
                ctx.rotate(markupobject.rotation);
                ctx.translate(-tx, -ty);
            }

            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + width, y);
            ctx.lineTo(x + width, y + height);
            ctx.lineTo(x, y + height);
            ctx.closePath();

            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }


            ctx.restore(); // restore context to what it was on entry

        };


        this.drawradius = function(ctx, x, y, w, h, crossl, linewidth, strokecolor, bdiameter){
            ctx.save(); // save the context so we don't mess up others
            ctx.strokeStyle = strokecolor;
            ctx.lineWidth = 2;

            var xdiff = Math.max(x,w) - Math.min(x,w);
            var ydiff = Math.max(y,h) - Math.min(y,h);
            var radius = markupobject.getdiag(xdiff, ydiff);

            //draw center cross.
            ctx.beginPath();
            ctx.moveTo(x-crossl, y);
            ctx.lineTo(x+crossl, y);
            ctx.moveTo(x, y-crossl);
            ctx.lineTo(x, y+crossl);
            ctx.stroke();

            //draw leader

            ctx.restore(); // restore context to what it was on entry




        };


        this.radiusDimLeader = function(ctx,x,y,w,h, linewidth, strokecolor){


        };

        this.Circle = function(ctx, x, y, w, h, linewidth, fill, stroke, fillcolor, strokecolor){

            ctx.save(); // save the context so we don't mess up others

            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;
            ctx.lineWidth = linewidth;

            /*if (markupobject.rotation != 0) {
                ctx.translate(x, y);
                ctx.rotate(markupobject.rotation);
                ctx.translate(-x, -y);
            }*/

            var xdiff = Math.max(x,w) - Math.min(x,w);
            var ydiff = Math.max(y,h) - Math.min(y,h);
            var radius = markupobject.getdiag(xdiff, ydiff);


            ctx.beginPath();
            ctx.arc(x,y,radius,0,2*Math.PI);



            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }

            ctx.restore(); // restore context to what it was on entry
        };

        this.Oval = function (ctx, x, y, width, height, linewidth, fill, stroke, fillcolor, strokecolor) {

            var ox = (width / 2) * kappa;
            var oy = (height / 2) * kappa;
            var xe = x + width;
            var ye = y + height;
            var xm = x + width / 2;
            var ym = y + height / 2;


            ctx.save(); // save the context so we don't mess up others

            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;
            ctx.lineWidth = linewidth;



            if (markupobject.rotation != 0) {
                var tx = x + (width / 2);
                var ty = y + (height / 2);
                ctx.translate(tx, ty);
                ctx.rotate(markupobject.rotation);
                ctx.translate(-tx, -ty);
            }


            ctx.beginPath();
            ctx.moveTo(x, ym);
            ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
            ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
            ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
            ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
            ctx.closePath();

            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }


            ctx.restore(); // restore context to what it was on entry

        };

        /*this.polygon=function(ctx,linewidth,fill,stroke,fillcolor,strokecolor){
         var counter = 0;

         ctx.save();

         ctx.strokeStyle = strokecolor;
         ctx.lineWidth = linewidth;
         ctx.fillStyle = fillcolor;
         ctx.beginPath();
         ctx.moveTo(markupobject.points[0].x, markupobject.points[0].y);

         for (counter=1;counter<markupobject.points.length;counter++){
         ctx.lineTo(markupobject.points[counter].x, markupobject.points[counter].y);
         }
         ctx.closePath();


         if(fill){
         ctx.fill();
         }
         if(stroke){
         ctx.stroke();
         }
         ctx.restore();


         };*/

        this.polygon = function (ctx, linewidth, fill, stroke, fillcolor, strokecolor, scalefactor,dx,dy,useoffset) {
            var counter = 0;

            var xscaled = (this.points[0].x - this.xoffset) * scalefactor;
            var yscaled = (this.points[0].y - this.yoffset) * scalefactor;

            if(useoffset){
                xscaled += dx;
                yscaled += dy;
            }

            ctx.save();

            ctx.strokeStyle = strokecolor;

            if(bUseFixedScale){
                ctx.lineWidth = linewidth * markupobject.fixedscaleFactor;
            }else{
                ctx.lineWidth = linewidth * scalefactor;
            }

            ctx.fillStyle = fillcolor;

            ctx.beginPath();


            //      ctx.moveTo(markupobject.points[0].x, markupobject.points[0].y);
            ctx.moveTo(xscaled, yscaled);

            for (counter = 1; counter < markupobject.points.length; counter++) {
                //            ctx.lineTo(markupobject.points[counter].x, markupobject.points[counter].y);
                xscaled = (this.points[counter].x - this.xoffset) * scalefactor;
                yscaled = (this.points[counter].y - this.yoffset) * scalefactor;
                if(useoffset){
                    xscaled += dx;
                    yscaled += dy;
                }

                ctx.lineTo(xscaled, yscaled);

            }
            ctx.closePath();


            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
            ctx.restore();


        };
        this.polyline = function (ctx, linewidth, strokecolor, scalefactor,dx,dy,useoffset) {
            var counter = 0;

            var xscaled = (this.points[0].x - this.xoffset) * scalefactor;
            var yscaled = (this.points[0].y - this.yoffset) * scalefactor;

            if(useoffset){
                xscaled += dx;
                yscaled += dy;

            }

            ctx.save();

            ctx.strokeStyle = strokecolor;

            if(bUseFixedScale){
                ctx.lineWidth = linewidth * markupobject.fixedscaleFactor;
            }else{
                ctx.lineWidth = linewidth * scalefactor;
            }

            ctx.beginPath();


            //      ctx.moveTo(markupobject.points[0].x, markupobject.points[0].y);
            ctx.moveTo(xscaled, yscaled);

            for (counter = 1; counter < markupobject.points.length; counter++) {
                //            ctx.lineTo(markupobject.points[counter].x, markupobject.points[counter].y);
                xscaled = (this.points[counter].x - this.xoffset) * scalefactor;
                yscaled = (this.points[counter].y - this.yoffset) * scalefactor;
                if(useoffset){
                    xscaled += dx;
                    yscaled += dy;
                }

                ctx.lineTo(xscaled, yscaled);

            }
            //ctx.closePath();
            ctx.stroke();

            ctx.restore();


        };

        this.polycurves = function (ctx, linewidth, strokecolor, scalefactor) {
            var counter = 0;
            var control = new point();
            var start = new point();
            var xscaled = (this.points[0].x - this.xoffset) * scalefactor;
            var yscaled = (this.points[0].y - this.yoffset) * scalefactor;

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                yscaled += DocObj.pages[DocObj.currentpage].dyvector;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                yscaled += DocObj.pages[DocObj.currentpage].dypdf;

            } else {
                xscaled = xscaled + DocObj.pages[DocObj.currentpage].dx;
                yscaled = yscaled + DocObj.pages[DocObj.currentpage].dy;

            }


            ctx.save();

            ctx.strokeStyle = strokecolor;
            ctx.lineWidth = linewidth * scalefactor;


            ctx.beginPath();

            //      ctx.moveTo(markupobject.points[0].x, markupobject.points[0].y);
            ctx.moveTo(xscaled, yscaled);
            start.x = xscaled;
            start.y = yscaled;

            for (counter = 1; counter < markupobject.points.length; counter++) {

                xscaled = (this.points[counter].x - this.xoffset) * scalefactor;
                yscaled = (this.points[counter].y - this.yoffset) * scalefactor;
                if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                    xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                    yscaled += DocObj.pages[DocObj.currentpage].dyvector;

                } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                    xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                    yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                } else {
                    xscaled = xscaled + DocObj.pages[DocObj.currentpage].dx;
                    yscaled = yscaled + DocObj.pages[DocObj.currentpage].dy;

                }


                if (isEven(counter)) {

                    ctx.moveTo(start.x, start.y);
                    ctx.quadraticCurveTo(control.x, control.y, xscaled, yscaled);
                    start.x = xscaled;
                    start.y = yscaled;

                } else {
                    //dont draw if converted to curve.
                    if (counter + 1 == markupobject.points.length) {
                        ctx.lineTo(xscaled, yscaled);
                    }
                    control.x = xscaled;
                    control.y = yscaled;

                }

                //ctx.lineTo(xscaled, yscaled);

            }
            //ctx.closePath();
            ctx.stroke();

            ctx.restore();


        };


        this.dimensionLeader = function (ctx, x, y, width, height, offset, arrowl, arrowa, linewidth, type, fillcolor, strokecolor) {
            //bounding box
            var arrwidth = width - x;
            var arrheight = height - y;

            var baranglerad = 90 / (180 / Math.PI);
            var arrowanglerad = arrowa / (180 / Math.PI);

            //angle of diagonal in radians
            var arrdiagrad = Math.atan2(arrheight, arrwidth);


            //arrowhead length
            var arrowhead = Math.abs(arrowl / Math.cos(arrowanglerad));

            //bar length
            var barhead = arrowl / 2;


            //negative angle of diagonal
            var arrangleradneg = Math.PI + arrdiagrad;
            //angle of end barb lines relative to line
            var aarrowupperangle = arrangleradneg + arrowanglerad;
            var aarrowlowerangle = arrangleradneg - arrowanglerad;

            //angle of end bar lines relative to line
            var abarupperangle = arrangleradneg + baranglerad;
            var abarlowerangle = arrangleradneg - baranglerad;


            //calculated points of the line end barbs
            var arrtopx = width + Math.cos(aarrowupperangle) * arrowhead;
            var arrtopy = height + Math.sin(aarrowupperangle) * arrowhead;
            var arrbotx = width + Math.cos(aarrowlowerangle) * arrowhead;
            var arrboty = height + Math.sin(aarrowlowerangle) * arrowhead;



            //calculated points of the line end bar
            var bartopx = width + Math.cos(abarupperangle) * barhead;
            var bartopy = height + Math.sin(abarupperangle) * barhead;
            var barbotx = width + Math.cos(abarlowerangle) * barhead;
            var barboty = height + Math.sin(abarlowerangle) * barhead;

            //new end points for main line with leader line offsets.
            var leaderoffsetendx = width + Math.cos(abarlowerangle) * offset;
            var leaderoffsetendy = height + Math.sin(abarlowerangle) * offset;



            var startx = x + Math.cos(arrdiagrad) * barhead;
            var starty = y + Math.sin(arrdiagrad) * barhead;
            var endx = width - Math.cos(arrdiagrad) * barhead;
            var endy = height - Math.sin(arrdiagrad) * barhead;


            //angle of start barb lines relative to line
            var asarrowupperangle = arrdiagrad + arrowanglerad;
            var asarrowlowerangle = arrdiagrad - arrowanglerad;

            //angle of start bar lines relative to line
            var asbarupperangle = arrdiagrad + baranglerad;
            var asbarlowerangle = arrdiagrad - baranglerad;


            //calculated points of the line start barbs
            var arrstopx = x + Math.cos(asarrowupperangle) * arrowhead;
            var arrstopy = y + Math.sin(asarrowupperangle) * arrowhead;
            var arrsbotx = x + Math.cos(asarrowlowerangle) * arrowhead;
            var arrsboty = y + Math.sin(asarrowlowerangle) * arrowhead;

            //calculated points of the line start bar
            var barstopx = x + Math.cos(asbarupperangle) * barhead;
            var barstopy = y + Math.sin(asbarupperangle) * barhead;
            var barsbotx = x + Math.cos(asbarlowerangle) * barhead;
            var barsboty = y + Math.sin(asbarlowerangle) * barhead;

            //new position for main line start and stop when having leader line offsets.
            var leaderoffsetx = x + Math.cos(asbarupperangle) * offset;
            var leaderoffsety = y + Math.sin(asbarupperangle) * offset;

            //calculated points of the line end barbs for offset
            var arrtopxoffset = leaderoffsetendx + Math.cos(aarrowupperangle) * arrowhead;
            var arrtopyoffset = leaderoffsetendy + Math.sin(aarrowupperangle) * arrowhead;
            var arrbotxoffset = leaderoffsetendx + Math.cos(aarrowlowerangle) * arrowhead;
            var arrbotyoffset = leaderoffsetendy + Math.sin(aarrowlowerangle) * arrowhead;

            //calculated points of the line start barbs with offset
            var arrstopxoffset = leaderoffsetx + Math.cos(asarrowupperangle) * arrowhead;
            var arrstopyoffset = leaderoffsety + Math.sin(asarrowupperangle) * arrowhead;
            var arrsbotxoffset = leaderoffsetx + Math.cos(asarrowlowerangle) * arrowhead;
            var arrsbotyoffset = leaderoffsety + Math.sin(asarrowlowerangle) * arrowhead;


            //var offsetdims = {x:leaderoffsetx, y: leaderoffsety, w : leaderoffsetendx, h: leaderoffsetendy};

            //var leaderpoint = {x: }


            ctx.save(); // save the context so we don't mess up others

            ctx.lineWidth = linewidth;
            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;

            if(this.subtype == 9){
                ctx.lineCap="butt";
            }else{
                ctx.lineCap = 'round';
            }

            ctx.beginPath();
            if (type == 1 || type == 3) {
                if (type == 1) {
                    ctx.moveTo(x, y);
                } else if (type == 3) {
                    ctx.moveTo(startx, starty);
                }
                ctx.lineTo(endx, endy);
            } else {
                if(offset == 0){
                    ctx.moveTo(x, y);
                    ctx.lineTo(width, height);

                }else{
                    ctx.moveTo(leaderoffsetx, leaderoffsety);
                    ctx.lineTo(leaderoffsetendx, leaderoffsetendy);
                }

            }
            //ctx.closePath();
            ctx.stroke();

            if (type == 0) {

                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(arrtopx, arrtopy);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(arrbotx, arrboty);
                //ctx.closePath();
                ctx.stroke();

            }
            if (type == 1) {
                //ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(arrtopx, arrtopy);
                ctx.lineTo(arrbotx, arrboty);
                ctx.closePath();
                //ctx.stroke();
                ctx.fill();

            }
            if (type == 2) {

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(arrstopx, arrstopy);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(arrsbotx, arrsboty);
                //ctx.closePath();
                ctx.stroke();


                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(arrtopx, arrtopy);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(arrbotx, arrboty);
                //ctx.closePath();
                ctx.stroke();
            }


            if (type == 3) {
                //ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(arrstopx, arrstopy);
                ctx.lineTo(arrsbotx, arrsboty);
                ctx.closePath();
                ctx.fill();
                ctx.lineCap = 'round';
                //ctx.stroke();


                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(arrtopx, arrtopy);
                ctx.lineTo(arrbotx, arrboty);
                ctx.closePath();
                ctx.fill();
                ctx.lineCap = 'round';
                //ctx.stroke();

            }
            //bars both ends
            if (type == 4) {


                ctx.beginPath();
                ctx.moveTo(x, y);
                if (offset == 0){
                    ctx.lineTo(barstopx, barstopy);
                }else{
                    ctx.lineTo(leaderoffsetx, leaderoffsety);

                }

                //ctx.closePath();
                ctx.stroke();

                if (offset == 0){
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(barsbotx, barsboty);
                    //ctx.closePath();
                    ctx.stroke();


                    ctx.beginPath();
                    ctx.moveTo(width, height);
                    ctx.lineTo(bartopx, bartopy);
                    //ctx.closePath();
                    ctx.stroke();

                }

                ctx.beginPath();
                ctx.moveTo(width, height);
                if (offset == 0){
                    ctx.lineTo(barbotx, barboty);
                }else{
                    ctx.lineTo(leaderoffsetendx, leaderoffsetendy);
                }

                //ctx.closePath();
                ctx.stroke();

            }
            //bars and open arrows
            if (type == 5) {

                if (offset == 0){
                    var awstrtx = x;
                    var awstrty = y;
                    var awendx = width;
                    var awendy = height;

                    var arwstrttopx = arrstopx;
                    var arwstrttopy = arrstopy;
                    var arwstrtbotx = arrsbotx;
                    var arwstrtboty = arrsboty;
                    var arwendtopx = arrtopx;
                    var arwendtopy = arrtopy;
                    var arwendbotx = arrbotx;
                    var arwendboty = arrboty;

                }else{
                    awstrtx = leaderoffsetx;
                    awstrty = leaderoffsety;
                    awendx = leaderoffsetendx;
                    awendy = leaderoffsetendy;

                    arwstrttopx = arrstopxoffset;
                    arwstrttopy = arrstopyoffset;
                    arwstrtbotx = arrsbotxoffset;
                    arwstrtboty = arrsbotyoffset;
                    arwendtopx = arrtopxoffset;
                    arwendtopy = arrtopyoffset;
                    arwendbotx = arrbotxoffset;
                    arwendboty = arrbotyoffset;

                }



                ctx.beginPath();
                ctx.moveTo(awstrtx, awstrty);
                ctx.lineTo(arwstrttopx, arwstrttopy);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(awstrtx, awstrty);
                ctx.lineTo(arwstrtbotx, arwstrtboty);
                //ctx.closePath();
                ctx.stroke();


                ctx.beginPath();
                ctx.moveTo(awendx, awendy);
                ctx.lineTo(arwendtopx, arwendtopy);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(awendx, awendy);
                ctx.lineTo(arwendbotx, arwendboty);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x, y);

                if (offset == 0){
                    ctx.lineTo(barstopx, barstopy);
                }else{
                    ctx.lineTo(leaderoffsetx, leaderoffsety);

                }


                //ctx.closePath();
                ctx.stroke();

                if (offset == 0){
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(barsbotx, barsboty);
                    //ctx.closePath();
                    ctx.stroke();


                    ctx.beginPath();
                    ctx.moveTo(width, height);
                    ctx.lineTo(bartopx, bartopy);
                    //ctx.closePath();
                    ctx.stroke();

                }

                ctx.beginPath();
                ctx.moveTo(width, height);
                if (offset == 0){
                    ctx.lineTo(barbotx, barboty);
                }else{
                    ctx.lineTo(leaderoffsetendx, leaderoffsetendy);
                }
                //ctx.closePath();
                ctx.stroke();

            }
            /*if (type == 9) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(width, height);
                ctx.stroke();
            }*/

            ctx.restore(); // restore context to what it was on entry

            var offsetdims = {x:leaderoffsetx, y: leaderoffsety, w : leaderoffsetendx, h: leaderoffsetendy};
            return offsetdims;
        };


        this.barhead = function(ctx, x,y, width, height, lineEnds, arrowl, linewidth, strokecolor) {
            var arrwidth = width - x;
            var arrheight = height - y;

            var baranglerad = 90 / (180 / Math.PI);

            //angle of diagonal in radians
            var arrdiagrad = Math.atan2(arrheight, arrwidth);

            //bar length
            var barhead = arrowl / 2;

            //negative angle of diagonal
            var arrangleradneg = Math.PI + arrdiagrad;

            //angle of end bar lines relative to line
            var abarupperangle = arrangleradneg + baranglerad;
            var abarlowerangle = arrangleradneg - baranglerad;


            //calculated points of the line end bar
            var bartopx = width + Math.cos(abarupperangle) * barhead;
            var bartopy = height + Math.sin(abarupperangle) * barhead;
            var barbotx = width + Math.cos(abarlowerangle) * barhead;
            var barboty = height + Math.sin(abarlowerangle) * barhead;

            var startx = x + Math.cos(arrdiagrad) * barhead;
            var starty = y + Math.sin(arrdiagrad) * barhead;
            var endx = width - Math.cos(arrdiagrad) * barhead;
            var endy = height - Math.sin(arrdiagrad) * barhead;

            //angle of start bar lines relative to line
            var asbarupperangle = arrdiagrad + baranglerad;
            var asbarlowerangle = arrdiagrad - baranglerad;

            //calculated points of the line start bar
            var barstopx = x + Math.cos(asbarupperangle) * barhead;
            var barstopy = y + Math.sin(asbarupperangle) * barhead;
            var barsbotx = x + Math.cos(asbarlowerangle) * barhead;
            var barsboty = y + Math.sin(asbarlowerangle) * barhead;

            ctx.save(); // save the context so we don't mess up others

            ctx.lineCap = 'round';
            ctx.lineWidth = linewidth;
            ctx.strokeStyle = strokecolor;


            if(lineEnds.start){
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(barstopx, barstopy);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(barsbotx, barsboty);
                //ctx.closePath();
                ctx.stroke();

            }

            if(lineEnds.end){
                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(bartopx, bartopy);
                //ctx.closePath();
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(width, height);
                ctx.lineTo(barbotx, barboty);
                //ctx.closePath();
                ctx.stroke();

            }

            ctx.restore(); // restore context to what it was on entry


        };
        this.arrowhead = function(ctx, x,y, width, height, lineEnds, arrowa, arrowl, linewidth, strokecolor, bopen){
            var arrwidth = width - x;
            var arrheight = height - y;

            var arrowanglerad = arrowa / (180 / Math.PI);

            //angle of diagonal in radians
            var arrdiagrad = Math.atan2(arrheight, arrwidth);

            //arrowhead length
            var arrowhead = Math.abs(arrowl / Math.cos(arrowanglerad));

            //negative angle of diagonal
            var arrangleradneg = Math.PI + arrdiagrad;

            //angle of end barb lines relative to line
            var aarrowupperangle = arrangleradneg + arrowanglerad;
            var aarrowlowerangle = arrangleradneg - arrowanglerad;

            //calculated points of the line end barbs
            var arrtopx = width + Math.cos(aarrowupperangle) * arrowhead;
            var arrtopy = height + Math.sin(aarrowupperangle) * arrowhead;
            var arrbotx = width + Math.cos(aarrowlowerangle) * arrowhead;
            var arrboty = height + Math.sin(aarrowlowerangle) * arrowhead;

            //angle of start barb lines relative to line
            var asarrowupperangle = arrdiagrad + arrowanglerad;
            var asarrowlowerangle = arrdiagrad - arrowanglerad;

            //calculated points of the line start barbs
            var arrstopx = x + Math.cos(asarrowupperangle) * arrowhead;
            var arrstopy = y + Math.sin(asarrowupperangle) * arrowhead;
            var arrsbotx = x + Math.cos(asarrowlowerangle) * arrowhead;
            var arrsboty = y + Math.sin(asarrowlowerangle) * arrowhead;


            //if blinestart arrow on start of line else on end of line.

            ctx.save(); // save the context so we don't mess up others

            ctx.lineCap = 'round';
            ctx.lineWidth = linewidth;
            ctx.strokeStyle = strokecolor;


            if(lineEnds.start){
                if(bopen){
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(arrstopx, arrstopy);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(arrsbotx, arrsboty);
                    ctx.closePath();
                    ctx.stroke();

                }else{
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(arrstopx, arrstopy);
                    ctx.lineTo(arrsbotx, arrsboty);
                    ctx.closePath();
                    ctx.fill();
                    ctx.lineCap = 'round';

                }

            }

            if(lineEnds.end){
                if(bopen){
                    ctx.beginPath();
                    ctx.moveTo(width, height);
                    ctx.lineTo(arrtopx, arrtopy);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(width, height);
                    ctx.lineTo(arrbotx, arrboty);
                    ctx.closePath();
                    ctx.stroke();

                }else{
                    ctx.beginPath();
                    ctx.moveTo(width, height);
                    ctx.lineTo(arrtopx, arrtopy);
                    ctx.lineTo(arrbotx, arrboty);
                    ctx.closePath();
                    //ctx.stroke();
                    ctx.fill();

                }

            }

            ctx.restore(); // restore context to what it was on entry

        };

        this.arrow = function (ctx, x, y, width, height, arrowl, arrowa, linewidth, type, fillcolor, strokecolor) {

            //bounding box
            var arrwidth = width - x;
            var arrheight = height - y;


            var arrdiagrad = Math.atan2(arrheight, arrwidth);

            var barhead = arrowl / 2;


            var startx = x + Math.cos(arrdiagrad) * barhead;
            var starty = y + Math.sin(arrdiagrad) * barhead;
            var endx = width - Math.cos(arrdiagrad) * barhead;
            var endy = height - Math.sin(arrdiagrad) * barhead;


            var lineEnds = {start : false, end : false};

            ctx.save(); // save the context so we don't mess up others

            ctx.lineWidth = linewidth;
            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;

            if(this.subtype == 9){
                ctx.lineCap="butt";
            }else{
                ctx.lineCap = 'round';
            }

            ctx.beginPath();
            if (type == 1 || type == 3) {
                if (type == 1) {
                    ctx.moveTo(x, y);
                } else if (type == 3) {
                    ctx.moveTo(startx, starty);
                }
                ctx.lineTo(endx, endy);
            } else {
                ctx.moveTo(x, y);
                ctx.lineTo(width, height);

            }
            //ctx.closePath();
            ctx.stroke();

            if (type == 0) {

                lineEnds.end = true;
                lineEnds.start = false;

                markupobject.arrowhead(ctx, x,y, width, height, lineEnds, arrowa, arrowl, linewidth, strokecolor, true);
            }
            if (type == 1) {

                lineEnds.end = true;
                lineEnds.start = false;

                markupobject.arrowhead(ctx, x,y, width, height, lineEnds, arrowa, arrowl, linewidth, strokecolor, false);
            }
            if (type == 2) {


                lineEnds.end = true;
                lineEnds.start = true;

                markupobject.arrowhead(ctx, x,y, width, height, lineEnds, arrowa, arrowl, linewidth, strokecolor, true);
            }

            if (type == 3) {

                lineEnds.end = true;
                lineEnds.start = true;

                markupobject.arrowhead(ctx, x,y, width, height, lineEnds, arrowa, arrowl, linewidth, strokecolor, false);


            }
            //bars both ends
            if (type == 4) {

                lineEnds.end = true;
                lineEnds.start = true;
                markupobject.barhead(ctx, x,y, width, height, lineEnds, arrowl, linewidth, strokecolor);

            }
            //bars and open arrows
            if (type == 5) {

                lineEnds.end = true;
                lineEnds.start = true;

                markupobject.arrowhead(ctx, x,y, width, height, lineEnds, arrowa, arrowl, linewidth, strokecolor, true);

                lineEnds.end = true;
                lineEnds.start = true;
                markupobject.barhead(ctx, x,y, width, height, lineEnds, arrowl, linewidth, strokecolor);

            }

            if (type == 6){
                lineEnds.end = false;
                lineEnds.start = true;

                markupobject.arrowhead(ctx, x,y, width, height, lineEnds, arrowa, arrowl, linewidth, strokecolor, true);

            }

            /*if (type == 9) {
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(width, height);
                ctx.stroke();
            }*/

            ctx.restore(); // restore context to what it was on entry

        };

        this.setdimvaluepoly = function(){

            var dimdiag = 0;
            for (var i = 0;i<markupobject.points.length;i++){
                if (i > 0){
                    var dimwidth = markupobject.points[i].x - markupobject.points[i-1].x;
                    var dimheight = markupobject.points[i].y - markupobject.points[i-1].y;
                    dimdiag += markupobject.getdiag(dimwidth, dimheight);
                    markupobject.dimtext = getUnitlength(dimdiag / markupobject.scaling);
                    markupobject.dimtext = markupobject.dimtext.toFixed(2);
                    markupobject.dimtext = markupobject.dimtext + " " + Unitlabel;

                }

            }

        };

        this.setdimvalue = function (x, y, width, height) {
            var dimwidth = width - x;
            var dimheight = height - y;
            var dimdiag = markupobject.getdiag(dimwidth, dimheight);
             var blocalusefraction = false;

            if(Unitofmeasure == 2){

                if (bUseFraction){
                    blocalusefraction = true;
                }
                var fractionval = getUnitlengthRemainder(dimdiag / this.scaling);

                var dimtextfrac = fractionval.quot;
                var dimtextrem = fractionval.rem;


                if(SubmeasureUnit == 1){

                    var szdimtext = dimtextfrac + "\"";
                    if(fractionval.numerator != 0 && fractionval.denominator != 0){
                        if(fractionval.numerator == fractionval.denominator){
                            dimtextfrac + 1;
                            var szdimtext = dimtextfrac + "\"";
                        }else{
                            var szfraction = fractionval.numerator + "/" + fractionval.denominator;
                            var szdimtext = dimtextfrac + " " + szfraction + "\"";

                        }
                    }

                }
                if(SubmeasureUnit == 2){

                    if(dimtextrem != 0){
                        var szdimtext = dimtextfrac + "\' - " + dimtextrem + "\"";
                    }else{
                        szdimtext = dimtextfrac + "\'";
                    }

                    if(fractionval.numerator != 0 && fractionval.denominator != 0){
                        if(fractionval.numerator == fractionval.denominator){
                            dimtextrem + 1;
                            var szdimtext = dimtextfrac + "\' - " + dimtextrem + "\"";
                        }else{
                            if(dimtextrem != 0){
                                var szfraction = fractionval.numerator + "/" + fractionval.denominator;
                                var szdimtext = dimtextfrac + "\' - " + dimtextrem + " " + szfraction + "\"";
                            }else{
                                var szfraction = fractionval.numerator + "/" + fractionval.denominator;
                                var szdimtext = dimtextfrac + "\' - " + szfraction + "\"";
                            }

                        }

                    }


                }


            }

            this.dimtext = getUnitlength(dimdiag / this.scaling);
            this.dimtext = this.dimtext.toFixed(2);
            this.dimtext = this.dimtext + " " + Unitlabel;

            if(blocalusefraction){
                this.dimtext = szdimtext;
            }

        };

        this.customlabeldraw = function(ctx, textarray, areatextxscaled, areatextyscaled, strokecolor, areatextscaled, localscalefactor){

            ctx.textAlign = "start";
            markupobject.font.setScale(localscalefactor);

            ctx.font = markupobject.font.fontstringScaled;
            //ctx.font = areatextscaled + "pt " + "Helvetica";
            //this.textheight = this.measuretextheight;

            var areat = ctx.measureText(dimtext);
            var areatextwidth = areat.width;
            var areatextheight = areatextscaled;

            areatextxscaled += (markupobject.labeloffsetx * localscalefactor);
            areatextyscaled += (markupobject.labeloffsety * localscalefactor);

            areatextxscaled = areatextxscaled - (areatextwidth / 2);
            areatextyscaled = areatextyscaled + (areatextheight / 2);

            ctx.lineWidth = 1;
            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = "white";

            ctx.fillRect(areatextxscaled - (10 * localscalefactor), areatextyscaled - (20 * localscalefactor), areatextwidth + (20 * localscalefactor), areatextscaled + (15 * localscalefactor));
            ctx.strokeRect(areatextxscaled - (10 * localscalefactor), areatextyscaled - (20 * localscalefactor), areatextwidth + (20 * localscalefactor), areatextscaled + (15 * localscalefactor));



        };

        this.insidelabel = function(x,y){
            var within = false;

            if((!markupobject.busecustomlabel && markupobject.subtype == 1) || bMarkupNoLabel){
                return within;
            }else{
                if (x > markupobject.labelRect.x && x < (markupobject.labelRect.x + markupobject.labelRect.w)) {
                    if (y > markupobject.labelRect.y && y < (markupobject.labelRect.y + markupobject.labelRect.h)) {
                        within = true;
                    }
                }
            }


            return within;
        };

        this.areavaluedraw = function (ctx, dimtext, areatextxscaled, areatextyscaled, strokecolor, areatextscaled, localscalefactor, scalefactor){



            ctx.textAlign = "start";
            markupobject.font.setScale(localscalefactor);

            ctx.font = markupobject.font.fontstringScaled;
            //ctx.font = areatextscaled + "pt " + "Helvetica";
            //this.textheight = this.measuretextheight;

            var labelsizefactor = markupobject.font.height / 12;
            var labelstartoffsetx = 10 * labelsizefactor;
            var labelstartoffsety = 20 * labelsizefactor;

            var labelwidthtoffset = 20 * labelsizefactor;
            var labelheightoffset = 15 * labelsizefactor;


            var areat = ctx.measureText(dimtext);
            var areatextwidth = areat.width;
            var areatextheight = areatextscaled;
            var scaletextheight = markupobject.font.height * localscalefactor;

            //areatextxscaled += markupobject.labeloffsetx;
            //areatextyscaled += markupobject.labeloffsety;

            areatextxscaled += (markupobject.labeloffsetx * scalefactor);
            areatextyscaled += (markupobject.labeloffsety * scalefactor);


            areatextxscaled = areatextxscaled - (areatextwidth / 2);
            areatextyscaled = areatextyscaled + (areatextheight / 2);

            ctx.lineWidth = 1;
            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = markupobject.labelfillcolor;


            markupobject.labelRect.x = areatextxscaled - (labelstartoffsetx * localscalefactor);
            markupobject.labelRect.y = areatextyscaled - (labelstartoffsety * localscalefactor);
            markupobject.labelRect.w = areatextwidth + (labelwidthtoffset * localscalefactor);
            markupobject.labelRect.h = scaletextheight + (labelheightoffset * localscalefactor);


            //ctx.fillRect(areatextxscaled - (labelstartoffsetx * localscalefactor), areatextyscaled - (labelstartoffsety * localscalefactor), areatextwidth + (labelwidthtoffset * localscalefactor), areatextscaled + (labelheightoffset * localscalefactor));
            ctx.fillRect(areatextxscaled - (labelstartoffsetx * localscalefactor), areatextyscaled - (labelstartoffsety * localscalefactor), areatextwidth + (labelwidthtoffset * localscalefactor), scaletextheight + (labelheightoffset * localscalefactor));

            //ctx.strokeRect(areatextxscaled - (labelstartoffsetx * localscalefactor), areatextyscaled - (labelstartoffsety * localscalefactor), areatextwidth + (labelwidthtoffset * localscalefactor), areatextscaled + (labelheightoffset * localscalefactor));
            ctx.strokeRect(areatextxscaled - (labelstartoffsetx * localscalefactor), areatextyscaled - (labelstartoffsety * localscalefactor), areatextwidth + (labelwidthtoffset * localscalefactor), scaletextheight + (labelheightoffset * localscalefactor));


            // ctx.fillStyle = this.color;
            ctx.fillStyle = "black";
            ctx.fillText(dimtext, areatextxscaled, areatextyscaled);
        };

        this.dimvaluedraw = function (ctx, x, y, width, height, color, scalefactor,brotate) {
            ctx.save();

            var dimwidth = width - x;
            var dimheight = height - y;
            var dimdiag = markupobject.getdiag(dimwidth, dimheight);

            var dimanglerad = Math.atan2(dimheight, dimwidth);


            ctx.textAlign = "start";
            markupobject.font.setScale(scalefactor);
            var scaletextheight = markupobject.font.height * scalefactor;
            this.textheight = markupobject.font.height;

            var labelsizefactor = markupobject.font.height / 12;
            var labelstartoffsetx = 10 * labelsizefactor;
            var labelstartoffsety = 5 * labelsizefactor;

            var labelwidthtoffset = 20 * labelsizefactor;
            var labelheightoffset = 10 * labelsizefactor;

            ctx.font = markupobject.font.fontstringScaled;
            var dimt = ctx.measureText(this.dimtext);
            var dimtextwidth = dimt.width;

            if(markupobject.saved){
                var dimtextx = x + (dimwidth / 2) - (dimtextwidth / 2);
                var dimtexty = y + (dimheight / 2) + (scaletextheight / 2);

            }else{
                //var dimtextx = x + (dimwidth / 2) - (dimtextwidth / 2);
                dimtextx = width + (15 * scalefactor);
                dimtexty = height;
                //var dimtexty = y + (dimheight / 2) + (scaletextheight / 2);
            }


            if (dimanglerad > (Math.PI * 0.5) || dimanglerad < -(Math.PI * 0.5)) {
                if (markupobject.pagerotation == 0){
                    dimanglerad += Math.PI;
                }
           }
            //console.log(dimanglerad);


            if (brotate && markupobject.saved){

                var tx = x + (dimwidth / 2);
                var ty = y + (dimheight / 2);

                ctx.translate(tx, ty);
                ctx.rotate(dimanglerad);
                ctx.translate(-tx, -ty);

            }


            /*if(rotation !=0){
             }*/

            ctx.lineWidth = 1;
            var yrect = dimtexty - scaletextheight;
            ctx.fillStyle = "white";
            ctx.strokeStyle = this.strokecolor;

            ctx.fillRect(dimtextx - (labelstartoffsetx * scalefactor), yrect - (labelstartoffsety * scalefactor), dimtextwidth + (labelwidthtoffset * scalefactor), scaletextheight + (labelheightoffset * scalefactor));
            ctx.strokeRect(dimtextx - (labelstartoffsetx * scalefactor), yrect - (labelstartoffsety * scalefactor), dimtextwidth + (labelwidthtoffset * scalefactor), scaletextheight + (labelheightoffset * scalefactor));

            labelsize.w = dimtextwidth + (labelwidthtoffset * scalefactor);
            labelsize.h = scaletextheight + (labelheightoffset * scalefactor);

            ctx.fillStyle = "black";
            ctx.fillText(this.dimtext, dimtextx, dimtexty);


            ctx.restore();
        };

        this.roundedRect = function (ctx, x, y, width, height, rotation, radius, linewidth, fill, stroke, fillcolor, strokecolor) {
            ctx.save(); // save the context so we don't mess up others

            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;
            ctx.lineWidth = linewidth;


            if (rotation != 0) {
                var tx = x + (width / 2);
                var ty = y + (height / 2);
                ctx.translate(tx, ty);
                ctx.rotate(markupobject.rotation);
                ctx.translate(-tx, -ty);
            }
            //alternative 2 start
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.arcTo(x + width, y, x + width, y + radius, radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
            ctx.lineTo(x + radius, y + height);
            ctx.arcTo(x, y + height, x, y + height - radius, radius);
            ctx.lineTo(x, y + radius);
            ctx.arcTo(x, y, x + radius, y, radius);

            //alternative 2 end
            /*ctx.beginPath();

             // draw top and top right corner
             ctx.moveTo(x+radius,y);
             ctx.arcTo(x+width,y,x+width,y+radius,radius);

             // draw right side and bottom right corner
             ctx.arcTo(x+width,y+height,x+width-radius,y+height,radius);

             // draw bottom and bottom left corner
             ctx.arcTo(x,y+height,x,y+height-radius,radius);

             // draw left and top left corner
             ctx.arcTo(x,y,x+radius,y,radius);*/

            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
            ctx.restore(); // restore context to what it was on entry
        };


        this.newcloud = function (ctx, x, y, width, height, radius, linewidth, fill, stroke, fillcolor, strokecolor) {

            if(width == 0 || height == 0){
                return;
            }

            if (width <= 0 || height <= 0) {
                if (width < 0) {
                    x += width;
                    width = Math.abs(width);

                }
                if (height < 0) {
                    y += height;
                    height = Math.abs(height);
                }
                //return;
            }

            var diameter = radius * 2;
            var numdiamh = Math.floor(width / diameter);
            var numdiamv = Math.floor(height / diameter);
            var diamwidth = diameter * numdiamh;
            var diamheight = diameter * numdiamv;
            var doscale = false;
            var xscale = 1;
            var yscale = 1;


            var lNumX = 8;
            var dRadX = width / lNumX;
            var lNumY = height / dRadX;

            if (lNumY < 6) {
                dRadX = height / 6;
                lNumY = 6;
                lNumX = width / dRadX;
            }
            var dRadY = height / lNumY;

            //var nArcsX = lNumX/2;
            //var nArcsY = lNumY/2 - 1;


            var localradiusx = dRadX;
            var diameterx = localradiusx * 2;
            var localradiusy = dRadY;
            var diametery = localradiusy * 2;

            numdiamh = Math.floor(width / diameterx);
            var doublediamh = (width / diameterx);
            numdiamv = Math.floor(height / diameterx);
            var doublediamv = (height / diameterx);


            /*if(width > 0){
             }else{
             numdiamh = 1;
             doublediamh = 1;
             }
             if(height > 0){

             }else{
             numdiamv = 1;
             doublediamv = 1;
             }*/


            var doublediamwidth = diameterx * doublediamh;
            var doublediamheight = diameterx * doublediamv;

            diamwidth = diameterx * numdiamh;
            diamheight = diameterx * numdiamv;


            ctx.save(); // save the context so we don't mess up others

            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;
            ctx.lineWidth = linewidth;


            if (markupobject.rotation != 0) {
                var tx = x + (width / 2);
                var ty = y + (height / 2);
                ctx.translate(tx, ty);
                ctx.rotate(markupobject.rotation);
                ctx.translate(-tx, -ty);
            }

            if (width > diamwidth) {
                xscale = width / diamwidth;
                doscale = true;
            }

            if (height > diamheight) {
                yscale = height / diamheight;
                doscale = true;
            }
            if (doscale) {
                ctx.translate(x, y);
                ctx.scale(xscale, yscale);
                ctx.translate(-x, -y);
            }


            ctx.beginPath();

            //ctx.moveTo(x+localradiusx,y+diametery);

            //upper left bubble
            ctx.arc(x + localradiusx, y + localradiusx, localradiusx, (0.5 * Math.PI), 0, false);
            //if (numdiamh > 2){
            for (var i = 2; i < numdiamh; i++) {
                var vertoffsett = x + localradiusx + (diameterx * (i - 1));
                ctx.arc(vertoffsett, y + localradiusx, localradiusx, Math.PI, 0, false);
            }
            //}
            //upper right bubble
            ctx.arc(x + diamwidth - localradiusx, y + localradiusx, localradiusx, Math.PI, (0.5 * Math.PI), false);

            //if (numdiamv > 2){
            for (i = 2; i < numdiamv; i++) {

                var horoffsetr = y + localradiusx + (diameterx * (i - 1));
                ctx.arc(x + diamwidth - localradiusx, horoffsetr, localradiusx, 1.5 * Math.PI, 0.5 * Math.PI, false);
            }

            //}

            //lower right bubble

            ctx.arc(x + diamwidth - localradiusx, y + diamheight - localradiusx, localradiusx, (1.5 * Math.PI), Math.PI, false);

            //if (numdiamh > 2){
            for (i = numdiamh - 1; i > 1; i--) {
                var vertoffsetb = x + localradiusx + (diameterx * (i - 1));

                ctx.arc(vertoffsetb, y + diamheight - localradiusx, localradiusx, 0, Math.PI, false);
            }
            //}


            //lower left bubble

            ctx.arc(x + localradiusx, y + diamheight - localradiusx, localradiusx, 0, (1.5 * Math.PI), false);
            //if (numdiamv > 2){
            for (i = numdiamv - 1; i > 1; i--) {

                var horoffsetl = y + localradiusx + (diameterx * (i - 1));
                ctx.arc(x + localradiusx, horoffsetl, localradiusx, 0.5 * Math.PI, 1.5 * Math.PI, false);
            }

            //}


            /*if (width<diameter*2 && height<diameter*2){
             //draw a circle until width > radius and height > radius
             ctx.arc(x+radius, y+radius, width/2, 0 , 2 * Math.PI, false);
             //ArcToPolyline( x1+nPosX*dRadX, y1 + dRadY, dRadX, dRadY, 90, 270, 0, pDestPnts, &lPoints );
             }else{

             }*/
            //ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
            ctx.restore(); // restore context to what it was on entry

        };
        this.cloud = function (ctx, x, y, width, height, radius, linewidth, fill, stroke, fillcolor, strokecolor) {
            var diameter = radius * 2;
            var numdiamh = Math.floor(width / diameter);
            var numdiamv = Math.floor(height / diameter);
            var diamwidth = diameter * numdiamh;
            var diamheight = diameter * numdiamv;


            ctx.save(); // save the context so we don't mess up others

            ctx.strokeStyle = strokecolor;
            ctx.fillStyle = fillcolor;
            ctx.lineWidth = linewidth;


            if (markupobject.rotation != 0) {
                var tx = x + (width / 2);
                var ty = y + (height / 2);
                ctx.translate(tx, ty);
                ctx.rotate(markupobject.rotation);
                ctx.translate(-tx, -ty);
            }


            ctx.beginPath();
            if (width < diameter * 2 && height < diameter * 2) {
                //draw a circle until width > radius and height > radius
                ctx.arc(x + radius, y + radius, width / 2, 0, 2 * Math.PI, false);
            } else {

                ctx.moveTo(x + radius, y + diameter);

                //upper left bubble
                ctx.arc(x + radius, y + radius, radius, (0.5 * Math.PI), 0, false);
                if (numdiamh > 2) {
                    for (var i = 2; i < numdiamh; i++) {
                        var vertoffsett = x + radius + diameter * (i - 1);
                        ctx.arc(vertoffsett, y + radius, radius, Math.PI, 0, false);
                    }
                }
                //upper right bubble
                ctx.arc(x + diamwidth - radius, y + radius, radius, Math.PI, (0.5 * Math.PI), false);

                if (numdiamv > 2) {
                    for (i = 2; i < numdiamv; i++) {
                        var horoffsetr = y + radius + diameter * (i - 1);
                        ctx.arc(x + diamwidth - radius, horoffsetr, radius, 1.5 * Math.PI, 0.5 * Math.PI, false);
                    }

                }

                //lower right bubble

                ctx.arc(x + diamwidth - radius, y + diamheight - radius, radius, (1.5 * Math.PI), Math.PI, false);

                if (numdiamh > 2) {
                    for (i = numdiamh - 1; i > 1; i--) {
                        var vertoffsetb = x + radius + (diameter * (i - 1));
                        ctx.arc(vertoffsetb, y + diamheight - radius, radius, 0, Math.PI, false);
                    }
                }


                //lower left bubble

                ctx.arc(x + radius, y + diamheight - radius, radius, 0, (1.5 * Math.PI), false);
                if (numdiamv > 2) {
                    for (i = numdiamv - 1; i > 1; i--) {
                        var horoffsetl = y + radius + (diameter * (i - 1));
                        ctx.arc(x + radius, horoffsetl, radius, 0.5 * Math.PI, 1.5 * Math.PI, false);
                    }

                }


            }
            //ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
            ctx.restore(); // restore context to what it was on entry
        };

        this.editpolygon = function (ctx, scalefactor) {
            var counter = 0;
            ctx.save();
            ctx.strokeStyle = "red";


            ctx.fillStyle = "white";
            ctx.lineWidth = 1;
            //ctx.beginPath();
            //ctx.moveTo(this.points[0].x, this.points[0].y);
            var xscaled = 0.0;
            var yscaled = 0.0;


            for (counter = 0; counter < markupobject.points.length; counter++) {

                xscaled = (this.points[counter].x - this.xoffset) * scalefactor;
                yscaled = (this.points[counter].y - this.yoffset) * scalefactor;

                if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                    xscaled += DocObj.pages[DocObj.currentpage].dxvector;
                    yscaled += DocObj.pages[DocObj.currentpage].dyvector;
                } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                    xscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                    yscaled += DocObj.pages[DocObj.currentpage].dypdf;

                } else {
                    xscaled = xscaled + DocObj.pages[DocObj.currentpage].dx;
                    yscaled = yscaled + DocObj.pages[DocObj.currentpage].dy;

                }

                var bpolyline = (this.type == 1 && (this.subtype == 1 || this.subtype == 3));
                var blastpoint = (counter == markupobject.points.length - 1);
                var bnonextpoint = (markupobject.editcurpoint + 1 > markupobject.points.length - 1);
                var bmarkfirstpoint = (!bpolyline && bnonextpoint && counter == 0);
                var bpolylinelastpoint = (bpolyline && bnonextpoint);

                if(markupobject.bpointEdit && (markupobject.editcurpoint == counter || markupobject.editcurpoint + 1 == counter || bmarkfirstpoint) && !bpolylinelastpoint){
                    ctx.save();
                    ctx.fillStyle = "blue";
                    ctx.lineWidth = 2;
                    ctx.fillRect(xscaled - 5, yscaled - 5, 10, 10);
                    ctx.strokeRect(xscaled - 5, yscaled - 5, 10, 10);
                    ctx.restore();
                }else{
                    ctx.fillRect(xscaled - 5, yscaled - 5, 10, 10);
                    ctx.strokeRect(xscaled - 5, yscaled - 5, 10, 10);

                }
            }
            //ctx.closePath();
            //markupobject
            ctx.restore();

        };


        this.selectLabel = function(ctx, x, y, width, height, full, rotate){
            var halfmarker = markersize / 2;

            ctx.save(); // save the context so we don't mess up others
            ctx.strokeStyle = "blue";
            ctx.fillStyle = "white";
            ctx.lineWidth = 1;
            ctx.beginPath();

            var tx = x + ((width - x) / 2);
            var ty = y + ((height - y) / 2);

            //var centerx = width - (x / 2);
            //var centery = height - (y / 2);
            ctx.arc(tx, ty, halfmarker, 0, Math.PI * 2, false);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();


            ctx.restore(); // restore context to what it was on entry


        };

        this.select = function (ctx, x, y, width, height, full, rotate) {

            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);
            var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
            var rotRad360 = 360 * (Math.PI / 180);
            var halfmarker = markersize / 2;

            var pointul = new point();
            var pointlr = new point();
            pointul.x = x;
            pointul.y = y;
            pointlr.x = width;
            pointlr.y = height;

            var tx = x + ((width - x) / 2);
            var ty = y + ((height - y) / 2);


            if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                pointul = markupobject.getRotatedMarkup(centercanvX, centercanvY, x, y, CanvRotRad);
                pointlr = markupobject.getRotatedMarkup(centercanvX, centercanvY, width, height, CanvRotRad);
            }


            ctx.save(); // save the context so we don't mess up others
            if (full) {
                //if text created on rotated canvas

                if (markupobject.textrotate != 0 && markupobject.type == 9 && markupobject.subtype == 0) {

                    ctx.translate(x, y);
                    ctx.rotate(markupobject.textrotate);
                    ctx.translate(-x, -y);

                }

                //find center
                if (markupobject.rotation != 0) {
                    //var tx = x+(width/2);
                    //var ty = y+(height/2);

                    ctx.translate(tx, ty);
                    ctx.rotate(markupobject.rotation);
                    ctx.translate(-tx, -ty);

                    if (markupobject.type == 9 && markupobject.subtype == 0) {

                        ty = y - ((y - height) / 2);

                        var negheightcenter = (height - y) / 2;

                        if (markupobject.textrotate != 0) {
                            var lrrotpoint = markupobject.getMarkupSelectPointRot(((width - x) / 2), (-(height - y) / 2), markupobject.rotation);
                            var tulrotpoint = markupobject.getMarkupSelectPointRot(lrrotpoint.x, lrrotpoint.y, markupobject.textrotate);
                            var rmrkcenter = markupobject.getMarkupSelectPointRot((width - x) / 2, negheightcenter, markupobject.textrotate);
                            tx = x + rmrkcenter.x;
                            ty = y + rmrkcenter.y;

                            this.LowerRightRectRot.x = tx + tulrotpoint.x - halfmarker;
                            this.LowerRightRectRot.y = ty + tulrotpoint.y - halfmarker;
                            this.LowerRightRectRot.w = tx + tulrotpoint.x + halfmarker;
                            this.LowerRightRectRot.h = ty + tulrotpoint.y + halfmarker;


                        } else {
                            var ulrotpoint = markupobject.getMarkupSelectPointRot(-((width - x) / 2), -(-((height - y) / 2)), markupobject.rotation);
                            this.UpperLeftRectRot.x = tx + ulrotpoint.x - halfmarker;
                            this.UpperLeftRectRot.y = ty + ulrotpoint.y - halfmarker;
                            this.UpperLeftRectRot.w = tx + ulrotpoint.x + halfmarker;
                            this.UpperLeftRectRot.h = ty + ulrotpoint.y + halfmarker;

                            lrrotpoint = markupobject.getMarkupSelectPointRot(((width - x) / 2), (-(height - y) / 2), markupobject.rotation);
                            this.LowerRightRectRot.x = tx + lrrotpoint.x - halfmarker;
                            this.LowerRightRectRot.y = ty + lrrotpoint.y - halfmarker;
                            this.LowerRightRectRot.w = tx + lrrotpoint.x + halfmarker;
                            this.LowerRightRectRot.h = ty + lrrotpoint.y + halfmarker;

                        }

                    } else {
                        ulrotpoint = markupobject.getMarkupSelectPointRot(-((width - x) / 2), -((height - y) / 2), markupobject.rotation);
                        this.UpperLeftRectRot.x = tx + ulrotpoint.x - halfmarker;
                        this.UpperLeftRectRot.y = ty + ulrotpoint.y - halfmarker;
                        this.UpperLeftRectRot.w = tx + ulrotpoint.x + halfmarker;
                        this.UpperLeftRectRot.h = ty + ulrotpoint.y + halfmarker;

                        lrrotpoint = markupobject.getMarkupSelectPointRot(((width - x) / 2), ((height - y) / 2), markupobject.rotation);
                        this.LowerRightRectRot.x = tx + lrrotpoint.x - halfmarker;
                        this.LowerRightRectRot.y = ty + lrrotpoint.y - halfmarker;
                        this.LowerRightRectRot.w = tx + lrrotpoint.x + halfmarker;
                        this.LowerRightRectRot.h = ty + lrrotpoint.y + halfmarker;

                        var llrotpoint = markupobject.getMarkupSelectPointRot(-((width - x) / 2), ((height - y) / 2), markupobject.rotation);
                        this.LowerLeftRectRot.x = tx + llrotpoint.x - halfmarker;
                        this.LowerLeftRectRot.y = ty + llrotpoint.y - halfmarker;
                        this.LowerLeftRectRot.w = tx + llrotpoint.x + halfmarker;
                        this.LowerLeftRectRot.h = ty + llrotpoint.y + halfmarker;

                        var urrotpoint = markupobject.getMarkupSelectPointRot(((width - x) / 2), -((height - y) / 2), markupobject.rotation);
                        this.UpperRightRectRot.x = tx + urrotpoint.x - halfmarker;
                        this.UpperRightRectRot.y = ty + urrotpoint.y - halfmarker;
                        this.UpperRightRectRot.w = tx + urrotpoint.x + halfmarker;
                        this.UpperRightRectRot.h = ty + urrotpoint.y + halfmarker;
                    }
                    if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                        var ULrotpointul = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.UpperLeftRectRot.x, this.UpperLeftRectRot.y, CanvRotRad);
                        var ULrotpointlr = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.UpperLeftRectRot.w, this.UpperLeftRectRot.h, CanvRotRad);
                        this.UpperLeftRectRot.x = Math.min(ULrotpointul.x, ULrotpointlr.x);
                        this.UpperLeftRectRot.y = Math.min(ULrotpointul.y, ULrotpointlr.y);
                        this.UpperLeftRectRot.w = Math.max(ULrotpointul.x, ULrotpointlr.x);
                        this.UpperLeftRectRot.h = Math.max(ULrotpointul.y, ULrotpointlr.y);


                        var URrotpointul = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.UpperRightRectRot.x, this.UpperRightRectRot.y, CanvRotRad);
                        var URrotpointlr = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.UpperRightRectRot.w, this.UpperRightRectRot.h, CanvRotRad);
                        this.UpperRightRectRot.x = Math.min(URrotpointul.x, URrotpointlr.x);
                        this.UpperRightRectRot.y = Math.min(URrotpointul.y, URrotpointlr.y);
                        this.UpperRightRectRot.w = Math.max(URrotpointul.x, URrotpointlr.x);
                        this.UpperRightRectRot.h = Math.max(URrotpointul.y, URrotpointlr.y);

                        var LLrotpointul = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.LowerLeftRectRot.x, this.LowerLeftRectRot.y, CanvRotRad);
                        var LLrotpointlr = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.LowerLeftRectRot.w, this.LowerLeftRectRot.h, CanvRotRad);
                        this.LowerLeftRectRot.x = Math.min(LLrotpointul.x, LLrotpointlr.x);
                        this.LowerLeftRectRot.y = Math.min(LLrotpointul.y, LLrotpointlr.y);
                        this.LowerLeftRectRot.w = Math.max(LLrotpointul.x, LLrotpointlr.x);
                        this.LowerLeftRectRot.h = Math.max(LLrotpointul.y, LLrotpointlr.y);

                        var LRrotpointul = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.LowerRightRectRot.x, this.LowerRightRectRot.y, CanvRotRad);
                        var LRrotpointlr = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.LowerRightRectRot.w, this.LowerRightRectRot.h, CanvRotRad);
                        this.LowerRightRectRot.x = Math.min(LRrotpointul.x, LRrotpointlr.x);
                        this.LowerRightRectRot.y = Math.min(LRrotpointul.y, LRrotpointlr.y);
                        this.LowerRightRectRot.w = Math.max(LRrotpointul.x, LRrotpointlr.x);
                        this.LowerRightRectRot.h = Math.max(LRrotpointul.y, LRrotpointlr.y);


                    }

                    if (rotate) {
                        if (markupobject.type == 9 && markupobject.subtype == 0) {
                            if (markupobject.textrotate == 0) {
                                var rmrotpoint = markupobject.getMarkupSelectPointRot(0, -(-(negheightcenter - 20)), markupobject.rotation);
                            } else {

                                rmrotpoint = markupobject.getMarkupSelectPointRot(0, -(-(negheightcenter - 20)), markupobject.rotation);
                                rmrotpoint = markupobject.getMarkupSelectPointRot(rmrotpoint.x, rmrotpoint.y, markupobject.textrotate);
                                var rmcenter = markupobject.getMarkupSelectPointRot((width - x) / 2, negheightcenter, markupobject.textrotate);
                                var xyrot = markupobject.getMarkupSelectPointRot((width - x) / 2, negheightcenter, markupobject.rotation);


                                tx = x + rmcenter.x;
                                ty = y + rmcenter.y;


                            }

                        } else {
                            rmrotpoint = markupobject.getMarkupSelectPointRot(0, -(((height - y) / 2) + 20), markupobject.rotation);
                        }
                        this.RotmarkerRectRot.x = tx + rmrotpoint.x - halfmarker;
                        this.RotmarkerRectRot.y = ty + rmrotpoint.y - halfmarker;
                        this.RotmarkerRectRot.w = tx + rmrotpoint.x + halfmarker;
                        this.RotmarkerRectRot.h = ty + rmrotpoint.y + halfmarker;

                        if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                            var rotrotpointul = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.RotmarkerRectRot.x, this.RotmarkerRectRot.y, CanvRotRad);
                            var rotrotpointlr = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.RotmarkerRectRot.w, this.RotmarkerRectRot.h, CanvRotRad);
                            this.RotmarkerRectRot.x = Math.min(rotrotpointul.x, rotrotpointlr.x);
                            this.RotmarkerRectRot.y = Math.min(rotrotpointul.y, rotrotpointlr.y);
                            this.RotmarkerRectRot.w = Math.max(rotrotpointul.x, rotrotpointlr.x);
                            this.RotmarkerRectRot.h = Math.max(rotrotpointul.y, rotrotpointlr.y);
                        }


                    }


                }

                if (markupobject.type == 9 && markupobject.subtype == 0) {
                    if (markupobject.textrotate == 0) {
                        //markupobject.textrotate
                        this.LowerLeftRect.x = x - halfmarker;
                        this.LowerLeftRect.y = y - halfmarker;
                        this.LowerLeftRect.w = x + halfmarker;
                        this.LowerLeftRect.h = y + halfmarker;

                        this.LowerRightRect.x = width - halfmarker;
                        this.LowerRightRect.y = y - halfmarker;
                        this.LowerRightRect.w = width + halfmarker;
                        this.LowerRightRect.h = y + halfmarker;

                        this.UpperRightRect.x = width - halfmarker;
                        this.UpperRightRect.y = height - halfmarker;
                        this.UpperRightRect.w = width + halfmarker;
                        this.UpperRightRect.h = height + halfmarker;

                        this.UpperLeftRect.x = x - halfmarker;
                        this.UpperLeftRect.y = height - halfmarker;
                        this.UpperLeftRect.w = x + halfmarker;
                        this.UpperLeftRect.h = height + halfmarker;

                    } else {
                        lrrotpoint = markupobject.getMarkupSelectPointRot((width - x), 0, markupobject.textrotate);
                        this.LowerRightRect.x = x + lrrotpoint.x - halfmarker;
                        this.LowerRightRect.y = y + lrrotpoint.y - halfmarker;
                        this.LowerRightRect.w = x + lrrotpoint.x + halfmarker;
                        this.LowerRightRect.h = y + lrrotpoint.y + halfmarker;
                        if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                            //lrrotpoint = markupobject.getMarkupSelectPointRot((this.rotatedrect.w-this.rotatedrect.x), 0,markupobject.textrotate);
                            this.LowerRightRect.x = this.rotatedrect.w - halfmarker;
                            this.LowerRightRect.y = this.rotatedrect.y - halfmarker;
                            this.LowerRightRect.w = this.rotatedrect.w + halfmarker;
                            this.LowerRightRect.h = this.rotatedrect.y + halfmarker;

                        }

                    }


                } else {
                    this.UpperLeftRect.x = pointul.x - halfmarker;
                    this.UpperLeftRect.y = pointul.y - halfmarker;
                    this.UpperLeftRect.w = pointul.x + halfmarker;
                    this.UpperLeftRect.h = pointul.y + halfmarker;

                    this.LowerLeftRect.x = pointul.x - halfmarker;
                    this.LowerLeftRect.y = pointlr.y - halfmarker;
                    this.LowerLeftRect.w = pointul.x + halfmarker;
                    this.LowerLeftRect.h = pointlr.y + halfmarker;

                    this.UpperRightRect.x = pointlr.x - halfmarker;
                    this.UpperRightRect.y = pointul.y - halfmarker;
                    this.UpperRightRect.w = pointlr.x + halfmarker;
                    this.UpperRightRect.h = pointul.y + halfmarker;

                    this.LowerRightRect.x = pointlr.x - halfmarker;
                    this.LowerRightRect.y = pointlr.y - halfmarker;
                    this.LowerRightRect.w = pointlr.x + halfmarker;
                    this.LowerRightRect.h = pointlr.y + halfmarker;

                }
                ctx.strokeStyle = "blue";
                ctx.fillStyle = "white";
                ctx.lineWidth = 1;

                if(markupobject.type != 10){

                    ctx.beginPath();
                    ctx.arc(x, y, halfmarker, 0, Math.PI * 2, false);
                    //ctx.closePath();

                    //ctx.fill();
                    //ctx.stroke();
                    //ctx.beginPath();
                    ctx.moveTo(x+halfmarker,height);
                    ctx.arc(x, height, halfmarker, 0, Math.PI * 2, false);


                    //ctx.closePath();
                    //ctx.fill();
                    //ctx.stroke();

                    //ctx.beginPath();
                    ctx.moveTo(width+halfmarker,y);
                    ctx.arc(width, y, halfmarker, 0, Math.PI * 2, false);
                    //ctx.closePath();
                    //ctx.fill();
                    //ctx.stroke();
                    ctx.moveTo(width+halfmarker,height);
                    //ctx.beginPath();
                    ctx.arc(width, height, halfmarker, 0, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                }


                ctx.strokeStyle = "red";
                ctx.strokeRect(((x + width) / 2) - 3, y - 3, 6, 6);
                ctx.strokeRect(x - 3, ((height + y) / 2) - 3, 6, 6);
                ctx.strokeRect(width - 3, ((height + y) / 2) - 3, 6, 6);
                ctx.strokeRect(((width + x) / 2) - 3, height - 3, 6, 6);
                if (rotate) {
                    if (markupobject.type == 9 && markupobject.subtype == 0) {
                        ctx.beginPath();
                        ctx.moveTo((x + width) / 2, height - 3);
                        ctx.lineTo((x + width) / 2, height - 15);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.strokeStyle = "blue";
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc((x + width) / 2, height - 20, halfmarker, 0, Math.PI * 2, false);
                        ctx.stroke();
                        if (markupobject.textrotate == 0) {
                            this.RotmarkerRect.x = ((x + width) / 2) - halfmarker;
                            this.RotmarkerRect.y = (height - 20) - halfmarker;
                            this.RotmarkerRect.w = ((x + width) / 2) + halfmarker;
                            this.RotmarkerRect.h = (height - 20) + halfmarker;
                        } else {
                            rmrotpoint = markupobject.getMarkupSelectPointRot((width - x) / 2, -((y - (height)) + 20), markupobject.textrotate);
                            this.RotmarkerRect.x = x + rmrotpoint.x - halfmarker;
                            this.RotmarkerRect.y = y + rmrotpoint.y - halfmarker;
                            this.RotmarkerRect.w = x + rmrotpoint.x + halfmarker;
                            this.RotmarkerRect.h = y + rmrotpoint.y + halfmarker;

                        }
                    } else {
                        ctx.beginPath();
                        ctx.moveTo((x + width) / 2, y - 3);
                        ctx.lineTo((x + width) / 2, y - 15);
                        ctx.closePath();
                        ctx.stroke();
                        ctx.strokeStyle = "blue";
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.arc((x + width) / 2, y - 20, halfmarker, 0, Math.PI * 2, false);
                        ctx.fill();
                        ctx.stroke();

                        this.RotmarkerRect.x = ((x + width) / 2) - halfmarker;
                        this.RotmarkerRect.y = (y - 20) - halfmarker;
                        this.RotmarkerRect.w = ((x + width) / 2) + halfmarker;
                        this.RotmarkerRect.h = (y - 20) + halfmarker;

                    }
                    if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                        var rotpointul = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.RotmarkerRect.x, this.RotmarkerRect.y, CanvRotRad);
                        var rotpointlr = markupobject.getRotatedMarkup(centercanvX, centercanvY, this.RotmarkerRect.w, this.RotmarkerRect.h, CanvRotRad);
                        this.RotmarkerRect.x = Math.min(rotpointul.x, rotpointlr.x);
                        this.RotmarkerRect.y = Math.min(rotpointul.y, rotpointlr.y);
                        this.RotmarkerRect.w = Math.max(rotpointul.x, rotpointlr.x);
                        this.RotmarkerRect.h = Math.max(rotpointul.y, rotpointlr.y);
                    }


                }
                //find center
                /*var centerx = (x+width)/2;
                 var centery = (y+height)/2;
                 //draw circle in center
                 ctx.strokeStyle = "blue";
                 ctx.lineWidth = 1;
                 ctx.beginPath();
                 ctx.arc(centerx, centery, 5, 0, Math.PI * 2,false);
                 ctx.closePath();
                 ctx.stroke();*/


            } else {
                ctx.strokeStyle = "blue";
                ctx.fillStyle = "white";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(x, y, halfmarker, 0, Math.PI * 2, false);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                var btextboxleader = (this.type == 6 && this.subtype == 6);
                if(!btextboxleader){
                    ctx.beginPath();
                    ctx.arc(width, height, halfmarker, 0, Math.PI * 2, false);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.fill();
                }
            }

            ctx.restore(); // restore context to what it was on entry
        };


        this.setAnglelengthPoints = function(length, angle){

            var point = markupobject.points.length - 2;
            return markupobject.setAngleLengthinternalPoints(length, angle, true, point);
        };

        this.setWidthHeight = function(w,h){

            var scalewidth = w * markupobject.scaling;
            var scaleheight = h * markupobject.scaling;

            var widthvalue = getScreenDim(scalewidth);
            var heighthvalue = getScreenDim(scaleheight);

            var x2 = widthvalue;
            var y2 = heighthvalue;

            return {w : x2, h : y2};

        };

        this.setWidthHeightEdit = function(w,h){
            return markupobject.setWidthHeight(w,h);
        };

        this.setAnglelength = function(length, angle, type){
            //(x2, y2) = (x1 + l * cos(a),y1 + l * sin(a));

            return markupobject.setAngleLengthinternal(length, angle, type, true);

        };

        this.setAngleLenghtEdit = function(length, angle, type){
            return markupobject.setAngleLengthinternal(length, angle, type, false);
        };

        this.setAngleLengthPointsEdit = function(length, angle){

            var point = markupobject.editcurpoint;
            markupobject.bpointEdit = true;

            return markupobject.setAngleLengthinternalPoints(length, angle, false, point);
        };

        this.setAngleLengthinternalPoints = function(length, angle, brotate, point){

            var bpointexist = (point >= 0 && point <= this.points.length - 1);

            if(!bpointexist){
                return;
            }

            var bpolyline = (this.type == 1 && (this.subtype == 1 || this.subtype == 3));

            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);
            var CanvRotRad = (360 - DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
            var CanvRotRadOrig = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

            if(angle > 0){
                angle *= -1;
            }else{
                angle = 360 - angle;
            }

            if (!brotate){
                //add page rotation to draw angle.
                angle += (360 - DocObj.pages[DocObj.currentpage].drotation);
                if (angle > 360){
                    angle -= 360;
                }
            }

            var scalelength = length * markupobject.scaling;

            var linewidthvalue = getScreenDim(scalelength);

            var lineangle = angle * (Math.PI / 180);

            var origx = markupobject.points[0].x;
            var origy = markupobject.points[0].y;


            //use points
            var x2 = markupobject.points[point].x + (linewidthvalue * Math.cos(lineangle));
            var y2 = markupobject.points[point].y + (linewidthvalue * Math.sin(lineangle));


            markupobject.bUsemouseinput = false;

            if (DocObj.pages[DocObj.currentpage].drotation != 0 && brotate){

                //use points
                var transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, markupobject.points[point].x, markupobject.points[point].y, CanvRotRad);
                markupobject.points[point].x = transpoint.x;
                markupobject.points[point].y = transpoint.y;

                //use points
                transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, x2, y2, CanvRotRad);
                x2 = transpoint.x;
                y2 = transpoint.y;

                //add document page rotation to markup rotation here.
            }

            if (point == markupobject.points.length - 1){

                markupobject.editcurpoint = 0;

                if (bpolyline){
                    x2 = origx;
                    y2 = origy;
                }
            }else{
                markupobject.editcurpoint = point + 1;

            }

            return {w : x2, h : y2, p : markupobject.editcurpoint};


        };

        this.setAngleLengthinternal = function(length, angle, type, brotate){
            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);
            var CanvRotRad = (360 - DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);
            var CanvRotRadOrig = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

            if(angle > 0){
                angle *= -1;
            }else{
                angle = 360 - angle;
            }

            if (!brotate){
                //add page rotation to draw angle.
                angle += (360 - DocObj.pages[DocObj.currentpage].drotation);
                if (angle > 360){
                    angle -= 360;
                }
            }

            var scalelength = length * markupobject.scaling;

            var linewidthvalue = getScreenDim(scalelength, type);

            var lineangle = angle * (Math.PI / 180);

            var x2 = this.x + (linewidthvalue * Math.cos(lineangle));
            var y2 = this.y + (linewidthvalue * Math.sin(lineangle));

            //this.AdjustForRotation(false);

            markupobject.bUsemouseinput = false;

            if (DocObj.pages[DocObj.currentpage].drotation != 0 && brotate){


                var transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, this.x, this.y, CanvRotRad);
                this.x = transpoint.x;
                this.y = transpoint.y;

                transpoint = markupobject.setinitRotatedMarkupPoint(centercanvX, centercanvY, x2, y2, CanvRotRad);
                x2 = transpoint.x;
                y2 = transpoint.y;

                //add document page rotation to markup rotation here.
            }

            return {w : x2, h : y2};
        };

        this.lengthangleCallbackSelect = function(){
            if (markupobject.anglelengthsupport){
                markupobject.lengthangleCallback(this.x, this.y, this.w, this.h, DocObj.pages[DocObj.currentpage].drotation);
            }
            if(markupobject.setRadiusSupport){
                markupobject.radiusCallback(this.x, this.y, this.w, this.h,true);
            }

            if(markupobject.setPointSupport){
                markupobject.lengthangleCallbackPointSelect();
            }
            if(markupobject.widthHeightsupport){
                markupobject.widthHeightCallback(this.w, this.h);
            }

        };

        this.lengthangleCallbackPointSelect = function(){
            if(this.points.length < 2){
                return;
            }

            var drotation = DocObj.pages[DocObj.currentpage].drotation;

            if (markupobject.editcurpoint == 0){

                //var curpoint = 0;
                var prevpoint = markupobject.points.length - 1;
                //markupobject.points.length - 1
                //x2 = origx;
                //y2 = origy;
            }else{
                //markupobject.editcurpoint = point + 1;
                prevpoint = markupobject.editcurpoint - 1;
            }


            if (markupobject.editcurpoint == markupobject.points.length - 1){
                var nextpoint = 0;
            }else{
                nextpoint = markupobject.editcurpoint + 1;
            }

            var x = this.points[markupobject.editcurpoint].x;
            var y = this.points[markupobject.editcurpoint].y;

            var w = this.points[nextpoint].x;
            var h = this.points[nextpoint].y;


            //var x = this.points[prevpoint].x;
            //var y = this.points[prevpoint].y;

            //var w = this.points[markupobject.editcurpoint].x;
            //var h = this.points[markupobject.editcurpoint].y;

            //var w = this.points[prevpoint].x;
            //var h = this.points[prevpoint].y;

            var lengthangle = markupobject.anglelength(x, y, w, h, false);


            lengthangle.length = getUnitlength(lengthangle.length / markupobject.scaling);

            if (RxCore_GUI_markupdrawParams != undefined){
                if(!markupobject.bUsemouseinput){
                    lengthangle.angle -= drotation;
                }
                RxCore_GUI_markupdrawParams.onDrawEvent(lengthangle);
            }

        };


        this.lengthangleCallbackPoints = function(drotation){

            if(this.points.length < 2){
                return;
            }

            var x = this.points[this.points.length - 2].x;
            var y = this.points[this.points.length - 2].y;
            var w = this.points[this.points.length - 1].x;
            var h = this.points[this.points.length - 1].y;

            //var x = this.points[0].x;
            //var y = this.points[0].y;
            //var w = this.points[1].x;
            //var h = this.points[1].y;


            var lengthangle = markupobject.anglelength(x, y, w, h, false);


            lengthangle.length = getUnitlength(lengthangle.length / markupobject.scaling);

            if (RxCore_GUI_markupdrawParams != undefined){
                if(!markupobject.bUsemouseinput){
                    lengthangle.angle -= drotation;
                }
                RxCore_GUI_markupdrawParams.onDrawEvent(lengthangle);
            }


        };

        this.widthHeightCallback = function(w,h){
            var lengthangle = {width : w,height : h};

            lengthangle.width = getUnitlength(w / markupobject.scaling);
            lengthangle.height = getUnitlength(h / markupobject.scaling);

            if (RxCore_GUI_markupdrawParams != undefined){
                RxCore_GUI_markupdrawParams.onDrawEvent(lengthangle);
            }

        };

        this.lengthangleCallback = function(x,y, w, h, drotation){
            var lengthangle = markupobject.anglelength(x, y, w, h, false);
            lengthangle.length = getUnitlength(lengthangle.length / markupobject.scaling);

            if (RxCore_GUI_markupdrawParams != undefined){
                if(!markupobject.bUsemouseinput){
                    lengthangle.angle -= drotation;
                }
                RxCore_GUI_markupdrawParams.onDrawEvent(lengthangle);
            }


        };

        this.radiusCallback = function(x,y, w, h, useabs){
            var lengthangle = markupobject.anglelength(x, y, w, h, useabs);

            lengthangle.length = getUnitlength(lengthangle.length / markupobject.scaling);
            if (RxCore_GUI_markupdrawParams != undefined){
                RxCore_GUI_markupdrawParams.onDrawEvent(lengthangle);

            }


        };

        this.anglelength = function (startx, starty, endx, endy, useabs) {

            var width = 0;
            var height = 0;

            width = Math.abs(endx - startx);
            height = Math.abs(endy - starty);

            var dimwsq = Math.pow(width, 2);
            var dimhsq = Math.pow(height, 2);
            var dimdiag = Math.sqrt((dimwsq + dimhsq));

            if (useabs) {
                width = Math.abs(endx - startx);
                height = Math.abs(endy - starty);
            } else {
                width = endx - startx;
                height = endy - starty;
            }

            var lineangle = Math.atan2(height, width) * (180 / Math.PI);

            if(lineangle < 0){
                lineangle *= -1;
            }else{
                lineangle = 360 - lineangle;
            }

            return {
                length : dimdiag,
                angle : lineangle
            };

        };


        this.drawme = function (ctx) {

            var scalefactor = DocObj.pages[DocObj.currentpage].dscale; // markupobject.scaling;


            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector; // markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {

                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf); // markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale; // markupobject.scaling;
                if (DocObj.Type == 0) {
                    scalefactor = DocObj.pages[0].dscale; // markupobject.scaling;
                }

            }

            markupobject.fixedscaleFactor =  scalefactor / DocObj.pages[DocObj.currentpage].fixedScale;

            if(bUseFixedScale){
                var linewidthlocal = this.linewidth * markupobject.fixedscaleFactor;
            }else{
                linewidthlocal = this.linewidth;
            }

            if(bUseFixedScale){
                var arrowlengthlocal = this.arrowlength * markupobject.fixedscaleFactor;
            }else{
                arrowlengthlocal = this.arrowlength;
            }


            /*if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                var txcanv = (canvasowidth / 2);
                var tycanv = (canvasoheight / 2);
                ctx.save();
                ctx.translate(txcanv, tycanv);
                ctx.rotate((360 - DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180));
                ctx.translate(-txcanv, -tycanv);

            }*/


            switch (this.type) {
                case 0: //pencil
                    ctx.save();
                    if (this.subtype == 1) {
                        if (DocObj.backgroundColor != undefined) {
                            ctx.strokeStyle = DocObj.backgroundColor;
                        } else {
                            ctx.strokeStyle = "white";
                        }

                        ctx.lineWidth = linewidthlocal * 10;

                    } else {
                        ctx.lineWidth = linewidthlocal;
                        ctx.strokeStyle = this.strokecolor;


                        this.GetLinestyle(markupobject.linestyle,ctx,1);


                    }

                    ctx.lineTo(this.points[this.points.length - 1].x, this.points[this.points.length -1].y);
                    ctx.stroke();
                    ctx.restore();

                    break;
                case 1: //polygon
                    /*switch (this.subtype){
                        case 3:
                            //markupobject.findrectangle();
                            break;

                    }*/
                    var coords = markupobject.setDimDrawme();
                    this.setlastpoint(coords.w, coords.h);


                    if(markupobject.bUsemouseinput){
                        this.AdjustForRotation(false);
                    }

                    markupobject.lengthangleCallbackPoints(DocObj.pages[DocObj.currentpage].drotation);


                    this.drawmescaled(ctx);

                    break;

                case 2:
                    switch (this.subtype) {
                        case 1:
                            markupobject.polycurves(ctx, markupobject.linewidth, markupobject.color, 1);
                            break;
                    }
                    break;
                case 3: //rectangle

                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;

                    this.AdjustForRotation(false);

                    markupobject.widthHeightCallback(this.w, this.h);

                    this.drawmescaled(ctx);

                    break;

                case 4: //oval

                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;

                    this.AdjustForRotation(false);

                    if (this.subtype == 1){
                        markupobject.radiusCallback(this.x, this.y, this.w, this.h, true);
                    }

                    this.drawmescaled(ctx);

                    break;
                case 5: //cloud//(ctx,x,y,width,height,radius,linewidth,fill,stroke,fillcolor,strokecolor)

                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;
                    this.AdjustForRotation(false);
                    this.drawmescaled(ctx);

                    break;
                case 6: //line, arrow

                    /*ctx.save();
                    markupobject.GetLinestyle(markupobject.linestyle,ctx,1);
                    var coords = markupobject.setDimDrawme();
                    markupobject.arrow(ctx, coords.x, coords.y, this.w, this.h, arrowlengthlocal, arrowangle, linewidthlocal, this.subtype, markupobject.strokecolor, markupobject.strokecolor);
                    ctx.restore();*/

                    if(bOrthoOn){
                        markupobject.calculateOrtho(false,0, {x : 0, y : 0});
                    }

                    var coords = markupobject.setDimDrawme();

                    if(!bOrthoOn){
                        this.w = coords.w;
                        this.h = coords.h;
                    }

                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;

                    if(markupobject.bUsemouseinput){
                        this.AdjustForRotation(false);
                    }

                    markupobject.lengthangleCallback(this.x, this.y, this.w, this.h, DocObj.pages[DocObj.currentpage].drotation);

                    /*var lengthangle = markupobject.anglelength(this.xscaled, this.yscaled, this.wscaled, this.hscaled, false);
                    lengthangle.length = getUnitlength(lengthangle.length / markupobject.scaling);

                    if (RxCore_GUI_markupdrawParams != undefined){
                        if(!markupobject.bUsemouseinput){
                            lengthangle.angle -= DocObj.pages[DocObj.currentpage].drotation;
                        }
                        RxCore_GUI_markupdrawParams.onDrawEvent(lengthangle);
                    }*/

                    this.drawmescaled(ctx);

                    break;
                case 7: //dimension line
                    if(bOrthoOn){
                        markupobject.calculateOrtho(false, 0, {x : 0, y : 0});
                    }

                    /*ctx.save();
                    markupobject.GetLinestyle(markupobject.linestyle,ctx,1);
                    var dimtype = this.subtype + 4;
                    var coords = markupobject.setDimDrawme();
                    markupobject.arrow(ctx, coords.x, coords.y, this.w, this.h, arrowlengthlocal, arrowangle, linewidthlocal, dimtype, markupobject.strokecolor, markupobject.strokecolor);
                    ctx.restore();
                    markupobject.setdimvalue(this.x, this.y, this.w, this.h);
                    if(bUseFixedScale){
                        var localscale = markupobject.fixedscaleFactor;
                    }else{
                        localscale = 1;
                    }

                    markupobject.dimvaluedraw(ctx, coords.x, coords.y, coords.w, coords.h, this.strokecolor, localscale,true);*/

                    var coords = markupobject.setDimDrawme();


                    this.w = coords.w;
                    this.h = coords.h;

                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;

                    if(markupobject.bUsemouseinput){
                        this.AdjustForRotation(false);
                    }

                    markupobject.lengthangleCallback(this.x, this.y, this.w, this.h, DocObj.pages[DocObj.currentpage].drotation);

                    this.drawmescaled(ctx);

                    break;
                case 8:
                    var coords = markupobject.setDimDrawme();
                    this.setlastpoint(coords.w, coords.h);

                    if(markupobject.bUsemouseinput){
                        this.AdjustForRotation(false);
                    }

                    markupobject.lengthangleCallbackPoints(DocObj.pages[DocObj.currentpage].drotation);


                    this.drawmescaled(ctx);

                    break;
                case 9: //text markup
                    ctx.font = this.font.fontstring;
                    var dim = ctx.measureText(this.text);
                    this.textwidth = dim.width;
                    this.w = this.textwidth;
                    this.h = this.textheight;

                    ctx.textAlign = "start";
                    //cursor
                    //drawing of text goes here.
                    ctx.fillStyle = markupobject.fillcolor;
                    //ctx.font = this.textheight + "pt Helvetica";

                    if(this.subtype == 1 || this.subtype == 2){
                        markupobject.Rect(ctx, this.x, this.y, this.w, this.h, this.linewidth, true, true, markupobject.fillcolor, markupobject.strokecolor);
                        ctx.fillText(this.text, this.x + 10 , this.y + this.h + 10);
                    }else{
                        //fontstylevalue.value;
                        ctx.fillText(this.text, this.x, this.y);
                        this.xscaled = this.x;
                        this.yscaled = this.y;
                        this.wscaled = this.w;
                        this.hscaled = this.h;

                    }

                    break;
                case 10:
                    this.w = noteimage.width;
                    this.h = noteimage.height;
                    ctx.drawImage(noteimage, this.x, this.y, this.w, this.h);

                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;

                    break;

                case 11:
                    this.w = this.image.width;
                    this.h = this.image.height;
                    if (markupobject.imageloaded){
                        ctx.drawImage(this.image, this.x, this.y, this.w, this.h);
                    }
                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;

                    break;

                case 12:

                    this.xscaled = this.x;
                    this.yscaled = this.y;
                    this.wscaled = this.w;
                    this.hscaled = this.h;
                    this.AdjustForRotation(false);
                    this.drawmescaled(ctx);

                    break;
            }

            /*if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                ctx.restore();
            }*/


        };

        this.drawmescaled = function (ctx) {

            var scalefactor = DocObj.pages[DocObj.currentpage].dscale; // markupobject.scaling;


            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector; // markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {

                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf); // markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale; // markupobject.scaling;
                if (DocObj.Type == 0) {
                    scalefactor = DocObj.pages[0].dscale; // markupobject.scaling;
                }

            }
            //var fixedscale = DocObj.pages[DocObj.currentpage].fixedScale;
            markupobject.fixedscaleFactor =  scalefactor / DocObj.pages[DocObj.currentpage].fixedScale;

            scalefactor /= markupobject.scaling;


            var pagedx = 0;
            var pagedy = 0;

            if (DocObj.Type == 0) {
                var docdx = DocObj.pages[0].dx;
            } else {
                docdx = DocObj.pages[DocObj.currentpage].dx;
            }

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                pagedx = DocObj.pages[DocObj.currentpage].dxvector;
                pagedy = DocObj.pages[DocObj.currentpage].dyvector;


            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                pagedx = DocObj.pages[DocObj.currentpage].dxpdf;
                pagedy = DocObj.pages[DocObj.currentpage].dypdf;

            } else {
                pagedx = docdx;
                pagedy = DocObj.pages[DocObj.currentpage].dy;

            }

            //console.log(pagedx);
            //console.log(pagedy);
            var xscalepoint = 0;
            var yscalepoint = 0;

            if(bUseFixedScale){
                var arrowlengthscaled = this.arrowlength * markupobject.fixedscaleFactor;
            }else{
                arrowlengthscaled = this.arrowlength * scalefactor;
            }

            if(bUseFixedScale){
                var radiusScaled = 10 * markupobject.fixedscaleFactor;
            }else{
                radiusScaled = 10 * scalefactor;
            }


            var textoffsetScaled = (this.h / 10) * scalefactor;

            if(bUseFixedScale){
                var linewidthScaled = this.linewidth * markupobject.fixedscaleFactor;
                var crossl = 5 * markupobject.fixedscaleFactor;
            }else{
                linewidthScaled = this.linewidth * scalefactor;
                crossl = 5 * scalefactor;

            }



            var leaderOffsetScalded = this.leaderoffset * scalefactor;

            var tx = 0;
            var ty = 0;
            var ptrn = getHatch(ctx, markupobject.hatchStyle, this.color);

            if (DocObj.pages[DocObj.currentpage].drotation != 0) {

                var txcanv = (canvasowidth / 2);
                var tycanv = (canvasoheight / 2);
                ctx.save();
                ctx.translate(txcanv, tycanv);
                ctx.rotate(DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180));
                ctx.translate(-txcanv, -tycanv);
            }

            switch (this.type) {
                case 0: //pencil, marker, eraser
                    var counter = 0;
                    var lcounter = 0;

                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);

                    /*xscalepoint = this.pointlist[0][0].x - this.xoffset * scalefactor;
                    yscalepoint = this.pointlist[0][0].y - this.yoffset * scalefactor;

                    //xscalepoint = (this.points[0].x - this.xoffset) * scalefactor;
                    //yscalepoint = (this.points[0].y - this.yoffset) * scalefactor;

                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        xscalepoint += DocObj.pages[DocObj.currentpage].dxvector;
                        yscalepoint += DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {

                        xscalepoint += DocObj.pages[DocObj.currentpage].dxpdf;
                        yscalepoint += DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        xscalepoint += DocObj.pages[DocObj.currentpage].dx;
                        yscalepoint += DocObj.pages[DocObj.currentpage].dy;

                    }*/


                    ctx.save();
                    if (this.subtype == 1) {
                        if (DocObj.backgroundColor != undefined) {
                            ctx.strokeStyle = DocObj.backgroundColor;
                        } else {
                            ctx.strokeStyle = "white";
                        }

                        ctx.lineWidth = linewidthScaled * 10;


                    } else {
                        ctx.strokeStyle = this.strokecolor;
                        ctx.lineWidth = linewidthScaled;

                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                    }

                    ctx.beginPath();


                    for (lcounter = 0; lcounter < this.pointlist.length; lcounter++) {
                        for (counter = 0; counter < this.pointlist[lcounter].length; counter++) {

                            xscalepoint = (this.pointlist[lcounter][counter].x - this.xoffset) * scalefactor;
                            yscalepoint = (this.pointlist[lcounter][counter].y - this.yoffset) * scalefactor;
                            //xscalepoint = (this.points[counter].x - this.xoffset) * scalefactor;
                            //yscalepoint = (this.points[counter].y - this.yoffset) * scalefactor;

                            xscalepoint += pagedx;
                            yscalepoint += pagedy;

                            if (counter == 0){
                                ctx.moveTo(xscalepoint, yscalepoint);
                            }else{
                                ctx.lineTo(xscalepoint, yscalepoint);
                            }



                        }
                    }

                    ctx.stroke();
                    ctx.restore();
                    if (markupobject.selected) {

                        markupobject.select(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, true, false);
                    }


                    break;
                case 1: //polygon
                    var pcounter = 0;

                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);

                    switch (this.subtype) {
                        case 1:
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.polyline(ctx, markupobject.linewidth, markupobject.strokecolor, scalefactor, pagedx, pagedy, true);
                            ctx.restore();
                            break;


                        case 2:
                            if (this.alternative == 0) {
                                ctx.save();
                                markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                                markupobject.polygon(ctx, markupobject.linewidth, false, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,pagedx, pagedy, true);
                                ctx.restore();
                            }

                            if (this.alternative == 1) {
                                ctx.save();
                                markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                                markupobject.polygon(ctx, markupobject.linewidth, true, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,pagedx, pagedy, true);
                                ctx.restore();
                            }
                            if (this.alternative == 2) {
                                markupobject.polygon(ctx, markupobject.linewidth, true, true, "white", markupobject.color, scalefactor,pagedx, pagedy, true);
                            }
                            if (this.alternative >= 3) {
                                markupobject.polygon(ctx, markupobject.linewidth, true, true, ptrn, markupobject.color, scalefactor,pagedx, pagedy, true);
                            }

                            break;
                        case 3:
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.polyline(ctx, markupobject.linewidth, markupobject.strokecolor, scalefactor, pagedx, pagedy, true);
                            ctx.restore();

                            //markupobject.findrectangle();

                            markupobject.setdimvaluepoly();

                            if(bUseFixedScale){
                                markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, markupobject.fixedscaleFactor,false);
                            }else{
                                markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, scalefactor,false);
                            }



                            //markupobject.setdimvaluepoly();
                            //markupobject.findrectangle();
                            //markupobject.dimvaluedraw(ctx, this.x, this.y, this.w, this.h, this.color, 1);


                            break;
                    }

                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, true, false);
                    }
                    if (markupobject.selectedit) {
                        markupobject.editpolygon(ctx, scalefactor);
                    }


                    break;
                case 2:
                    var curvcounter = 0;

                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);


                    switch (this.subtype) {
                        case 1:
                            markupobject.polycurves(ctx, markupobject.linewidth, markupobject.color, scalefactor);
                            break;
                    }
                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, true, false);
                    }
                    if (markupobject.selectedit) {
                        markupobject.editpolygon(ctx, scalefactor);
                    }

                    break;


                case 3: //rectangle

                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);

                    if (this.subtype == 2) {


                        if (DocObj.backgroundColor != undefined) {
                            var erasecolor = DocObj.backgroundColor;
                        } else {
                            erasecolor = "white";
                        }
                        markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, false, erasecolor, erasecolor);
                        //ctx.lineWidth = this.linewidth * 10 * scalefactor;

                    }

                    if (this.subtype == 4) {
                        markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, 1, true, true, markupobject.fillcolor, markupobject.fillcolor);
                    }

                    if (this.subtype == 3) {


                        markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, false, markupobject.fillcolor, markupobject.fillcolor);

                    }
                    if (this.subtype == 1) {

                        //

                        if (this.alternative == 0) {
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();
                        }
                        if (this.alternative == 1) {
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();
                        }
                        if (this.alternative == 2) {

                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, true, true, "white", this.color);
                        }
                        if (this.alternative >= 3) {

                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, true, true, ptrn, this.color);
                        }


                    }
                    if (this.subtype == 0) {
                        if (this.alternative == 0) {
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();
                        }
                        if (this.alternative == 1) {
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);

                            ctx.restore();
                        }
                        if (this.alternative == 2) {

                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, "white", this.color);
                        }

                        if (this.alternative >= 3) {
                            //var ptrn = ctx.createPattern(hatchdiagforw,'repeat');

                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, ptrn, this.color);
                        }


                    }
                    if (markupobject.selected) {

                        markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, true);
                    }

                    break;
                case 4: //oval

                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);


                    if (this.alternative == 0) {
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        if (this.subtype == 1){
                            markupobject.Circle(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                            markupobject.drawradius(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, crossl, linewidthScaled, markupobject.strokecolor, false);

                        }else{
                            markupobject.Oval(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                        }

                        ctx.restore();
                    }
                    if (this.alternative == 1) {
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        if (this.subtype == 1){
                            markupobject.Circle(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                            markupobject.drawradius(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, crossl, linewidthScaled, markupobject.strokecolor, false);
                        }else{
                            markupobject.Oval(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                        }

                        ctx.restore();

                    }
                    if (this.alternative == 2) {

                        markupobject.Oval(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, "white", this.color);

                    }
                    if (this.alternative >= 3) {

                        markupobject.Oval(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, ptrn, this.color);

                    }
                    if (markupobject.selected) {
                        if (this.subtype == 1){
                            //markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, false, false);
                            markupobject.select(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, false, false);
                        }else{
                            markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, true);
                        }

                    }


                    break;
                case 5:
                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);

                    if (this.alternative == 0) {
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        //markupobject.cloud(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,radiusScaled,linewidthScaled,false,true,this.color,this.color);
                        markupobject.newcloud(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, radiusScaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                        ctx.restore();
                    }
                    if (this.alternative == 1) {
                        //markupobject.cloud(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,radiusScaled,linewidthScaled,true,true,this.color,this.color);
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        markupobject.newcloud(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, radiusScaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                        ctx.restore();

                    }
                    if (this.alternative == 2) {

                        //markupobject.cloud(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,radiusScaled,linewidthScaled,true,true,"white",this.color);
                        markupobject.newcloud(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, radiusScaled, linewidthScaled, true, true, "white", this.color);

                    }
                    if (this.alternative >= 3) {

                        //markupobject.cloud(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,radiusScaled,linewidthScaled,true,true,ptrn,this.color);
                        markupobject.newcloud(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, radiusScaled, linewidthScaled, true, true, ptrn, this.color);

                    }
                    if (markupobject.selected) {

                        markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, true);
                    }

                    break;
                case 6: //line arrow


                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);
                    ctx.save();
                    markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);


                    markupobject.arrow(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, arrowlengthscaled, arrowangle, linewidthScaled, this.subtype, markupobject.strokecolor, markupobject.strokecolor);
                    ctx.restore();

                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, false, false);
                    }


                    break;
                case 7: //dimension line
                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);
                    var dimtype = this.subtype + 4;
                    ctx.save();
                    markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                    this.labelpos = markupobject.dimensionLeader(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, leaderOffsetScalded,arrowlengthscaled, arrowangle, linewidthScaled, dimtype, markupobject.strokecolor, markupobject.strokecolor);

                    ctx.restore();
                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, false, false);
                        if(this.leaderoffset == 0){
                            markupobject.selectLabel(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, false, false);

                        }else{
                            markupobject.selectLabel(ctx, this.labelpos.x, this.labelpos.y, this.labelpos.w, this.labelpos.h, false, false);

                        }
                    }

                    markupobject.setdimvalue(this.x, this.y, this.w, this.h);


                    if (bUseFixedScale){

                        if (this.leaderoffset == 0){
                            markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, markupobject.fixedscaleFactor,true);
                        }else{

                            markupobject.dimvaluedraw(ctx, this.labelpos.x, this.labelpos.y, this.labelpos.w, this.labelpos.h, this.strokecolor, markupobject.fixedscaleFactor,true);
                        }


                    }else{
                        if (this.leaderoffset == 0){
                            markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, scalefactor,true);
                        }else{
                            markupobject.dimvaluedraw(ctx, this.labelpos.x, this.labelpos.y, this.labelpos.w, this.labelpos.h, this.strokecolor, scalefactor,true);
                        }

                    }



                    break;

                case 8:
                    var acounter = 0;
                    var dimarea = 0;
                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);

                    if(bUseFixedScale){
                        var localscalefactor = markupobject.fixedscaleFactor;
                    }else{
                        localscalefactor = scalefactor;
                    }

                    /*if(markupobject.subtype == 1){

                    }*/

                    if(!markupobject.spaceselected && markupobject.subtype == 1){
                        markupobject.linestyle = 0;
                    }

                    if( markupobject.spaceselected && markupobject.subtype == 1){
                        ctx.save();

                        var grd = ctx.createLinearGradient(this.xscaled, this.yscaled, this.wscaled, this.hscaled);

                        grd.addColorStop(0, markupobject.selectSpaceColor);
                        grd.addColorStop(.5, markupobject.selectSpaceStopColor);
                        grd.addColorStop(1, markupobject.selectSpaceColor);


                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        //markupobject.polygon(ctx, markupobject.linewidth, true, true, markupobject.selectSpaceColor, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);
                        markupobject.polygon(ctx, markupobject.linewidth, true, true, grd, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);

                        /*if(markupobject.linestyle == 6 && bAnimateLineStyle){
                            markupobject.polygon(ctx, markupobject.linewidth, false, true, markupobject.selectSpaceColor, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);
                        }else{

                        }*/

                        ctx.restore();

                    }else{
                        if (this.alternative == 0) {
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.polygon(ctx, markupobject.linewidth, false, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);
                            ctx.restore();
                        }


                        if (this.alternative == 1) {
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.polygon(ctx, markupobject.linewidth, true, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);
                            ctx.restore();
                        }


                        if (this.alternative == 2) {
                            markupobject.polygon(ctx, markupobject.linewidth, true, true, "white", markupobject.color, scalefactor,pagedx, pagedy,true);
                        }
                        if (this.alternative >= 3) {
                            markupobject.polygon(ctx, markupobject.linewidth, true, true, ptrn, markupobject.color, scalefactor,pagedx, pagedy,true);
                        }
                    }




                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, true, false);
                    }
                    if (markupobject.selectedit) {
                        markupobject.editpolygon(ctx, scalefactor);
                    }

                    var markupscalesq = this.scaling * this.scaling;
                    dimarea = markupobject.PolygonArea();
                    this.dimtext = getUnitArea(dimarea / markupscalesq);
                    this.dimtext = this.dimtext.toFixed(2);
                    this.dimtext = this.dimtext + " " + AreaUnitlabel;

                    var centroidpt = get_polygon_centroid(this.points);


                    if(markupobject.subtype ==1){
                        markupobject.updateAttribute('Rx_Area', this.dimtext);
                    }

                    //var areatextx = markupobject.PolygonCentre('x');
                    //var areatexty = markupobject.PolygonCentre('y');

                    var areatextx = centroidpt.x;
                    var areatexty = centroidpt.y;


                    var areatextxscaled = (areatextx - this.xoffset) * scalefactor;
                    var areatextyscaled = (areatexty - this.yoffset) * scalefactor;

                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        areatextxscaled = areatextxscaled + DocObj.pages[DocObj.currentpage].dxvector;
                        areatextyscaled = areatextyscaled + DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        areatextxscaled += DocObj.pages[DocObj.currentpage].dxpdf;
                        areatextyscaled += DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        areatextxscaled = areatextxscaled + DocObj.pages[DocObj.currentpage].dx;
                        areatextyscaled = areatextyscaled + DocObj.pages[DocObj.currentpage].dy;

                    }

                    var areatextscaled = this.measuretextheight * scalefactor;

                    if (bUseFixedScale){
                        areatextscaled = this.measuretextheight * markupobject.fixedscaleFactor;
                    }


                    if(!bMarkupNoLabel && markupobject.busecustomlabel){
                        markupobject.areavaluedraw(ctx, markupobject.customlabeltext, areatextxscaled, areatextyscaled, markupobject.strokecolor, areatextscaled, localscalefactor, scalefactor );
                    }

                    if(!bMarkupNoLabel && !markupobject.busecustomlabel && markupobject.subtype != 1){

                        markupobject.areavaluedraw(ctx, this.dimtext, areatextxscaled, areatextyscaled, this.strokecolor, areatextscaled, localscalefactor, scalefactor );



                        /*ctx.textAlign = "start";
                        ctx.font = areatextscaled + "pt " + "Helvetica";
                        this.textheight = this.measuretextheight;

                        var areat = ctx.measureText(this.dimtext);
                        var areatextwidth = areat.width;
                        var areatextheight = areatextscaled;
                        areatextxscaled = areatextxscaled - (areatextwidth / 2);
                        areatextyscaled = areatextyscaled + (areatextheight / 2);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = this.strokecolor;
                        ctx.fillStyle = "white";

                        ctx.fillRect(areatextxscaled - (10 * localscalefactor), areatextyscaled - (20 * localscalefactor), areatextwidth + (20 * localscalefactor), areatextscaled + (15 * localscalefactor));
                        ctx.strokeRect(areatextxscaled - (10 * localscalefactor), areatextyscaled - (20 * localscalefactor), areatextwidth + (20 * localscalefactor), areatextscaled + (15 * localscalefactor));*/



                        // ctx.fillStyle = this.color;
                        //ctx.fillStyle = "black";
                        //ctx.fillText(this.dimtext, areatextxscaled, areatextyscaled);
                    }


                    break;
                case 9: //text
                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);
                    if(markupobject.selectedit){
                        break;
                    }

                    if(bUseFixedScale){
                        var temptxtscale = markupobject.fixedscaleFactor;
                        temptxtscale *= fTextScale;

                    }else{
                        temptxtscale = scalefactor;

                    }

                    this.font.setScale(temptxtscale);

                    var textscaled = this.font.height * temptxtscale;


                    ctx.font = this.font.fontstringScaled;

                    var dimsel = ctx.measureText(this.text);
                    this.textwidth = dimsel.width;



                    //draw text selected goes here.


                    ctx.save();

                    tx = this.xscaled;
                    ty = this.yscaled;

                    if (markupobject.textrotate != 0 && markupobject.subtype == 0) {
                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.textrotate);
                        ctx.translate(-tx, -ty);

                    }

                    //console.log(markupobject.rotation * (180 / Math.PI));

                    if (markupobject.rotation != 0) {
                        tx = this.xscaled + (this.wscaled / 2);
                        if( markupobject.subtype == 0){
                            ty = this.yscaled - (this.hscaled / 2);
                        }else{
                            ty = this.yscaled + (this.hscaled / 2);
                        }

                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.rotation);
                        ctx.translate(-tx, -ty);
                    }


                    ctx.textAlign = "start";
                    ctx.fillStyle = markupobject.textcolor;

                    if(this.subtype == 1 || this.subtype == 2){
                        //markupobject.fillcolor = "rgba(255,255,255, 0.9)";
                        //this.textcolor = "rgba(255,255,255, 0.9)";
                        var toffsetx = 4*temptxtscale;
                        //var toffsety = 2*scalefactor;

                        var toffsety = ((this.font.height / 4) * 2.0) * temptxtscale;
                        //var toffsety = ((this.font.height / 3)) * temptxtscale;

                        if(markupobject.linewidth == 0){
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, false, markupobject.fillcolor, markupobject.strokecolor);
                        }else{
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();
                        }

                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
                        ctx.clip();
                        //ctx.font=font;
                        //ctx.fillText(theText,3,50);
                        //wraptext(ctx, this.text, x, y, maxWidth, lineHeight);

                        var textarray = this.text.split('\n');
                        var ystart = this.yscaled + textscaled + toffsety;
                        var ttx = this.xscaled;// + (this.wscaled);
                        var tty = this.yscaled; //+ (this.hscaled/2);

                        var txtrotate = markupobject.textrotate * (180 / Math.PI);

                        switch(markupobject.pagerotation){
                            case 0:
                                var startx = this.xscaled + toffsetx;
                                var maxwidth = this.wscaled;
                                break;
                            case 90:
                                startx = (this.xscaled + toffsetx) - this.hscaled;
                                ctx.translate(ttx , tty);
                                ctx.rotate(-(markupobject.pagerotation * (Math.PI / 180)));
                                ctx.translate(-ttx, -tty);
                                maxwidth = this.hscaled;

                                break;
                            case 270:
                                //startx = this.xscaled + toffsetx;
                                startx = (this.xscaled + toffsetx);// + this.hscaled;
                                //ystart = (this.yscaled + toffsety) - this.wscaled;
                                ystart = (this.yscaled + textscaled + toffsety) - this.wscaled;
                                ctx.translate(ttx , tty);
                                ctx.rotate(-(markupobject.pagerotation * (Math.PI / 180)));
                                ctx.translate(-ttx, -tty);
                                maxwidth = this.hscaled;

                                break;
                            case 180:
                                startx = this.xscaled + toffsetx;
                                ttx = this.xscaled + (this.wscaled / 2);
                                tty = this.yscaled + (this.hscaled / 2);
                                ctx.translate(ttx, tty);
                                ctx.rotate(-(markupobject.pagerotation * (Math.PI / 180)));
                                ctx.translate(-ttx, -tty);
                                //adjust maxwidth to match text area
                                maxwidth = this.wscaled;

                                break;
                        }
                        maxwidth -= 5;
                        wrapText(ctx, this.text, startx, ystart, maxwidth, textscaled + toffsety);

                        /*for (var i = 0; i < textarray.length; i++) {

                            ctx.fillText(textarray[i], startx , ystart);
                            ystart += textscaled + toffsety;
                            //ctx.fillText(textarray[i], x + 5, ystart);

                        }*/
                        ctx.restore();


                    }else{
                        ctx.fillText(this.text, this.xscaled, this.yscaled);
                    }


                    ctx.restore();
                    if (markupobject.selected) {
                        if(this.subtype == 1 || this.subtype == 2){
                            if (this.bhasArrow){
                                markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, false);
                            }else{
                                markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, true);
                            }

                        }else{
                            markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled - this.hscaled, true, true);
                        }


                    }

                    break;
                case 10:

                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);

                    /*if (bUseFixedScale){

                    }else{
                        markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);
                    }*/


                    ctx.save();

                    tx = this.xscaled;
                    ty = this.yscaled;
                    if (markupobject.rotation != 0) {
                        tx = this.xscaled + (this.wscaled / 2);
                        ty = this.yscaled - (this.hscaled / 2);

                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.rotation);
                        ctx.translate(-tx, -ty);
                    }

                    ctx.drawImage(noteimage, this.xscaled, this.yscaled, this.wscaled, this.hscaled);

                    ctx.restore();

                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, false);
                    }

                    break;
                case 11:
                    if (!markupobject.imageloaded){
                        break;
                    }

                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);
                    ctx.save();

                    tx = this.xscaled;
                    ty = this.yscaled;
                    if (markupobject.rotation != 0) {
                        tx = this.xscaled + (this.wscaled / 2);
                        ty = this.yscaled + (this.hscaled / 2);

                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.rotation);
                        ctx.translate(-tx, -ty);
                    }

                    if (markupobject.imageloaded){
                        ctx.drawImage(this.image, this.xscaled, this.yscaled, this.wscaled, this.hscaled);
                    }


                    ctx.restore();

                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, true);
                    }

                    break;

                case 12:
                    markupobject.SetDimensions(scalefactor, DocObj.pages[DocObj.currentpage].drotation, pagedx, pagedy);

                    var textstampscaled = this.font.height * scalefactor;
                    this.font.setScale(scalefactor);
                    var textsmallstampscaled = markupobject.stampsmalltheight * scalefactor;

                    if(bUseFixedScale){
                        markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, 3 * markupobject.fixedscaleFactor, true, true, markupobject.fillcolor, markupobject.strokecolor);
                    }else{
                        markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, 3 * scalefactor, true, true, markupobject.fillcolor, markupobject.strokecolor);
                    }

                    if (markupobject.selected) {
                        markupobject.select(ctx, this.xscaled, this.yscaled, this.xscaled + this.wscaled, this.yscaled + this.hscaled, true, true);
                    }


                    var Displayname = GetDisplayName(markupobject.signature);

                    var datetext = markupobject.GetDateTime(false);
                    //var smalltext = "By " + markupobject.signature + "," + " ";
                    this.smalltext = "By " + Displayname + "," + " ";
                    this.smalltext += datetext;
                    /*if (this.subtype != 100) {
                        markupobject.text = Stamplist[this.subtype];
                    }*/

                    /*if (this.subtype == 0){ markupobject.text = "Approved";}
                     if (this.subtype == 1){ markupobject.text = "Draft";}
                     if (this.subtype == 2){ markupobject.text = "Received";}
                     if (this.subtype == 3){ markupobject.text = "Rejected";}
                     if (this.subtype == 4){ markupobject.text = "Reviewed";}
                     if (this.subtype == 5){ markupobject.text = "Revised";}*/

                    ctx.save();


                    if (markupobject.rotation != 0) {
                        tx = this.xscaled + (this.wscaled / 2);
                        ty = this.yscaled + (this.hscaled / 2);

                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.rotation);
                        ctx.translate(-tx, -ty);
                    }

                    /*var heightorient = this.hscaled;
                     var widthorient = this.wscaled;
                     //main stamp text.
                     if(this.hscaled > this.wscaled){
                     heightorient = this.wscaled;
                     widthorient = this.hscaled;
                     }else
                     markupobject.textheight = (heightorient/4);*/

                    /*if(DocObj.pages[DocObj.currentpage].drotation == 90 || DocObj.pages[DocObj.currentpage].drotation == 270){
                     markupobject.textheight = (this.wscaled/4);
                     tx = this.xscaled+(this.hscaled/2);
                     ty = this.yscaled+(this.wscaled/2)-textoffsetScaled;

                     }else{

                     }*/
                    ctx.fillStyle = markupobject.strokecolor;

                    //ctx.font = "bold " + textstampscaled + "pt " + "Times New Roman";
                    ctx.font = this.font.fontstringScaled;

                    var stampdim = ctx.measureText(this.text);
                    this.textwidth = stampdim.width;
                    tx = this.xscaled + (this.wscaled / 2);
                    //ty = this.yscaled+(this.hscaled/2);
                    if(this.alternative == 0){
                        ty = this.yscaled + ((this.hscaled / 4) + (textstampscaled / 2));
                    }else{
                        ty = this.yscaled + (this.hscaled / 2);
                        ty += (textstampscaled / 4);
                    }



                    //tx = this.xscaled+(this.wscaled/2);
                    //ty = this.yscaled+(this.hscaled/2);

                    if (markupobject.textrotate != 0) {
                        ty = this.yscaled + (this.hscaled / 2);
                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.textrotate);
                        ctx.translate(-tx, -ty);

                        tx = this.xscaled + (this.wscaled / 2);
                        //ty = this.yscaled+(this.hscaled/2);
                        if(this.alternative == 0){
                            ty = this.yscaled + ((this.hscaled / 4) + (textstampscaled / 2));
                        }else{
                            ty = this.yscaled + (this.hscaled / 2);
                            ty += (textstampscaled / 4);
                        }


                    }
                    ctx.textAlign = 'center';
                    if (DocObj.pages[DocObj.currentpage].drotation == 90 || DocObj.pages[DocObj.currentpage].drotation == 270) {
                        ctx.fillText(this.text, tx, ty);
                    } else {
                        ctx.fillText(this.text, tx, ty);
                    }

                    if(this.alternative == 0 ){
                        //stamp information text.
                        //var smalltextsize = markupobject.textheight / 2;
                        ctx.fillStyle = this.color;
                        ctx.font = "bold " + textsmallstampscaled + "pt " + "Times New Roman";

                        /*tx = this.xscaled+(this.wscaled/2);
                         ty = this.yscaled+(this.hscaled/2)+textoffsetScaled;

                         if (markupobject.textrotate !=0){
                         ctx.translate(tx,ty);
                         ctx.rotate(markupobject.textrotate);
                         ctx.translate(-tx,-ty);

                         }*/
                        ty = this.yscaled + ((this.hscaled / 4) * 3);

                        if (DocObj.pages[DocObj.currentpage].drotation == 90 || DocObj.pages[DocObj.currentpage].drotation == 270) {
                            ctx.fillText(this.smalltext, tx, ty);
                        } else {
                            ctx.fillText(this.smalltext, tx, ty);
                        }

                    }



                    ctx.restore();
                    break;

            }
            if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                ctx.restore();
            }
        };



        this.drawthumb = function (ctx){

            //this.drawprint(ctx,DocObj.pages[DocObj.currentpage].dxthumb,DocObj.pages[DocObj.currentpage].dythumb,DocObj.pages[DocObj.currentpage].dscalethumb);
            this.drawprint(ctx,DocObj.pages[DocObj.currentpage].dxthumb,DocObj.pages[DocObj.currentpage].dythumb,DocObj.pages[DocObj.currentpage].dscalethumb,0, true);


        };

        this.drawprint = function(ctx, dx,dy,dscale,drotation, bthumbnail){
            markupobject.fixedscaleFactor =  dscale / DocObj.pages[DocObj.currentpage].fixedScale;

            var scalefactor = dscale / markupobject.scaling;
            var pagedx = dx;
            var pagedy = dy;

            //var scalefactor = DocObj.pages[DocObj.currentpage].dscalethumb / markupobject.scaling;

            //var pagedx = DocObj.pages[DocObj.currentpage].dxthumb;
            //var pagedy = DocObj.pages[DocObj.currentpage].dythumb;

            var xscalepoint = 0;
            var yscalepoint = 0;


            if(bUseFixedScale && !bthumbnail){
                var arrowlengthscaled = this.arrowlength * markupobject.fixedscaleFactor;
            }else{
                arrowlengthscaled = this.arrowlength * scalefactor;
            }

            if(bUseFixedScale && !bthumbnail){
                var radiusScaled = 10 * markupobject.fixedscaleFactor;
            }else{
                radiusScaled = 10 * scalefactor;
            }


            var textoffsetScaled = (this.h / 10) * scalefactor;

            if(bUseFixedScale && !bthumbnail){
                var linewidthScaled = this.linewidth * markupobject.fixedscaleFactor;
            }else{
                linewidthScaled = this.linewidth * scalefactor;
            }

            var leaderOffsetScalded = this.leaderoffset * scalefactor;

            var tx = 0;
            var ty = 0;
            var ptrn = getHatch(ctx,markupobject.hatchStyle,this.color);


            if(bUseFixedScale && !bthumbnail){
                var linewidthScaled = this.linewidth * markupobject.fixedscaleFactor;
                var crossl = 5 * markupobject.fixedscaleFactor;
            }else{
                linewidthScaled = this.linewidth * scalefactor;
                crossl = 5 * scalefactor;
            }


            switch(this.type){
                case 0: //pencil, marker, eraser

                    var counter = 0;
                    var lcounter = 0;

                    //markupobject.SetDimensions(scalefactor,0,pagedx,pagedy);
                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    ctx.save();
                    if (this.subtype == 1){
                        ctx.strokeStyle = "white";
                        /*if(backgroundColor != undefined){
                            ctx.strokeStyle = backgroundColor;
                        }else{
                            ctx.strokeStyle = "white";
                        }*/
                        ctx.lineWidth = this.linewidth * 10 * scalefactor;

                    }else{
                        ctx.strokeStyle = this.strokecolor;
                        ctx.lineWidth = this.linewidth * scalefactor;
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                    }

                    ctx.beginPath();

                    for (lcounter = 0; lcounter < this.pointlist.length; lcounter++) {
                        for (counter = 0; counter < this.pointlist[lcounter].length; counter++) {

                            xscalepoint = (this.pointlist[lcounter][counter].x - this.xoffset) * scalefactor;
                            yscalepoint = (this.pointlist[lcounter][counter].y - this.yoffset) * scalefactor;

                            xscalepoint += dx;
                            yscalepoint += dy;


                            if (counter == 0){
                                ctx.moveTo(xscalepoint, yscalepoint);
                            }else{
                                ctx.lineTo(xscalepoint, yscalepoint);
                            }



                        }
                    }

                    ctx.stroke();
                    ctx.restore();


                    break;
                case 1: //polygon
                    var pcounter = 0;


                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    switch(this.subtype){
                        case 1:
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                            markupobject.polyline(ctx, markupobject.linewidth, markupobject.strokecolor, scalefactor,dx,dy,true);

                            ctx.restore();

                            break;


                        case 2:
                            if (this.alternative == 0){
                                ctx.save();
                                markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                                markupobject.polygon(ctx, markupobject.linewidth, false, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,dx,dy,true);
                                ctx.restore();


                            }

                            if (this.alternative == 1){

                                markupobject.polygon(ctx, markupobject.linewidth, true, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,dx,dy,true);
                            }
                            if (this.alternative == 2){


                                markupobject.polygon(ctx, markupobject.linewidth, true, true, "white", markupobject.color, scalefactor,dx,dy,true);
                            }
                            if (this.alternative >= 3){


                                markupobject.polygon(ctx, markupobject.linewidth, true, true, ptrn, markupobject.color, scalefactor,dx,dy,true);
                            }

                            break;
                        case 3:
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.polyline(ctx, markupobject.linewidth, markupobject.strokecolor, scalefactor, dx,dy, true);
                            ctx.restore();


                            markupobject.setdimvaluepoly();

                            if(bUseFixedScale && !bthumbnail){
                                markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, markupobject.fixedscaleFactor,false);
                            }else{
                                markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, scalefactor,false);
                            }


                            break;
                    }


                    break;
                case 2:
                    var curvcounter = 0;


                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    switch (this.subtype){
                        case 1:
                            markupobject.polycurves(ctx,markupobject.linewidth,markupobject.color, scalefactor);
                            break;
                    }
                    break;


                case 3: //rectangle


                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    if (this.subtype == 2){



                        if(DocObj.backgroundColor != undefined){
                            var erasecolor  = DocObj.backgroundColor;
                        }else{
                            erasecolor = "white";
                        }
                        markupobject.Rect(ctx,this.xscaled, this.yscaled, this.wscaled, this.hscaled,linewidthScaled,true,false,erasecolor,erasecolor);
                        //ctx.lineWidth = this.linewidth * 10 * scalefactor;

                    }

                    if (this.subtype == 4){
                        markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.fillcolor);
                    }

                    if (this.subtype == 3){

                        markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, false, markupobject.fillcolor, markupobject.fillcolor);


                    }
                    if (this.subtype == 1){

                        //

                        if (this.alternative == 0){
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();

                        }
                        if (this.alternative == 1){
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();

                        }
                        if (this.alternative == 2){

                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, true, true, "white", this.color);
                        }
                        if (this.alternative >= 3){

                            markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, linewidthScaled, true, true, ptrn, this.color);
                        }



                    }
                    if (this.subtype == 0){
                        if (this.alternative == 0){
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();

                        }
                        if (this.alternative == 1){
                            ctx.save();

                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);

                            ctx.restore();
                        }
                        if (this.alternative == 2){

                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, "white", this.color);
                        }

                        if(this.alternative >= 3){
                            //var ptrn = ctx.createPattern(hatchdiagforw,'repeat');

                            markupobject.Rect(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,linewidthScaled,true,true,ptrn,this.color);
                        }


                    }

                    break;
                case 4: //oval


                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);


                    if (this.alternative ==0){


                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        if (this.subtype == 1){
                            markupobject.Circle(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                            markupobject.drawradius(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, crossl, linewidthScaled, markupobject.strokecolor, false);

                        }else{
                            markupobject.Oval(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                        }

                        ctx.restore();

                    }
                    if (this.alternative == 1){
                        ctx.save();

                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                        if (this.subtype == 1){
                            markupobject.Circle(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                            markupobject.drawradius(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, crossl, linewidthScaled, markupobject.strokecolor, false);

                        }else{
                            markupobject.Oval(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                        }

                        ctx.restore();

                    }
                    if (this.alternative == 2){

                        markupobject.Oval(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,linewidthScaled,true,true,"white",this.color);

                    }
                    if (this.alternative >= 3){
                        markupobject.Oval(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,linewidthScaled,true,true,ptrn,this.color);

                    }


                    break;
                case 5:

                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    if (this.alternative == 0){
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        markupobject.newcloud(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, radiusScaled, linewidthScaled, false, true, markupobject.fillcolor, markupobject.strokecolor);
                        ctx.restore();

                    }
                    if (this.alternative == 1){
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        markupobject.newcloud(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, radiusScaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                        ctx.restore();

                    }
                    if (this.alternative == 2){

                        markupobject.newcloud(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,radiusScaled,linewidthScaled,true,true,"white",this.color);

                    }
                    if (this.alternative >= 3){

                        markupobject.newcloud(ctx,this.xscaled,this.yscaled,this.wscaled,this.hscaled,radiusScaled,linewidthScaled,true,true,ptrn,this.color);

                    }

                    break;
                case 6: //line arrow


                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    ctx.save();
                    markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                    markupobject.arrow(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, arrowlengthscaled, arrowangle, linewidthScaled, this.subtype, markupobject.strokecolor, markupobject.strokecolor);
                    ctx.restore();



                    break;
                case 7: //dimension line

                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    var dimtype = this.subtype + 4;

                    ctx.save();
                    markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                    //markupobject.arrow(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, arrowlengthscaled, arrowangle, linewidthScaled, dimtype, markupobject.strokecolor, markupobject.strokecolor);
                    markupobject.labelpos = markupobject.dimensionLeader(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, leaderOffsetScalded,arrowlengthscaled, arrowangle, linewidthScaled, dimtype, markupobject.strokecolor, markupobject.strokecolor);
                    ctx.restore();


                    markupobject.setdimvalue(this.x, this.y, this.w, this.h);



                    if (bUseFixedScale && !bthumbnail){
                        if (this.leaderoffset == 0){
                            markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, markupobject.fixedscaleFactor,true);
                        }else{
                            markupobject.dimvaluedraw(ctx, this.labelpos.x, this.labelpos.y, this.labelpos.w, this.labelpos.h, this.strokecolor, markupobject.fixedscaleFactor,true);
                        }

                    }else{
                        if (this.leaderoffset == 0){
                            markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, scalefactor,true);
                        }else{
                            markupobject.dimvaluedraw(ctx, this.labelpos.x, this.labelpos.y, this.labelpos.w, this.labelpos.h, this.strokecolor, scalefactor,true);
                        }


                    }



                    break;

                case 8:
                    var acounter = 0;
                    var dimarea = 0;

                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);


                    if(bUseFixedScale && !bthumbnail){
                        var localscalefactor = markupobject.fixedscaleFactor;
                    }else{
                        localscalefactor = scalefactor;
                    }


                    if(!markupobject.spaceselected && markupobject.subtype == 1){
                        markupobject.linestyle = 0;
                    }

                    if( markupobject.spaceselected && markupobject.subtype == 1){
                        ctx.save();

                        var grd = ctx.createLinearGradient(this.xscaled, this.yscaled, this.wscaled, this.hscaled);

                        grd.addColorStop(0, markupobject.selectSpaceColor);
                        grd.addColorStop(.5, markupobject.selectSpaceStopColor);
                        grd.addColorStop(1, markupobject.selectSpaceColor);


                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                        markupobject.polygon(ctx, markupobject.linewidth, true, true, grd, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);

                        /*if(markupobject.linestyle == 6 && bAnimateLineStyle){
                            markupobject.polygon(ctx, markupobject.linewidth, false, true, markupobject.selectSpaceColor, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);
                        }else{

                        }*/

                        ctx.restore();
                    }

                    /*if(bUseFixedScale && !bthumbnail){
                        markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, markupobject.fixedscaleFactor,true);
                    }else{
                        markupobject.dimvaluedraw(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, this.strokecolor, scalefactor,true);
                    }*/

                    if (this.alternative == 0){
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                        markupobject.polygon(ctx, markupobject.linewidth, false, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);
                        ctx.restore();

                    }

                    if (this.alternative == 1){
                        ctx.save();
                        markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);

                        markupobject.polygon(ctx, markupobject.linewidth, true, true, markupobject.fillcolor, markupobject.strokecolor, scalefactor,pagedx, pagedy,true);
                        ctx.restore();
                    }
                    if (this.alternative == 2){

                        markupobject.polygon(ctx,markupobject.linewidth,true,true,"white",markupobject.color,scalefactor,pagedx, pagedy,true);
                    }
                    if (this.alternative >= 3){


                        markupobject.polygon(ctx,markupobject.linewidth,true,true,ptrn,markupobject.color,scalefactor,pagedx, pagedy,true);
                    }


                    var markupscalesq = this.scaling*this.scaling;
                    dimarea = markupobject.PolygonArea();
                    this.dimtext = getUnitArea(dimarea/markupscalesq);
                    this.dimtext = this.dimtext.toFixed(2);
                    this.dimtext = this.dimtext + " " + AreaUnitlabel;


                    var areatextx = markupobject.PolygonCentre('x');
                    var areatexty = markupobject.PolygonCentre('y');

                    var areatextxscaled = (areatextx - this.xoffset) * scalefactor;
                    var areatextyscaled = (areatexty - this.yoffset) * scalefactor;

                    areatextxscaled += dx;
                    areatextyscaled += dy;

                    var areatextscaled = this.measuretextheight * scalefactor;

                    if (bUseFixedScale && !bthumbnail){
                        areatextscaled = this.measuretextheight * markupobject.fixedscaleFactor;
                    }

                    if(!bMarkupNoLabel && markupobject.busecustomlabel){
                        markupobject.areavaluedraw(ctx, markupobject.customlabeltext, areatextxscaled, areatextyscaled, markupobject.strokecolor, areatextscaled, localscalefactor, scalefactor );
                    }

                    if(!bMarkupNoLabel && markupobject.subtype != 1){


                        markupobject.areavaluedraw(ctx, this.dimtext, areatextxscaled, areatextyscaled, this.strokecolor, areatextscaled, localscalefactor);

                        /*var areatextscaled = this.measuretextheight * scalefactor;

                        if (bUseFixedScale && !bthumbnail){
                            areatextscaled = this.measuretextheight * markupobject.fixedscaleFactor;
                        }*/


                        /*ctx.textAlign  = "start";
                        ctx.font = areatextscaled + "pt " + "Helvetica";
                        this.textheight = this.measuretextheight;

                        var areat = ctx.measureText(this.dimtext);
                        var areatextwidth = areat.width;
                        var areatextheight = areatextscaled;
                        areatextxscaled = areatextxscaled - (areatextwidth/2);
                        areatextyscaled = areatextyscaled + (areatextheight/2);
                        ctx.lineWidth = 1;
                        ctx.strokeStyle=this.color;
                        ctx.fillStyle = "white";
                        ctx.fillRect(areatextxscaled-(10*localscalefactor), areatextyscaled-(20*localscalefactor),areatextwidth + (20*localscalefactor),areatextscaled + (15*localscalefactor));
                        ctx.strokeRect(areatextxscaled-(10*localscalefactor), areatextyscaled-(20*localscalefactor),areatextwidth + (20*localscalefactor),areatextscaled + (15*localscalefactor));*/

                        /*ctx.fillStyle = "black";
                        ctx.fillText(this.dimtext, areatextxscaled, areatextyscaled);*/

                    }



                    break;
                case 9: //text
                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);
                    if(markupobject.selectedit){
                        break;
                    }

                    if(bUseFixedScale && !bthumbnail){
                        var temptxtscale = markupobject.fixedscaleFactor;
                    }else{
                        temptxtscale = scalefactor;

                    }

                    this.font.setScale(temptxtscale);
                    var textscaled = this.font.height * temptxtscale;


                    ctx.font = this.font.fontstringScaled;


                    var dimsel = ctx.measureText(this.text);
                    this.textwidth = dimsel.width;




                    //draw text selected goes here.


                    ctx.save();

                    tx = this.xscaled;
                    ty = this.yscaled;

                    if (markupobject.textrotate != 0 && markupobject.subtype == 0) {
                        ctx.translate(tx,ty);
                        ctx.rotate(markupobject.textrotate);
                        ctx.translate(-tx,-ty);

                    }



                    ctx.textAlign = "start";
                    ctx.fillStyle = markupobject.textcolor;

                    if(this.subtype == 1 || this.subtype == 2){
                        var toffsetx = 4*temptxtscale;
                        //var toffsety = 8*scalefactor;
                        //var toffsety = ((this.font.height / 4) * 1.3) * scalefactor;
                        var toffsety = ((this.font.height / 4) * 2.0) * temptxtscale;

                        if(markupobject.linewidth == 0){
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, false, markupobject.fillcolor, markupobject.strokecolor);
                        }else{
                            ctx.save();
                            markupobject.GetLinestyle(markupobject.linestyle,ctx,markupobject.fixedscaleFactor);
                            markupobject.Rect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, linewidthScaled, true, true, markupobject.fillcolor, markupobject.strokecolor);
                            ctx.restore();
                        }

                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(this.xscaled, this.yscaled, this.wscaled, this.hscaled);
                        ctx.clip();

                        var textarray = this.text.split('\n');
                        var ystart = this.yscaled + textscaled + toffsety;

                        var ttx = this.xscaled;// + (this.wscaled);
                        var tty = this.yscaled; //+ (this.hscaled/2);

                        var txtrotate = markupobject.textrotate * (180 / Math.PI);

                        switch(markupobject.pagerotation){
                            case 0:
                                var startx = this.xscaled + toffsetx;
                                var maxwidth = this.wscaled;
                                break;
                            case 90:
                                startx = (this.xscaled + toffsetx) - this.hscaled;
                                ctx.translate(ttx , tty);
                                ctx.rotate(-(markupobject.pagerotation * (Math.PI / 180)));
                                ctx.translate(-ttx, -tty);
                                maxwidth = this.hscaled;
                                break;
                            case 270:
                                //startx = this.xscaled + toffsetx;
                                startx = (this.xscaled + toffsetx);// + this.hscaled;
                                //ystart = (this.yscaled + toffsety) - this.wscaled;
                                ystart = (this.yscaled + textscaled + toffsety) - this.wscaled;
                                ctx.translate(ttx , tty);
                                ctx.rotate(-(markupobject.pagerotation * (Math.PI / 180)));
                                ctx.translate(-ttx, -tty);
                                maxwidth = this.hscaled;
                                break;
                            case 180:
                                startx = this.xscaled + toffsetx;
                                ttx = this.xscaled + (this.wscaled / 2);
                                tty = this.yscaled + (this.hscaled / 2);
                                ctx.translate(ttx, tty);
                                ctx.rotate(-(markupobject.pagerotation * (Math.PI / 180)));
                                ctx.translate(-ttx, -tty);
                                maxwidth = this.wscaled;
                                break;
                        }

                        wrapText(ctx, this.text, startx, ystart, maxwidth, textscaled + toffsety);

                        /*for (var i = 0; i < textarray.length; i++) {

                            ctx.fillText(textarray[i], startx , ystart);
                            ystart += textscaled + toffsety;

                        }*/

                        ctx.restore();


                    }else{
                        ctx.fillText(this.text, this.xscaled, this.yscaled);
                    }



                    ctx.restore();

                    break;
                case 10:

                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);
                    ctx.save();

                    tx = this.xscaled;
                    ty = this.yscaled;
                    if (markupobject.rotation != 0) {
                        tx = this.xscaled + (this.wscaled / 2);
                        ty = this.yscaled - (this.hscaled / 2);

                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.rotation);
                        ctx.translate(-tx, -ty);
                    }

                    ctx.drawImage(noteimage, this.xscaled, this.yscaled, this.wscaled, this.hscaled);
                    ctx.restore();



                    break;
                case 11:

                    if (!markupobject.imageloaded){
                        break;
                    }

                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);
                    ctx.save();

                    tx = this.xscaled;
                    ty = this.yscaled;

                    if (markupobject.rotation != 0) {
                        tx = this.xscaled + (this.wscaled / 2);
                        ty = this.yscaled + (this.hscaled / 2);

                        ctx.translate(tx, ty);
                        ctx.rotate(markupobject.rotation);
                        ctx.translate(-tx, -ty);
                    }

                    ctx.drawImage(this.image, this.xscaled, this.yscaled, this.wscaled, this.hscaled);

                    ctx.restore();

                    break;

                case 12:

                    markupobject.SetDimensions(scalefactor,drotation,pagedx,pagedy);

                    var textstampscaled = this.font.height * scalefactor;
                    this.font.setScale(scalefactor);

                    var textsmallstampscaled = markupobject.stampsmalltheight * scalefactor;

                    if(bUseFixedScale && !bthumbnail){
                        markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, 3 * markupobject.fixedscaleFactor, true, true, markupobject.fillcolor, markupobject.strokecolor);
                    }else{
                        markupobject.roundedRect(ctx, this.xscaled, this.yscaled, this.wscaled, this.hscaled, markupobject.rotation, radiusScaled, 3 * scalefactor, true, true, markupobject.fillcolor, markupobject.strokecolor);
                    }


                    var Displayname = GetDisplayName(markupobject.signature);

                    var datetext = markupobject.GetDateTime(false);
                    //var smalltext = "By " + markupobject.signature + "," + " ";
                    this.smalltext = "By " + Displayname + "," + " ";
                    this.smalltext += datetext;



                    ctx.save();


                    if(markupobject.rotation !=0){
                        tx = this.xscaled + (this.wscaled/2);
                        ty = this.yscaled + (this.hscaled / 2);

                        ctx.translate(tx,ty);
                        ctx.rotate(markupobject.rotation);
                        ctx.translate(-tx,-ty);
                    }



                    ctx.fillStyle = markupobject.strokecolor;
                    ctx.font = markupobject.font.fontstringScaled;



                    var stampdim = ctx.measureText(this.text);
                    this.textwidth = stampdim.width;
                    tx = this.xscaled+(this.wscaled/2);
                    //ty = this.yscaled+(this.hscaled/2);
                    if(this.alternative == 0){
                        ty = this.yscaled + ((this.hscaled / 4) + (textstampscaled / 2));
                    }else{
                        ty = this.yscaled + (this.hscaled / 2);
                        ty += (textstampscaled / 4);
                    }



                    //tx = this.xscaled+(this.wscaled/2);
                    //ty = this.yscaled+(this.hscaled/2);

                    if (markupobject.textrotate !=0){
                        ctx.translate(tx,ty);
                        ctx.rotate(markupobject.textrotate);
                        ctx.translate(-tx,-ty);

                        tx = this.xscaled+(this.wscaled/2);
                        //ty = this.yscaled+(this.hscaled/2);
                        if(this.alternative == 0){
                            ty = this.yscaled + ((this.hscaled / 4) + (textstampscaled / 2));
                        }else{
                            ty = this.yscaled + (this.hscaled / 2);
                            ty += (textstampscaled / 4);
                        }



                    }
                    ctx.textAlign = 'center';
                    ctx.fillText(this.text, tx, ty);

                    if(this.alternative == 0 ){
                        ctx.fillStyle = this.color;
                        ctx.font = "bold " + textsmallstampscaled + "pt " + "Times New Roman";
                        ty = this.yscaled +((this.hscaled/4)*3);
                        ctx.fillText(this.smalltext, tx, ty);

                    }


                    ctx.restore();
                    break;

            }
        };

        this.setinitRotatedMarkupPoint = function (width, height, x, y, anglerad) {
            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);

            var hw = x - width;
            var hh = y - height;

            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);

            var transpoint = new point(newx, newy);
            transpoint.x = width + transpoint.x;
            transpoint.y = height + transpoint.y;
            return transpoint;

        };
        /*this.setinitRotatedMarkuprect = function(width, height,absolute, anglerad){
         var origx = this.x;
         var origy = this.y;
         var origw = this.w;
         var origh = this.h;

         var cosangle = Math.cos(anglerad);
         var sinangle = Math.sin(anglerad);


         var hw = origx - width;
         var hh = origy - height;

         var newx = (hw*cosangle) - (hh*sinangle);
         var newy = (hw*sinangle) + (hh*cosangle);

         //var transpoint = new point(newx,newy);
         newx = width + newx;
         newy = height + newy;

         this.x = newx;
         this.y = newy;

         if (absolute){
         hw = origw - width;
         hh = origh - height;
         }else{
         hw = (origx + origw) - width;
         hh = (origy + origh) - height;
         }

         var neww = (hw*cosangle) - (hh*sinangle);
         var newh = (hw*sinangle) + (hh*cosangle);

         neww = width + neww;
         newh = height + newh;


         this.w = neww;
         this.h = newh;

         };*/

        //transformed coordinates for rotated canvas.
        this.setRotatedMarkuprect = function (width, height, absolute, anglerad) {


            var origx = this.rotatedrect.x;
            var origy = this.rotatedrect.y;
            var origw = this.rotatedrect.w;
            var origh = this.rotatedrect.h;

            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);


            var hw = origx - width;
            var hh = origy - height;

            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);

            //var transpoint = new point(newx,newy);
            newx = width + newx;
            newy = height + newy;

            this.rotatedrect.x = newx;
            this.rotatedrect.y = newy;

            if (absolute) {
                hw = origw - width;
                hh = origh - height;
            } else {
                if (this.type == 9 && this.subtype == 0) {
                    hw = (origx + origw) - width;
                    hh = (origy - origh) - height;
                } else {
                    hw = (origx + origw) - width;
                    hh = (origy + origh) - height;

                }
            }

            var neww = (hw * cosangle) - (hh * sinangle);
            var newh = (hw * sinangle) + (hh * cosangle);

            neww = width + neww;
            newh = height + newh;

            if (markupobject.textrotate != 0) {
                cosangle = Math.cos(markupobject.textrotate);
                sinangle = Math.sin(markupobject.textrotate);
            }

            this.rotatedrect.w = neww;
            this.rotatedrect.h = newh;

        };


        //transformed coordinates for rotated canvas.
        this.getRotatedMarkup = function (width, height, x, y, anglerad) {
            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);

            var hw = x - width;
            var hh = y - height;

            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);

            var transpoint = new point(newx, newy);
            transpoint.x = width + transpoint.x;
            transpoint.y = height + transpoint.y;
            return transpoint;

        };

        this.getMarkupSelectPointRot = function (width, height, anglerad) {

            var hw = width;
            var hh = height;

            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);
            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);
            var transpoint = new point(newx, newy);
            return transpoint;
        };


        this.getTopLeftRot = function (width, height, anglerad) {

            var hw = -width / 2;
            var hh = -height / 2;

            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);

            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);

            var transpoint = new point(newx, newy);
            return transpoint;
        };

        this.getBottomRightRot = function (width, height, anglerad) {

            var hw = width / 2;
            var hh = height / 2;

            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);
            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);
            var transpoint = new point(newx, newy);
            return transpoint;
        };

        this.getRotSelectRot = function (width, height, anglerad) {

            var hw = 0;
            var hh = (-height / 2) - 15;

            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);
            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);
            var transpoint = new point(newx, newy);
            return transpoint;
        };

        this.GetwithinCorner = function (x, y) {
            var within = false;
            var scalecorner = 0;
            var editaction = 0;
            var pagerotation = DocObj.pages[DocObj.currentpage].drotation;


            if (markupobject.rotation != 0){
                var x1 = this.LowerRightRectRot.x;
                var x2 =  this.LowerRightRectRot.w;
                var y1 = this.LowerRightRectRot.y;
                var y2 = this.LowerRightRectRot.h;
                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    scalecorner = 4;
                    editaction = 2;

                }
                x1 = this.UpperLeftRectRot.x;
                x2 =  this.UpperLeftRectRot.w;
                y1 = this.UpperLeftRectRot.y;
                y2 = this.UpperLeftRectRot.h;
                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    scalecorner = 1;
                    editaction = 2;
                }

                x1 = this.UpperRightRectRot.x;
                x2 = this.UpperRightRectRot.w;
                y1 = this.UpperRightRectRot.y;
                y2 = this.UpperRightRectRot.h;
                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    scalecorner = 2;
                    editaction = 2;
                }
                x1 = this.LowerLeftRectRot.x;
                x2 = this.LowerLeftRectRot.w;
                y1 = this.LowerLeftRectRot.y;
                y2 = this.LowerLeftRectRot.h;

                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;

                    scalecorner = 3;
                    editaction = 2;
                }

                x1 = this.RotmarkerRectRot.x;
                x2 = this.RotmarkerRectRot.w;
                y1 = this.RotmarkerRectRot.y;
                y2 = this.RotmarkerRectRot.h;

                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    scalecorner = 5;
                    editaction = 3;
                }

            }else{
                //this.LowerRightRect.x, this.LowerRightRect.w, this.LowerRightRect.y, this.LowerRightRect.h
                x1 = this.LowerRightRect.x;
                x2 =  this.LowerRightRect.w;
                y1 = this.LowerRightRect.y;
                y2 = this.LowerRightRect.h;
                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    scalecorner = 4;
                    editaction = 2;
                }
                //this.UpperLeftRect.x, this.UpperLeftRect.w, this.UpperLeftRect.y, this.UpperLeftRect.h
                x1 = this.UpperLeftRect.x;
                x2 =  this.UpperLeftRect.w;
                y1 = this.UpperLeftRect.y;
                y2 = this.UpperLeftRect.h;
                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    scalecorner = 1;
                    editaction = 2;
                }

                x1 = this.UpperRightRect.x;
                x2 = this.UpperRightRect.w;
                y1 = this.UpperRightRect.y;
                y2 = this.UpperRightRect.h;
                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    if(pagerotation == 90 || pagerotation == 270){
                        scalecorner = 3;
                    }else{
                        scalecorner = 2;
                    }

                    editaction = 2;
                }


                x1 = this.LowerLeftRect.x;
                x2 = this.LowerLeftRect.w;
                y1 = this.LowerLeftRect.y;
                y2 = this.LowerLeftRect.h;

                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    if(pagerotation == 90 || pagerotation == 270){
                        scalecorner = 2;
                    }else{
                        scalecorner = 3;
                    }

                    editaction = 2;
                }
                //this.RotmarkerRect.x, this.RotmarkerRect.w, this.RotmarkerRect.y, this.RotmarkerRect.h
                x1 = this.RotmarkerRect.x;
                x2 = this.RotmarkerRect.w;
                y1 = this.RotmarkerRect.y;
                y2 = this.RotmarkerRect.h;

                if (markupobject.Getwithin(x,y,x1,x2,y1,y2)){
                    within = true;
                    scalecorner = 5;
                    editaction = 3;
                }


            }

            return {
                within : within,
                scalecorner : scalecorner,
                editaction : editaction
            };

        };


        this.Getwithin = function (x, y, x1, x2, y1, y2) {
            var within = false;

            if (x > x1 && x < x2) {
                if (y > y1 && y < y2) {
                    within = true;
                }
            }


            return within;

        };

        this.normalizeRect = function(rect){
            var normrect = {
                x:rect.x,
                y:rect.y,
                w:rect.w,
                h:rect.h
            };
            normrect.x = Math.min(rect.x, rect.w);
            normrect.y = Math.min(rect.y, rect.h);
            normrect.w = Math.max(rect.x, rect.w);
            normrect.h = Math.max(rect.y, rect.h);

            return normrect;
        };

        this.GetwithinRect = function(x,y,rect){
            var within = false;
            if (x > rect.x && x < rect.w) {
                if (y > rect.y && y < rect.h) {
                    within = true;
                }
            }
            return within;
        };

        /*this.getBottomRightRot = function (width, height, anglerad,point){

         var hw = width /2;
         var hh = width /2

         var cosangle = Math.cos(anglerad);
         var sinangle = Math.sin(anglerad);


         switch(point){
         case 1://upper left
         hw = -width /2;
         hh = -height /2;

         break;
         case 2://lower right
         break;
         case 3: //upper right
         hw = width /2;
         hh = -height /2;
         break;
         case 4:
         hw = -widht/2;
         hh = height /2;
         break;
         case 5: //rotate point
         hw = 0;
         hh = -height/2-15;
         break;
         }

         var newx = (hw*cosangle) - (hh*sinangle);
         var newy = (hw*sinangle)+(hh*cosangle);
         var transpoint = new point(newx,newy);
         return transpoint;
         };*/

        /*function getTopLeft( width:Number, height:Number, theta:Number ) : Point
         {
         //half width and height directed appropriately (for top left)
         var hw:Number = -width / 2;
         var hh:Number = -height / 2;
         var cos:Number = Math.cos( theta );
         var sin:Number = Math.sin( theta );
         return new Point( hw * cos - hh * sin, hw * sin + hh * cos );
         }*/



        this.iswithin = function (x, y) {
            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);

            var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

            switch(DocObj.pages[DocObj.currentpage].drotation){
                case 0:
                    CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                    break;
                case 90:
                    CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation + 180) * (Math.PI / 180);
                    break;
                case 270:
                    CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation - 180) * (Math.PI / 180);
                    break;
                case 180:
                    CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                    break;
            }



            var pagedx = 0;
            var pagedy = 0;

            if (DocObj.Type == 0) {
                var docdx = DocObj.pages[0].dx;
            } else {
                docdx = DocObj.pages[DocObj.currentpage].dx;
            }

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                pagedx = DocObj.pages[DocObj.currentpage].dxvector;
                pagedy = DocObj.pages[DocObj.currentpage].dyvector;


            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                pagedx = DocObj.pages[DocObj.currentpage].dxpdf;
                pagedy = DocObj.pages[DocObj.currentpage].dypdf;

            } else {
                pagedx = docdx;
                pagedy = DocObj.pages[DocObj.currentpage].dy;
            }

            var scalefactor = DocObj.pages[DocObj.currentpage].dscale / this.scaling;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                scalefactor = DocObj.pages[DocObj.currentpage].dscalevector / markupobject.scaling;
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) / markupobject.scaling;

            } else {
                scalefactor = DocObj.pages[DocObj.currentpage].dscale / markupobject.scaling;
            }


            //markupobject.SetDimensions(scalefactor,DocObj.pages[DocObj.currentpage].drotation);

            var centerx = this.xscaled + (this.wscaled / 2);
            var centery = this.yscaled + (this.hscaled / 2);

            var rotX = 0.0;
            var rotY = 0.0;

            var xscaledpoint = 0.0;
            var yscaledpoint = 0.0;

            var nodeselectsize = 8;


            var rotaneg = 0.0;
            if (markupobject.rotation != 0) {
                rotaneg = markupobject.rotation;
                var rotpoint = markupobject.getBottomRightRot(this.wscaled, this.hscaled, rotaneg);
                rotX = rotpoint.x;
                rotY = rotpoint.y;
                var rotXLower = centerx + rotX;
                var rotYLower = centery + rotY;
                rotpoint = markupobject.getRotSelectRot(this.wscaled, this.hscaled, rotaneg);
                var rotXSelect = centerx + rotpoint.x;
                var rotYSelect = centery + rotpoint.y;

            }


            var within = false;
            var orgmousepoint = {x:x,y:y};
            //var pagerotation = DocObj.pages[DocObj.currentpage].drotation;

            if (DocObj.pages[DocObj.currentpage].drotation != 0) {
                var rotmousepoint = markupobject.getRotatedMarkup(centercanvX, centercanvY, x, y, CanvRotRad);
                x = rotmousepoint.x;
                y = rotmousepoint.y;

            }else{
                //rotmousepoint.x = x;
                //rotmousepoint.y = y;
            }

            var extentx = Math.min(this.xscaled, this.xscaled + this.wscaled);
            var extentw = Math.max(this.xscaled, this.xscaled + this.wscaled);
            var extenty = Math.min(this.yscaled, this.yscaled + this.hscaled);
            var extenth = Math.max(this.yscaled, this.yscaled + this.hscaled);

            var extentxabs = Math.min(this.xscaled, this.wscaled);
            var extentwabs = Math.max(this.xscaled, this.wscaled);
            var extentyabs = Math.min(this.yscaled, this.hscaled);
            var extenthabs = Math.max(this.yscaled, this.hscaled);


            var checktype = this.type;

            //if(checktype == 1 && this.subtype == 2){checktype = 8};

            switch (checktype) {
                case 0:

                    /*this.wscaled = (this.w - this.xoffset) * scalefactor;
                     this.hscaled = (this.h - this.yoffset) * scalefactor;

                     this.wscaled = this.wscaled + DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled = this.hscaled + DocObj.pages[DocObj.currentpage].dy;*/


                    //xscaled = xscaled + dx;
                    //yscaled = yscaled + dy;


                    if (x > this.xscaled && x < this.wscaled) {
                        if (y > this.yscaled && y < this.hscaled) {
                            within = true;
                            this.editaction = 1;
                        }
                    }
                    //within lower right scaling area (disabled for this type)
                    if (x > (this.wscaled - markersize) && x < (this.wscaled + markersize)) {
                        if (y > (this.hscaled - markersize) && y < (this.hscaled + markersize)) {
                            within = true;
                            //this.editaction = 2;
                            //this.scalecorner = 4;
                        }
                    }

                    break;
                case 1:


                    var mp = {
                        x:x,
                        y:y
                    };

                    var lp1 = {
                        x:this.xscaled,
                        y:this.yscaled
                    };

                    var lp2 = {
                        x:this.wscaled,
                        y:this.hscaled
                    };

                    var epsilon = {
                        x : lp1.x - ((lp2.x - lp1.x) / 10),
                        y : lp2.y - ((lp2.y - lp1.y) / 2)
                    };


                    if (markupobject.subtype == 2){
                        within = insidepolygon(scalefactor,pagedx,pagedy,markupobject.xoffset,markupobject.yoffset,markupobject.sides,mp,epsilon);
                        this.editaction = 1;
                    }else{
                        if (x > this.xscaled && x < this.wscaled) {
                            if (y > this.yscaled && y < this.hscaled) {
                                within = true;
                                this.editaction = 1;
                            }
                        }
                        var counter = 0;
                        for (counter = 0; counter < markupobject.points.length; counter++) {
                            xscaledpoint = (markupobject.points[counter].x - this.xoffset) * scalefactor;
                            yscaledpoint = (markupobject.points[counter].y - this.yoffset) * scalefactor;

                            xscaledpoint = xscaledpoint + pagedx;
                            yscaledpoint = yscaledpoint + pagedy;

                            if(counter == markupobject.points.length-1){
                                var nxtxscaledpoint = (markupobject.points[0].x - this.xoffset) * scalefactor;
                                var nxtyscaledpoint = (markupobject.points[0].y - this.yoffset) * scalefactor;

                                nxtxscaledpoint += pagedx;
                                nxtyscaledpoint += pagedy;
                                var point1no = counter;
                                var point2no = 0;

                            }else{

                                nxtxscaledpoint = (markupobject.points[counter+1].x - this.xoffset) * scalefactor;
                                nxtyscaledpoint = (markupobject.points[counter+1].y - this.yoffset) * scalefactor;

                                nxtxscaledpoint += pagedx;
                                nxtyscaledpoint += pagedy;

                                point1no = counter;
                                point2no = counter+1;

                            }
                                mp = {
                                    x:x,
                                    y:y
                                };

                                lp1 = {
                                    x:xscaledpoint,
                                    y:yscaledpoint
                                };

                                lp2 = {
                                    x:nxtxscaledpoint,
                                    y:nxtyscaledpoint
                                };


                            if (distToSegment(mp, lp1, lp2) < 5) {
                                within = true;
                                //new select line segment action
                                markupobject.editaction = 1;
                                //markupobject.linesegment = {p1 : point1no, p2 : point2no};
                                //return within;
                            }
                        }//end for

                        //within lower right scaling area (disabled for this type)
                        /*if (x > (this.wscaled - markersize) && x < (this.wscaled + markersize)) {
                         if (y > (this.hscaled - markersize) && y < (this.hscaled + markersize)) {
                         within = true;
                         //this.editaction = 2;
                         //this.scalecorner = 4;
                         }
                         }*/

                    }


                    if (markupobject.selectedit) {
                        counter = 0;
                        for (counter = 0; counter < markupobject.points.length; counter++) {
                            xscaledpoint = (markupobject.points[counter].x - this.xoffset) * scalefactor;
                            yscaledpoint = (markupobject.points[counter].y - this.yoffset) * scalefactor;

                            xscaledpoint = xscaledpoint + pagedx;
                            yscaledpoint = yscaledpoint + pagedy;

                            if(counter == markupobject.points.length-1){
                                var nxtxscaledpoint = (markupobject.points[0].x - this.xoffset) * scalefactor;
                                var nxtyscaledpoint = (markupobject.points[0].y - this.yoffset) * scalefactor;

                                nxtxscaledpoint += pagedx;
                                nxtyscaledpoint += pagedy;
                                var point1no = counter;
                                var point2no = 0;

                            }else{

                                nxtxscaledpoint = (markupobject.points[counter+1].x - this.xoffset) * scalefactor;
                                nxtyscaledpoint = (markupobject.points[counter+1].y - this.yoffset) * scalefactor;

                                nxtxscaledpoint += pagedx;
                                nxtyscaledpoint += pagedy;

                                point1no = counter;
                                point2no = counter+1;

                            }
                                mp = {
                                    x:x,
                                    y:y
                                };

                                lp1 = {
                                    x:xscaledpoint,
                                    y:yscaledpoint
                                };

                                lp2 = {
                                    x:nxtxscaledpoint,
                                    y:nxtyscaledpoint
                                };


                            if (distToSegment(mp, lp1, lp2) < 5) {
                                within = true;
                                //new select line segment action
                                markupobject.editaction = 7;
                                markupobject.linesegment = {p1 : point1no, p2 : point2no};
                                //return within;
                            }

                            if (x > xscaledpoint - nodeselectsize && x < xscaledpoint + nodeselectsize) {
                                if (y > yscaledpoint - nodeselectsize && y < yscaledpoint + nodeselectsize) {
                                    within = true;
                                    markupobject.selectedpoint = counter;
                                    markupobject.editaction = 4;
                                    break;
                                }
                            }


                        }
                        return within;
                    }

                    /*if (markupobject.selectedit) {
                        var counter = 0;
                        for (counter = 0; counter < markupobject.points.length; counter++) {
                            xscaledpoint = (markupobject.points[counter].x - this.xoffset) * scalefactor;
                            yscaledpoint = (markupobject.points[counter].y - this.yoffset) * scalefactor;

                            xscaledpoint = xscaledpoint + pagedx;
                            yscaledpoint = yscaledpoint + pagedy;


                            if (x > xscaledpoint - nodeselectsize && x < xscaledpoint + nodeselectsize) {
                                if (y > yscaledpoint - nodeselectsize && y < yscaledpoint + nodeselectsize) {
                                    within = true;
                                    markupobject.selectedpoint = counter;
                                    markupobject.editaction = 4;
                                }
                            }


                        }

                    }*/
                    break;
                case 2:

                    if (x > this.xscaled && x < this.wscaled) {
                        if (y > this.yscaled && y < this.hscaled) {
                            within = true;
                            this.editaction = 1;
                        }
                    }
                    //within lower right scaling area (disabled for this type)
                    if (x > (this.wscaled - markersize) && x < (this.wscaled + markersize)) {
                        if (y > (this.hscaled - markersize) && y < (this.hscaled + markersize)) {
                            within = true;
                            //this.editaction = 2;
                            //this.scalecorner = 4;
                        }
                    }
                    if (markupobject.selectedit) {
                        counter = 0;
                        for (counter = 0; counter < markupobject.points.length; counter++) {
                            xscaledpoint = (markupobject.points[counter].x - this.xoffset) * scalefactor;
                            yscaledpoint = (markupobject.points[counter].y - this.yoffset) * scalefactor;

                            xscaledpoint = xscaledpoint + pagedx;
                            yscaledpoint = yscaledpoint + pagedy;


                            if (x > xscaledpoint - nodeselectsize && x < xscaledpoint + nodeselectsize) {
                                if (y > yscaledpoint - nodeselectsize && y < yscaledpoint + nodeselectsize) {
                                    within = true;
                                    markupobject.selectedpoint = counter;
                                    markupobject.editaction = 4;
                                }
                            }


                        }

                    }
                    break;

                case 3:

                    if (markupobject.Getwithin(x, y, extentx, extentw, extenty, extenth)) {
                        within = true;
                        this.editaction = 1;

                    }
                    var selectcorner = markupobject.GetwithinCorner(orgmousepoint.x, orgmousepoint.y);

                    if (selectcorner.within){
                        within = true;
                        this.editaction = selectcorner.editaction;
                        this.scalecorner = selectcorner.scalecorner;
                    }




                    break;
                case 4:

                 if(this.subtype == 1){

                    var xdiff = Math.max(this.xscaled, this.wscaled) - Math.min(this.xscaled, this.wscaled);
                    var ydiff = Math.max(this.yscaled, this.hscaled) - Math.min(this.yscaled, this.hscaled);

                    var radius = markupobject.getdiag(xdiff, ydiff);

                    if (Math.sqrt((x-this.xscaled)*(x-this.xscaled) + (y-this.yscaled)*(y-this.yscaled)) < radius){
                        within = true;
                        this.editaction = 1;
                    }

                    //within lower right scaling area
                    var xlr = this.wscaled;
                    var ylr = this.hscaled;

                    var xlrl = xlr - markersize;
                    var xlrr = xlr + markersize;

                    var ylrl = ylr - markersize;
                    var ylrr = ylr + markersize;

                    if (x > (xlrl) && x < (xlrr)) {
                        if (y > (ylrl) && y < (ylrr)) {
                            within = true;
                            this.editaction = 2;
                            this.scalecorner = 4;
                        }
                    }

                 }else{
                    if (markupobject.Getwithin(x, y, extentx, extentw, extenty, extenth)) {
                        within = true;
                        this.editaction = 1;

                    }

                    selectcorner = markupobject.GetwithinCorner(orgmousepoint.x, orgmousepoint.y);

                    if (selectcorner.within){
                        within = true;
                        this.editaction = selectcorner.editaction;
                        this.scalecorner = selectcorner.scalecorner;
                    }

                 }


                    break;

                case 5:

                    if (markupobject.Getwithin(x, y, extentx, extentw, extenty, extenth)) {
                        within = true;
                        this.editaction = 1;

                    }
                    selectcorner = markupobject.GetwithinCorner(orgmousepoint.x, orgmousepoint.y);

                    if (selectcorner.within){
                        within = true;
                        this.editaction = selectcorner.editaction;
                        this.scalecorner = selectcorner.scalecorner;
                    }


                    break;
                case 6: //line, arrow

                    /*this.wscaled = (this.w - this.xoffset) * scalefactor;
                     this.hscaled = (this.h - this.yoffset) * scalefactor;


                     this.wscaled = this.wscaled + DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled = this.hscaled + DocObj.pages[DocObj.currentpage].dy;*/

                    //                  xscaled = xscaled + dx;
                    //                  yscaled = yscaled + dy;


                    /*if (x> extentxabs && x<extentwabs ){
                     if (y> extentyabs && y<extenthabs){
                     within = true;
                     this.editaction = 1;
                     }
                     }*/
                    mp = {
                        x:x,
                        y:y
                    };

                    lp1 = {
                        x:this.xscaled,
                        y:this.yscaled
                    };

                    lp2 = {
                        x:this.wscaled,
                        y:this.hscaled
                    };
                    if (distToSegment(mp, lp1, lp2) < 10) {
                        within = true;
                        this.editaction = 1;
                    }


                    /*if (x> extentxabs && x<extentwabs ){
                     if (this.yscaled == this.hscaled || Math.abs(this.yscaled - this.hscaled) < markersize ){
                     if (y> this.yscaled - markersize && y<this.hscaled + markersize){
                     within = true;
                     this.editaction = 1;
                     }

                     }
                     if (this.yscaled < this.hscaled){

                     if (y> this.yscaled && y<this.hscaled){
                     within = true;
                     this.editaction = 1;
                     }
                     }else{
                     if (y> this.hscaled && y<this.yscaled){
                     within = true;
                     this.editaction = 1;
                     }

                     }

                     }*/
                    //within lower right scaling area
                    if (x > (this.wscaled - markersize) && x < (this.wscaled + markersize)) {
                        if (y > (this.hscaled - markersize) && y < (this.hscaled + markersize)) {
                            if (this.subtype != 6){
                                within = true;
                                this.editaction = 2;
                                this.scalecorner = 4;
                            }
                        }
                    }
                    //within upper left scaling area
                    if (x > (this.xscaled - markersize) && x < (this.xscaled + markersize)) {
                        if (y > (this.yscaled - markersize) && y < (this.yscaled + markersize)) {
                            if (this.subtype != 6){
                                within = true;
                                this.editaction = 2;
                                this.scalecorner = 4;

                            }
                        }

                    }
                    //within upper left scaling area
                    if (x > (this.xscaled - markersize) && x < (this.xscaled + markersize)) {
                        if (y > (this.yscaled - markersize) && y < (this.yscaled + markersize)) {
                            within = true;
                            this.editaction = 2;
                            this.scalecorner = 1;
                        }

                    }

                    break;
                case 7: //dimention line
                    /*switch(DocObj.pages[DocObj.currentpage].currentimage){
                     case 0:
                     xscaled = xscaled + DocObj.pages[DocObj.currentpage].dx;
                     yscaled = yscaled + DocObj.pages[DocObj.currentpage].dy;
                     break;
                     case 1:
                     xscaled = xscaled + DocObj.pages[DocObj.currentpage].dxextent;
                     yscaled = yscaled + DocObj.pages[DocObj.currentpage].dyextent;

                     break;
                     }

                     this.wscaled = (this.w - this.xoffset) * scalefactor;
                     this.hscaled = (this.h - this.yoffset) * scalefactor;


                     this.wscaled = this.wscaled + DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled = this.hscaled + DocObj.pages[DocObj.currentpage].dy;*/

                    //                  xscaled = xscaled + dx;
                    //                  yscaled = yscaled + dy;

                    mp = {
                        x:x,
                        y:y
                    };

                    lp1 = {
                        x:this.xscaled,
                        y:this.yscaled
                    };

                    lp2 = {
                        x:this.wscaled,
                        y:this.hscaled
                    };
                    if (distToSegment(mp, lp1, lp2) < 10) {
                        within = true;
                        this.editaction = 1;
                    }
                    /*if (x> extentxabs && x<extentwabs ){
                     if (this.yscaled == this.hscaled || Math.abs(this.yscaled - this.hscaled) < markersize ){
                     if (y> this.yscaled - markersize && y<this.hscaled + markersize){
                     within = true;
                     this.editaction = 1;
                     }

                     }
                     if (this.yscaled < this.hscaled){

                     if (y> this.yscaled && y<this.hscaled){
                     within = true;
                     this.editaction = 1;
                     }
                     }else{
                     if (y> this.hscaled && y<this.yscaled){
                     within = true;
                     this.editaction = 1;
                     }

                     }

                     }*/
                    //within lower right scaling area
                    if (x > (this.wscaled - markersize) && x < (this.wscaled + markersize)) {
                        if (y > (this.hscaled - markersize) && y < (this.hscaled + markersize)) {
                            within = true;
                            this.editaction = 2;
                            this.scalecorner = 4;
                        }
                    }
                    //within upper left scaling area
                    if (x > (this.xscaled - markersize) && x < (this.xscaled + markersize)) {
                        if (y > (this.yscaled - markersize) && y < (this.yscaled + markersize)) {
                            within = true;
                            this.editaction = 2;
                            this.scalecorner = 4;
                        }

                    }
                    //within upper left scaling area
                    if (x > (this.xscaled - markersize) && x < (this.xscaled + markersize)) {
                        if (y > (this.yscaled - markersize) && y < (this.yscaled + markersize)) {
                            within = true;
                            this.editaction = 2;
                            this.scalecorner = 1;
                        }

                    }

                    //labelposition for changing leader line offset.
                    if(this.leaderoffset == 0){
                        var tx = this.xscaled + ((this.wscaled - this.xscaled) / 2);
                        var ty = this.yscaled + ((this.hscaled - this.yscaled) / 2);
                    }else{
                        tx = this.labelpos.x + ((this.labelpos.w - this.labelpos.x) / 2);
                        ty = this.labelpos.y + ((this.labelpos.h - this.labelpos.y) / 2);
                    }

                    //labelsize.w = dimtextwidth + (20 * scalefactor);
                    //labelsize.h = scaletextheight + (10 * scalefactor);
                    if(labelsize.w != 0 && labelsize.h !=0){
                        var lwsize = labelsize.w * 0.5;
                        if (x > (tx - lwsize) && x < (tx + lwsize)) {
                            if (y > (ty - lwsize) && y < (ty + lwsize)) {
                                within = true;
                                this.editaction = 6;

                                //this.scalecorner = 3;

                            }
                        }

                    }else{
                        if (x > (tx - markersize) && x < (tx + markersize)) {
                            if (y > (ty - markersize) && y < (ty + markersize)) {
                                within = true;
                                this.editaction = 6;

                                //this.scalecorner = 3;

                            }
                        }

                    }

                    /*if (x > (this.xscaled - markersize) && x < (this.xscaled + markersize)) {
                        if (y > (this.yscaled - markersize) && y < (this.yscaled + markersize)) {
                            within = true;
                            this.editaction = 2;
                            this.scalecorner = 1;
                        }

                    }*/

                    break;
                case 8:

                    /* this.wscaled = (this.w - this.xoffset) * scalefactor;
                     this.hscaled = (this.h - this.yoffset) * scalefactor;

                     this.wscaled = this.wscaled + DocObj.pages[DocObj.currentpage].dx;
                     this.hscaled = this.hscaled + DocObj.pages[DocObj.currentpage].dy;*/

                    mp = {
                        x:x,
                        y:y
                    };

                    lp1 = {
                        x:this.xscaled,
                        y:this.yscaled
                    };

                    lp2 = {
                        x:this.wscaled,
                        y:this.hscaled
                    };

                    epsilon = {
                        x : lp1.x - ((lp2.x - lp1.x) / 10),
                        y : lp2.y - ((lp2.y - lp1.y) / 2)
                    };

                    within = insidepolygon(scalefactor,pagedx,pagedy,markupobject.xoffset,markupobject.yoffset,markupobject.sides,mp,epsilon);
                    if (within){
                        this.editaction = 1;
                    }

                    /*if (x > this.xscaled && x < this.wscaled) {
                     if (y > this.yscaled && y < this.hscaled) {
                     within = true;
                     this.editaction = 1;
                     }
                     }*/
                    //within lower right scaling area (disabled for this type)
                    /*if (x > (this.wscaled - markersize) && x < (this.wscaled + markersize)) {
                        if (y > (this.hscaled - markersize) && y < (this.hscaled + markersize)) {
                            within = true;
                            //this.editaction = 2;
                            //this.scalecorner = 4;
                        }
                    }*/

                    if (markupobject.selectedit) {


                        var acounter = 0;
                        for (acounter = 0; acounter < markupobject.points.length; acounter++) {
                            xscaledpoint = (markupobject.points[acounter].x - this.xoffset) * scalefactor;
                            yscaledpoint = (markupobject.points[acounter].y - this.yoffset) * scalefactor;

                            xscaledpoint = xscaledpoint + pagedx;
                            yscaledpoint = yscaledpoint + pagedy;




                            if(acounter == markupobject.points.length-1){
                                var nxtxscaledpoint = (markupobject.points[0].x - this.xoffset) * scalefactor;
                                var nxtyscaledpoint = (markupobject.points[0].y - this.yoffset) * scalefactor;

                                nxtxscaledpoint += pagedx;
                                nxtyscaledpoint += pagedy;
                                var point1no = acounter;
                                var point2no = 0;

                            }else{

                                nxtxscaledpoint = (markupobject.points[acounter+1].x - this.xoffset) * scalefactor;
                                nxtyscaledpoint = (markupobject.points[acounter+1].y - this.yoffset) * scalefactor;

                                nxtxscaledpoint += pagedx;
                                nxtyscaledpoint += pagedy;

                                point1no = acounter;
                                point2no = acounter+1;

                            }
                                mp = {
                                    x:x,
                                    y:y
                                };

                                lp1 = {
                                    x:xscaledpoint,
                                    y:yscaledpoint
                                };

                                lp2 = {
                                    x:nxtxscaledpoint,
                                    y:nxtyscaledpoint
                                };


                            if (distToSegment(mp, lp1, lp2) < 5) {
                                within = true;
                                //new select line segment action
                                markupobject.editaction = 7;
                                markupobject.linesegment = {p1 : point1no, p2 : point2no};
                                //return within;
                            }

                            if (x > xscaledpoint - nodeselectsize && x < xscaledpoint + nodeselectsize) {
                                if (y > yscaledpoint - nodeselectsize && y < yscaledpoint + nodeselectsize) {
                                    within = true;
                                    markupobject.selectedpoint = acounter;
                                    markupobject.editaction = 4;
                                    break;
                                    //return within;
                                }
                            }

                        }//end for

                        if(markupobject.insidelabel(x,y)){
                            within = true;
                            markupobject.editaction = 8;
                        }

                        return within;
                    }


                    break;
                case 9:
                    if(this.subtype == 1 || this.subtype == 2){
                        if (markupobject.Getwithin(x, y, extentx, extentw, extenty, extenth)) {
                            within = true;
                            this.editaction = 1;



                        }
                        selectcorner = markupobject.GetwithinCorner(orgmousepoint.x, orgmousepoint.y);

                        if (selectcorner.within){
                            within = true;
                            this.editaction = selectcorner.editaction;
                            this.scalecorner = selectcorner.scalecorner;
                        }


                    }else if(this.subtype == 0){

                        this.hscaled = this.textheight * scalefactor;
                        this.wscaled = this.textwidth;
                        var wscaled = this.wscaled;
                        var hscaled = this.hscaled;
                        var switchval = wscaled;

                        switch (this.textrotate / (Math.PI / 180)) {
                            case 0:
                                if(this.subtype == 0){
                                    if (markupobject.Getwithin(x, y, this.xscaled, this.xscaled + wscaled, this.yscaled - hscaled, this.yscaled)) {
                                        within = true;
                                        this.editaction = 1;

                                    }

                                }else if(this.subtype == 1 || this.subtype == 2){
                                    if (markupobject.Getwithin(x, y, this.xscaled, this.xscaled + wscaled, this.yscaled + hscaled, this.yscaled)) {
                                        within = true;
                                        this.editaction = 1;

                                    }

                                }

                                break;
                            case 90:
                                wscaled = hscaled;
                                hscaled = switchval;
                                var mtextx1 = Math.min(this.xscaled, this.xscaled + wscaled);
                                var mtextx2 = Math.max(this.xscaled, this.xscaled + wscaled);
                                var mtexty1 = Math.min(this.yscaled, this.yscaled + hscaled);
                                var mtexty2 = Math.max(this.yscaled, this.yscaled + hscaled);

                                if (markupobject.Getwithin(x, y, mtextx1, mtextx2, mtexty1, mtexty2)) {
                                    within = true;
                                    this.editaction = 1;

                                }

                                break;
                            case 180:
                                mtextx1 = Math.min(this.xscaled, this.xscaled - wscaled);
                                mtextx2 = Math.max(this.xscaled, this.xscaled - wscaled);
                                mtexty1 = Math.min(this.yscaled, this.yscaled + hscaled);
                                mtexty2 = Math.max(this.yscaled, this.yscaled + hscaled);

                                if (markupobject.Getwithin(x, y, mtextx1, mtextx2, mtexty1, mtexty2)) {
                                    within = true;
                                    this.editaction = 1;

                                }

                                break;
                            case 270:
                                wscaled = hscaled;
                                hscaled = switchval;
                                mtextx1 = Math.min(this.xscaled, this.xscaled - wscaled);
                                mtextx2 = Math.max(this.xscaled, this.xscaled - wscaled);
                                mtexty1 = Math.min(this.yscaled, this.yscaled - hscaled);
                                mtexty2 = Math.max(this.yscaled, this.yscaled - hscaled);

                                if (markupobject.Getwithin(x, y, mtextx1, mtextx2, mtexty1, mtexty2)) {
                                    within = true;
                                    this.editaction = 1;

                                }

                                break;

                        }
                        selectcorner = markupobject.GetwithinCorner(orgmousepoint.x, orgmousepoint.y);

                        if (selectcorner.within){
                            within = true;
                            this.editaction = selectcorner.editaction;
                            this.scalecorner = selectcorner.scalecorner;
                        }


                    }

                    break;
                case 10:
                    if (x > this.xscaled && x < (this.xscaled + this.wscaled)) {
                        if (y > this.yscaled && y < (this.yscaled + this.hscaled)) {
                            //also hover over
                            within = true;
                            this.editaction = 1;
                        }
                    }

                    break;
                case 11:
                    if (markupobject.Getwithin(x, y, this.xscaled, this.xscaled + this.wscaled, this.yscaled, this.yscaled + this.hscaled)) {
                        within = true;
                        this.editaction = 1;

                    }

                    selectcorner = markupobject.GetwithinCorner(orgmousepoint.x, orgmousepoint.y);

                    if (selectcorner.within){
                        within = true;
                        this.editaction = selectcorner.editaction;
                        this.scalecorner = selectcorner.scalecorner;
                    }

                    break;
                case 12:

                    if (x > this.xscaled && x < (this.xscaled + this.wscaled)) {
                        if (y > this.yscaled && y < (this.yscaled + this.hscaled)) {
                            within = true;
                            this.editaction = 1;
                        }
                    }

                    selectcorner = markupobject.GetwithinCorner(orgmousepoint.x, orgmousepoint.y);

                    if (selectcorner.within){
                        within = true;
                        this.editaction = selectcorner.editaction;
                        this.scalecorner = selectcorner.scalecorner;
                    }



                    break;
            }

            return within;

        };

    };

    function finddoublemarkup(x, y) {
        var curmarkup = 0;
        var found = false;
        var id = -1;

        //for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
        for (curmarkup = DocObj.markupdraworder.length; curmarkup > 0; curmarkup--) {
            var curindex = DocObj.markupdraworder[curmarkup-1];

            if (DocObj.markuplist[curindex] != null) {
                if (DocObj.markuplist[curindex].iswithin(x, y) && DocObj.markuplist[curindex].signature == signature && DocObj.markuplist[curindex].display) {


                    switch (DocObj.markuplist[curindex].type) {
                        /*case 1:
                         //editpolygon
                         DocObj.markuplist[curmarkup - 1].selectedit = true;
                         DocObj.markuplist[curmarkup - 1].selected = false;
                         found = true;
                         id = DocObj.markuplist[curmarkup - 1].markupnumber;
                         break;
                         case 8:
                         //edit area
                         DocObj.markuplist[curmarkup - 1].selectedit = true;
                         DocObj.markuplist[curmarkup - 1].selected = false;
                         found = true;
                         id = DocObj.markuplist[curmarkup - 1].markupnumber;

                         break;*/
                        case 9:
                            unselelectallmarkup();
                            unselecteditmarkupall();
                            //edit text
                            DocObj.markuplist[curindex].selectedit = true;
                            DocObj.markuplist[curindex].setselect(false);

                            found = true;
                            id = DocObj.markuplist[curindex].markupnumber;

                            break;
                        case 10:
                            //unselelectallmarkup();
                            //unselecteditmarkupall();
                            //DocObj.markuplist[curmarkup - 1].selectedit = true;
                            //DocObj.markuplist[curmarkup - 1].selected = false;
                            //found = true;
                            //id = DocObj.markuplist[curmarkup - 1].markupnumber;

                            break;
                        default:
                            //DocObj.markuplist[curmarkup - 1].selected = true;
                            //found = true;
                            //id = DocObj.markuplist[curmarkup - 1].markupnumber;

                            break;

                    } //end switch

                } //end if
            } //end if
            if(found){
              break;
            }
        } //end for
        if (!found) {
            /*for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    DocObj.markuplist[curmarkup].selected = false;
                    DocObj.markuplist[curmarkup].selectedit = false;
                }

            }*/

        }


        return id;

    }

    function findmarkupHover(x, y) {
        var curmarkup = 0;
        var found = false;
        var id = -1;
        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            var curindex = DocObj.markupdraworder[curmarkup];

            if (DocObj.markuplist[curmarkup] != null) {
                if (DocObj.markuplist[curmarkup].iswithin(x, y) && DocObj.markuplist[curmarkup].display && DocObj.markuplist[curmarkup].pagenumber == DocObj.getcurPage()) {
                    found = true;
                    id = DocObj.markuplist[curmarkup].markupnumber;
                }
            }
        }

        return id;

    }

    function CopymarkupSelected() {
        var curmarkup = 0;

        if (typeof(Storage) !== "undefined") {
            localStorage.clear();
        }


        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup].selected == true || DocObj.markuplist[curmarkup].selectedit ) {

                if (bMultiselect || DocObj.getMarkupMultiselected()){
                    multiMarkupToLocalStorage(DocObj.markuplist[curmarkup]);
                }else{
                    singleMarkupToLocalStorage(DocObj.markuplist[curmarkup]);
                }

                //MarkupToLocalStorage(DocObj.markuplist[curmarkup]);
            }
        }
    }


    function getSelectedmarkup() {
        var selectedmarkup = {isempty : true};

        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup].selected || DocObj.markuplist[curmarkup].selectedit ) {
                if(DocObj.markuplist[curmarkup].bhasArrow && DocObj.markuplist[curmarkup].markupArrowConnected != null){

                    selectedmarkup = DocObj.markuplist[curmarkup].markupArrowConnected;

                }else{
                    selectedmarkup = DocObj.markuplist[curmarkup];

                }
            }
        }
        return selectedmarkup;
    }


    function ChangeMspaceColorByindx(indx,type){

        DocObj.markuplist[curmarkup].fillcolor = convertHex(markupfillcolor, DocObj.markuplist[curmarkup].transparency);


    }
    function ChangeMarkupByindx(indx,type){
        var curmarkup = 0;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup].markupnumber == indx) {

                switch (type) {
                    case 0:
                        DocObj.markuplist[curmarkup].layer = markuplayer;
                        break;
                    case 1:
                        //DocObj.markuplist[curmarkup].color = markupcolor;
                        DocObj.markuplist[curmarkup].strokecolor = convertHex(markuplinecolor, 100);

                        /*if (DocObj.markuplist[curmarkup].type == 9 && DocObj.markuplist[curmarkup].subtype == 1) {
                         DocObj.markuplist[curmarkup].textcolor = convertHex(markupcolor, DocObj.markuplist[curmarkup].transparency);
                         }

                         if (DocObj.markuplist[curmarkup].type == 9 || DocObj.markuplist[curmarkup].type == 12) {
                         else{
                         //DocObj.markuplist[curmarkup].fillcolor = convertHex(markupcolor, DocObj.markuplist[curmarkup].transparency);
                         }


                         }*/

                        break;
                    case 2:
                        DocObj.markuplist[curmarkup].linewidth = linewidthvalue;
                        if (DocObj.markuplist[curmarkup].type == 6 || DocObj.markuplist[curmarkup].type == 7) {
                            var arrowlength = nArrowSize;
                            arrowlength += linewidthvalue;
                            DocObj.markuplist[curmarkup].arrowlength = arrowlength;
                        }
                        break;
                    case 3:
                        /* background pattern */
                        DocObj.markuplist[curmarkup].alternative = fillstyle;
                        if (DocObj.markuplist[curmarkup].alternative >= 3) {
                            DocObj.markuplist[curmarkup].hatchStyle = DocObj.markuplist[curmarkup].alternative - 3;
                        }

                        break;
                    case 4:

                        //DocObj.markuplist[curmarkup].fontname = fontstylevalue;
                        DocObj.markuplist[curmarkup].font.setFontname(defaultFont.fontName);
                        DocObj.markuplist[curmarkup].font.setHeight(defaultFont.height);
                        DocObj.markuplist[curmarkup].font.setBold(defaultFont.bold);
                        DocObj.markuplist[curmarkup].font.setItalic(defaultFont.italic);

                        break;
                    case 5:
                        //DocObj.markuplist[curmarkup].rotation = markuprotation;
                        break;
                    case 6:

                        DocObj.markuplist[curmarkup].fillcolor = setTransp(DocObj.markuplist[curmarkup].fillcolor, globaltransparency);
                        DocObj.markuplist[curmarkup].strokecolor = setTransp(DocObj.markuplist[curmarkup].strokecolor, 100);
                        DocObj.markuplist[curmarkup].transparency = globaltransparency;
                        break;
                    case 7:
                        DocObj.markuplist[curmarkup].fillcolor = convertHex(markupfillcolor, DocObj.markuplist[curmarkup].transparency);
                        break;
                    case 8:
                        DocObj.markuplist[curmarkup].textcolor = convertHex(markuptextcolor, DocObj.markuplist[curmarkup].transparency);
                        break;

                }

                drawmarkupAll(cntximg);
                DrawMarkupSelected(context);


            }
        }
    }

    function SpaceidAttribute(szname, szvalue){
        var curmarkup = 0;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup].selected || DocObj.markuplist[curmarkup].selectedit) {
                if (DocObj.markuplist[curmarkup].type == 8 && DocObj.markuplist[curmarkup].subtype == 1){
                    DocObj.markuplist[curmarkup].updateAttribute(szname, szvalue);
                }
            }
        }
    }

    function ChangeMarkupSelected(type) {
        var curmarkup = 0;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup].selected || DocObj.markuplist[curmarkup].selectedit) {

                switch (type) {
                    case 0:
                        DocObj.markuplist[curmarkup].layer = markuplayer;
                        break;
                    case 1:
                        //DocObj.markuplist[curmarkup].color = markupcolor;
                        DocObj.markuplist[curmarkup].strokecolor = convertHex(markuplinecolor, 100);

                        /*if (DocObj.markuplist[curmarkup].type == 9 && DocObj.markuplist[curmarkup].subtype == 1) {
                            DocObj.markuplist[curmarkup].textcolor = convertHex(markupcolor, DocObj.markuplist[curmarkup].transparency);
                        }

                        if (DocObj.markuplist[curmarkup].type == 9 || DocObj.markuplist[curmarkup].type == 12) {
                            else{
                                //DocObj.markuplist[curmarkup].fillcolor = convertHex(markupcolor, DocObj.markuplist[curmarkup].transparency);
                            }


                        }*/

                        break;
                    case 2:
                        DocObj.markuplist[curmarkup].linewidth = linewidthvalue;
                        if (DocObj.markuplist[curmarkup].type == 6 || DocObj.markuplist[curmarkup].type == 7) {
                            var arrowlength = nArrowSize;
                            arrowlength += linewidthvalue;
                            DocObj.markuplist[curmarkup].arrowlength = arrowlength;
                        }
                        break;
                    case 3:
						/* background pattern */
                        DocObj.markuplist[curmarkup].alternative = fillstyle;
                        if (DocObj.markuplist[curmarkup].alternative >= 3) {
                            DocObj.markuplist[curmarkup].hatchStyle = DocObj.markuplist[curmarkup].alternative - 3;
                        }

                        break;
                    case 4:

                        //DocObj.markuplist[curmarkup].fontname = fontstylevalue;
                        DocObj.markuplist[curmarkup].font.setFontname(defaultFont.fontName);
                        DocObj.markuplist[curmarkup].font.setHeight(defaultFont.height);
                        DocObj.markuplist[curmarkup].font.setBold(defaultFont.bold);
                        DocObj.markuplist[curmarkup].font.setItalic(defaultFont.italic);

                        break;
                    case 5:
                        //DocObj.markuplist[curmarkup].rotation = markuprotation;
                        break;
                    case 6:

                        DocObj.markuplist[curmarkup].fillcolor = setTransp(DocObj.markuplist[curmarkup].fillcolor, globaltransparency);
                        DocObj.markuplist[curmarkup].strokecolor = setTransp(DocObj.markuplist[curmarkup].strokecolor, 100);
                        DocObj.markuplist[curmarkup].transparency = globaltransparency;
                        break;
                    case 7:
                        DocObj.markuplist[curmarkup].fillcolor = convertHex(markupfillcolor, DocObj.markuplist[curmarkup].transparency);
                        break;
                    case 8:
                        //DocObj.markuplist[curmarkup].textcolor = convertHex(markuptextcolor, DocObj.markuplist[curmarkup].transparency);
                        DocObj.markuplist[curmarkup].textcolor = convertHex(markuptextcolor, 100);
                        break;

                    case 9:

                        DocObj.markuplist[curmarkup].linestyle = nlinestyle;
                        break;

                    case 10:
                        if (DocObj.markuplist[curmarkup].type == 6 || DocObj.markuplist[curmarkup].type == 7) {

                            var arrowlength = nArrowSize;
                            arrowlength += DocObj.markuplist[curmarkup].linewidth;
                            DocObj.markuplist[curmarkup].arrowlength = arrowlength;
                        }

                        break;
                    case 11:
                        if (DocObj.markuplist[curmarkup].type == 8 || DocObj.markuplist[curmarkup].type == 7) {

                            //var arrowlength = nArrowSize;
                            DocObj.markuplist[curmarkup].font.setHeight(nLabelTextsize);
                            //arrowlength += DocObj.markuplist[curmarkup].linewidth;
                            //DocObj.markuplist[curmarkup].arrowlength = arrowlength;
                        }

                        break;
                    case 12:

                        //DocObj.markuplist[curmarkup].fillcolor = setTransp(DocObj.markuplist[curmarkup].fillcolor, globaltransparency);
                        //DocObj.markuplist[curmarkup].strokecolor = setTransp(DocObj.markuplist[curmarkup].strokecolor, 100);

                        DocObj.markuplist[curmarkup].labelfillcolor = setTransp(DocObj.markuplist[curmarkup].labelfillcolor, globaltransparency);
                        DocObj.markuplist[curmarkup].labeltransparency = globaltransparency;

                        break;


                }

                drawmarkupAll(cntximg);
                DrawMarkupSelected(context);


            }
        }

        if (type == 4 && DocObj.selectedmarkup.id != -1 && DocObj.selectedmarkup.edit && DocObj.selectedmarkup.selected){


            DocObj.markuplist[DocObj.selectedmarkup.id].font.setFontname(defaultFont.fontName);
            DocObj.markuplist[DocObj.selectedmarkup.id].font.setHeight(defaultFont.height);
            DocObj.markuplist[DocObj.selectedmarkup.id].font.setBold(defaultFont.bold);
            DocObj.markuplist[DocObj.selectedmarkup.id].font.setItalic(defaultFont.italic);

        }

    }

    function unselectmarkup(id){
        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null && DocObj.markuplist[curmarkup].markupnumber == id) {
                //DocObj.markuplist[curmarkup].selected = false;
                if(DocObj.markuplist[curmarkup].selected){
                    DocObj.markuplist[curmarkup].setselect(false);
                    DocObj.markuplist[curmarkup].bUsemouseinput = true;
                    if(RxCore_GUI_MarkupUnselect != undefined){
                        RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[curmarkup]);
                    }
                }
                if(DocObj.markuplist[curmarkup].selectedit){

                    DocObj.markuplist[curmarkup].selectedit = false;
                    DocObj.markuplist[curmarkup].bpointEdit = false;
                    DocObj.markuplist[curmarkup].bUsemouseinput = true;

                    if(RxCore_GUI_MarkupUnselect != undefined){
                        RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[curmarkup]);
                    }
                }


            }

        }

        //DocObj.setMarkupMultiselected();

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }
    function unselecteditmarkup(id) {

        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null && DocObj.markuplist[curmarkup].markupnumber != id) {
                //DocObj.markuplist[curmarkup].selected = false;
                if(DocObj.markuplist[curmarkup].selectedit){
                    DocObj.markuplist[curmarkup].selectedit = false;
                    DocObj.markuplist[curmarkup].bpointEdit = false;
                    if(RxCore_GUI_MarkupUnselect != undefined){
                        RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[curmarkup]);
                    }
                }


            }

        }

        //DocObj.setMarkupMultiselected();

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }

    function deleteUniqueMarkup(GUID){
        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            for (var curmarkup = 0; curmarkup < OpenFiles[curdoc].markuplist.length; curmarkup++) {
                if (OpenFiles[curdoc].markuplist[curmarkup] != null) {
                    if(OpenFiles[curdoc].markuplist[curmarkup].getUniqueID() == GUID){
                        MarkupSaveState(OpenFiles[curdoc].markuplist[curmarkup].markupnumber);
                        OpenFiles[curdoc].markuplist.splice(curmarkup,1);
                    }
                }
            }

        }

    }

    function findUniqueMarkup(GUID){
        var uniqueMarkup = {isempty : true};
        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            for (var curmarkup = 0; curmarkup < OpenFiles[curdoc].markuplist.length; curmarkup++) {
                if (OpenFiles[curdoc].markuplist[curmarkup] != null) {
                    if(OpenFiles[curdoc].markuplist[curmarkup].getUniqueID() == GUID){
                        uniqueMarkup = OpenFiles[curdoc].markuplist[curmarkup];
                    }
                }
            }

        }
        return uniqueMarkup;

    }
    function checkUniqueID(ID){
        var bidunique = true;
        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            for (var curmarkup = 0; curmarkup < OpenFiles[curdoc].markuplist.length; curmarkup++) {
                if (OpenFiles[curdoc].markuplist[curmarkup] != null) {
                    if(OpenFiles[curdoc].markuplist[curmarkup].getUniqueID() == ID){
                        bidunique = false;
                    }
                }
            }

        }
        return bidunique;
    }

    function unselecteditmarkupall() {

        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {
                //DocObj.markuplist[curmarkup].selected = false;
                if(DocObj.markuplist[curmarkup].selectedit){
                    DocObj.markuplist[curmarkup].selectedit = false;
                    DocObj.markuplist[curmarkup].bpointEdit = false;

                    if(RxCore_GUI_MarkupUnselect != undefined){
                        RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[curmarkup]);
                    }
                }


            }

        }
        //DocObj.setMarkupMultiselected();

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }


    function unselelectallmarkup() {
        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {



                if(DocObj.markuplist[curmarkup].selected){
                    DocObj.markuplist[curmarkup].setselect(false);
                    DocObj.markuplist[curmarkup].bUsemouseinput = true;
                    if(RxCore_GUI_MarkupUnselect != undefined){
                        RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[curmarkup]);
                    }
                }

                //DocObj.markuplist[curmarkup].selectedit = false;
            }

        }

        //DocObj.setMarkupMultiselected();

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }


    function selectSpaceMarkup(blockid, multi){

        var markupnull = {};
        var customattribs = [];
        var partlist = [];
        var selected = [];
        var spaceobj = {isempty : true};
        var curmarkup = 0;
        var id = -1;

        var spacemarkup = findSpaceMarkup(blockid);
        var bfound = (spacemarkup != undefined);

        for (curmarkup = DocObj.markuplist.length; curmarkup > 0; curmarkup--) {

            if(bfound){
                var bspaceid = (spacemarkup.markupnumber == DocObj.markuplist[curmarkup - 1].markupnumber);
            }else{
                bspaceid = false;
            }

            if (DocObj.markuplist[curmarkup - 1] != null && !bspaceid) {

                if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){


                    if(multi && DocObj.markuplist[curmarkup - 1].spaceselected){

                        id = DocObj.markuplist[curmarkup - 1].markupnumber;
                            customattribs = DocObj.markuplist[curmarkup - 1].GetAttributes();
                            spaceobj = {
                                id : id,
                                attr : customattribs,
                                isempty : false
                            };
                            selected.push(spaceobj);
                    }else{
                            DocObj.markuplist[curmarkup - 1].spaceselected = false;
                            DocObj.markuplist[curmarkup - 1].linewidth = 1;
                    }

                }
            }
        }



        if(bfound){
            id = spacemarkup.markupnumber;

            spacemarkup.spaceselected = !spacemarkup.spaceselected;

            customattribs = spacemarkup.GetAttributes();

            if (spacemarkup.spaceselected){

                spacemarkup.linewidth = 2;
                spaceobj = {
                    id : id,
                    attr : customattribs,
                    isempty : false
                };
                selected.push(spaceobj);

            }else{
                spacemarkup.linewidth = 1;
            }

        }


        if (selected.length == 0 && !spacemarkup.spaceselected){
            RxCore_animateLineStyle(false);
        }else{
            RxCore_animateLineStyle(true);
        }


        if(multi){
            if (RxCore_GUI_2DBlockID != undefined) {
                RxCore_GUI_2DBlockID.set2DBlockID(selected);
            }
        }else{
            if (RxCore_GUI_2DBlockID != undefined) {
                RxCore_GUI_2DBlockID.set2DBlockID(spaceobj);
            }
        }



        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);


    }

    function findSpaceMarkup(blockid){
        var curmarkup = 0;
        var markupobj = undefined;

        for (curmarkup = DocObj.markuplist.length; curmarkup > 0; curmarkup--) {
            if (DocObj.markuplist[curmarkup - 1] != null) {
                if (DocObj.markuplist[curmarkup - 1].display && DocObj.markuplist[curmarkup - 1].pagenumber == DocObj.getcurPage()) {

                    if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){


                        var szblockid = blockid.toString();
                        if (DocObj.markuplist[curmarkup - 1].findAttribute('SpaceID', szblockid)){
                            markupobj = DocObj.markuplist[curmarkup - 1];

                        }

                    }

                }

            }
        }

        return markupobj;

    }


    function restoreSpacemarkupStates(){
        var curmarkup = 0;
        for (curmarkup = DocObj.markuplist.length; curmarkup > 0; curmarkup--) {
            if (DocObj.markuplist[curmarkup - 1] != null) {
                if (DocObj.markuplist[curmarkup - 1].display && DocObj.markuplist[curmarkup - 1].pagenumber == DocObj.getcurPage()) {

                    if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){

                        //id = DocObj.markuplist[curmarkup - 1].markupnumber;
                        //DocObj.markuplist[curmarkup - 1].spaceselected = !DocObj.markuplist[curmarkup - 1].spaceselected;

                        DocObj.markuplist[curmarkup - 1].alternative = 0;

                    }

                }

            }
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);
    }

    function setMarkupSpaceColor(blockid, Color, override){
        var curmarkup = 0;
        var id = -1;
        var customattribs = [];
        var found = false;

        for (curmarkup = DocObj.markuplist.length; curmarkup > 0; curmarkup--) {
            if (DocObj.markuplist[curmarkup - 1] != null) {
                if (DocObj.markuplist[curmarkup - 1].display && DocObj.markuplist[curmarkup - 1].pagenumber == DocObj.getcurPage()) {

                    if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){

                        //id = DocObj.markuplist[curmarkup - 1].markupnumber;
                        //DocObj.markuplist[curmarkup - 1].spaceselected = !DocObj.markuplist[curmarkup - 1].spaceselected;

                        var szblockid = blockid.toString();
                        if (DocObj.markuplist[curmarkup - 1].findAttribute('SpaceID', szblockid)){
                            found = true;
                            if(override){
                                DocObj.markuplist[curmarkup - 1].alternative = 1;
                                DocObj.markuplist[curmarkup - 1].fillcolor = Color;

                            }else{
                                DocObj.markuplist[curmarkup - 1].alternative = 0;
                                //DocObj.markuplist[curmarkup - 1].fillcolor = Color;

                            }
                            //DocObj.markuplist[curmarkup - 1].setFillColor(Color, override);
                        }

                    }

                }

            }
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);
        return found;
    }

    function unselectAllSpaceMarkup(){
        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {

                if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){
                    DocObj.markuplist[curmarkup].spaceselected = false;
                }



                /*if(DocObj.markuplist[curmarkup].spaceselected){
                    DocObj.markuplist[curmarkup].setselect(false);
                    DocObj.markuplist[curmarkup].bUsemouseinput = true;



                    if(RxCore_GUI_MarkupUnselect != undefined){
                        RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[curmarkup]);
                    }
                }*/

                //DocObj.markuplist[curmarkup].selectedit = false;
            }

        }

        if (RxCore_GUI_2DBlockID != undefined) {
            RxCore_GUI_2DBlockID.set2DBlockID([]);
        }


        //DocObj.setMarkupMultiselected();

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }


    function unselectAllSpaces(){
        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {


                if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){
                    if(DocObj.markuplist[curmarkup].spaceselected){

                        DocObj.markuplist[curmarkup].spaceselected = false;

                    }

                }

                //DocObj.markuplist[curmarkup].selectedit = false;
            }

        }

        //DocObj.setMarkupMultiselected();

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);
    }

    function findspacemarkup(x,y, multi){
        var curmarkup = 0;
        var found = false;
        var foundwithin = false;
        var id = -1;
        var blink = false;
        var index = -1;
        var markupnull = {};
        var customattribs = [];
        var partlist = [];
        var selected = [];
        var spaceobj = {isempty : true};



        for (curmarkup = DocObj.markupdraworder.length; curmarkup > 0; curmarkup--) {

            //var curindex  = DocObj.markupdraworder[curmarkup - 1];

            if (DocObj.markuplist[curmarkup - 1] != null) {

                if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){
                    if (DocObj.markuplist[curmarkup - 1].iswithin(x, y) && DocObj.markuplist[curmarkup - 1].display && DocObj.markuplist[curmarkup - 1].pagenumber == DocObj.getcurPage()) {

                            var drawindex = curmarkup - 1;

                            foundwithin = true;
                            id = DocObj.markuplist[curmarkup - 1].markupnumber;
                            DocObj.markuplist[curmarkup - 1].spaceselected = !DocObj.markuplist[curmarkup - 1].spaceselected;
                            found = DocObj.markuplist[curmarkup - 1].spaceselected;

                            if (found){
                                DocObj.markuplist[curmarkup - 1].linewidth = 2;
                            }else{
                                DocObj.markuplist[curmarkup - 1].linewidth = 1;
                            }

                            customattribs = DocObj.markuplist[curmarkup - 1].GetAttributes();

                            spaceobj = {
                                id : id,
                                attr : customattribs,
                                isempty : false
                            };

                            /*if(multi && DocObj.markuplist[curmarkup - 1].spaceselected){
                                selected.push(spaceobj);
                            }*/


                    }else{

                        if(!multi){
                            DocObj.markuplist[curmarkup - 1].spaceselected = false;
                            DocObj.markuplist[curmarkup - 1].linewidth = 1;
                         }

                        /*if(multi && DocObj.markuplist[curmarkup - 1].spaceselected){

                            found = DocObj.markuplist[curmarkup - 1].spaceselected;

                            id = DocObj.markuplist[curmarkup - 1].markupnumber;
                            customattribs = DocObj.markuplist[curmarkup - 1].GetAttributes();
                            spaceobj = {
                                id : id,
                                attr : customattribs,
                                isempty : false
                            };

                            selected.push(spaceobj);

                        }*/

                    }
                }
                /*if (DocObj.markuplist[curmarkup - 1].iswithin(x, y) && DocObj.markuplist[curmarkup - 1].display && DocObj.markuplist[curmarkup - 1].pagenumber == DocObj.getcurPage()) {


                    if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){

                        id = DocObj.markuplist[curmarkup - 1].markupnumber;
                        DocObj.markuplist[curmarkup - 1].spaceselected = !DocObj.markuplist[curmarkup - 1].spaceselected;

                        customattribs = DocObj.markuplist[curmarkup - 1].GetAttributes();

                        spaceobj = {
                            id : id,
                            attr : customattribs
                        };

                        if(!multi){
                            if (RxCore_GUI_2DBlockInfo != undefined) {
                                RxCore_GUI_2DBlockInfo.set2DBlockInfo(spaceobj);
                            }

                        }

                    }

                }else{
                    if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){
                        DocObj.markuplist[curmarkup - 1].spaceselected = false;
                    }
                }*/


            }// end if not null
        }//end for

        //reorder draworder array to find another markup on second select
        //var tempentry = DocObj.markupdraworder[drawindex];
        //var lastentry = DocObj.markupdraworder[DocObj.markupdraworder.length - 1];
        //DocObj.markupdraworder[DocObj.markupdraworder.length - 1] = tempentry;
        //DocObj.markupdraworder[drawindex] = lastentry;

        for (curmarkup = DocObj.markuplist.length; curmarkup > 0; curmarkup--) {


            if (DocObj.markuplist[curmarkup - 1] != null) {

                if(DocObj.markuplist[curmarkup - 1].type == 8 && DocObj.markuplist[curmarkup - 1].subtype == 1){

                    if(!multi && spaceobj.id != DocObj.markuplist[curmarkup - 1].markupnumber){
                        DocObj.markuplist[curmarkup - 1].spaceselected = false;
                    }

                    if(multi && DocObj.markuplist[curmarkup - 1].spaceselected){
                        found = DocObj.markuplist[curmarkup - 1].spaceselected;
                        id = DocObj.markuplist[curmarkup - 1].markupnumber;
                            customattribs = DocObj.markuplist[curmarkup - 1].GetAttributes();
                            spaceobj = {
                                id : id,
                                attr : customattribs,
                                isempty : false
                            };
                            selected.push(spaceobj);
                    }

                }
            }
        }

        if(multi){

            if (RxCore_GUI_2DBlockID != undefined) {
                RxCore_GUI_2DBlockID.set2DBlockID(selected);
            }

        }else{
            if (RxCore_GUI_2DBlockID != undefined) {
                RxCore_GUI_2DBlockID.set2DBlockID(spaceobj);
            }

        }

        if(!bAnimateLineStyle){
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);
        }

        return {found : found, within : foundwithin};

    }

    function findmarkup(x, y, bCanSelectSpace) {
        var curmarkup = 0;
        var found = false;
        var id = -1;
        var blink = false;
        var index = -1;
        var locked = false;
        var markupnull = {};
        var foundmarkup = [];

        DocObj.setMarkupMultiselected();

        if(!bMultiselect && !DocObj.getMarkupMultiselected()){
            unselelectallmarkup();
        }

        // && !DocObj.markuplist[curmarkup - 1].locked
        //for (curmarkup=0;curmarkup<DocObj.markuplist.length;curmarkup--){
        for (curmarkup = DocObj.markupdraworder.length; curmarkup > 0; curmarkup--) {

            var curindex  = DocObj.markupdraworder[curmarkup - 1];

            if (DocObj.markuplist[curindex] != null) {
                if (DocObj.markuplist[curindex].iswithin(x, y) && DocObj.markuplist[curindex].display && DocObj.markuplist[curindex].pagenumber == DocObj.getcurPage()) {

                    var drawindex = curmarkup - 1;
                    foundmarkup.push(drawindex);

                    if(DocObj.markuplist[curindex].bhaveLink && (DocObj.bMarkupLocked || DocObj.markuplist[curindex].locked)){
                        found = false;
                        blink = true;
                        id = DocObj.markuplist[curindex].markupnumber;
                        index = curindex;
                        locked = DocObj.markuplist[curindex].locked;
                        break;
                    }
                    if(DocObj.markuplist[curindex].signature == signature){
                        if (DocObj.markuplist[curindex].selectedit) {
                            DocObj.markuplist[curindex].setselect(false);
                            DocObj.markuplist[curindex].bUsemouseinput = true;
                            found = true;
                            id = DocObj.markuplist[curindex].markupnumber;

                            if(DocObj.markuplist[curindex].editaction == 4 || DocObj.markuplist[curindex].editaction == 8){
                                break;
                            }

                            //DocObj.markuplist[curmarkup].lastselected = false;
                        } else {

                            if (DocObj.markuplist[curindex].editaction == 2 || DocObj.markuplist[curindex].editaction == 3){
                                DocObj.markuplist[curindex].setselect(true);
                                DocObj.markuplist[curindex].bUsemouseinput = true;
                                found = true;
                                id = DocObj.markuplist[curindex].markupnumber;
                                break;
                            }

                            if(!bMultiselect && !DocObj.markuplist[curindex].selected) {
                                unselelectallmarkup();
                            }

                            switch (DocObj.markuplist[curindex].type) {
                                case 1:
                                    //editpolygon
                                    DocObj.markuplist[curindex].selectedit = true;
                                    DocObj.markuplist[curindex].setselect(false);
                                    DocObj.markuplist[curindex].bUsemouseinput = true;
                                    DocObj.markuplist[curindex].lastselected = true;
                                    found = true;
                                    id = DocObj.markuplist[curindex].markupnumber;
                                    index = curindex;
                                    DocObj.markuplist[curindex].lengthangleCallbackSelect();


                                    break;
                                case 8:

                                    if(bCanSelectSpace || DocObj.markuplist[curindex].subtype != 1){
                                        DocObj.markuplist[curindex].selectedit = true;
                                        DocObj.markuplist[curindex].setselect(false);
                                        DocObj.markuplist[curindex].bUsemouseinput = true;
                                        DocObj.markuplist[curindex].lastselected = true;
                                        found = true;
                                        id = DocObj.markuplist[curindex].markupnumber;
                                        index = curindex;

                                        DocObj.markuplist[curindex].lengthangleCallbackSelect();


                                    } //edit area

                                    break;
                                default:


                                    DocObj.markuplist[curindex].setselect(true);
                                    DocObj.markuplist[curindex].lastselected = true;



                                    found = true;
                                    id = DocObj.markuplist[curindex].markupnumber;
                                    index = curindex;
                                    //add markup angle lenght callback;

                                    DocObj.markuplist[curindex].lengthangleCallbackSelect();

                                    break;

                            } //end switch


                            //id = DocObj.markuplist[curmarkup-1].markupnumber;

                            //break;


                        }
                    }



                    /*found = true;
                     id = DocObj.markuplist[curmarkup].markupnumber;
                     break;*/
                }

            }
        }

        for (var foundc = 0;  foundc < foundmarkup.length; foundc++ ){
            var tempentry = DocObj.markupdraworder[foundmarkup[foundc]];
            var lastentry = DocObj.markupdraworder[DocObj.markupdraworder.length - 1];
            DocObj.markupdraworder[DocObj.markupdraworder.length - 1] = tempentry;
            DocObj.markupdraworder[foundmarkup[foundc]] = lastentry;
        }
        //var tempentry = DocObj.markupdraworder[drawindex];





        if(!bMultiselect && !DocObj.getMarkupMultiselected()){
            unselecteditmarkup(id);
        }


        if (!found) {

            if (RxCore_GUI_Markup != undefined) {
                if (id == -1){
                    RxCore_GUI_Markup.setMarkupSelected(id, {created : false, modified : false, deleted : false});
                }else{
                    var btextboxleader = (DocObj.markuplist[index].type == 9 &&  DocObj.markuplist[index].subtype == 2);
                    if(!btextboxleader){
                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index], {created : false, modified : false, deleted : false});
                    }else{
                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index].markupArrowConnected, {created : false, modified : false, deleted : false});
                    }

                }

            }

            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    DocObj.markuplist[curmarkup].setselect(false);
                    DocObj.markuplist[curmarkup].bUsemouseinput = true;
                    DocObj.markuplist[curmarkup].selectedit = false;
                    DocObj.markuplist[curmarkup].bpointEdit = false;
                    DocObj.markuplist[curmarkup].resetcupoint();


                }

            }

        } else {
            if (RxCore_GUI_Markup != undefined && DocObj.markuplist[index] != undefined) {

                btextboxleader = (DocObj.markuplist[index].type == 9 &&  DocObj.markuplist[index].subtype == 2);

                if(btextboxleader){
                    RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index].markupArrowConnected, {created : false, modified : true, deleted : false});
                }else{
                    RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index], {created : false, modified : true, deleted : false});
                }

            }



        }
        //add multiselect state here.
        DocObj.setMarkupMultiselected();


        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
            /* Andriy Notify */
            // RxCore_GUI_Markuplist.notify();

        }

        return {
            id : id,
            blink : blink,
            index : index,
            locked : locked
        };

    }

    function moveToFront() {
        /* Andriy: it can be declared in for loop, no need to set to 0 twice */
        // var curmarkup = 0;

        var id = -1;

        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {
                if (!DocObj.markuplist[curmarkup].selected && !DocObj.markuplist[curmarkup].selectedit) {

                } else {
                    id = DocObj.markuplist[curmarkup].markupnumber;
                    MarkupSaveState(id);

                    var tempmarkup = DocObj.markuplist[curmarkup];
                    DocObj.markuplist[curmarkup] = DocObj.markuplist[DocObj.markuplist.length - 1];
                    DocObj.markuplist[DocObj.markuplist.length - 1] = tempmarkup;

                    break;
                }

            }
        }


        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
        }
        if (RxCore_GUI_pagethumbs != undefined) {
            RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);
    }

    function moveToBack() {
        /* Andriy: it can be declared in for loop, no need to set to 0 twice */
        // var curmarkup = 0;
        var id = -1;

        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {
                if (!DocObj.markuplist[curmarkup].selected && !DocObj.markuplist[curmarkup].selectedit) {

                } else {
                    id = DocObj.markuplist[curmarkup].markupnumber;
                    var tempmarkup = DocObj.markuplist[curmarkup];
                    DocObj.markuplist[curmarkup] = DocObj.markuplist[0];
                    DocObj.markuplist[0] = tempmarkup;
                    MarkupSaveState(id);
                    break;
                }

            }
        }


        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
        }
        if (RxCore_GUI_pagethumbs != undefined) {
            RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);
    }

    function undoremovemarkup(id){
        var curmarkup = 0;
        var deletedmarkup = 0;
        var markupcount = 0;

        var tempmarkuplist = [];

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null ) {

                var bOwned = (DocObj.markuplist[curmarkup].signature == signature);
                if(id == DocObj.markuplist[curmarkup].markupnumber){
                    if (RxCore_GUI_Markup != undefined) {
                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[curmarkup], {created : false, modified : false, deleted : true});
                    }

                }else{
                    tempmarkuplist[markupcount] = DocObj.markuplist[curmarkup];
                    markupcount++;
                }

            }
        }

        DocObj.markuplist = tempmarkuplist;
        DocObj.nummarkups = DocObj.markuplist.length;

        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
        }

        if (RxCore_GUI_pagethumbs != undefined) {
            RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }

    function deletemarkup() {
        var curmarkup = 0;
        var deletedmarkup = 0;
        var markupcount = 0;
        var id = -1;
        //var tempmarkuplistsel = new Array();
        var tempmarkuplist = [];
        DocObj.markupdraworder = [];

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            //DocObj.markuplist[curmarkup].usser
            if (DocObj.markuplist[curmarkup] != null ) {
                var bOwned = (DocObj.markuplist[curmarkup].signature == signature);
                //console.log(DocObj.markuplist[curmarkup].selected, DocObj.markuplist[curmarkup].selectedit);

                if(bOwned && (DocObj.markuplist[curmarkup].selected || DocObj.markuplist[curmarkup].selectedit)){
                    id = DocObj.markuplist[curmarkup].markupnumber;
                    MarkupSaveState(id);
                    if (RxCore_GUI_Markup != undefined) {
                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[curmarkup], {created : false, modified : false, deleted : true});
                    }
                }else{
                    tempmarkuplist[markupcount] = DocObj.markuplist[curmarkup];
                    DocObj.markupdraworder[markupcount] = markupcount;
                    markupcount++;
                }

                /*if (!DocObj.markuplist[curmarkup].selected && !DocObj.markuplist[curmarkup].selectedit ) {
                    //id = DocObj.markuplist[curmarkup].markupnumber;
                    //MarkupSaveState(id);

                    tempmarkuplist[markupcount] = DocObj.markuplist[curmarkup];
                    markupcount++;
                } else {
                    id = DocObj.markuplist[curmarkup].markupnumber;
                    MarkupSaveState(id);

                }*/

            }
        }
        //DocObj.markuplist = [];
        DocObj.markuplist = tempmarkuplist;
        DocObj.nummarkups = DocObj.markuplist.length;

        /*    for (deletedmarkup=0;deletedmarkup<tempmarkuplist.length;deletedmarkup++){
         //delete DocObj.markuplist[tempmarkuplist[deletedmarkup]];
         //DocObj.markuplist.splice(tempmarkuplist[deletedmarkup],1);
         }*/

        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
            /* Andriy */
            // RxCore_GUI_Markuplist.notify();

        }
        if (RxCore_GUI_pagethumbs != undefined) {
            RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);
    }

    function drawmarkupMagnify(ctx,page,dx,dy,dscale,drotation){
        var curmarkup = 0;
        if (DocObj.Drawmarkup) {
            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].pagenumber == page) {
                        if (DocObj.markuplist[curmarkup].display) {
                            DocObj.markuplist[curmarkup].drawprint(ctx,dx,dy,dscale,drotation,false);

                        }
                    }
                }
            }
        }
    }

    function drawmarkupPrint(ctx,page,dx,dy,dscale){
        var curmarkup = 0;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {
                if (DocObj.markuplist[curmarkup].pagenumber == page) {
                    if (DocObj.markuplist[curmarkup].display) {
                        DocObj.markuplist[curmarkup].drawprint(ctx,dx,dy,dscale,0,false);

                    }
                }
            }
        }
        if(RxCore_GUI_printpage != undefined){
            RxCore_GUI_printpage.printpageComplete(DocObj.pages[page].printobj);
        }



    }

    function getlastmarkupnumber(){
        var curmarkup = 0;
        var curmarkupnum = 0;
        var prevmarkupnum = 0;
        var nextnumber = 0;
        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {
                if(curmarkup == 0){
                    curmarkupnum = DocObj.markuplist[curmarkup].markupnumber;
                    prevmarkupnum = curmarkupnum;
                    nextnumber = curmarkupnum + 1;
                }else{
                    curmarkupnum = DocObj.markuplist[curmarkup].markupnumber;
                    if(prevmarkupnum < curmarkupnum){
                        nextnumber = curmarkupnum + 1;
                    }else{
                        nextnumber = prevmarkupnum + 1;
                    }
                    prevmarkupnum = curmarkupnum;
                }
            }
        }
        return nextnumber;

    }

    function hidemarkupAll(onOff){
        var curmarkup = 0;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup] != null) {

                if (DocObj.markuplist[curmarkup].type == 0 && DocObj.markuplist[curmarkup].subtype == 1) {

                }else{
                    DocObj.markuplist[curmarkup].display = onOff;
                }

            }

        }

    }

    function drawmarkupAll(ctx) {

        var curmarkup = 0;
        ctx.clearRect(0, 0, canvasowidth, canvasoheight);
        DocObj.pages[DocObj.currentpage].draw_thumbnail();

        if (bSuspendDraw){
            return;
        }


        if (DocObj.Drawmarkup) {

            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].pagenumber == DocObj.getcurPage()) {
                        if (!DocObj.markuplist[curmarkup].selected && !DocObj.markuplist[curmarkup].selectedit) {
                            if (DocObj.markuplist[curmarkup].display) {
                                DocObj.markuplist[curmarkup].drawthumb(DocObj.pages[DocObj.currentpage].thumbctx);
                                DocObj.markuplist[curmarkup].drawmescaled(ctx);
                            }

                        }

                    }
                }

            }

        } else {
            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].pagenumber == DocObj.getcurPage()) {
                        if (DocObj.markuplist[curmarkup].type == 0 && DocObj.markuplist[curmarkup].subtype == 1) {
                            if (DocObj.markuplist[curmarkup].display) {
                                DocObj.markuplist[curmarkup].drawthumb(DocObj.pages[DocObj.currentpage].thumbctx);
                                DocObj.markuplist[curmarkup].drawmescaled(ctx);
                            }

                        }
                    }
                }

            }

        }

    }

    function DrawMarkupSelected(ctx) {
        var curmarkup = 0;
        ctx.clearRect(0, 0, canvasowidth, canvasoheight);

        if (DocObj.Drawmarkup) {
            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].pagenumber == DocObj.getcurPage()) {
                        if (DocObj.markuplist[curmarkup].selected || DocObj.markuplist[curmarkup].selectedit) {
                            if (DocObj.markuplist[curmarkup].display) {
                                DocObj.markuplist[curmarkup].drawthumb(DocObj.pages[DocObj.currentpage].thumbctx);
                                DocObj.markuplist[curmarkup].drawmescaled(ctx);
                            }

                        }
                    }
                }

            }

        } else {
            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].pagenumber == DocObj.getcurPage()) {
                        if (DocObj.markuplist[curmarkup].type == 0 && DocObj.markuplist[curmarkup].subtype == 1) {
                            if (DocObj.markuplist[curmarkup].display) {
                                DocObj.markuplist[curmarkup].drawthumb(DocObj.pages[DocObj.currentpage].thumbctx);
                                DocObj.markuplist[curmarkup].drawmescaled(ctx);
                            }

                        }
                    }
                }

            }
        }


    }

    function drawSpaceSelected(ctx){
        var curmarkup = 0;
        var bisSpace = false;
        ctx.clearRect(0, 0, canvasowidth, canvasoheight);

        if (DocObj.Drawmarkup) {
            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].pagenumber == DocObj.getcurPage()) {
                        if (DocObj.markuplist[curmarkup].spaceselected) {
                            bisSpace = (DocObj.markuplist[curmarkup].type == 8 && DocObj.markuplist[curmarkup].subtype == 1)
                            if (DocObj.markuplist[curmarkup].display && bisSpace) {
                                DocObj.markuplist[curmarkup].drawmescaled(ctx);
                            }
                        }
                    }
                }

            }

        } else {
            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {
                    if (DocObj.markuplist[curmarkup].pagenumber == DocObj.getcurPage()) {
                        if (DocObj.markuplist[curmarkup].type == 0 && DocObj.markuplist[curmarkup].subtype == 1) {
                            if (DocObj.markuplist[curmarkup].display) {
                                DocObj.markuplist[curmarkup].drawmescaled(ctx);
                            }

                        }
                    }
                }

            }
        }
    }

    /*function getXML2dData(pageobject){

     var xhr = new XMLHttpRequest();

     try{
     xhr.open('GET', pageobject.Vector2DSRC, true);
     }
     catch(e){
     alert("Error 1 - " + e);
     }
     try{
     xhr.responseType = 'document';
     }
     catch(e){
     //alert("Error 2 - " + e);
     }


     xhr.onload = function(e) {
     if (this.status == 200) {
     var xmlDoc = this.responseXML;
     var pageobject.VectorPageObj = new VectorPageObject(xmlDoc);
     }
     };

     xhr.send();

     }*/

    var textObject = function (texobject, fontobject, blockname) {
        var scope = this;
        this.type = "text";
        this.blockname = blockname;
        this.blockstate = 1;
        this.layerstate = 1;

        this.x1 = texobject.x1;
        this.y1 = texobject.y1;
        this.height = fontobject.height;
        this.fontname = fontobject.name;
        this.weight = fontobject.weight;
        this.rotation = -(fontobject.rotation*(Math.PI/180));

        this.layer = texobject.layer;
        this.layerstate = texobject.layerstate;
        this.drawmode = texobject.drawmode;
        this.text = texobject.text;

        this.strokecolor = texobject.strokecolor;
        this.fillcolor = texobject.fillcolor;
        this.stroketempcolor = texobject.strokecolor;
        this.filltempcolor = texobject.fillcolor;
        this.selected = false;



        this.insidePolygon = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            return false;
        };

        this.toggleselect = function(){
            var selectstate = !scope.selected;
            scope.selected = selectstate;


        };
        this.getRectangle = function(scalefactor, offsetx, offsety, mediax, mediay, mediah){

            var minx = (scope.x1 - mediax) * scalefactor;
            var miny = (mediah - scope.y1) * scalefactor;
            //var maxx = (scope.x2 - mediax) * scalefactor;
            //var maxy = (mediah - scope.y2) * scalefactor;

            var height = scope.height * scalefactor;
            var maxy = miny + height;
            var maxx = minx + height;

            minx += offsetx;
            maxx += offsetx;
            miny += offsety;
            maxy += offsety;

            if (minx > maxx){
                var tempx = minx;
                minx = maxx;
                maxx = tempx;
            }
            if (miny > maxy){
                var tempy = miny;
                miny = maxy;
                maxy = tempy;
            }

            return  {
                found : true,
                x : minx,
                y : miny,
                w : maxx - minx,
                h : maxy - miny,
                wp : (maxx - minx) / 10,
                hp : (maxy - miny) / 10
            };

        };


        this.findsnapPoint = function (x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah) {
            return {
                found:false,
                x:0,
                y:0,
                type : 1
            };
        };

        this.drawemeoverlay = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, ls,bs){
            this.drawcompare = false;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);
        };


        this.drawemecompare = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, color,ls,bs) {
            this.drawcompare = true;
            this.comparecolor = color;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);

        };

        this.drawme = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint) {
            var x1scaled = (scope.x1 - mediax) * scalefactor;
            var y1scaled = (mediah - scope.y1) * scalefactor;
            var height = scope.height * scalefactor;
            y1scaled += height;
            //var x2scaled = (this.x2-mediax) * scalefactor;
            //var y2scaled = (mediah - this.y2) * scalefactor;

            if (ls == 0 || bs == 0) {
                return;
            }

            if(!bKeepVectorColor){
                if (scope.stroketempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        scope.stroketempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        scope.stroketempcolor = "#FFFFFF";
                    }
                }

                if (scope.filltempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        scope.filltempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        scope.filltempcolor = "#FFFFFF";
                    }

                }
            }else{
                this.stroketempcolor = scope.strokecolor;
                this.filltempcolor = scope.fillcolor;

            }


            if(drawprint && scope.stroketempcolor == "#FFFFFF"){
                scope.stroketempcolor = "#000000";
            }
            if(drawprint && scope.filltempcolor == "#FFFFFF"){
                scope.filltempcolor = "#000000";
            }

            if (height < 5) {
                var fontvalue = "800 " + height + "px " + scope.fontname + ", Helvetica";
                //console.log(height);
            } else {
                fontvalue = "normal " + height + "px " + scope.fontname + ", Helvetica";
            }
            //ctx.font = this.weight + " " + height + "pt " +  this.fontname;

            ctx.font = fontvalue;
            if (scope.drawcompare) {
                ctx.fillStyle = scope.comparecolor;
                ctx.strokeStyle = scope.comparecolor;

            }else{
                ctx.fillStyle = scope.filltempcolor;
                ctx.strokeStyle = scope.stroketempcolor;
            }


            x1scaled += offsetx;
            y1scaled += offsety;
            ctx.save();
            if(scope.rotation != 0){
                ctx.translate(x1scaled,y1scaled-height);
                ctx.rotate(scope.rotation);
                ctx.translate(-x1scaled,-(y1scaled-height));
            }

            ctx.fillText(scope.text, x1scaled, y1scaled);
            ctx.restore();


        };

        this.Close = function () {

        };


    };

    var imageObject = function (xmldata, blockname, binary) {
        //<image x1='1908247.00' y1='1777044.00' x2='2851685.00' y2='2484622.00' type="png" encoding="base64">
        var scope = this;
        this.type = "image";
        this.blockname = blockname;
        this.blockstate = 1;
        this.layerstate = 1;

        this.x1 = xmldata.x1;
        this.y1 = xmldata.y1;
        this.x2 = xmldata.x2;
        this.y2 = xmldata.y2;

        this.layer = xmldata.layer;
        this.layerstate = xmldata.layerstate;
        this.drawmode = xmldata.drawmode;
        this.selected = false;

        var createimage = new Image();

        var cachfolder;

        if (xmldata.useref) {
            cachfolder = getURLPath(DocObj.FileNameSRC);
            createimage.src = cachfolder + xmldata.image;
        } else {
            createimage.src = xmldata.image;
        }


        this.image = createimage;
        /*imageobject = {
         x1:lX1,
         y1:lY1,
         x2:lX2,
         y2:lY2,
         image : imagestr
         };*/

        this.insidePolygon = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            return false;
        };

        this.toggleselect = function(){
            var selectstate = !scope.selected;
            scope.selected = selectstate;


        };

        this.getRectangle = function(scalefactor, offsetx, offsety, mediax, mediay, mediah){

            var minx = (scope.x1 - mediax) * scalefactor;
            var miny = (mediah - scope.y1) * scalefactor;
            var maxx = (scope.x2 - mediax) * scalefactor;
            var maxy = (mediah - scope.y2) * scalefactor;


            minx += offsetx;
            maxx += offsetx;
            miny += offsety;
            maxy += offsety;

            if (minx > maxx){
                var tempx = minx;
                minx = maxx;
                maxx = tempx;
            }
            if (miny > maxy){
                var tempy = miny;
                miny = maxy;
                maxy = tempy;
            }

            return  {
                found : true,
                x : minx,
                y : miny,
                w : maxx - minx,
                h : maxy - miny,
                wp : (maxx - minx) / 10,
                hp : (maxy - miny) / 10
            };

        };

        this.findsnapPoint = function (x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah) {
            return {
                found:false,
                x:0,
                y:0,
                type : 1
            };
        };

        this.drawemeoverlay = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, ls,bs){
            this.drawcompare = false;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);
        };

        this.drawemecompare = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, color,ls,bs) {
            this.drawcompare = true;
            this.comparecolor = color;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);

        };


        this.drawme = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint) {
            var x1scaled = (this.x1 - mediax) * scalefactor;
            var y1scaled = (mediah - this.y1) * scalefactor;
            var x2scaled = (this.x2 - mediax) * scalefactor;
            var y2scaled = (mediah - this.y2) * scalefactor;

            if (ls == 0 || bs == 0) {
                return;
            }


            x1scaled += offsetx;
            y1scaled += offsety;
            x2scaled += offsetx;
            y2scaled += offsety;

            var height = y1scaled - y2scaled;
            var width = x2scaled - x1scaled;


            ctx.drawImage(this.image, x1scaled, y2scaled, width, height);
            //ctx.save();


        };
        this.Close = function () {

        };


    };


    function drawtextmarker(marerobj,ctx,scalefactor,offsetx,offsety,mediax,mediay,mediah,ls,bs){
        var x1scaled = (marerobj.x1 - mediax) * scalefactor;
        var y1scaled = (mediah - marerobj.y1) * scalefactor;
        var x2scaled = (marerobj.x2 - mediax) * scalefactor;
        var y2scaled = (mediah - marerobj.y2) * scalefactor;

        x1scaled += offsetx;
        y1scaled += offsety;
        x2scaled += offsetx;
        y2scaled += offsety;

        var markercolor = "rgba(255, 255, 0, 0.3)";
        ctx.fillStyle = markercolor;
        ctx.strokeStyle = markercolor;
        ctx.fillRect(x1scaled, y1scaled, x2scaled - x1scaled, y2scaled - y1scaled);



    }

    function drawvectorline(lineobj,ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint){
        var x1scaled = (lineobj.x1 - mediax) * scalefactor;
        var y1scaled = (mediah - lineobj.y1) * scalefactor;
        var x2scaled = (lineobj.x2 - mediax) * scalefactor;
        var y2scaled = (mediah - lineobj.y2) * scalefactor;

        if (ls == 0 || bs == 0) {
            return;
        }


        x1scaled += offsetx;
        y1scaled += offsety;
        x2scaled += offsetx;
        y2scaled += offsety;

        if(!lineobj.parent.backgroundrender){
            if (x1scaled < 0 && x2scaled < 0) {

                return;
            }
            if (y1scaled < 0 && y2scaled < 0) {

                return;
            }

            if (x1scaled > canvasowidth && x2scaled > canvasowidth) {

                return;
            }
            if (y1scaled > canvasoheight && y2scaled > canvasoheight) {

                return;
            }

        }

        /*if (DocObj.pages[DocObj.currentpage].VectorPageObj != undefined) {
            if (!DocObj.pages[DocObj.currentpage].VectorPageObj.backgroundrender) {
                if (x1scaled < 0 && x2scaled < 0) {
                    return;
                }
                if (y1scaled < 0 && y2scaled < 0) {
                    return;
                }

                if (x1scaled > canvasowidth && x2scaled > canvasowidth) {
                    return;
                }
                if (y1scaled > canvasoheight && y2scaled > canvasoheight) {
                    return;
                }
            }

        } else {
            if (x1scaled < 0 && x2scaled < 0) {
                return;
            }
            if (y1scaled < 0 && y2scaled < 0) {
                return;
            }

            if (x1scaled > canvasowidth && x2scaled > canvasowidth) {
                return;
            }
            if (y1scaled > canvasoheight && y2scaled > canvasoheight) {
                return;
            }

        }*/

        //ctx.save();
        ctx.lineCap = 'round';
        //ctx.globalAlpha = 0.5;
        //ctx.imageSmoothingEnabled = false;
        if(!bKeepVectorColor){
            if (lineobj.stroketempcolor == DocObj.backgroundColor) {
                if (DocObj.backgroundColor == "#FFFFFF") {
                    lineobj.stroketempcolor = "#000000";
                }
                if (DocObj.backgroundColor == "#000000") {
                    lineobj.stroketempcolor = "#FFFFFF";
                }
            }
        }else{
            lineobj.stroketempcolor = lineobj.strokecolor;
        }


        if(drawprint && lineobj.stroketempcolor == "#FFFFFF" ){
            lineobj.stroketempcolor = "#000000";
        }

        if (lineobj.drawcompare) {
            ctx.strokeStyle = lineobj.comparecolor;
        } else if (lineobj.parent.viewmode == 1) {

            ctx.strokeStyle = "black";

        }else{
            ctx.strokeStyle = lineobj.stroketempcolor;
        }

        if (lineobj.linewidth * scalefactor < 1) {
            ctx.lineWidth = 1;
        } else {
            ctx.lineWidth = lineobj.linewidth * scalefactor;
        }
        //ctx.lineWidth = this.linewidth * scalefactor;


        ctx.beginPath();
        ctx.moveTo(x1scaled, y1scaled);
        ctx.lineTo(x2scaled, y2scaled);
        ctx.stroke();

        lineobj.drawcompare = false;
    }

    var lineObject = function (xmldata, parent,blockname, binary) {
        // <line x1="1108602768.00" y1="-433854298.00" x2="1108602767.00" y2="-433830557.00" fs='0' ls='0' lc="#FF69B4" lw='0.00' pen='2' la='41'/>
        var scope = this;
        this.parent = parent;
        this.type = "line";
        this.blockname = blockname;
        this.blockstate = 1;
        this.layer = xmldata.layer;
        this.layerstate = 1;
        this.drawmode = xmldata.drawmode;
        this.pen = xmldata.pen;
        this.strokecolor = xmldata.strokecolor;
        this.fillcolor = xmldata.fillcolor;
        this.stroketempcolor = xmldata.strokecolor;
        this.filltempcolor = xmldata.fillcolor;

        this.drawcompare = false;
        this.comparecolor = this.fillcolor;
        this.selected = false;

        var lw = xmldata.linewidth;
        if (lw == 0) {
            //this.linewidth = 1;
        } else {
            this.linewidth = lw;
        }


        this.layerstate = xmldata.layerstate;

        /*var lineobject = {
         layer : drawlayer,
         pen : drawpen,
         strokecolor : hexdrawcolor,
         fillcolor : hexfillcolor,
         linewidth : linewidth,
         x1 : lX1,
         y1 : lY1,
         x2 : lX2,
         y2 : lY2
         };*/


        this.x1 = xmldata.x1;
        this.y1 = xmldata.y1;
        this.x2 = xmldata.x2;
        this.y2 = xmldata.y2;


        this.insidePolygon = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            return false;
        };

        this.getRectangle = function(scalefactor, offsetx, offsety, mediax, mediay, mediah){

            var minx = (scope.x1 - mediax) * scalefactor;
            var miny = (mediah - scope.y1) * scalefactor;
            var maxx = (scope.x2 - mediax) * scalefactor;
            var maxy = (mediah - scope.y2) * scalefactor;


            minx += offsetx;
            maxx += offsetx;
            miny += offsety;
            maxy += offsety;

            if (minx > maxx){
                var tempx = minx;
                minx = maxx;
                maxx = tempx;
            }
            if (miny > maxy){
                var tempy = miny;
                miny = maxy;
                maxy = tempy;
            }

            return  {
                found : true,
                x : minx,
                y : miny,
                w : maxx - minx,
                h : maxy - miny,
                wp : (maxx - minx) / 10,
                hp : (maxy - miny) / 10
            };

        };

        this.toggleselect = function(){
            var selectstate = !scope.selected;
            scope.selected = selectstate;



        };

        this.findInterSections = function(line){

            return intersect(this.x1, this.y1, this.x2, this.y2, line.x1, line.y1, line.x2, line.y2);

        };

        this.getInterSection = function(x,y,line, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            var x1scaled = (this.x1 - mediax) * scalefactor;
            var y1scaled = (mediah - this.y1) * scalefactor;
            var x2scaled = (this.x2 - mediax) * scalefactor;
            var y2scaled = (mediah - this.y2) * scalefactor;

            x1scaled += offsetx;
            y1scaled += offsety;
            x2scaled += offsetx;
            y2scaled += offsety;

            var x3scaled = (line.x1 - mediax) * scalefactor;
            var y3scaled = (mediah - line.y1) * scalefactor;
            var x4scaled = (line.x2 - mediax) * scalefactor;
            var y4scaled = (mediah - line.y2) * scalefactor;

            x3scaled += offsetx;
            y3scaled += offsety;
            x4scaled += offsetx;
            y4scaled += offsety;


            //returns false if not found.
            var intsect = intersect(x1scaled, y1scaled, x2scaled, y2scaled, x3scaled,y3scaled,x4scaled,y4scaled);


            var snapradius = 10;

            if (intsect){
                if (intsect.x > x - snapradius && intsect.x < x + snapradius) {
                    if (intsect.y > y - snapradius && intsect.y < y + snapradius) {
                        return intsect;
                    }

                }
            }

            return false;

            //line.x1,  line.y1, line.x2, line.y2

        };

        this.closeToMouse = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            var snapradius = 10;
            var within = false;

            var x1scaled = (this.x1 - mediax) * scalefactor;
            var y1scaled = (mediah - this.y1) * scalefactor;
            var x2scaled = (this.x2 - mediax) * scalefactor;
            var y2scaled = (mediah - this.y2) * scalefactor;

            x1scaled += offsetx;
            y1scaled += offsety;
            x2scaled += offsetx;
            y2scaled += offsety;

            var mp = {
                x:x,
                y:y
            };

            var lp1 = {
                x:x1scaled,
                y:y1scaled
            };

            var lp2 = {
                x:x2scaled,
                y:y2scaled
            };

            if (distToSegment(mp, lp1, lp2) < snapradius) {
                within = true;
            }

            return within;

        };



        this.findsnapPoint = function (x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah) {
            var x1scaled = (this.x1 - mediax) * scalefactor;
            var y1scaled = (mediah - this.y1) * scalefactor;
            var x2scaled = (this.x2 - mediax) * scalefactor;
            var y2scaled = (mediah - this.y2) * scalefactor;

            x1scaled += offsetx;
            y1scaled += offsety;
            x2scaled += offsetx;
            y2scaled += offsety;

            var snapradius = 10;

            var midpointx = (x1scaled + x2scaled) * 0.5;
            var midpointy = (y1scaled + y2scaled) * 0.5;

            if (x1scaled > x - snapradius && x1scaled < x + snapradius) {
                if (y1scaled > y - snapradius && y1scaled < y + snapradius) {
                    return {
                        found:true,
                        x:x1scaled,
                        y:y1scaled,
                        type : 1
                    };
                }

            }
            if (x2scaled > x - snapradius && x2scaled < x + snapradius) {
                if (y2scaled > y - snapradius && y2scaled < y + snapradius) {
                    return {
                        found:true,
                        x:x2scaled,
                        y:y2scaled,
                        type : 1
                    };
                }

            }

            if (midpointx > x - snapradius && midpointx < x + snapradius) {
                if (midpointy > y - snapradius && midpointy < y + snapradius) {
                    return {
                        found:true,
                        x:midpointx,
                        y:midpointy,
                        type : 3
                    };
                }

            }


            return {
                found:false,
                x:0,
                y:0,
                type : 1
            };


        };

        this.drawemeoverlay = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, ls,bs){
            this.drawcompare = false;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);
        };


        this.drawemecompare = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, color,ls,bs) {
            scope.drawcompare = true;
            scope.comparecolor = color;
            scope.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);

        };


        this.drawme = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint) {
            var x1scaled = (scope.x1 - mediax) * scalefactor;
            var y1scaled = (mediah - scope.y1) * scalefactor;
            var x2scaled = (scope.x2 - mediax) * scalefactor;
            var y2scaled = (mediah - scope.y2) * scalefactor;

            if (ls == 0 || bs == 0) {
                return;
            }


            x1scaled += offsetx;
            y1scaled += offsety;
            x2scaled += offsetx;
            y2scaled += offsety;

            if (!scope.parent.backgroundrender){
                if (x1scaled < 0 && x2scaled < 0) {

                    return;

                }
                if (y1scaled < 0 && y2scaled < 0) {

                    return;

                }

                if (x1scaled > canvasowidth && x2scaled > canvasowidth) {

                    return;
                }
                if (y1scaled > canvasoheight && y2scaled > canvasoheight) {

                    return;
                }
            }


            /*if (DocObj.pages[DocObj.currentpage].VectorPageObj != undefined) {
                if (!DocObj.pages[DocObj.currentpage].VectorPageObj.backgroundrender) {
                    if (x1scaled < 0 && x2scaled < 0) {
                        return;
                    }
                    if (y1scaled < 0 && y2scaled < 0) {
                        return;
                    }

                    if (x1scaled > canvasowidth && x2scaled > canvasowidth) {
                        return;
                    }
                    if (y1scaled > canvasoheight && y2scaled > canvasoheight) {
                        return;
                    }
                }

            } else {
                if (x1scaled < 0 && x2scaled < 0) {
                    return;
                }
                if (y1scaled < 0 && y2scaled < 0) {
                    return;
                }

                if (x1scaled > canvasowidth && x2scaled > canvasowidth) {
                    return;
                }
                if (y1scaled > canvasoheight && y2scaled > canvasoheight) {
                    return;
                }

            }*/

            //ctx.save();
            ctx.lineCap = 'round';
            //ctx.globalAlpha = 0.5;
            //ctx.imageSmoothingEnabled = false;
            if(!bKeepVectorColor){

                if (scope.stroketempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        scope.stroketempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        scope.stroketempcolor = "#FFFFFF";
                    }
                }

            }else{
                scope.stroketempcolor = scope.strokecolor;
                //scope.filltempcolor = xmldata.fillcolor;

            }

            if(drawprint && scope.stroketempcolor == "#FFFFFF"){
                scope.stroketempcolor = "#000000";
            }

            if (scope.drawcompare) {
                ctx.strokeStyle = scope.comparecolor;
            } else if (scope.parent.viewmode == 1) {

                ctx.strokeStyle = "black";
            }else{
                ctx.strokeStyle = scope.stroketempcolor;
            }

            if (scope.linewidth * scalefactor < 1) {
                ctx.lineWidth = 1;
            } else {
                ctx.lineWidth = scope.linewidth * scalefactor;
            }
            //ctx.lineWidth = this.linewidth * scalefactor;


            ctx.beginPath();
            ctx.moveTo(x1scaled, y1scaled);
            ctx.lineTo(x2scaled, y2scaled);
            ctx.stroke();

            scope.drawcompare = false;
            //ctx.restore();
        };

        this.Close = function () {

        };


    };

    var circleObject = function (xmldata, parent,blockname, binary) {
        var circleHandle = this;
        this.type = "circle";
        this.parent = parent;
        //circle cx="388466.18" cy="1351977.86" r="10152.93"  fs='0' ls='0' lc="#808080" lw='0.00' wt='25' pen='8' la='3'/>

        this.blockname = blockname;
        this.blockstate = 1;


        /*circleobject = {
         layer : drawlayer,
         pen : drawpen,
         strokecolor : hexdrawcolor,
         fillcolor : hexfillcolor,
         linewidth : linewidth,
         cx : cX,
         cy : cY,
         cr : cR,
         filled : false,
         };*/
        this.selected = false;
        this.layer = xmldata.layer;
        this.layerstate = 1;
        this.drawmode = xmldata.drawmode;
        this.filled = xmldata.filled;

        this.strokecolor = xmldata.strokecolor;
        this.fillcolor = xmldata.fillcolor;
        this.stroketempcolor = xmldata.strokecolor;
        this.filltempcolor = xmldata.fillcolor;


        this.drawcompare = false;
        this.comparecolor = this.fillcolor;

        var lw = xmldata.linewidth;
        if (lw == 0) {
            //this.linewidth = 1;
        } else {
            this.linewidth = lw;
        }

        this.cx = xmldata.cx;
        this.cy = xmldata.cy;
        this.r = xmldata.cr;



        this.insidePolygon = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            return false;
        };

        this.getRectangle = function(scalefactor, offsetx, offsety, mediax, mediay, mediah){

            var absxscaled = (circleHandle.cx - mediax) * scalefactor;
            var absyscaled = (mediah - circleHandle.cy) * scalefactor;
            var absradius = circleHandle.r * scalefactor;

            var minx = absxscaled - absradius;
            var miny = absyscaled - absradius;
            var maxx = absxscaled + absradius;
            var maxy = absyscaled + absradius;

            minx += offsetx;
            maxx += offsetx;
            miny += offsety;
            maxy += offsety;

            if (minx > maxx){
                var tempx = minx;
                minx = maxx;
                maxx = tempx;
            }
            if (miny > maxy){
                var tempy = miny;
                miny = maxy;
                maxy = tempy;
            }

            return  {
                found : true,
                x : minx,
                y : miny,
                w : maxx - minx,
                h : maxy - miny,
                wp : (maxx - minx) / 10,
                hp : (maxy - miny) / 10
            };

        };

        this.toggleselect = function(){
            var selectstate = !circleHandle.selected;
            circleHandle.selected = selectstate;


        };

        this.findsnapPoint = function (x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah) {
            var absxscaled = (this.cx - mediax) * scalefactor;
            var absyscaled = (mediah - this.cy) * scalefactor;

            absxscaled += offsetx;
            absyscaled += offsety;

            var snapradius = 10;

            if (absxscaled > x - snapradius && absxscaled < x + snapradius) {
                if (absyscaled > y - snapradius && absyscaled < y + snapradius) {
                    return {
                        found:true,
                        x:absxscaled,
                        y:absyscaled,
                        type : 1
                    };
                }

            } else {
                return {
                    found:false,
                    x:0,
                    y:0,
                    type : 1

                };

            }

        };


        this.drawemeoverlay = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, ls,bs){
            this.drawcompare = false;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);
        };


        this.drawemecompare = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, color,ls,bs) {
            circleHandle.drawcompare = true;
            circleHandle.comparecolor = color;
            circleHandle.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);

        };


        this.drawme = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint) {
            var absxscaled = (circleHandle.cx - mediax) * scalefactor;
            var absyscaled = (mediah - circleHandle.cy) * scalefactor;
            var absradius = circleHandle.r * scalefactor;

            if (ls == 0 || bs == 0) {
                return;
            }

            absxscaled += offsetx;
            absyscaled += offsety;

            if (!circleHandle.parent.backgroundrender){
                if (absxscaled < 0 && absxscaled + absradius < 0) {

                    return;
                }
                if (absyscaled < 0 && absyscaled + absradius < 0) {

                    return;
                }

                if (absxscaled > canvasowidth && absxscaled - absradius > canvasowidth) {

                    return;
                }
                if (absyscaled > canvasoheight && absyscaled - absradius > canvasoheight) {

                    return;
                }
            }

            /*if (DocObj.pages[DocObj.currentpage].VectorPageObj != undefined) {
                if (!DocObj.pages[DocObj.currentpage].VectorPageObj.backgroundrender) {
                    if (absxscaled < 0 && absxscaled + absradius < 0) {
                        return;
                    }
                    if (absyscaled < 0 && absyscaled + absradius < 0) {
                        return;
                    }

                    if (absxscaled > canvasowidth && absxscaled - absradius > canvasowidth) {
                        return;
                    }
                    if (absyscaled > canvasoheight && absyscaled - absradius > canvasoheight) {
                        return;
                    }
                }
            } else {
                if (absxscaled < 0 && absxscaled + absradius < 0) {
                    return;
                }
                if (absyscaled < 0 && absyscaled + absradius < 0) {
                    return;
                }

                if (absxscaled > canvasowidth && absxscaled - absradius > canvasowidth) {
                    return;
                }
                if (absyscaled > canvasoheight && absyscaled - absradius > canvasoheight) {
                    return;
                }

            }*/

            if(!bKeepVectorColor){
                if (circleHandle.stroketempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        circleHandle.stroketempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        circleHandle.stroketempcolor = "#FFFFFF";
                    }
                }

                if (this.filltempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        circleHandle.filltempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        circleHandle.filltempcolor = "#FFFFFF";
                    }

                }

            }else{
                circleHandle.stroketempcolor = circleHandle.strokecolor;
                circleHandle.filltempcolor = circleHandle.fillcolor;

            }

            if(drawprint && circleHandle.strokecolor == "#FFFFFF"){
                circleHandle.stroketempcolor = "#000000";
            }
            if(drawprint && circleHandle.fillcolor == "#FFFFFF"){
                circleHandle.filltempcolor = "#000000";
            }

            ctx.lineCap = 'round';
            if (circleHandle.drawcompare) {
                ctx.strokeStyle = circleHandle.comparecolor;
            } else if (circleHandle.parent.viewmode == 1) {
                ctx.fillStyle = "black";
            }else{
                ctx.strokeStyle = circleHandle.stroketempcolor;
            }

            if (circleHandle.linewidth * scalefactor < 1) {
                ctx.lineWidth = 1;
            } else {
                ctx.lineWidth = circleHandle.linewidth * scalefactor;
            }

            ctx.beginPath();
            ctx.arc(absxscaled, absyscaled, absradius, 0, 2 * Math.PI, false);
            if (this.filled == 1 && circleHandle.parent.viewmode == 0) {
                if (circleHandle.drawcompare) {
                    ctx.fillStyle = circleHandle.comparecolor;

                }else{
                    if(parent.blocklist[circleHandle.blockname].overridecolor){
                        ctx.fillStyle = parent.blocklist[circleHandle.blockname].color;
                    }else if (circleHandle.selected) {
                        //var grd = ctx.createLinearGradient(minx, miny, maxx, maxy);
                        var rect = this.getRectangle(scalefactor,offsetx,offsety,mediax,mediay,mediah);

                        /*found : true,
                        x : minx,
                        y : miny,
                        w : maxx - minx,
                        h : maxy - miny,
                        wp : (maxx - minx) / 10,
                        hp : (maxy - miny) / 10*/
                        var minx = rect.x;
                        var miny = rect.y;
                        var maxx = rext.w + rect.x;
                        var maxy = rext.h + rect.y;


                        var grd = ctx.createLinearGradient(maxx, miny, minx, maxy);

                        grd.addColorStop(0, parent.selectColor);
                        grd.addColorStop(.5, parent.gradientStop);
                        grd.addColorStop(1, parent.selectColor);

                        //grd.addColorStop(0, parent.selectColor);
                        //grd.addColorStop(1, parent.gradientStop);


                        //ctx.fillStyle = parent.selectColor;//"#bf3ad1";
                        ctx.fillStyle = grd;


                        //ctx.fillStyle = parent.selectColor;//"#bf3ad1";
                    }else{
                        ctx.fillStyle = circleHandle.filltempcolor;
                    }

                }


                ctx.fill();
                //ctx.lineWidth = 5;
                //ctx.strokeStyle = '#003300';

            }
            ctx.stroke();

            circleHandle.drawcompare = false;

        };
        this.Close = function () {

        };


    };

    var arcObject = function (xmldata, parent,blockname, binary) {
            var arcHandle = this;

            this.type = "arc";
            this.parent = parent;
            //circle cx="388466.18" cy="1351977.86" r="10152.93"  fs='0' ls='0' lc="#808080" lw='0.00' wt='25' pen='8' la='3'/>

            this.blockname = blockname;
            this.blockstate = 1;


            /*circleobject = {
             layer : drawlayer,
             pen : drawpen,
             strokecolor : hexdrawcolor,
             fillcolor : hexfillcolor,
             linewidth : linewidth,
             cx : cX,
             cy : cY,
             cr : cR,
             filled : false,
             };*/
            this.selected = false;
            this.layer = xmldata.layer;
            this.layerstate = 1;
            this.drawmode = xmldata.drawmode;
            //this.filled = xmldata.filled;
            this.clockwise = xmldata.clockwise;


            this.strokecolor = xmldata.strokecolor;
            this.fillcolor = xmldata.fillcolor;
            this.stroketempcolor = xmldata.strokecolor;
            this.filltempcolor = xmldata.fillcolor;


            this.drawcompare = false;
            this.comparecolor = this.fillcolor;

            var lw = xmldata.linewidth;
            if (lw == 0) {
                //this.linewidth = 1;
            } else {
                this.linewidth = lw;
            }

            this.cx = xmldata.ax;
            this.cy = xmldata.ay;
            this.r = xmldata.ar;
            this.sa = xmldata.asa;
            this.ea = xmldata.aea;
            this.fullcircle = Math.PI*2;



            this.insidePolygon = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
                return false;
            };

            this.getRectangle = function(scalefactor, offsetx, offsety, mediax, mediay, mediah){

                var absxscaled = (arcHandle.cx - mediax) * scalefactor;
                var absyscaled = (mediah - arcHandle.cy) * scalefactor;
                var absradius = arcHandle.r * scalefactor;

                var minx = absxscaled - absradius;
                var miny = absyscaled - absradius;
                var maxx = absxscaled + absradius;
                var maxy = absyscaled + absradius;

                minx += offsetx;
                maxx += offsetx;
                miny += offsety;
                maxy += offsety;

                if (minx > maxx){
                    var tempx = minx;
                    minx = maxx;
                    maxx = tempx;
                }
                if (miny > maxy){
                    var tempy = miny;
                    miny = maxy;
                    maxy = tempy;
                }

                return  {
                    found : true,
                    x : minx,
                    y : miny,
                    w : maxx - minx,
                    h : maxy - miny,
                    wp : (maxx - minx) / 10,
                    hp : (maxy - miny) / 10
                };

            };

            this.toggleselect = function(){
                var selectstate = !arcHandle.selected;
                arcHandle.selected = selectstate;


            };

            this.findsnapPoint = function (x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah) {
                var absxscaled = (this.cx - mediax) * scalefactor;
                var absyscaled = (mediah - this.cy) * scalefactor;

                absxscaled += offsetx;
                absyscaled += offsety;

                var snapradius = 10;

                if (absxscaled > x - snapradius && absxscaled < x + snapradius) {
                    if (absyscaled > y - snapradius && absyscaled < y + snapradius) {
                        return {
                            found:true,
                            x:absxscaled,
                            y:absyscaled,
                            type : 1
                        };
                    }

                } else {
                    return {
                        found:false,
                        x:0,
                        y:0,
                        type : 1
                    };

                }

            };


            this.drawemeoverlay = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, ls,bs){
                this.drawcompare = false;
                this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);
            };


            this.drawemecompare = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, color,ls,bs) {
                arcHandle.drawcompare = true;
                arcHandle.comparecolor = color;
                arcHandle.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);

            };


            this.drawme = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint) {
                var absxscaled = (arcHandle.cx - mediax) * scalefactor;
                var absyscaled = (mediah - arcHandle.cy) * scalefactor;
                var absradius = arcHandle.r * scalefactor;

                if (ls == 0 || bs == 0) {
                    return;
                }

                absxscaled += offsetx;
                absyscaled += offsety;

                if (!arcHandle.parent.backgroundrender){
                    if (absxscaled < 0 && absxscaled + absradius < 0) {

                        return;
                    }
                    if (absyscaled < 0 && absyscaled + absradius < 0) {

                        return;
                    }

                    if (absxscaled > canvasowidth && absxscaled - absradius > canvasowidth) {

                        return;
                    }
                    if (absyscaled > canvasoheight && absyscaled - absradius > canvasoheight) {

                        return;
                    }
                }



                if(!bKeepVectorColor){
                    if (arcHandle.stroketempcolor == DocObj.backgroundColor) {
                        if (DocObj.backgroundColor == "#FFFFFF") {
                            arcHandle.stroketempcolor = "#000000";
                        }
                        if (DocObj.backgroundColor == "#000000") {
                            arcHandle.stroketempcolor = "#FFFFFF";
                        }
                    }

                    if (this.filltempcolor == DocObj.backgroundColor) {
                        if (DocObj.backgroundColor == "#FFFFFF") {
                            arcHandle.filltempcolor = "#000000";
                        }
                        if (DocObj.backgroundColor == "#000000") {
                            arcHandle.filltempcolor = "#FFFFFF";
                        }

                    }

                }else{
                    arcHandle.stroketempcolor = arcHandle.strokecolor;
                    arcHandle.filltempcolor = arcHandle.fillcolor;

                }

                if(drawprint && arcHandle.strokecolor == "#FFFFFF"){
                    arcHandle.stroketempcolor = "#000000";
                }
                if(drawprint && arcHandle.fillcolor == "#FFFFFF"){
                    arcHandle.filltempcolor = "#000000";
                }

                ctx.lineCap = 'round';
                if (arcHandle.drawcompare) {
                    ctx.strokeStyle = arcHandle.comparecolor;
                } else if (arcHandle.parent.viewmode == 1) {
                    ctx.fillStyle = "black";
                }else{
                    ctx.strokeStyle = arcHandle.stroketempcolor;
                }

                if (arcHandle.linewidth * scalefactor < 1) {
                    ctx.lineWidth = 1;
                } else {
                    ctx.lineWidth = arcHandle.linewidth * scalefactor;
                }
                //ctx.save();
                ctx.beginPath();
                //ctx.translate(absxscaled, absyscaled);
                //ctx.scale(1,-1);

                ctx.arc(absxscaled, absyscaled, absradius, arcHandle.fullcircle - arcHandle.sa, arcHandle.fullcircle-arcHandle.ea, arcHandle.clockwise);

                /*if (this.filled == 1 && arcHandle.parent.viewmode == 0) {
                    if (arcHandle.drawcompare) {
                        ctx.fillStyle = arcHandle.comparecolor;

                    }else{
                        if(parent.blocklist[arcHandle.blockname].overridecolor){
                            ctx.fillStyle = parent.blocklist[arcHandle.blockname].color;
                        }else if (arcHandle.selected) {
                            ctx.fillStyle = parent.selectColor;//"#bf3ad1";
                        }else{
                            ctx.fillStyle = arcHandle.filltempcolor;
                        }

                    }


                    ctx.fill();
                    //ctx.lineWidth = 5;
                    //ctx.strokeStyle = '#003300';

                }*/
                ctx.stroke();
                //ctx.restore();
                arcHandle.drawcompare = false;

            };
            this.Close = function () {

            };

    };

    var subPathObject = function (points, parentpath, last, precision, binary) {
        var pathHandle = this;
        this.type = "subpath";
        this.precision = precision;
        this.parentpath = parentpath;
        this.blockname = parentpath.blockname;
        this.blockstate = parentpath.blockstate;
        this.layer = parentpath.layer;
        this.layerstate = parentpath.layerstate;
        this.drawmode = parentpath.drawmode;
        this.strokecolor = parentpath.strokecolor;
        this.fillcolor = parentpath.fillcolor;
        this.stroketempcolor = parentpath.strokecolor;
        this.filltempcolor = parentpath.fillcolor;
        this.filled = parentpath.filled;
        this.selected = false;
        this.linewidth = parentpath.linewidth;
        this.linestyle = parentpath.linestyle;
        this.svgpathstr = '';


        if(pathHandle.precision == 0){
            this.points = new Float32Array(points.length);
        }else if(pathHandle.precision == 1){
            this.points = new Float64Array(points.length);
        }
        var numpoints = points.length;
        this.last = last;
        var pctr = 0;
        while (pctr < numpoints) {
            this.points[pctr] = points[pctr];
            pctr++;
        }


        this.findsnapPoint = function (x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah) {

            var absxscaled = (this.points[0] - mediax) * scalefactor;
            var absyscaled = (mediah - this.points[1]) * scalefactor;

            var relxscaled = 0;
            var relyscaled = 0;

            absxscaled += offsetx;
            absyscaled += offsety;
            var snapradius = 10;


            if (absxscaled > x - snapradius && absxscaled < x + snapradius) {
                if (absyscaled > y - snapradius && absyscaled < y + snapradius) {

                    return {
                        found:true,
                        x:absxscaled,
                        y:absyscaled,
                        type : 1
                    };
                }

            }

            for (var counter = 2; counter < this.points.length; counter += 2) {

                relxscaled = ((this.points[counter] - mediax) * scalefactor);
                relyscaled = ((mediah - this.points[counter + 1]) * scalefactor);
                relxscaled += offsetx;
                relyscaled += offsety;
                if (relxscaled > x - snapradius && relxscaled < x + snapradius) {
                    if (relyscaled > y - snapradius && relyscaled < y + snapradius) {

                        return {
                            found:true,
                            x:relxscaled,
                            y:relyscaled,
                            type : 1
                        };
                    }

                }


            }

            return {
                found:false,
                x:0,
                y:0,
                type : 1
            };


        };

        this.drawemeoverlay = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, ls,bs){
            this.drawcompare = false;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);
        };


        this.drawemecompare = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, color,ls,bs) {
            this.drawcompare = true;
            this.comparecolor = color;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);

        };


        this.drawme = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint) {
            var absxscaled = (pathHandle.points[0] - mediax) * scalefactor;
            var absyscaled = (mediah - pathHandle.points[1]) * scalefactor;
            var relxscaled = 0;
            var relyscaled = 0;

            if (ls == 0 || bs == 0) {
                return;
            }

            absxscaled += offsetx;
            absyscaled += offsety;




            if (!pathHandle.parentpath.render) {
                return;
            }

            //ctx.save();

            //ctx.imageSmoothingEnabled = false;
            //ctx.globalCompositeOperation = 'destination-out';
            if(!bKeepVectorColor){
                if (pathHandle.stroketempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        pathHandle.stroketempcolor = "#000000";
                        pathHandle.filltempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        pathHandle.stroketempcolor = "#FFFFFF";
                        pathHandle.filltempcolor = "#FFFFFF";
                    }
                }

            }else{
                this.stroketempcolor = pathHandle.strokecolor;
                this.filltempcolor = pathHandle.fillcolor;

            }

            if(drawprint && pathHandle.stroketempcolor == "#FFFFFF"){
                pathHandle.stroketempcolor = "#000000";
                pathHandle.filltempcolor = "#000000";
            }

            if (this.drawcompare) {
                ctx.strokeStyle = pathHandle.comparecolor;
            } else if (pathHandle.parentpath.viewmode == 1) {

                ctx.strokeStyle = "black";

            }else{
                ctx.strokeStyle = pathHandle.stroketempcolor;
            }

            //console.log('subpath');
            //console.log(this.filled);

            //ctx.lineWidth = this.linewidth * scalefactor;
            if (pathHandle.linewidth * scalefactor < 1 && pathHandle.filled == 0) {
                ctx.lineWidth = 1;
            } else {
                ctx.lineWidth = pathHandle.linewidth * scalefactor;
                //var linew = (0.5 + (this.linewidth * scalefactor)) | 0;
                //ctx.lineWidth = linew;


            }
            //ctx.lineWidth = this.linewidth * scalefactor;


            //ctx.beginPath();


            //      ctx.moveTo(markupobject.points[0].x, markupobject.points[0].y);

            ctx.moveTo(absxscaled, absyscaled); //round off test for better performance
            //ctx.moveTo(((0.5 + absxscaled) | 0), ((0.5 + absyscaled) | 0));

            /* Andriy: unused variable var count = 0; */
            for (var counter = 2; counter < this.points.length; counter += 2) {
                //            ctx.lineTo(markupobject.points[counter].x, markupobject.points[counter].y);
                relxscaled = ((pathHandle.points[counter] - mediax) * scalefactor);
                relyscaled = ((mediah - pathHandle.points[counter + 1]) * scalefactor);
                relxscaled += offsetx;
                relyscaled += offsety;
                //xscaled = xscaled + offsetx;
                //yscaled = yscaled + offsety;
                ctx.lineTo(relxscaled, relyscaled); //round off test for better performance
                //ctx.lineTo(((0.5 + relxscaled) | 0), ((0.5 + relyscaled) | 0));

            }
            ctx.closePath();
            ctx.lineCap = 'round';

            if (pathHandle.last) {
                if ((pathHandle.filled == 1 && pathHandle.parentpath.parent.viewmode == 0) || pathHandle.selected || parentpath.parent.blocklist[pathHandle.blockname].overridecolor ) {

                    if (pathHandle.drawcompare) {
                        ctx.fillStyle = pathHandle.comparecolor;
                    } else {
                        if(parentpath.parent.blocklist[pathHandle.blockname].overridecolor){
                            ctx.fillStyle = parentpath.parent.blocklist[pathHandle.blockname].color;
                        }else if (pathHandle.selected) {

                            var minx = (parentpath.x - mediax) * scalefactor;
                            var miny = (mediah - parentpath.y) * scalefactor;
                            var maxx = (parentpath.w - mediax) * scalefactor;
                            var maxy = (mediah - parentpath.h) * scalefactor;
                            //var grd = ctx.createLinearGradient(minx, miny, maxx, maxy);
                            var grd = ctx.createLinearGradient(maxx, miny, minx, maxy);

                            grd.addColorStop(0, parentpath.parent.selectColor);
                            grd.addColorStop(.5, parentpath.parent.gradientStop);
                            grd.addColorStop(1, parentpath.parent.selectColor);

                            //grd.addColorStop(0, parent.selectColor);
                            //grd.addColorStop(1, parent.gradientStop);


                            //ctx.fillStyle = parent.selectColor;//"#bf3ad1";
                            ctx.fillStyle = grd;
                            //ctx.fillStyle = parentpath.parent.selectColor;

                        }else{
                            ctx.fillStyle = pathHandle.filltempcolor;
                        }

                    }


                    ctx.fill();
                } else {
                    //ctx.closePath();
                    //ctx.stroke();
                    //ctx.fillStyle = this.fillcolor;
                    //ctx.fill();

                }
                //ctx.closePath();

                ctx.stroke();

            }
            //ctx.clip();
            //ctx.restore();
            this.drawcompare = false;
        };

        this.Close = function () {

            this.points = null;
        };


    };

    var pathObject = function (xmldata, parent,blockname, binary) {

        var pathHandle = this;
        this.type = "path";
        this.precision = xmldata.precision; //0 = float32, 1=float64
        this.parent = parent;

        this.x = 0.0;
        this.y = 0.0;
        this.w = 0.0;
        this.h = 0.0;

        this.centroid = {x:0,y:0};

        this.render = true;
        this.selected = false;
        this.svgpathstr = '';
        this.drawcompare = false;
        this.comparecolor = this.fillcolor;

        this.shape = xmldata.shape;
        this.blockname = blockname;
        this.blockstate = 1;
        this.closed = false;

        this.layer = xmldata.layer;
        this.layerstate = 1;

        this.drawmode = xmldata.drawmode;
        this.strokecolor = xmldata.strokecolor;

        this.fillcolor = xmldata.fillcolor;
        this.stroketempcolor = xmldata.strokecolor;
        this.filltempcolor = xmldata.fillcolor;


        this.filled = xmldata.filled;
        this.gotsubpath = xmldata.gotsubpath;
        this.subpaths = [];
        this.linestyle = 0;

        if (xmldata.linewidth == 0) {
            //this.linewidth = 1;
        } else {
            this.linewidth = xmldata.linewidth;
        }


        if (xmldata.gotsubpath) {

            this.gotsubpath = true;

            if(this.precision == 0){
                this.points = new Float32Array(xmldata.numpoints);
            }else if (this.precision == 1){
                this.points = new Float64Array(xmldata.numpoints);
            }


            var cpnts = 0;
            var numpoints = xmldata.numpoints;
            var mainarray = xmldata.points[0];
            while (cpnts < numpoints) {
                this.points[cpnts] = mainarray[cpnts];
                cpnts++;
            }


            /*pathobject = {
             layer : drawlayer,
             pen : drawpen,
             strokecolor : hexdrawcolor,
             fillcolor : hexfillcolor,
             linewidth : linewidth,
             numpoints : numpointarr[0],
             points : subpatharrays,
             filled : true,
             gotsubpath : true
             };*/

            var numsubpaths = xmldata.points.length;
            var spc = 1;
            var islasthole = false;
            while (spc < numsubpaths) {
                mainarray = xmldata.points[spc];
                if (spc == numsubpaths - 1) {
                    islasthole = true;
                }
                spc++;
                this.subpaths.push(new subPathObject(mainarray, pathHandle, islasthole, pathHandle.precision, true));
            }


        } else {

            if(this.precision == 0){
                this.points = new Float32Array(xmldata.numpoints);
            }else if (this.precision == 1){
                this.points = new Float64Array(xmldata.numpoints);
            }

            //this.points = new Float32Array(xmldata.numpoints);


            //this.points[0] = xmldata.points[0];
            //this.points[1] = xmldata.points[1];

            cpnts = 0;
            numpoints = xmldata.numpoints;

            while (cpnts < numpoints) {
                this.points[cpnts] = xmldata.points[cpnts];
                cpnts++;
            }

        }

        if (this.shape == 2){
           if(this.points[0] == this.points[this.points.length - 2] && this.points[1] == this.points[this.points.length - 1] ){
               this.closed = true;
           }
        }


        /*                    var pathobject = {
         layer : drawlayer,
         pen : drawpen,
         strokecolor : hexdrawcolor,
         fillcolor : hexfillcolor,
         linewidth : linewidth,
         numpoints : numpoints,
         points : lpoints,
         filled : false,
         gotsubpath : false
         };
         */




        //fs='0' ls='0' lc="#FFFFFF" lw='0.00' wt='25' pen='7' la='8'


        this.toggleselect = function(){
            var selectstate = !pathHandle.selected;
            pathHandle.selected = selectstate;

            for (var scount = 0; scount < pathHandle.subpaths.length; scount++) {
                pathHandle.subpaths[scount].selected = selectstate;
            }

        };

        this.unselect = function(){
            pathHandle.selected = false;

            for (var scount = 0; scount < pathHandle.subpaths.length; scount++) {
                pathHandle.subpaths[scount].selected = false;
            }

        };

        this.select = function (){
            pathHandle.selected = true;

            for (var scount = 0; scount < pathHandle.subpaths.length; scount++) {
                pathHandle.subpaths[scount].selected = true;
            }

        };

        this.findcentroid = function(){

            var pts = [];
            var pointsctr = 0;
            for (var counter = 0; counter < this.points.length; counter += 2) {
                pts[pointsctr] = {x: this.points[counter], y: this.points[counter + 1]};
                pointsctr++;

            }


            if(this.gotsubpath){
                for (var scount = 0; scount < pathHandle.subpaths.length; scount++) {
                    //pathHandle.subpaths[scount].selected = false;
                    for ( counter = 0; counter < pathHandle.subpaths[scount].points.length; counter += 2) {
                        pts[pointsctr] = {x: pathHandle.subpaths[scount].points[counter], y: pathHandle.subpaths[scount].points[counter + 1]};
                        pointsctr++;

                    }
                }

            }
            pathHandle.centroid = get_polygon_centroid(pts);


        };

        this.getcentroid = function(scalefactor, offsetx, offsety, mediax, mediay, mediah){

            if(pathHandle.centroid.x == 0 && pathHandle.centroid.y == 0 ){
                pathHandle.findcentroid();
            }

            var centrx = (pathHandle.centroid.x - mediax) * scalefactor;
            var centry = (mediah - pathHandle.centroid.y) * scalefactor;

            centrx += offsetx;
            centry += offsety;

            return  {x:centrx, y : centry};
        };

        this.findrectangle = function () {
            /* Andriy: variable initialization is reduntant as it's set to 2 in the first interation of the loop */
            /*var counter = 0;*/

            var minx = this.points[0];
            var miny = this.points[1];
            var maxx = this.points[0];
            var maxy = this.points[1];

            for (var counter = 2; counter < this.points.length; counter += 2) {
                var relxscaled = this.points[counter];
                var relyscaled = this.points[counter + 1];

                if (relxscaled < minx) {
                    minx = relxscaled;
                }
                if (relyscaled < miny) {
                    miny = relyscaled;
                }
                if (relxscaled > maxx) {
                    maxx = relxscaled;
                }
                if (relyscaled > maxy) {
                    maxy = relyscaled;
                }

            }


            if(this.gotsubpath){
                for (var scount = 0; scount < pathHandle.subpaths.length; scount++) {
                    //pathHandle.subpaths[scount].selected = false;
                    for ( counter = 0; counter < pathHandle.subpaths[scount].points.length; counter += 2) {
                        relxscaled = pathHandle.subpaths[scount].points[counter];
                        relyscaled = pathHandle.subpaths[scount].points[counter + 1];

                        if (relxscaled < minx) {
                            minx = relxscaled;
                        }
                        if (relyscaled < miny) {
                            miny = relyscaled;
                        }
                        if (relxscaled > maxx) {
                            maxx = relxscaled;
                        }
                        if (relyscaled > maxy) {
                            maxy = relyscaled;
                        }

                    }
                }

            }

            this.x = minx;
            this.y = miny;
            this.w = maxx;
            this.h = maxy;


        };

        this.getblockPath = function(){
            return pathHandle;
        };

        this.getblockPathPoints = function(){

            return pathHandle.points;

        };

        this.getRectangle = function(scalefactor, offsetx, offsety, mediax, mediay, mediah){

            var minx = (pathHandle.x - mediax) * scalefactor;
            var miny = (mediah - pathHandle.y) * scalefactor;
            var maxx = (pathHandle.w - mediax) * scalefactor;
            var maxy = (mediah - pathHandle.h) * scalefactor;

            minx += offsetx;
            maxx += offsetx;
            miny += offsety;
            maxy += offsety;

            if (minx > maxx){
                var tempx = minx;
                minx = maxx;
                maxx = tempx;
            }
            if (miny > maxy){
                var tempy = miny;
                miny = maxy;
                maxy = tempy;
            }

            return  {
                found : true,
                x : minx,
                y : miny,
                w : maxx - minx,
                h : maxy - miny,
                wp : (maxx - minx) / 10,
                hp : (maxy - miny) / 10
            };

        };

        this.getpath = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            if (pathHandle.insidePolygon(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah)){
                return pathHandle;
            }else{
                return null;
            }


        };

        this.getpathPoints = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){
            if (pathHandle.insidePolygon(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah)){

                return pathHandle.points;

                /*if (!pathHandle.gotsubpath) {

                }else{
                    for (var scount = 0; scount < pathHandle.subpaths.length; scount++) {
                        if (pathHandle.drawcompare) {
                            pathHandle.subpaths[scount].drawemecompare(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, pathHandle.comparecolor,ls,bs);
                            //this.drawemecompare = function(ctx,scalefactor,offsetx,offsety, mediax, mediay,mediah,color){
                        } else {

                            pathHandle.subpaths[scount].drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint);
                        }

                    }

                }*/




            }else{
                return [];
            }
        };

        this.insidePolygon = function(x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah){

            var polyshape = (pathHandle.shape == 3 || pathHandle.shape == 6 || pathHandle.shape == 23 || pathHandle.shape == 26);
            var closedpoly = (pathHandle.shape == 2 && pathHandle.closed);
            if (pathHandle.shape == 2){
                //console.log('polyline');
            }

            if (!polyshape && !closedpoly){
                pathHandle.unselect();
                return false;

            }
            /*if(pathHandle.shape != 3 && pathHandle.shape != 6 && pathHandle.shape != 23 && pathHandle.shape != 26){
                pathHandle.unselect();
                return false;
            }*/
            var mp = {
                x:x,
                y:y
            };

            var minx = (pathHandle.x - mediax) * scalefactor;
            var miny = (mediah - pathHandle.y) * scalefactor;
            var maxx = (pathHandle.w - mediax) * scalefactor;
            var maxy = (mediah - pathHandle.h) * scalefactor;

            minx += offsetx;
            maxx += offsetx;
            miny += offsety;
            maxy += offsety;

            if (minx > maxx){
                var tempx = minx;
                minx = maxx;
                maxx = tempx;
            }
            if (miny > maxy){
                var tempy = miny;
                miny = maxy;
                maxy = tempy;
            }

            //cntximg.strokeStyle = "yellow";
            //cntximg.lineWidth = 2;
            //cntximg.strokeRect(minx, miny, maxx - minx, maxy - miny);


            if((mp.x < minx || mp.x > maxx) || (mp.y < miny || mp.y > maxy)){
                if(!pathHandle.parent.multiselect){
                    pathHandle.unselect();
                }
                return false;
            }

            var epsilon = {
                x : minx - ((maxx - minx) / 100),
                y : maxy - ((maxy - miny) / 2)
            };

            var within = insidepolygonpoints(scalefactor,offsetx,offsety,mediax, mediay, mediah,pathHandle,mp,epsilon);
            if(within){
                //pathHandle.toggleselect();
                return true;
                //console.log(pathHandle.blockname);
            }else{
                if(!pathHandle.parent.multiselect){
                    pathHandle.unselect();
                }
                return false;
            }


            /*var within = insidepolygonpoints(scalefactor,offsetx,offsety,mediax, mediay, mediah,pathHandle,mp,epsilon);
            if(within){
                pathHandle.select();
                return true;
                //console.log(pathHandle.blockname);
            }else{
                pathHandle.unselect();
                return false;
            }*/
            //(scalefactor,offsetx,offsety,mediax, mediay, mediah,pathHandle.points,mp,epsilon){



        };


        this.findsnapPoint = function (x, y, scalefactor, offsetx, offsety, mediax, mediay, mediah) {

            var absxscaled = (this.points[0] - mediax) * scalefactor;
            var absyscaled = (mediah - this.points[1]) * scalefactor;

            var relxscaled = 0;
            var relyscaled = 0;

            absxscaled += offsetx;
            absyscaled += offsety;
            var snapradius = 10;

            if (absxscaled > x - snapradius && absxscaled < x + snapradius) {
                if (absyscaled > y - snapradius && absyscaled < y + snapradius) {


                    return {
                        found:true,
                        x:absxscaled,
                        y:absyscaled,
                        type : 1
                    };
                }

            }

            for (var counter = 2; counter < this.points.length; counter += 2) {

                relxscaled = ((this.points[counter] - mediax) * scalefactor);
                relyscaled = ((mediah - this.points[counter + 1]) * scalefactor);
                relxscaled += offsetx;
                relyscaled += offsety;


                if (relxscaled > x - snapradius && relxscaled < x + snapradius) {
                    if (relyscaled > y - snapradius && relyscaled < y + snapradius) {

                        return {
                            found:true,
                            x:relxscaled,
                            y:relyscaled,
                            type : 1
                        };
                    }

                }


            }
            return {
                found:false,
                x:0,
                y:0,
                type : 1
            };


        };

        this.drawemeoverlay = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, ls,bs){
            this.drawcompare = false;
            this.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);
        };


        this.drawemecompare = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, color,ls,bs) {
            pathHandle.drawcompare = true;
            pathHandle.comparecolor = color;
            pathHandle.drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,false);

        };


        this.drawme = function (ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint) {
            var absxscaled = (pathHandle.points[0] - mediax) * scalefactor;
            var absyscaled = (mediah - pathHandle.points[1]) * scalefactor;
            var relxscaled = 0;
            var relyscaled = 0;

            if (ls == 0 || bs == 0) {
                return;
            }

            absxscaled += offsetx;
            absyscaled += offsety;
            pathHandle.render = true;

            var minx = (pathHandle.x - mediax) * scalefactor;
            var miny = (mediah - pathHandle.y) * scalefactor;
            var maxx = (pathHandle.w - mediax) * scalefactor;
            var maxy = (mediah - pathHandle.h) * scalefactor;

            minx += offsetx;
            maxx += offsetx;
            miny += offsety;
            maxy += offsety;

            if(!pathHandle.parent.backgroundrender){
                if ((minx < 0 && maxx < 0) || (miny < 0 && maxy < 0)) {
                    pathHandle.render = false;

                    return;
                }

                if ((minx > canvasowidth && maxx > canvasowidth) || (miny > canvasowidth && maxy > canvasoheight)) {
                    pathHandle.render = false;

                    return;
                }
            }

            /*if (DocObj.pages[DocObj.currentpage].VectorPageObj != undefined) {
                if (!DocObj.pages[DocObj.currentpage].VectorPageObj.backgroundrender) {

                    if ((minx < 0 && maxx < 0) || (miny < 0 && maxy < 0)) {
                        this.render = false;
                        return;
                    }

                    if ((minx > canvasowidth && maxx > canvasowidth) || (miny > canvasowidth && maxy > canvasoheight)) {
                        this.render = false;
                        return;
                    }

                }

            } else {
                if ((minx < 0 && maxx < 0) || (miny < 0 && maxy < 0)) {
                    this.render = false;
                    return;
                }

                if ((minx > canvasowidth && maxx > canvasowidth) || (miny > canvasowidth && maxy > canvasoheight)) {
                    this.render = false;
                    return;
                }

            }*/

            //ctx.save();

            //ctx.imageSmoothingEnabled = false;
            //ctx.restore();
            //ctx.globalCompositeOperation = 'source-over';
            if(!bKeepVectorColor){
                if (pathHandle.filltempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        pathHandle.filltempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        pathHandle.filltempcolor = "#FFFFFF";
                    }

                }

                if (pathHandle.stroketempcolor == DocObj.backgroundColor) {
                    if (DocObj.backgroundColor == "#FFFFFF") {
                        pathHandle.stroketempcolor = "#000000";
                    }
                    if (DocObj.backgroundColor == "#000000") {
                        pathHandle.stroketempcolor = "#FFFFFF";
                    }
                }

            }else{
                pathHandle.stroketempcolor = pathHandle.strokecolor;
                pathHandle.filltempcolor = pathHandle.fillcolor;

            }

            if(drawprint && pathHandle.stroketempcolor == "#FFFFFF"){
                pathHandle.stroketempcolor = "#000000";
            }
            if(drawprint && pathHandle.filltempcolor == "#FFFFFF"){
                pathHandle.filltempcolor = "#000000";
            }

            if (pathHandle.drawcompare) {
                ctx.strokeStyle = pathHandle.comparecolor;
            } else if (pathHandle.parent.viewmode == 1) {

                ctx.strokeStyle = "black";

            }else{
                ctx.strokeStyle = pathHandle.stroketempcolor;
            }

            //console.log(this.linewidth * scalefactor);
            //console.log('path');
            //console.log(this.filled);
            //ctx.lineWidth = this.linewidth * scalefactor;
            if (pathHandle.linewidth * scalefactor < 1 && pathHandle.filled == 0) {
                ctx.lineWidth = 1;
            } else {
                ctx.lineWidth = pathHandle.linewidth * scalefactor;
                //ctx.lineWidth = (0.5 + (this.linewidth * scalefactor)) | 0;


            }
            //ctx.lineWidth = this.linewidth * scalefactor;

            ctx.beginPath();


            //ctx.moveTo(markupobject.points[0].x, markupobject.points[0].y);
            ctx.moveTo(absxscaled, absyscaled); //convert to integer pixels.
            //ctx.moveTo(((0.5 + absxscaled) | 0), ((0.5 + absyscaled) | 0));
            /*Andriy: Unused variable var count = 0;*/
            for (var counter = 2; counter < this.points.length; counter += 2) {
                //            ctx.lineTo(markupobject.points[counter].x, markupobject.points[counter].y);
                relxscaled = ((pathHandle.points[counter] - mediax) * scalefactor);
                relyscaled = ((mediah - pathHandle.points[counter + 1]) * scalefactor);
                relxscaled += offsetx;
                relyscaled += offsety;
                //xscaled = xscaled + offsetx;
                //yscaled = yscaled + offsety;
                ctx.lineTo(relxscaled, relyscaled); //convert to integer pixels
                //ctx.lineTo(((0.5 + relxscaled) | 0), ((0.5 + relyscaled) | 0));

            }


            if (!pathHandle.gotsubpath) {

                if ((pathHandle.filled == 1 && pathHandle.parent.viewmode == 0) || pathHandle.selected || parent.blocklist[pathHandle.blockname].overridecolor) {
                    ctx.lineWidth = 1;
                    ctx.closePath();
                    if (pathHandle.drawcompare) {
                        ctx.fillStyle = pathHandle.comparecolor;
                    } else{
                        if(parent.blocklist[pathHandle.blockname].overridecolor){
                            ctx.fillStyle = parent.blocklist[pathHandle.blockname].color;
                        }else if (pathHandle.selected) {

                            //var grd = ctx.createLinearGradient(minx, miny, maxx, maxy);
                            var grd = ctx.createLinearGradient(maxx, miny, minx, maxy);

                            grd.addColorStop(0, parent.selectColor);
                            grd.addColorStop(.5, parent.gradientStop);
                            grd.addColorStop(1, parent.selectColor);

                            //grd.addColorStop(0, parent.selectColor);
                            //grd.addColorStop(1, parent.gradientStop);


                            //ctx.fillStyle = parent.selectColor;//"#bf3ad1";
                            ctx.fillStyle = grd;
                            //getlinestyle
                        }else{
                            ctx.fillStyle = pathHandle.filltempcolor;
                        }

                    }

                    ctx.fill();
                } else {
                    //ctx.lineCap = 'round';
                    //ctx.stroke();

                }
                ctx.lineCap = 'round';
                ctx.lineJoin = "round";
                ctx.stroke();

                if (!pathHandle.filled){

                }


            } else {
                for (var scount = 0; scount < pathHandle.subpaths.length; scount++) {
                    if (pathHandle.drawcompare) {
                        pathHandle.subpaths[scount].drawemecompare(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah, pathHandle.comparecolor,ls,bs);
                        //this.drawemecompare = function(ctx,scalefactor,offsetx,offsety, mediax, mediay,mediah,color){
                    } else {


                        pathHandle.subpaths[scount].drawme(ctx, scalefactor, offsetx, offsety, mediax, mediay, mediah,ls,bs,drawprint);
                    }

                }

            }

            //ctx.clip();

            //ctx.restore();
            pathHandle.drawcompare = false;
        };
        this.Close = function () {
            if (pathHandle.gotsubpath) {
                while (pathHandle.subpaths.length != 0) {
                    pathHandle.subpaths.pop();
                }
            }
            pathHandle.points = null;

        };

        this.findrectangle();


    };


    var LayerObject = function (layerxmldata, binary) {

        this.index = parseInt(layerxmldata.getInt32(0, true));
        var ncolor = parseInt(layerxmldata.getInt32(4, true));
        this.color = decimalToHex(ncolor);
        var statevar = parseInt(layerxmldata.getInt32(8, true));
        this.state = statevar;
        this.isplottable = parseInt(layerxmldata.getInt32(12, true));
        this.defaultstate = statevar;


        var nname = layerxmldata.getUint16(16, true);
        var lname = (nname == 0) ? " " : String.fromCharCode(nname);

        var i = 18;
        while (i <= 128) {

            nname = layerxmldata.getUint16(i, true);
            lname += (nname == 0) ? " " : String.fromCharCode(nname);
            i += 2;
        }
        this.name = lname;

        this.turnLayerOnOff = function (index) {

        };
    };

    var BlockObject = function (index, name, state,color) {
        this.index = index;
        this.name = name;
        this.state = state;
        this.defaultstate = state;
        this.defaultcolor = color;
        this.color = color;
        this.overridecolor = false;
        this.selected = false;

        //BloclistGUIContainer
        //BlocksContainer.Addblock(this.index,this.name,this.state);
        /*var nametd = "<TD>" + this.name + "</TD>";

         if (this.state == 1){
         var checkboxtd = "<TD>" + "<input type='checkbox' name='"+ this.name + "' value='On' checked onChange='VturnBlockOnOff(" + "\"" +  this.name + "\"" + ")'>"+"</TD>\n";
         }else{
         checkboxtd = "<TD>" + "<input type='checkbox' name='"+ this.name + "' value='Off' onChange='VturnBlockOnOff(" + "\"" + this.name + "\"" + ")'>"+"</TD>\n";
         }

         this.tableline = '<TR>' + nametd + checkboxtd + '</TR>';*/


    };

    var PDFDocObject = function(docobj){

        var thisdocument = this;

        this.document = docobj;

        this.initiate = function(PDFcmap){

            pdfjsLib.cMapUrl = PDFcmap;
            pdfjsLib.cMapPacked = true;
            //PDFJS.cMapUrl = PDFcmap;
            //PDFJS.cMapPacked = true;

        };

        this.openDocument = function (url){
            pdfjsLib.getDocument(url).then(function (pdfDoc_) {
                thisdocument.pdfDoc = pdfDoc_;

                //thisdocument.pdfFindController = new PDFJS.PDFFindController();
                // Initial/first page rendering

                thisdocument.document.setPDFdocument(thisdocument.pdfDoc, true);



            });
            /*PDFJS.getDocument(url).then(function (pdfDoc_) {
                thisdocument.pdfDoc = pdfDoc_;

                //thisdocument.pdfFindController = new PDFJS.PDFFindController();
                // Initial/first page rendering

                thisdocument.document.setPDFdocument(thisdocument.pdfDoc, true);



            });*/

        };

    };

    var VectorPageObject = function (page, pagexmldata, binary) {

        var scope = this;
        this.parent = page;
        this.firstdraw = false;
        this.firstdrawcompare = false;
        this.offscreen = document.createElement('canvas');
        this.offscreenctx = this.offscreen.getContext('2d');
        this.backgroundrender = true;
        this.docompare = false;
        this.dooverlay = false;
        this.isbackground = false;
        this.comparecolor = 'red';
        this.layerlist = [];
        this.numlayers = -1;
        this.vectorpagetime = 0;
        this.textlayerset = false;

        this.blocklist = [];
        this.filterblocklist = [];
        this.numblocks = -1;
        this.bnameunique = false;
        this.selectedobject = undefined;
        //this.selectColor = "#bf3ad1";
        this.selectColor = "rgba(191,58,209,0.6)";
        this.gradientStop = "rgba(255,255,255,0.3)"


        this.viewmode = 0;
        this.multiselect = false;
        this.selectedblocks = [];


        var dv = new DataView(pagexmldata);
        var header = String.fromCharCode(dv.getUint8(0));
        var i = 1;
        while (i <= 15) {
            header += String.fromCharCode(dv.getUint8(i));
            i++;
        }

        this.fileversion = parseInt(dv.getInt32(16, true));
        this.flag = dv.getInt32(20, true);
        //var version = parseInt(dv.getInt32(16, true));
        //console.log('version:' + version);
        var layerdvpos = 52;
        if (this.flag == 0){
            this.x = dv.getFloat32(24, true);
            this.y = dv.getFloat32(28, true);
            this.w = dv.getFloat32(32, true);
            this.h = dv.getFloat32(36, true);
            this.scale = dv.getFloat32(40, true);
            this.offsetx = dv.getFloat32(44, true);
            this.offsety = dv.getFloat32(48, true);
            layerdvpos = 52;
        }else if(this.flag == 1){
            this.x = dv.getFloat64(24, true);
            this.y = dv.getFloat64(32, true);
            this.w = dv.getFloat64(40, true);
            this.h = dv.getFloat64(48, true);
            this.scale = dv.getFloat64(56, true);
            this.offsetx = dv.getFloat64(64, true);
            this.offsety = dv.getFloat64(72, true);
            layerdvpos = 80;
        }

        /*---                           ---*/

        this.numlayers = parseInt(dv.getInt32(layerdvpos, true));
        var layerSize = 144;
        var startpos = layerdvpos + 4;
        var layertotsize = this.numlayers * layerSize;

        if(this.numlayers != 0){
            var layerdv = new DataView(pagexmldata, startpos, layerSize);
            //Layer number
            var nlayer = 0;

            while (nlayer < this.numlayers) {

                var NewLayer = new LayerObject(layerdv, true);
                this.layerlist[NewLayer.index] = NewLayer;
                //this.numlayers++;

                nlayer++;
                startpos += layerSize;
                if (nlayer < this.numlayers) {
                    layerdv = new DataView(pagexmldata, startpos, layerSize);
                }

            }

            if (RxCore_GUI_VectorLayers != undefined) {
                RxCore_GUI_VectorLayers.setVectorLayers(scope.layerlist);
            }

        }

        //startpos += layerSize;


        this.pathlist = [];
        this.textlist = [];
        this.attributes = [];
        this.intersections = [];

        this.numpaths = -1;

        this.width = this.w - this.x;
        this.height = this.h - this.y;
        var blockdv = new DataView(pagexmldata, startpos);

        this.pathlist = [];
        this.numpaths = -1;

        this.width = this.w - this.x;
        this.height = this.h - this.y;

        var blockindx = 0;

        var bobjid = parseInt(blockdv.getInt32(0, true));
        if (bobjid != 32768) {
            var blockid = parseInt(blockdv.getInt32(4, true));
            var blockflag = parseInt(blockdv.getInt32(8, true));
            this.bnameunique =  (blockflag == 1);

            var bnamelength = parseInt(blockdv.getInt32(12, true));
            var blocknamedv = new DataView(pagexmldata, startpos + 16, bnamelength * 2);
            var bnamecount = 0;
            var blockname = String.fromCharCode(blocknamedv.getUint16(bnamecount, true));
            bnamecount += 2;
            while (bnamecount < bnamelength * 2) {

                blockname += String.fromCharCode(blocknamedv.getUint16(bnamecount, true));
                bnamecount += 2;

            }
            //move to position after first block description
            var vectordv = new DataView(pagexmldata, startpos + 16 + bnamelength * 2);

            this.blocklist[blockindx] = new BlockObject(blockid, blockname, 1, backgroundColor);
            var dvpos = 0;
            var objid = parseInt(vectordv.getInt32(dvpos, true));
            var prevobjid = objid;
            var drawlayer = -1;
            var layerstate = 1;
            var drawpen = 0;
            var lineweight = 1;
            var linewidth = 0;
            var numpoints = 0;

            var fontobject = {
                height:10,
                rotation:0,
                weight:100,
                italic:0,
                underline:0,
                name:"Arial"
            };



        }

        function parse2Dloop(){


            var readstate = {
                objectid : objid,
                prevobjectid :prevobjid,
                blockpart : blockindx,
                maindvpos :dvpos,
                dlayer : drawlayer,
                lstate : layerstate,
                dpen : drawpen,
                scolor : decimalToHex(0),
                fcolor : decimalToHex(0),
                lwidth : linewidth,
                font : fontobject,
                drawmode : 13

            };

            //blockindx = readstate.blockpart

            yieldingLoop(readstate, 1000, function() {
                readstate = parse2Dbinary(readstate);

            }, function() {
                readbinarycomplete();
            });

            (function timer() {

                if(vectordv)

                    if (readstate.objectid != 32768) {
                        setTimeout(timer, 10);
                    }

            })();


        }


        function parse2Dbinary(readstate){
            switch (readstate.objectid) {
                case 1:

                    readstate.maindvpos += 4;
                    var lX1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lY1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lX2 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lY2 = vectordv.getFloat32(readstate.maindvpos, true);


                    var lineobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        x1:lX1,
                        y1:lY1,
                        x2:lX2,
                        y2:lY2
                    };

                    var lineobj = new lineObject(lineobject, scope,readstate.blockpart, true);

                    scope.pathlist.push(lineobj);
                    scope.numpaths++;

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 2:

                    readstate.maindvpos += 4;
                    numpoints = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lY1 = vectordv.getFloat32(readstate.maindvpos, true);

                    var lpoints = [];
                    lpoints.push(lX1);
                    lpoints.push(lY1);
                    var cpnts = 1;

                    while (cpnts < numpoints) {
                        readstate.maindvpos += 4;
                        lpoints.push(vectordv.getFloat32(readstate.maindvpos, true));
                        readstate.maindvpos += 4;
                        lpoints.push(vectordv.getFloat32(readstate.maindvpos, true));
                        cpnts++;
                    }

                    var pathobject = {
                        precision : 0,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        numpoints:numpoints * 2,
                        points:lpoints,
                        filled:0,
                        gotsubpath:false,
                        shape : readstate.objectid
                    };

                    var pathobj = new pathObject(pathobject,scope,  readstate.blockpart, true);

                    scope.pathlist.push(pathobj);
                    scope.numpaths++;

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 3:

                    readstate.maindvpos += 4;
                    numpoints = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lY1 = vectordv.getFloat32(readstate.maindvpos, true);

                    lpoints = [];
                    lpoints.push(lX1);
                    lpoints.push(lY1);
                    cpnts = 1;

                    while (cpnts < numpoints) {
                        readstate.maindvpos += 4;
                        lpoints.push(vectordv.getFloat32(readstate.maindvpos, true));
                        readstate.maindvpos += 4;
                        lpoints.push(vectordv.getFloat32(readstate.maindvpos, true));
                        cpnts++;
                    }

                    pathobject = {
                        precision : 0,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        numpoints:numpoints * 2,
                        points:lpoints,
                        filled:1,
                        gotsubpath:false,
                        shape : readstate.objectid

                    };

                    pathobj = new pathObject(pathobject, scope,  readstate.blockpart, true);

                    scope.pathlist.push(pathobj);
                    scope.numpaths++;

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 13:

                    readstate.maindvpos += 4;
                    var aX = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var aY = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var aR = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var aSa = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var aEa = vectordv.getFloat32(readstate.maindvpos, true);

                    //var endangle = aSa + Math.PI;
                    /*if(aSa > 0){
                        endangle = aSa + Math.PI;
                    }else{
                        endangle = aSa - Math.PI;
                    }*/

                    /*var startangle = aSa;
                    if(startangle < 0){
                        startangle += Math.PI*2;
                    }*/

                    var arcobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        clockwise : (aEa > 0),
                        ax:aX,
                        ay:aY,
                        ar:aR,
                        asa : aSa,
                        aea : aSa + aEa
                    };

                    var arcobj = new arcObject(arcobject, scope, readstate.blockpart, true);

                    scope.pathlist.push(arcobj);
                    scope.numpaths++;

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 4:

                    readstate.maindvpos += 4;
                    var cX = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var cY = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var cR = vectordv.getFloat32(readstate.maindvpos, true);

                    var circleobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        cx:cX,
                        cy:cY,
                        cr:cR,
                        filled:0
                    };

                    var circleobj = new circleObject(circleobject, scope, readstate.blockpart, true);

                    scope.pathlist.push(circleobj);
                    scope.numpaths++;

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 5:

                    readstate.maindvpos += 4;
                    cX = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    cY = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    cR = vectordv.getFloat32(readstate.maindvpos, true);

                    circleobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        cx:cX,
                        cy:cY,
                        cr:cR,
                        filled:1
                    };

                    circleobj = new circleObject(circleobject, scope, readstate.blockpart, true);

                    scope.pathlist.push(circleobj);
                    scope.numpaths++;

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 6:

                    var numpointarr = [];
                    var subpatharr = [];
                    var subpatharrays = [];
                    //readstate.maindvpos += 4;
                    //var tnumpoints = vectordv.getInt32(readstate.maindvpos,true);
                    readstate.maindvpos += 4;
                    var subpolygons = vectordv.getInt32(readstate.maindvpos, true);
                    //readstate.maindvpos += 4;
                    //var numpoints_1 = vectordv.getInt32(readstate.maindvpos,true);
                    var pcountr = 0;

                    while (pcountr < subpolygons) {
                        readstate.maindvpos += 4;
                        numpointarr.push(vectordv.getInt32(readstate.maindvpos, true));
                        pcountr++;
                    }

                    pcountr = 0;
                    while (pcountr < subpolygons) {
                        for (var pc = 0; pc < numpointarr[pcountr]; pc++) {
                            readstate.maindvpos += 4;
                            subpatharr.push(vectordv.getFloat32(readstate.maindvpos, true));
                            readstate.maindvpos += 4;
                            subpatharr.push(vectordv.getFloat32(readstate.maindvpos, true));

                        }
                        subpatharrays.push(subpatharr);
                        subpatharr = [];
                        pcountr++;
                    }

                    pathobject = {
                        precision : 0,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        numpoints:numpointarr[0] * 2,
                        points:subpatharrays,
                        filled:1,
                        gotsubpath:true,
                        shape : readstate.objectid
                    };

                    pathobj = new pathObject(pathobject, scope, readstate.blockpart, true);

                    //lpoints = [];
                    //lpoints.push(lX1);
                    //lpoints.push(lY1);
                    //cpnts = 1;

                    /*while(cpnts<numpoints){
                     readstate.maindvpos += 4;
                     lpoints.push(vectordv.getFloat32(readstate.maindvpos,true));
                     readstate.maindvpos += 4;
                     lpoints.push(vectordv.getFloat32(readstate.maindvpos,true));
                     cpnts++;
                     }*/


                    //pathobj = new pathObject(pathobject,blockindx,true);

                    scope.pathlist.push(pathobj);
                    scope.numpaths++;

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 7:
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lY1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lX2 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lY2 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var imagelength = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var imagestr = "";
                    var curpos = readstate.maindvpos;


                    while (curpos < imagelength + readstate.maindvpos) {
                        imagestr += String.fromCharCode(vectordv.getUint8(curpos));
                        curpos++;

                    }
                    readstate.maindvpos = curpos;

                    var imageobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:lX1,
                        y1:lY1,
                        x2:lX2,
                        y2:lY2,
                        image:imagestr,
                        useref:false
                    };

                    var imgobj = new imageObject(imageobject, readstate.blockpart, true);

                    scope.pathlist.push(imgobj);
                    scope.numpaths++;

                    //readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 8:
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lY1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lX2 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lY2 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var nameLength = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    imagestr = "";
                    curpos = readstate.maindvpos;


                    while (curpos < nameLength + readstate.maindvpos) {
                        imagestr += String.fromCharCode(vectordv.getUint8(curpos));
                        curpos++;

                    }
                    readstate.maindvpos = curpos;

                    imageobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:lX1,
                        y1:lY1,
                        x2:lX2,
                        y2:lY2,
                        image:imagestr,
                        useref:true
                    };

                    imgobj = new imageObject(imageobject, readstate.blockpart, true);

                    scope.pathlist.push(imgobj);
                    scope.numpaths++;

                    //readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 10:
                    //Attribute
                    readstate.maindvpos += 4;
                    var nAttrbutenl = parseInt(vectordv.getInt32(readstate.maindvpos, true));

                    readstate.maindvpos += 4;
                    var battrncount = readstate.maindvpos;
                    var szatrrname = "";


                    while (battrncount < readstate.maindvpos + nAttrbutenl * 2) {

                        szatrrname += String.fromCharCode(vectordv.getUint16(battrncount, true));
                        battrncount += 2;

                    }
                    readstate.maindvpos = battrncount;
                    var nAttrbutevl = parseInt(vectordv.getInt32(readstate.maindvpos, true));

                    readstate.maindvpos += 4;
                    var battrvcount = readstate.maindvpos;
                    var szatrtvalue = "";


                    while (battrvcount < readstate.maindvpos + nAttrbutevl * 2) {

                        szatrtvalue += String.fromCharCode(vectordv.getUint16(battrvcount, true));
                        battrvcount += 2;

                    }
                    readstate.maindvpos = battrvcount;

                    var AttributeObject = {
                        name : szatrrname,
                        value : szatrtvalue,
                        blockref : readstate.blockpart
                    };

                    scope.attributes.push(AttributeObject);
                    //vector3Dref.partlist[blockid].addAtrib(szatrrname,szatrtvalue);
                    /*
                     0	4	LONG	Object ID	10
                     4	4	LONG	NameLength		Number of characters in name
                     8	N	CHAR[N]	Name		Attribute Name
                     8+NameLength	4	LONG	ValueLength		Number of characters in value
                     8+NameLen+4	N	CHAR[N]	Value		Attribute Value

                     */

                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = parseInt(vectordv.getInt32(readstate.maindvpos, true));
                    break;
                case 11:
                    readstate.maindvpos += 4;
                    var ltX1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var ltY1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var ltX2 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var ltY2 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;

                    if (scope.fileversion >= 2 ){
                        var ltrot = vectordv.getFloat32(readstate.maindvpos, true);
                        readstate.maindvpos += 4;

                    }else{
                        ltrot = 0;
                    }
                    if (ltrot != 0){
                        //console.log(ltrot);
                    }


                    var nTextLength = vectordv.getInt32(readstate.maindvpos, true);
                    nTextLength *= 2;
                    readstate.maindvpos += 4;
                    var textncount = readstate.maindvpos;
                    var sztextobj = "";


                    while (textncount < readstate.maindvpos + nTextLength) {


                        sztextobj += String.fromCharCode(vectordv.getUint16(textncount, true));


                        textncount += 2;

                    }
                    readstate.maindvpos = textncount;

                    var textobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:ltX1,
                        y1:ltY1,
                        x2:ltX2,
                        y2:ltY2,
                        rot:ltrot,
                        text:sztextobj,
                        draw : false
                    };


                    scope.textlist.push(textobject);
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 12:
                    readstate.maindvpos += 4;
                    var ltoX1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lt0Y1 = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;

                    nTextLength = vectordv.getInt32(readstate.maindvpos, true);
                    nTextLength *= 2;

                    readstate.maindvpos += 4;
                    textncount = readstate.maindvpos;
                    sztextobj = "";


                    while (textncount < readstate.maindvpos + nTextLength) {

                        sztextobj += String.fromCharCode(vectordv.getUint16(textncount, true));
                        textncount += 2;

                    }
                    readstate.maindvpos = textncount;

                    var dtextobject = {
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:ltoX1,
                        y1:lt0Y1,
                        text:sztextobj
                    };


                    var textobj = new textObject(dtextobject, readstate.font, readstate.blockpart);

                    scope.pathlist.push(textobj);
                    scope.numpaths++;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 21: //double line.
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lX2 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY2 = vectordv.getFloat64(readstate.maindvpos, true);


                    lineobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        x1:lX1,
                        y1:lY1,
                        x2:lX2,
                        y2:lY2
                    };

                    lineobj = new lineObject(lineobject, scope,readstate.blockpart, true);

                    scope.pathlist.push(lineobj);
                    scope.numpaths++;

                    readstate.maindvpos += 8;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;

                case 22: //double polyline.
                    readstate.maindvpos += 4;
                    numpoints = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY1 = vectordv.getFloat64(readstate.maindvpos, true);

                    lpoints = [];
                    lpoints.push(lX1);
                    lpoints.push(lY1);
                    cpnts = 1;

                    while (cpnts < numpoints) {
                        readstate.maindvpos += 8;
                        lpoints.push(vectordv.getFloat64(readstate.maindvpos, true));
                        readstate.maindvpos += 8;
                        lpoints.push(vectordv.getFloat64(readstate.maindvpos, true));
                        cpnts++;
                    }

                    pathobject = {
                        precision : 1,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        numpoints:numpoints * 2,
                        points:lpoints,
                        filled:0,
                        gotsubpath:false,
                        shape : readstate.objectid
                    };

                    pathobj = new pathObject(pathobject,scope,  readstate.blockpart, true);

                    scope.pathlist.push(pathobj);
                    scope.numpaths++;

                    readstate.maindvpos += 8;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 23: //double polygon.
                    readstate.maindvpos += 4;
                    numpoints = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY1 = vectordv.getFloat64(readstate.maindvpos, true);

                    lpoints = [];
                    lpoints.push(lX1);
                    lpoints.push(lY1);
                    cpnts = 1;

                    while (cpnts < numpoints) {
                        readstate.maindvpos += 8;
                        lpoints.push(vectordv.getFloat64(readstate.maindvpos, true));
                        readstate.maindvpos += 8;
                        lpoints.push(vectordv.getFloat64(readstate.maindvpos, true));
                        cpnts++;
                    }

                    pathobject = {
                        precision : 1,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        numpoints:numpoints * 2,
                        points:lpoints,
                        filled:1,
                        gotsubpath:false,
                        shape : readstate.objectid
                    };

                    pathobj = new pathObject(pathobject, scope,  readstate.blockpart, true);

                    scope.pathlist.push(pathobj);
                    scope.numpaths++;

                    readstate.maindvpos += 8;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 24: //double outline circle.
                    readstate.maindvpos += 4;
                    cX = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    cY = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    cR = vectordv.getFloat64(readstate.maindvpos, true);

                    circleobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        cx:cX,
                        cy:cY,
                        cr:cR,
                        filled:0
                    };

                    circleobj = new circleObject(circleobject, scope, readstate.blockpart, true);

                    scope.pathlist.push(circleobj);
                    scope.numpaths++;

                    readstate.maindvpos += 8;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;

                case 34:
                    readstate.maindvpos += 4;
                    aX = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    aY = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    aR = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    aSa = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    aEa = vectordv.getFloat64(readstate.maindvpos, true);




                    arcobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        clockwise : (aEa > 0),
                        ax:aX,
                        ay:aY,
                        ar:aR,
                        asa : aSa,
                        aea : aSa + aEa
                    };

                    arcobj = new arcObject(arcobject, scope, readstate.blockpart, true);

                    scope.pathlist.push(arcobj);
                    scope.numpaths++;

                    readstate.maindvpos += 8;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 25: //double filled circle.
                    readstate.maindvpos += 4;
                    cX = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    cY = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    cR = vectordv.getFloat64(readstate.maindvpos, true);

                    circleobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        cx:cX,
                        cy:cY,
                        cr:cR,
                        filled:1
                    };

                    circleobj = new circleObject(circleobject, scope, readstate.blockpart, true);

                    scope.pathlist.push(circleobj);
                    scope.numpaths++;

                    readstate.maindvpos += 8;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 26: //double polypolygon.
                    numpointarr = [];
                    subpatharr = [];
                    subpatharrays = [];
                    readstate.maindvpos += 4;
                    subpolygons = vectordv.getInt32(readstate.maindvpos, true);

                    pcountr = 0;

                    while (pcountr < subpolygons) {
                        readstate.maindvpos += 4;
                        numpointarr.push(vectordv.getInt32(readstate.maindvpos, true));
                        pcountr++;
                    }
                    readstate.maindvpos += 4;

                    pcountr = 0;
                    while (pcountr < subpolygons) {
                        for (pc = 0; pc < numpointarr[pcountr]; pc++) {
                            /*if(pc == 0){
                                readstate.maindvpos += 4;
                            }else{
                                readstate.maindvpos += 8;
                            }*/

                            subpatharr.push(vectordv.getFloat64(readstate.maindvpos, true));
                            readstate.maindvpos += 8;
                            subpatharr.push(vectordv.getFloat64(readstate.maindvpos, true));
                            readstate.maindvpos += 8;

                        }
                        subpatharrays.push(subpatharr);
                        subpatharr = [];
                        pcountr++;
                    }

                    pathobject = {
                        precision : 1,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        pen:readstate.dpen,
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        linewidth:readstate.lwidth,
                        numpoints:numpointarr[0] * 2,
                        points:subpatharrays,
                        filled:1,
                        gotsubpath:true,
                        shape : readstate.objectid
                    };

                    pathobj = new pathObject(pathobject, scope, readstate.blockpart, true);

                    scope.pathlist.push(pathobj);
                    scope.numpaths++;

                    //readstate.maindvpos += 8;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 27: //double image embedded.
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lX2 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY2 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    imagelength = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    imagestr = "";
                    curpos = readstate.maindvpos;


                    while (curpos < imagelength + readstate.maindvpos) {
                        imagestr += String.fromCharCode(vectordv.getUint8(curpos));
                        curpos++;

                    }
                    readstate.maindvpos = curpos;

                    imageobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:lX1,
                        y1:lY1,
                        x2:lX2,
                        y2:lY2,
                        image:imagestr,
                        useref:false
                    };

                    imgobj = new imageObject(imageobject, readstate.blockpart, true);

                    scope.pathlist.push(imgobj);
                    scope.numpaths++;

                    //readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 28: //double image referenced.
                    readstate.maindvpos += 4;
                    lX1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lX2 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lY2 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    nameLength = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    imagestr = "";
                    curpos = readstate.maindvpos;


                    while (curpos < nameLength + readstate.maindvpos) {
                        imagestr += String.fromCharCode(vectordv.getUint8(curpos));
                        curpos++;

                    }
                    readstate.maindvpos = curpos;

                    imageobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:lX1,
                        y1:lY1,
                        x2:lX2,
                        y2:lY2,
                        image:imagestr,
                        useref:true
                    };

                    imgobj = new imageObject(imageobject, readstate.blockpart, true);

                    scope.pathlist.push(imgobj);
                    scope.numpaths++;

                    //readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 31: //double text element.
                    readstate.maindvpos += 4;
                    ltX1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    ltY1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    ltX2 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    ltY2 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;

                    if (scope.fileversion >= 2 ){
                        ltrot = vectordv.getFloat64(readstate.maindvpos, true);
                        readstate.maindvpos += 8;

                    }else{
                        ltrot = 0;
                    }
                    if (ltrot != 0){
                        //console.log(ltrot);
                    }


                    nTextLength = vectordv.getInt32(readstate.maindvpos, true);
                    nTextLength *= 2;
                    readstate.maindvpos += 4;
                    textncount = readstate.maindvpos;
                    sztextobj = "";


                    while (textncount < readstate.maindvpos + nTextLength) {


                        sztextobj += String.fromCharCode(vectordv.getUint16(textncount, true));


                        textncount += 2;

                    }
                    readstate.maindvpos = textncount;

                    textobject = {
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:ltX1,
                        y1:ltY1,
                        x2:ltX2,
                        y2:ltY2,
                        rot:ltrot,
                        text:sztextobj,
                        draw : false
                    };


                    scope.textlist.push(textobject);
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 32: //double text output.
                    readstate.maindvpos += 4;
                    ltoX1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;
                    lt0Y1 = vectordv.getFloat64(readstate.maindvpos, true);
                    readstate.maindvpos += 8;

                    nTextLength = vectordv.getInt32(readstate.maindvpos, true);
                    nTextLength *= 2;

                    readstate.maindvpos += 4;
                    textncount = readstate.maindvpos;
                    sztextobj = "";


                    while (textncount < readstate.maindvpos + nTextLength) {

                        sztextobj += String.fromCharCode(vectordv.getUint16(textncount, true));
                        textncount += 2;

                    }
                    readstate.maindvpos = textncount;

                    dtextobject = {
                        strokecolor:readstate.scolor,
                        fillcolor:readstate.fcolor,
                        layer:readstate.dlayer,
                        drawmode : readstate.drawmode,
                        layerstate:readstate.lstate,
                        x1:ltoX1,
                        y1:lt0Y1,
                        text:sztextobj
                    };


                    textobj = new textObject(dtextobject, readstate.font, readstate.blockpart);

                    scope.pathlist.push(textobj);
                    scope.numpaths++;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;

                case 64:

                    readstate.maindvpos += 4;
                    var ndrawcolor = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.scolor = decimalToHex(ndrawcolor);
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 65:

                    readstate.maindvpos += 4;
                    var nfillcolor = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.fcolor = decimalToHex(nfillcolor);
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 66:

                    readstate.maindvpos += 4;
                    readstate.lwidth = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 67:

                    readstate.maindvpos += 4;
                    var linestyle = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 68:

                    readstate.maindvpos += 4;
                    readstate.dlayer = vectordv.getInt32(readstate.maindvpos, true);

                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    /*for(var lc = 0;lc<this.layerlist.length;lc++){
                     if (this.layerlist[lc].index == readstate.dlayer){
                     readstate.lstate = this.layerlist[lc].state;
                     }
                     }*/


                    break;
                case 69:

                    readstate.maindvpos += 4;
                    readstate.dpen = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 70:

                    readstate.maindvpos += 4;
                    lineweight = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 71:

                    var drawbackcolor = true;
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 72:

                    var fillbackcolor = true;
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 73:

                    readstate.maindvpos += 4;
                    var drawmode = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.drawmode = drawmode;
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    break;
                case 76:
                    readstate.maindvpos += 4;
                    var fheight = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var frotation = vectordv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var fweight = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var fitalic = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var funderline = vectordv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var fontnamelength = vectordv.getInt32(readstate.maindvpos, true);
                    fontnamelength *= 2;
                    readstate.maindvpos += 4;
                    var fnamecount = readstate.maindvpos;
                    var szfontname = "";


                    while (fnamecount < readstate.maindvpos + fontnamelength) {
                        if (vectordv.getUint16(fnamecount, true) != 0) {
                            szfontname += String.fromCharCode(vectordv.getUint16(fnamecount, true));
                        }

                        fnamecount += 2;

                    }
                    readstate.maindvpos = fnamecount;
                    readstate.font = {
                        height:fheight,
                        rotation:frotation,
                        weight:fweight,
                        italic:fitalic,
                        underline:funderline,
                        name:szfontname
                    };
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);
                    break;
                case 12288:
                    readstate.objectid = 12288;
                    readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    //end of block;
                    break;
                case 4096:
                    readstate.objectid = 4096;

                    readstate.blockpart++;
                    //readstate.maindvpos += 4;
                    //bobjid = parseInt(vectordv.getInt32(readstate.maindvpos,true));
                    readstate.maindvpos += 4;
                    readstate.blockid = parseInt(vectordv.getInt32(readstate.maindvpos, true));
                    readstate.maindvpos += 4;
                    var blockflag = parseInt(vectordv.getInt32(readstate.maindvpos, true));
                    scope.bnameunique =  (blockflag == 1);
                    readstate.maindvpos += 4;
                    bnamelength = parseInt(vectordv.getInt32(readstate.maindvpos, true));
                    readstate.maindvpos += 4;
                    bnamecount = readstate.maindvpos;
                    blockname = "";
                    //bnamecount++;
                    while (bnamecount < readstate.maindvpos + bnamelength * 2) {

                        blockname += String.fromCharCode(vectordv.getUint16(bnamecount, true));
                        bnamecount += 2;

                    }
                    readstate.maindvpos = bnamecount;

                    var bexist = false;
                    if(scope.bnameunique){
                        for (var bcount = 0;bcount < scope.blocklist.length;bcount ++){
                             if (blockname == scope.blocklist[bcount].name){
                                 readstate.blockpart = bcount;
                                 bexist = true;
                                 break;
                             }

                        }

                    }
                    if (!bexist){
                        scope.blocklist[readstate.blockpart] = new BlockObject(readstate.blockid, blockname, 1,readstate.fcolor);
                    }


                    //readstate.maindvpos += 4;
                    readstate.prevobjectid = readstate.objectid;
                    readstate.objectid = vectordv.getInt32(readstate.maindvpos, true);

                    //start of new block
                    break;
                case 32768:
                    //read complete
                    readstate.objectid = 32768;
                    break;
                default:
                    console.log('default');
                    console.log(readstate.objectid);
                    console.log(readstate.prevobjectid);
                    console.log(readstate.maindvpos);
                    readstate.objectid = 32768;

            }
            return readstate;
        }

        function readbinarycomplete(){
            scope.filterblocklist = scope.blocklist.slice();


            if (RxCore_GUI_VectorBlocks != undefined) {
                RxCore_GUI_VectorBlocks.setVectorBlocks(scope.filterblocklist);
            }

            if (RxCore_GUI_VectorBlocksLoaded != undefined) {
                RxCore_GUI_VectorBlocksLoaded.setVectorBlocks(scope.filterblocklist);
            }


            if(scope.docompare){
                comparedrawcheck();
            }else{
                //DocObj.pages[DocObj.currentpage].draw_vector(true);
                DocObj.pages[DocObj.currentpage].redraw();
            }
            if (scope.textlist.length > 0 ){
                if (RxCore_GUI_HasText != undefined){

                    RxCore_GUI_HasText.hastext = true;
                    scope.parent.DocRef.hastext = true;
                    RxCore_GUI_HasText.hasText(scope.parent.DocRef.hastext, scope.parent.DocRef.bActive);
                }
                if(scope.parent.DocRef.pages[scope.parent.DocRef.currentpage].VectorPageObj != undefined){
                    scope.parent.DocRef.pages[scope.parent.DocRef.currentpage].settextdivs(true);
                }

            }else{
                if (RxCore_GUI_HasText != undefined){
                    RxCore_GUI_HasText.hastext = false;
                    scope.parent.DocRef.hastext = false;
                    RxCore_GUI_HasText.hasText(scope.parent.DocRef.hastext, scope.parent.DocRef.bActive);
                }

            }

        }



        function blockon(count){
            var bblcckon = true;
            if (scope.blocklist.length > 0) {
                bblcckon = (scope.blocklist[scope.pathlist[count].blockname].state == 1);
            }
            return bblcckon;
        }

        function layeron(count){
            var blayeron = true;

            if (scope.layerlist.length > 0) {
                if (scope.pathlist[count].layer != -1 && scope.layerlist[scope.pathlist[count].layer] != undefined) {
                    blayeron = (scope.layerlist[scope.pathlist[count].layer].state == 1);
                }
            }

            return blayeron;
        }

        function getBlockID(blockindex){

            //var blockindex = -1;

            var blockID = scope.blocklist[blockindex].index;


            return blockID;

        }

        function getBlockIndex(blockid){
            var blockindex = -1;
            for(var bcount = 0;bcount < scope.blocklist.length;bcount++){
                if (scope.blocklist[bcount].index == blockid){
                    blockindex = bcount;
                    break;
                }
            }
            return blockindex;
        }

        function getAttributes(blockindex){
            var partlist = [];
            //var blockindex = getBlockIndex(blockid);

            for(var attrc=0;attrc < scope.attributes.length;attrc++){
                if(scope.attributes[attrc].blockref == blockindex){
                    partlist.push(scope.attributes[attrc]);

                }
            }

            return partlist;

        }

        this.getInterSections = function(){
            this.intersections = [];

            for (var i = 0; i < this.pathlist.length; i++) {
                var blayeron = layeron(i);
                var bblcckon = blockon(i);

                if (blayeron && bblcckon && this.pathlist[i].type == "line") {
                    for (var j = 0; j < this.pathlist.length; j++) {
                        if(i != j){
                            var blayeron = layeron(j);
                            var bblcckon = blockon(j);

                            if (blayeron && bblcckon) {
                                if (this.pathlist[j].type == "line"){
                                    var intersect = this.pathlist[j].findInterSections(this.pathlist[i]);
                                    if(intersect){
                                        this.intersections.push(intersect);
                                    }

                                }

                            }

                        }

                    }
                }
            }

        };

        this.getBlocks = function(){
            return scope.filterblocklist;
        };

        this.restoreBlockStates = function(){
            for(var bcount = 0;bcount < scope.blocklist.length;bcount++){

                    scope.blocklist[bcount].overridecolor = false;
                    scope.blocklist[bcount].color = scope.blocklist[bcount].defaultcolor;

            }

        };

        this.setBlockColor = function(blockid , Color, override){
            //var blockindex = 0;
            var blockindex = getBlockIndex(blockid);

            scope.blocklist[blockindex].overridecolor = override;
            if (override){
                scope.blocklist[blockindex].color = Color;
            }else{
                scope.blocklist[blockindex].color = scope.blocklist[blockindex].defaultcolor;
            }

            /*for(var bcount = 0;bcount < scope.blocklist.length;bcount++){
                if (scope.blocklist[bcount].index == blockid){
                    scope.blocklist[bcount].color = Color;
                    break;
                }
            }*/

        };

        this.appendCustomBlockAttribute = function(blockid , name, value){
            var blockindex = getBlockIndex(blockid);

            var AttributeObject = {
                name : name,
                value : value,
                blockref : blockindex
            };

            scope.attributes.push(AttributeObject);

        };



        this.FindBlockByAttr = function(attrname, attrvalue){

            var blockref = -1;
            var blockindex = -1;
            //matchRuleShort(block.name, szBlockLoadMask);
            for(var attrc=0;attrc < scope.attributes.length;attrc++){
                if(scope.attributes[attrc].name.toUpperCase() == attrname.toUpperCase() && scope.attributes[attrc].value == attrvalue){

                     blockref = scope.attributes[attrc].blockref;
                    break;
                }
            }


            if (blockref != -1){
                blockindex = scope.blocklist[blockref].index;
                /*for(var bcount = 0;bcount < scope.blocklist.length;bcount++){
                    if (scope.blocklist[bcount].index == blockref){
                        blockindex = bcount;
                        break;
                    }
                }*/

            }

            return blockindex;

        };


        this.ViewMode = function(onoff){
            scope.viewmode = onoff;
        };

        this.unSelectAllBlocks = function(notify){
            for (var i = 0; i < scope.pathlist.length; i++) {
                if(scope.pathlist[i].type == "path"){
                    scope.pathlist[i].unselect();
                }
            }
            var partlist = [];
            if(notify){
                if (RxCore_GUI_2DBlockInfo != undefined) {
                    RxCore_GUI_2DBlockInfo.set2DBlockInfo(partlist);
                }

            }


        };

        this.blockAttributes = function(blockid){
            var partlist = [];
            var blockindex = getBlockIndex(blockid);
            partlist = getAttributes(blockindex);

            return partlist;

        };

        this.selectBlockPath = function(select, blockid){
            //var blockindex = getBlockIndex(blockid);


            for (var i = 0; i < scope.pathlist.length; i++) {
                var blayeron = layeron(i);
                var bblcckon = blockon(i);
                if (blayeron && bblcckon) {
                    if(scope.pathlist[i].blockname == blockid){
                        if(scope.pathlist[i].type == 'path'){

                            if(select){
                                scope.pathlist[i].select();
                            }else{
                                scope.pathlist[i].unselect();
                            }
                        }
                    }
                }
            }

        };

        this.selectBlock = function(blockid){
            var partlist = [];

            //getBlockIndex(blockid);
            var blockindex = getBlockIndex(blockid);


            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);


                if (blayeron && bblcckon) {
                    //within = scope.pathlist[i].insidePolygon(x, y, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h);
                    if(scope.pathlist[i].blockname == blockindex){
                        if(scope.pathlist[i].type == 'path'){
                            scope.pathlist[i].toggleselect();
                        }


                        if (scope.pathlist[i].selected){
                            partlist = getAttributes(blockindex);


                        }else{
                            partlist = [];
                        }

                    }else{

                        if(scope.pathlist[i].type == "path"){
                            scope.pathlist[i].unselect();
                        }


                    }

                }
            }
            if (RxCore_GUI_2DBlockID != undefined) {
                RxCore_GUI_2DBlockID.set2DBlockID([scope.blocklist[blockindex].index]);
            }


            if (RxCore_GUI_2DBlockInfo != undefined) {
                RxCore_GUI_2DBlockInfo.set2DBlockInfo(partlist);
            }


        };

        this.getblockcentroid = function(blockid,scalefactor, offsetx, offsety){
            //this.getcentroid

            var blockindex = getBlockIndex(blockid);
            var centroid = {};

            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);

                if (blayeron && bblcckon) {

                    if(scope.pathlist[i].blockname == blockindex){
                        centroid = scope.pathlist[i].getcentroid(scalefactor, offsetx, offsety,scope.x, scope.y, scope.h);
                        break;
                    }
                }
            }

            return centroid;

        };

        this.getBlockRect = function(blockid,scalefactor, offsetx, offsety){
            var blockindex = getBlockIndex(blockid);
            //var rect = {x:0,y:0,w:0,h:0};
            var rect =   {
                found : false,
                x : 0,
                y : 0,
                w : 0,
                h : 0,
                wp : 0,
                hp : 0
            };

            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);

                if (blayeron && bblcckon) {

                    if(scope.pathlist[i].blockname == blockindex){
                        rect = scope.pathlist[i].getRectangle(scalefactor, offsetx, offsety,scope.x, scope.y, scope.h);
                        break;
                    }
                }
            }

            return rect;
        };

        this.getpathbybId = function(blockid){
            var path = null;
            var blockindex = getBlockIndex(blockid);

            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);

                if (blayeron && bblcckon) {

                    if(scope.pathlist[i].blockname == blockindex){
                        //rect = scope.pathlist[i].getRectangle(scalefactor, offsetx, offsety,scope.x, scope.y, scope.h);
                        path = scope.pathlist[i].getblockPath();

                        break;
                    }
                }
            }


            return path;

        };



        this.getpathPointsBybId = function(blockid){
            var pointlist = [];
            var blockindex = getBlockIndex(blockid);

            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);

                if (blayeron && bblcckon) {

                    if(scope.pathlist[i].blockname == blockindex){
                        //rect = scope.pathlist[i].getRectangle(scalefactor, offsetx, offsety,scope.x, scope.y, scope.h);
                        pointlist = scope.pathlist[i].getblockPathPoints();

                        break;
                    }
                }
            }


            return pointlist;

            /*var points = [];
            if (thispage.usevectorxml){
                points =  thispage.VectorPageObj.getpathPoints(x, y, thispage.dscalevector, thispage.dxvector, thispage.dyvector);
            }

            return points;*/


        };


        this.getpath = function(x, y, scalefactor, offsetx, offsety){
            var rotatedpoint = {x:x,y:y};

            if(scope.parent.DocRef.pages[scope.parent.DocRef.currentpage].drotation != 0){
                rotatedpoint = mouse_rotated(x,y);
            }

            x = rotatedpoint.x;
            y = rotatedpoint.y;

            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);


                if (blayeron && bblcckon) {
                    if(scope.pathlist[i].getpath){

                        if (typeof scope.pathlist[i].getpath === "function"){
                            var polyPath = scope.pathlist[i].getpath(x, y, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h);
                            if (polyPath != null){
                                return polyPath;
                            }

                        }


                    }

                    /*if(within){
                        //scope.pathlist[i].toggleselect();
                        foundblock = scope.pathlist[i].blockname;
                        partindex = i;


                    }else{
                        //foundblock = undefined;
                    }*/
                }
            }
            return null;
        };

        this.getpathPoints = function(x, y, scalefactor, offsetx, offsety){
            var rotatedpoint = {x:x,y:y};
            var pointlist = [];

            if(scope.parent.DocRef.pages[scope.parent.DocRef.currentpage].drotation != 0){
                rotatedpoint = mouse_rotated(x,y);
            }

            x = rotatedpoint.x;
            y = rotatedpoint.y;

            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);


                if (blayeron && bblcckon) {
                    if(scope.pathlist[i].getpathPoints){

                        if (typeof scope.pathlist[i].getpathPoints === "function"){
                            var polypoints = scope.pathlist[i].getpathPoints(x, y, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h);
                            if (polypoints.length > 0){
                                return polypoints;
                            }

                        }


                    }

                    /*if(within){
                        //scope.pathlist[i].toggleselect();
                        foundblock = scope.pathlist[i].blockname;
                        partindex = i;


                    }else{
                        //foundblock = undefined;
                    }*/
                }
            }
            return pointlist;
        };

        this.getinsidePolygon = function(x, y, scalefactor, offsetx, offsety,multi){
            scope.multiselect = multi;
            var within = false;
            var rotatedpoint = {x:x,y:y};
            var partlist = [];
            var selected = [];
            var foundblock = undefined;
            var partindex = undefined;

            if(scope.parent.DocRef.pages[scope.parent.DocRef.currentpage].drotation != 0){
                rotatedpoint = mouse_rotated(x,y);
            }

            x = rotatedpoint.x;
            y = rotatedpoint.y;

            for (var i = 0; i < scope.pathlist.length; i++) {

                var blayeron = layeron(i);
                var bblcckon = blockon(i);


                if (blayeron && bblcckon) {
                    within = scope.pathlist[i].insidePolygon(x, y, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h);
                    if(within){
                        //scope.pathlist[i].toggleselect();
                        foundblock = scope.pathlist[i].blockname;
                        partindex = i;


                    }else{
                        //foundblock = undefined;
                        if(multi){
                            if (scope.pathlist[i].selected){
                                var blockindex = scope.pathlist[i].blockname;
                                selected.push(scope.blocklist[blockindex].index);
                            }
                        }
                    }
                }
            }

            if (foundblock){
                if(!scope.pathlist[partindex].selected){
                    scope.selectBlockPath(true,scope.pathlist[partindex].blockname);
                }else{
                    scope.selectBlockPath(false,scope.pathlist[partindex].blockname);
                }

                if(scope.pathlist[partindex].selected){
                    selected.push(scope.blocklist[foundblock].index);
                    if(!multi){
                        partlist = getAttributes(foundblock);
                    }

                }else{
                    if(!multi){
                        partlist = [];
                    }

                }

            }

            if (RxCore_GUI_2DBlockID != undefined) {
                RxCore_GUI_2DBlockID.set2DBlockID(selected);
            }

            if(!multi){
                if (RxCore_GUI_2DBlockInfo != undefined) {
                    RxCore_GUI_2DBlockInfo.set2DBlockInfo(partlist);
                }

            }


        };



        this.resetLayers = function () {
            for (var i = 0; i < this.layerlist.length; i++) {
                if (this.layerlist[i] == undefined) {
                    continue;
                }
                this.layerlist[i].state = this.layerlist[i].defaultstate;
            }
            if (RxCore_GUI_VectorLayers != undefined) {
                RxCore_GUI_VectorLayers.setVectorLayers(this.layerlist);
            }
        };

        this.filterBlocks = function(szBlockLoadMask){


            scope.filterblocklist = scope.blocklist.filter(function(block){
                return matchRuleShort(block.name, szBlockLoadMask);
            });

            if (RxCore_GUI_VectorBlocks != undefined) {
                RxCore_GUI_VectorBlocks.setVectorBlocks(scope.filterblocklist);
            }

            //matchRuleShort("bird123", "bird*")
        };

        this.turnBlockAllOnOff = function(OnOff){
            for (var i = 0; i < scope.filterblocklist.length; i++) {
                if (scope.filterblocklist[i] == undefined) {
                    continue;
                }

                scope.filterblocklist[i].state = OnOff ? 1:0;
            }

            for (i = 0; i < scope.blocklist.length; i++) {
                if (scope.blocklist[i] == undefined) {
                    continue;
                }

                scope.blocklist[i].state = OnOff ? 1:0;
            }


            if (RxCore_GUI_VectorBlocks != undefined) {
                RxCore_GUI_VectorBlocks.setVectorBlocks(scope.filterblocklist);
            }


        };

        this.turnLayerAllOnOff = function(OnOff){
            for (var i = 0; i < this.layerlist.length; i++) {
                if (this.layerlist[i] == undefined) {
                    continue;
                }

                this.layerlist[i].state = OnOff ? 1:0;
            }

            if (RxCore_GUI_VectorLayers != undefined) {
                RxCore_GUI_VectorLayers.setVectorLayers(scope.layerlist);
            }

        };

        this.setActive = function(){
            if (RxCore_GUI_VectorLayers != undefined) {
                RxCore_GUI_VectorLayers.setVectorLayers(scope.layerlist);
            }
            if (RxCore_GUI_VectorBlocks != undefined) {
                RxCore_GUI_VectorBlocks.setVectorBlocks(scope.filterblocklist);
            }

        };

        this.turnLayerOnOff = function (layerindex) {
            if (this.layerlist[layerindex].state == 1) {
                this.layerlist[layerindex].state = 0;

            } else {
                this.layerlist[layerindex].state = 1;

            }

            /*for (var i=0; i<this.pathlist.length;i++){
             if(layerindex == this.pathlist[i].layer ){
             this.pathlist[i].layerstate = this.layerlist[layerindex].state;
             }

             }*/
            /*for (i=0;i<this.layerlist.length-1;i++){
             if (this.layerlist[i].index == layerindex){
             if (this.layerlist[i].state == 1){
             this.layerlist[i].state = 0;
             return;
             }else{
             this.layerlist[i].state = 1;
             return;
             }
             }
             }*/
        };

        this.resetBlocks = function () {
            for (var i = 0; i < scope.filterblocklist.length; i++) {
                if (scope.filterblocklist[i] == undefined) {
                    continue;
                }
                scope.filterblocklist[i].state = scope.filterblocklist[i].defaultstate;
            }

            for (i = 0; i < scope.blocklist.length; i++) {
                if (scope.blocklist[i] == undefined) {
                    continue;
                }
                scope.blocklist[i].state = scope.blocklist[i].defaultstate;
            }


            if (RxCore_GUI_VectorBlocks != undefined) {
                RxCore_GUI_VectorBlocks.setVectorBlocks(scope.filterblocklist);
            }
        };

        this.turnBlockOnOff = function (index) {
            for (var i = 0; i < scope.filterblocklist.length; i++) {
                if (index == scope.filterblocklist[i].index) {
                    var bstate = (scope.filterblocklist[i].state == 1) ? 0 : 1;
                    scope.filterblocklist[i].state = bstate;
                }
            }

            for (i = 0; i < scope.blocklist.length; i++) {
                if (index == scope.blocklist[i].index) {
                    bstate = (scope.blocklist[i].state == 1) ? 0 : 1;
                    scope.blocklist[i].state = bstate;
                    //this.blocklist[i].state = (this.blocklist[i].state == 1) ? 0 : 1;

                    //(this.blocklist[i].state == 0) ? this.blocklist[i].state = 1 : this.blocklist[i].state = 0;
                    //(this.blocklist[i].state == 1) ? this.blocklist[i].state = 0 : this.blocklist[i].state = 1;
                    //this.blocklist[i].state = 1;
                    /*for (var j=0; j<this.pathlist.length;j++){
                     if(blockName == this.pathlist[j].blockname ){
                     this.pathlist[j].blockstate = 1;
                     }

                     }*/

                } /*else if (index == this.blocklist[i].index && this.blocklist[i].state == 1) {
                 this.blocklist[i].state = 0;

                 }*/


            }
        };

        function getrotpoint(width, height, x, y, anglerad){
            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);

            var hw = x - width;
            var hh = y - height;

            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);

            var transpoint = {x:newx, y:newy};
            transpoint.x = width + transpoint.x;
            transpoint.y = height + transpoint.y;
            return transpoint;

        }

        function rotate_pointrad(point, originX, originY, radians) {

            //var new_x_point = old_x_point * cos(Angle) - old_y_point * sin(Angle);
            //var new_y_point = old_y_point * cos(Angle) + old_x_point * sin(Angle);

            var transpx = point.x - originX;
            var transpy = point.y - originY;


            return {
                x: (Math.cos(radians) * (transpx) - Math.sin(radians) * (transpy)) + originX,
                y: (Math.sin(radians) * (transpx) + Math.cos(radians) * (transpy)) + originY
            };
        }

        this.rotate_point = function(pointX, pointY, originX, originY, angle) {
            angle = angle * Math.PI / 180.0;
            return {
                x: Math.cos(angle) * (pointX-originX) - Math.sin(angle) * (pointY-originY) + originX,
                y: Math.sin(angle) * (pointX-originX) + Math.cos(angle) * (pointY-originY) + originY
            };
        };

        this.gettextpos = function(marerobj,scalefactor,offsetx,offsety){
            //scope.x, scope.y, scope.h,layerstate,blockstate

            var x1scaled = Math.min(((marerobj.x1 - scope.x) * scalefactor),((marerobj.x2 - scope.x) * scalefactor));
            var y1scaled = Math.min(((scope.h - marerobj.y1) * scalefactor),((scope.h - marerobj.y2) * scalefactor));
            var x2scaled = Math.max(((marerobj.x1 - scope.x) * scalefactor),((marerobj.x2 - scope.x) * scalefactor));
            var y2scaled = Math.max(((scope.h - marerobj.y1) * scalefactor),((scope.h - marerobj.y2) * scalefactor));

            //marerobj.rot

            var centerx = x1scaled + ((x2scaled - x1scaled)/2);
            var centery = y1scaled + ((y2scaled - y1scaled)/2);

            var ulrotpoint = scope.rotate_point(x1scaled,y1scaled,centerx,centery,marerobj.rot);
            var lrrotpoint = scope.rotate_point(x2scaled,y2scaled,centerx,centery,marerobj.rot);

            x1scaled = Math.min(ulrotpoint.x,lrrotpoint.x);
            y1scaled = Math.min(ulrotpoint.y,lrrotpoint.y);
            x2scaled = Math.max(ulrotpoint.x,lrrotpoint.x);
            y2scaled = Math.max(ulrotpoint.y,lrrotpoint.y);



            return  {
                top : y1scaled,
                left : x1scaled,
                width : Math.abs(x2scaled - x1scaled),
                height : Math.abs(y2scaled - y1scaled),
                fontsize : y2scaled - y1scaled

            };

            /*function textmarkerdiv(marerobj,scalefactor,offsetx,offsety,mediax,mediay,mediah){

             }*/

        };

        this.TextLayerClear = function(texlayerdata){

            if(texlayerdata.textLayerDiv != undefined){
                while (texlayerdata.textLayerDiv.firstChild) {
                    texlayerdata.textLayerDiv.removeChild(texlayerdata.textLayerDiv.firstChild);
                }

            }
            scope.textlayerset = false;

        };

        this.TextLayerBuilder = function(texlayerdata){

            if(scope.textlayerset){
                return;
            }

            //var div = texlayerdata.textLayerDiv;
            for (var i=0;i < scope.textlist.length;i++){
                var textdivpos = scope.gettextpos(scope.textlist[i],texlayerdata.scale,texlayerdata.dx,texlayerdata.dy);
                var textdiv = document.createElement('div');
                var localx = textdivpos.left;
                var localy = textdivpos.top;

                if(scope.textlist[i].rot != 0){
                    //var radangle = scope.textlist[i].rot * (Math.PI/180);
                    //localx -= (textdivpos.height/2);

                    //localx = (textdivpos.left*Math.cos(radangle))-(textdivpos.top*Math.sin(radangle));
                    //localy = (textdivpos.left*Math.sin(radangle))+(textdivpos.top*Math.cos(radangle));

                }
                //<div data-canvas-width="132.41322" style="left: 191.37px; top: 228.609px; font-size: 14.94px; font-family: sans-serif; transform: scaleX(1.04262);">
                textdiv.style.left = localx + "px";
                textdiv.style.top = localy + "px";
                textdiv.style.width = textdivpos.width + "px";
                textdiv.style.height = textdivpos.height + "px";
                textdiv.style.fontFamily = "sans-serif";
                textdiv.style.fontSize = textdivpos.fontsize + "px";
                textdiv.style.transform="scale(1.3)";
                textdiv.textContent = scope.textlist[i].text;

                if(scope.textlist[i].rot != 0){
                    textdiv.style.transformOrigin="50% 50%";
                    var normrot = -scope.textlist[i].rot;
                    var szrotation = "scale(1.3) rotate(" + normrot + "deg)";
                    textdiv.style.transform = szrotation;

                }else{
                    //textdiv.style.fontFamily = "sans-serif";
                    //textdiv.style.fontSize = textdivpos.fontsize + "px";
                    //textdiv.textContent = scope.textlist[i].text;
                }


                texlayerdata.textLayerDiv.appendChild(textdiv);

            }
            scope.textlayerset = true;
        };

        this.clearSearchAll = function(){
            for (var i=0;i < scope.textlist.length;i++){
                scope.textlist[i].draw = false;
            }
        };

        this.textSearch = function(text,start){

            for (var i=start;i < scope.textlist.length;i++){
                if (scope.textlist[i].text == text){
                    return {
                        numtexts : scope.textlist.length,
                        position : i,
                        textobject : scope.textlist[i]
                    };
                }
            }
            //return last instance and check for match
            return {
                numtexts : scope.textlist.length,
                position : i,
                textobject : scope.textlist[i-1]
            };

        };

        this.highlightText = function(indx){

            scope.textlist[indx].draw = true;


        };

        this.getsnapPoint = function (x, y, scalefactor, offsetx, offsety) {

            var snappoint = {
                found:false,
                x:0,
                y:0
            };

            var linesegments = [];

            var rotatedpoint = {x:x,y:y};

            if(scope.parent.DocRef.pages[scope.parent.DocRef.currentpage].drotation != 0){
                rotatedpoint = mouse_rotated(x,y);
            }

            x = rotatedpoint.x;
            y = rotatedpoint.y;
            var snappoints = [];
            //var pathlines = [];


            //get all lines

            for (var i = 0; i < this.pathlist.length; i++) {
                //var localoffsetx = this.x * scalefactor;
                //var localoffsety = this.y * scalefactor;
                //this.layerlist[this.pathlist[i].layer].state == 1
                //this.blocklist[this.pathlist[i].blockname].state == 1
                var blayeron = layeron(i);
                var bblcckon = blockon(i);


                //var blayeron = true;
                //var bblcckon = true;

                /*if (this.layerlist.length > 0) {

                    if (this.pathlist[i].layer != -1 && this.layerlist[this.pathlist[i].layer] != undefined) {
                        blayeron = (this.layerlist[this.pathlist[i].layer].state == 1);
                    }
                }
                if (this.blocklist.length > 0) {
                    bblcckon = (this.blocklist[this.pathlist[i].blockname].state == 1);
                }*/


                if (blayeron && bblcckon) {
                    snappoint = this.pathlist[i].findsnapPoint(x, y, scalefactor, offsetx, offsety, this.x, this.y, this.h);

                    if (snappoint == undefined) {
                        snappoint = {
                            found:false,
                            x:0,
                            y:0,
                            type:1
                        };
                    }
                    if (snappoint.found){
                        snappoints.push(snappoint);
                    }

                    if (this.pathlist[i].type == "line"){
                        if(this.pathlist[i].closeToMouse(x, y, scalefactor, offsetx, offsety, this.x, this.y, this.h)){
                            linesegments.push(i);
                        }
                    }

                    /*if (this.pathlist[i].type == "line"){
                        for (var j = 0; j < this.pathlist.length; j++) {
                            var blayeron = layeron(j);
                            var bblcckon = blockon(j);

                            if (blayeron && bblcckon) {
                                if (this.pathlist[j].type == "line"){
                                   var intersect = this.pathlist[j].getInterSection(x,y,this.pathlist[i],scalefactor, offsetx, offsety, this.x, this.y, this.h);
                                   if(intersect){
                                        snappoints.push({found : true, x : intersect.x, y: intersect.y, type:2});
                                   }
                                }
                            }
                        }

                    }*/

                }
            }


            //this.intersections
            //this.getInterSection = function(x,y,line, scalefactor, offsetx, offsety, mediax, mediay, mediah){

            //var snapradius = 10;

            for(var ints = 0;ints < linesegments.length;ints++){

                for (var intsinner = 0; intsinner < linesegments.length; intsinner++) {

                    if(ints != intsinner){
                        var intersect = this.pathlist[linesegments[intsinner]].getInterSection(x,y,this.pathlist[linesegments[ints]],scalefactor, offsetx, offsety, this.x, this.y, this.h);

                        if(intersect){
                            snappoints.push({found : true, x : intersect.x, y: intersect.y, type:2});
                        }
                    }
                }
            }

            /*for(var ints = 0;ints < this.intersections.length; ints++){

                var xscaled =  (this.intersections[ints].x - this.x) * scalefactor;
                var yscaled =  (this.h - this.intersections[ints].y) * scalefactor;

                xscaled += offsetx;
                yscaled += offsety;


                if (xscaled > x - snapradius && xscaled < x + snapradius) {
                    if (yscaled > y - snapradius && yscaled < y + snapradius) {

                        snappoints.push({found: true, x: xscaled, y: yscaled, type : 2});
                    }

                }

            }*/


            if(snappoints.length > 0){
                var a = x - snappoints[0].x;
                var b = y - snappoints[0].y;
                var curdist = Math.sqrt(a*a + b*b);
                var tempdist = Math.sqrt(a*a + b*b);
                var snapindx = 0;

                for (i = 0;i<snappoints.length;i++){

                    if (snappoints[i].found){
                        a = x - snappoints[i].x;
                        b = y - snappoints[i].y;
                        tempdist = Math.sqrt(a*a + b*b);

                        if (tempdist < curdist){
                            curdist = tempdist;
                            snapindx = i;
                        }
                    }

                }

                snappoint = snappoints[snapindx];
                /*if(DocObj.pages[DocObj.currentpage].drotation != 0){
                    rotatedpoint = mouse_rotated(snappoint.x,snappoint.y);
                    snappoint.x = rotatedpoint.x;
                    snappoint.y = rotatedpoint.y;
                }*/


            }else{
                snappoint = {
                    found:false,
                    x:0,
                    y:0
                };

            }

            return snappoint;


        };


        this.offscreenscale = function (scalefactor) {
            if(this.backgroundrender){
                return this.offscreen.width / (this.width * scalefactor);
            }else{
                return 1;
            }

        };

        this.drawallmagnifycmpre = function(context, scalefactor, offsetx, offsety,comparecolor, isbackground){
            //this.isbackground = isbackground;
            this.docompare = true;
            this.comparecolor = comparecolor;
            //console.log(isbackground);
            //console.log(comparecolor);
            //backgroundColor = 'white';
            if (isbackground) {
                context.globalCompositeOperation = 'source-over';
                context.fillStyle = 'white';
                //context.fillRect(offsetx, offsety, this.width * scalefactor, this.height * scalefactor);
                context.fillRect(0, 0, magcanvas.width, magcanvas.height);

            } else {
                if(bShowDiffonly){
                    context.globalCompositeOperation = szdrawmode;
                }else{
                    context.globalCompositeOperation = 'darken';
                }


            }

            scope.drawallmagnify(context, scalefactor, offsetx, offsety);


        };

        this.drawallmagnify = function(context, scalefactor, offsetx, offsety){

            var layerstate = 1;
            var blockstate = 1;


            for (var pindx = 0; pindx < scope.pathlist.length; pindx++) {

                layerstate = layeron(i) ? 1 : 0;
                blockstate = blockon(i) ? 1 : 0;


                /*if (scope.layerlist.length > 0) {
                    if (scope.pathlist[pindx].layer != -1 && scope.layerlist[scope.pathlist[pindx].layer] != undefined) {
                        layerstate = scope.layerlist[scope.pathlist[pindx].layer].state;
                    }

                }
                if (scope.blocklist.length > 0) {
                    blockstate = scope.blocklist[scope.pathlist[pindx].blockname].state;
                }*/

                if (scope.docompare) {
                    if(scope.dooverlay){
                        scope.pathlist[pindx].drawemeoverlay(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, layerstate,blockstate);
                    }else{
                        scope.pathlist[pindx].drawemecompare(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, scope.comparecolor,layerstate,blockstate);
                    }

                } else {
                    if(scope.pathlist[pindx]){
                        if(scope.pathlist[pindx].type == "line"){
                            drawvectorline(scope.pathlist[pindx],context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate,false);
                        }else{
                            scope.pathlist[pindx].drawme(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate,false);
                        }


                    }

                }

            }
        };

        /*this.drawallcmpre = function (context, scalefactor, offsetx, offsety, refresh, comparecolor, isbackground) {

            this.isbackground = isbackground;
            this.docompare = true;
            this.comparecolor = comparecolor;
            //backgroundColor = 'white';
            if (this.isbackground) {
                context.globalCompositeOperation = 'source-over';
                context.fillStyle = 'white';
                context.fillRect(offsetx, offsety, this.width * scalefactor, this.height * scalefactor);

            } else {
                context.globalCompositeOperation = 'darken';
            }


            this.drawall(context, scalefactor, offsetx, offsety, refresh,false);



        };*/
        this.drawallcmpre = function (context, scalefactor, offsetx, offsety, refresh, comparecolor, isbackground, mode) {

            this.isbackground = isbackground;

            this.dooverlay = (mode == 1);
            this.docompare = true;
            this.comparecolor = comparecolor;


            //backgroundColor = 'white';
            if (this.isbackground) {
                //context.globalCompositeOperation = 'source-over';


                if(bShowDiffonly){
                    //context.fillStyle = 'black';
                    context.clearRect(offsetx, offsety, this.width * scalefactor, this.height * scalefactor);

                    context.globalCompositeOperation = szdrawmode;
                }else{
                    context.globalCompositeOperation = 'darken';
                }



            } else {

                if(bShowDiffonly){
                    context.globalCompositeOperation = szdrawmode;
                }else{
                    context.globalCompositeOperation = 'darken';
                }

            }


            this.drawallnew(context, scalefactor, offsetx, offsety, refresh,false);


        };

        this.drawallnew = function(context, scalefactor, offsetx, offsety, refresh,drawprint){
            var vectorstartrender = new Date().getTime();


            var layerstate = 1;
            var blockstate = 1;
            var curdrawmode = 13;

            if ((scope.width * scalefactor) * (scope.height * scalefactor) > nMaximageArea) {
                scope.backgroundrender = false;

                if (!scope.docompare) {
                    if(drawprint){
                        context.fillStyle = 'white';
                    }else{
                        context.fillStyle = scope.parent.DocRef.backgroundColor;
                    }

                    context.fillRect(offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);

                }
                for (var pindx = 0; pindx < scope.pathlist.length; pindx++) {

                    layerstate = layeron(pindx) ? 1 : 0;
                    blockstate = blockon(pindx) ? 1 : 0;


                    if (scope.docompare) {
                        if(scope.dooverlay){
                            scope.pathlist[pindx].drawemeoverlay(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, layerstate,blockstate);
                        }else{
                            scope.pathlist[pindx].drawemecompare(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, scope.comparecolor,layerstate,blockstate);
                        }


                    } else {
                        if(scope.pathlist[pindx]){
                            /*if(scope.pathlist[pindx].drawmode != curdrawmode){
                                switch(scope.pathlist[pindx].drawmode){
                                    case 13 :
                                        context.globalCompositeOperation = 'source-over';
                                        break;
                                    case 9 :
                                        context.globalCompositeOperation = 'darken';
                                        break;
                                    case 7 :
                                        context.globalCompositeOperation = 'darken';
                                        break;
                                    default :
                                        context.globalCompositeOperation = 'source-over';
                                        break;
                                }
                                curdrawmode = scope.pathlist[pindx].drawmode;
                            }*/
                            if(scope.pathlist[pindx].type == "line"){
                                drawvectorline(scope.pathlist[pindx],context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                            }else{
                                scope.pathlist[pindx].drawme(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                            }

                        }


                    }

                }


            } else {
                scope.backgroundrender = true;

                //context.drawImage(scope.offscreen, offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);
                //context.drawImage(scope.offscreen, offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);

                if (refresh) {
                    scope.offscreen.width = scope.width * scalefactor;
                    scope.offscreen.height = scope.height * scalefactor;
                    //offscreenctx = scope.offscreen.getContext('2d');
                    setSmoothingEnabledEx(true,scope.offscreenctx);

                    if (!scope.docompare) {
                        if(drawprint){
                            scope.offscreenctx.fillStyle = 'white';
                        }else{
                            scope.offscreenctx.fillStyle = scope.parent.DocRef.backgroundColor;
                        }

                        scope.offscreenctx.fillRect(0, 0, scope.width * scalefactor, scope.height * scalefactor);

                    }else{
                        scope.offscreenctx.clearRect(0, 0, scope.width * scalefactor, scope.height * scalefactor);
                    }
                    //offscreenctx.globalCompositeOperation = 'source-over';
                    var pathcount = 0;


                    while(pathcount < scope.pathlist.length){

                        layerstate = layeron(pathcount) ? 1 : 0;
                        blockstate = blockon(pathcount) ? 1 : 0;



                        if (scope.docompare) {

                            /*if(scope.pathlist[pathcount].type == "line"){
                             drawvectorline(scope.pathlist[pathcount],scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                             }else{

                             }*/
                            if(scope.dooverlay){
                                scope.pathlist[pathcount].drawemeoverlay(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h, layerstate,blockstate);
                            }else{
                                scope.pathlist[pathcount].drawemecompare(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h, scope.comparecolor,layerstate,blockstate);
                            }


                        } else {
                            /*if(scope.pathlist[pathcount].drawmode != curdrawmode){
                                switch(scope.pathlist[pathcount].drawmode){
                                    case 13 :
                                        scope.offscreenctx.globalCompositeOperation = 'source-over';
                                        break;
                                    case 9 :
                                        scope.offscreenctx.globalCompositeOperation = 'darken';
                                        break;
                                    case 7 :
                                        scope.offscreenctx.globalCompositeOperation = 'darken';
                                        break;
                                    default :
                                        scope.offscreenctx.globalCompositeOperation = 'source-over';
                                        break;
                                }
                                curdrawmode = scope.pathlist[pathcount].drawmode;
                            }*/


                            if(scope.pathlist[pathcount].type == "line"){
                                drawvectorline(scope.pathlist[pathcount],scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                            }else{
                                scope.pathlist[pathcount].drawme(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                            }

                        }

                        pathcount ++;

                    }



                }
                context.drawImage(this.offscreen, offsetx, offsety, this.width * scalefactor, this.height * scalefactor);

            }

            scope.firstdraw = true;
            if(scope.docompare){
                scope.firstdrawcompare = true;

            }

            var vectorendrender = new Date().getTime();
            scope.vectorpagetime = (vectorendrender - vectorstartrender);


        };

        this.drawSelected = function(context, scalefactor, offsetx, offsety){
            if(scope.selectedobject == undefined){
                return;
            }

            var layerstate = 1;
            var blockstate = 1;
            var curdrawmode = 13;

            if ((scope.width * scalefactor) * (scope.height * scalefactor) > nMaximageArea) {
                scope.backgroundrender = false;

                if (scope.layerlist.length > 0) {
                    if (scope.selectedobject.layer != -1 && scope.layerlist[scope.selectedobject.layer] != undefined) {
                        layerstate = scope.layerlist[scope.selectedobject.layer].state;
                    }

                }
                if (scope.blocklist.length > 0) {
                    blockstate = scope.blocklist[scope.selectedobject.blockname].state;
                    /*if (scope.blocklist[scope.pathlist[pindx].blockname].state == 0) {
                     continue;
                     }*/
                }

                if(scope.selectedobject){
                    scope.selectedobject.drawme(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate);
                }



            } else {
                scope.backgroundrender = true;

                //context.drawImage(scope.offscreen, offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);
                //context.drawImage(scope.offscreen, offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);

                if (scope.layerlist.length > 0) {
                    if (scope.selectedobject.layer != -1 && scope.layerlist[scope.selectedobject.layer] != undefined) {
                        layerstate = scope.layerlist[scope.selectedobject.layer].state;
                    }

                }
                if (scope.blocklist.length > 0) {
                    blockstate = scope.blocklist[scope.selectedobject.blockname].state;
                }

                if(scope.selectedobject.type == "line"){
                    drawvectorline(scope.selectedobject,scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                }else{
                    scope.selectedobject.drawme(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                }


                /*if (refresh) {
                    scope.offscreen.width = scope.width * scalefactor;
                    scope.offscreen.height = scope.height * scalefactor;
                    setSmoothingEnabledEx(true,scope.offscreenctx);

                    if (!scope.docompare) {
                        scope.offscreenctx.fillStyle = DocObj.backgroundColor;
                        scope.offscreenctx.fillRect(0, 0, scope.width * scalefactor, scope.height * scalefactor);

                    }

                }*/
                context.drawImage(scope.offscreen, offsetx, offsety, this.width * scalefactor, this.height * scalefactor);

            }

        };

        this.drawall = function (context, scalefactor, offsetx, offsety, refresh,drawprint) {

            var vectorstartrender = new Date().getTime();

            var layerstate = 1;
            var blockstate = 1;

            //context.fillStyle = backgroundColor;
            //context.fillRect(offsetx, offsety, this.width*scalefactor, scope.height*scalefactor);
            if ((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPad/i))) {
                if ((scope.width * scalefactor) * (scope.height * scalefactor) > 5000000) {
                    scope.backgroundrender = false;
                    if (!scope.docompare) {
                        if(drawprint){
                            context.fillStyle = 'white';
                        }else{
                            context.fillStyle = scope.parent.DocRef.backgroundColor;
                        }

                        context.fillRect(offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);

                    }
                    for (var pindx = 0; pindx < scope.pathlist.length; pindx++) {
                        if (scope.layerlist.length > 0) {
                            if (scope.pathlist[pindx].layer != -1 && scope.layerlist[scope.pathlist[pindx].layer] != undefined) {
                                layerstate = scope.layerlist[scope.pathlist[pindx].layer].state;
                                /*if (scope.layerlist[scope.pathlist[pindx].layer].state == 0) {
                                    continue;
                                }*/
                            }

                        }
                        if (scope.blocklist.length > 0) {
                            blockstate = scope.blocklist[scope.pathlist[pindx].blockname].state;
                            /*if (scope.blocklist[scope.pathlist[pindx].blockname].state == 0) {
                                continue;
                            }*/
                        }
                        if (scope.docompare) {
                            if(scope.dooverlay){
                                scope.pathlist[pindx].drawemeoverlay(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, layerstate,blockstate);
                            }else{
                                scope.pathlist[pindx].drawemecompare(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, scope.comparecolor,layerstate,blockstate);
                            }

                        } else {
                            if(scope.pathlist[pindx]){
                                scope.pathlist[pindx].drawme(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                            }

                        }


                    }
                    /*for (var tindx = 0; tindx < scope.textlist.length; tindx++) {
                        if(scope.textlist[tindx].draw){
                            drawtextmarker(scope.textlist[tindx],context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate);
                        }
                    }*/

                } else {
                    scope.backgroundrender = true;
                    if (refresh) {
                        scope.offscreen.width = scope.width * scalefactor;
                        scope.offscreen.height = scope.height * scalefactor;
                        //var offscreenctx = scope.offscreen.getContext('2d');
                        //setSmoothingEnabledEx(true,scope.offscreenctx);
                        //offscreenctx.imageSmoothingEnabled = false;
                        //offscreenctx.mozImageSmoothingEnabled = false;
                        //offscreenctx.webkitImageSmoothingEnabled = false;
                        //offscreenctx.msImageSmoothingEnabled = false;

                        if (!scope.docompare) {
                            if(drawprint){
                                scope.offscreenctx.fillStyle = 'white';
                            }else{
                                scope.offscreenctx.fillStyle = scope.parent.DocRef.backgroundColor;
                            }


                            scope.offscreenctx.fillRect(0, 0, scope.width * scalefactor, scope.height * scalefactor);

                        }
                        //offscreenctx.globalCompositeOperation = 'source-over';
                        for (var i = 0; i < scope.pathlist.length; i++) {
                            //var localoffsetx = scope.y * scalefactor;
                            //var localoffsety = scope.x * scalefactor;

                            if (scope.layerlist.length > 0) {
                                if (scope.pathlist[i].layer != -1 && scope.layerlist[scope.pathlist[i].layer] != undefined) {
                                    layerstate = scope.layerlist[scope.pathlist[i].layer].state;
                                    /*if (scope.layerlist[scope.pathlist[i].layer].state == 0) {
                                        continue;
                                    }*/
                                }

                            }
                            if (scope.blocklist.length > 0) {
                                blockstate = scope.blocklist[scope.pathlist[i].blockname].state;
                                /*if (scope.blocklist[scope.pathlist[i].blockname].state == 0) {
                                    continue;
                                }*/
                            }


                            if (scope.docompare) {
                                if(scope.dooverlay){
                                    scope.pathlist[i].drawemeoverlay(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h, layerstate,blockstate);
                                }else{
                                    scope.pathlist[i].drawemecompare(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h, scope.comparecolor,layerstate,blockstate);
                                }

                            } else {
                                if(scope.pathlist[i]){
                                    scope.pathlist[i].drawme(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                                }

                            }


                        }
                        /*for (tindx = 0; tindx < scope.textlist.length; tindx++) {
                            if(scope.textlist[tindx].draw){
                                drawtextmarker(scope.textlist[tindx],scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate);
                            }
                        }*/


                    }
                    context.drawImage(scope.offscreen, offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);

                }

            } else {
                if ((scope.width * scalefactor) * (scope.height * scalefactor) > 75000000) {
                    scope.backgroundrender = false;
                    if (!scope.docompare) {
                        if(drawprint){
                            context.fillStyle = 'white';
                        }else{
                            context.fillStyle = scope.parent.DocRef.backgroundColor;
                        }

                        context.fillRect(offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);

                    }
                    for (pindx = 0; pindx < scope.pathlist.length; pindx++) {

                        if (scope.layerlist.length > 0) {
                            if (scope.pathlist[pindx].layer != -1 && scope.layerlist[scope.pathlist[pindx].layer] != undefined) {
                                layerstate = scope.layerlist[scope.pathlist[pindx].layer].state;
                                /*if (scope.layerlist[scope.pathlist[pindx].layer].state == 0) {
                                    continue;
                                }*/
                            }

                        }
                        if (scope.blocklist.length > 0) {
                            blockstate = scope.blocklist[scope.pathlist[pindx].blockname].state;
                            /*if (scope.blocklist[scope.pathlist[pindx].blockname].state == 0) {
                                continue;
                            }*/
                        }

                        if (scope.docompare) {
                            if(scope.dooverlay){
                                scope.pathlist[pindx].drawemeoverlay(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, layerstate,blockstate);
                            }else{
                                scope.pathlist[pindx].drawemecompare(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h, scope.comparecolor,layerstate,blockstate);
                            }

                        } else {

                            if(scope.pathlist[pindx]){
                                if(scope.pathlist[pindx].type == "line"){
                                    drawvectorline(scope.pathlist[pindx],context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                                }else{
                                    scope.pathlist[pindx].drawme(context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                                }


                            }


                        }

                    }
                    /*for (tindx = 0; tindx < scope.textlist.length; tindx++) {
                        if(scope.textlist[tindx].draw){
                            drawtextmarker(scope.textlist[tindx],context, scalefactor, offsetx, offsety, scope.x, scope.y, scope.h,layerstate,blockstate);
                        }
                    }*/


                } else {
                    scope.backgroundrender = true;
                    //context.drawImage(scope.offscreen, offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);
                    //context.drawImage(scope.offscreen, offsetx, offsety, scope.width * scalefactor, scope.height * scalefactor);

                    if (refresh) {
                        scope.offscreen.width = scope.width * scalefactor;
                        scope.offscreen.height = scope.height * scalefactor;
                        //offscreenctx = scope.offscreen.getContext('2d');
                        setSmoothingEnabledEx(true,scope.offscreenctx);

                        if (!scope.docompare) {
                            if(drawprint){
                                scope.offscreenctx.fillStyle = 'white';
                            }else{
                                scope.offscreenctx.fillStyle = scope.parent.DocRef.backgroundColor;
                            }

                            scope.offscreenctx.fillRect(0, 0, scope.width * scalefactor, scope.height * scalefactor);

                        }
                        //offscreenctx.globalCompositeOperation = 'source-over';
                        var pathcount = 0;


                        while(pathcount < scope.pathlist.length){
                            if (scope.layerlist.length > 0) {
                                if (scope.pathlist[pathcount].layer != -1 && scope.layerlist[scope.pathlist[pathcount].layer] != undefined) {
                                    layerstate = scope.layerlist[scope.pathlist[pathcount].layer].state;
                                    /*if (scope.layerlist[scope.pathlist[pathcount].layer].state == 0) {
                                        bdrawlayerblock = false;
                                        //pathcount++;
                                        //continue;

                                    }*/
                                }

                            }
                            if (scope.blocklist.length > 0) {
                                blockstate = scope.blocklist[scope.pathlist[pathcount].blockname].state;
                                /*if (scope.blocklist[scope.pathlist[pathcount].blockname].state == 0) {
                                    bdrawlayerblock = false;
                                    //pathcount++;
                                    //continue;
                                }*/
                            }
                            //scope.pathlist[i].drawme(offscreenctx,scalefactor,offsetx,offsety,scope.x, scope.y,scope.h);


                                if (scope.docompare) {
                                    if(scope.dooverlay){
                                        scope.pathlist[pathcount].drawemeoverlay(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h, layerstate,blockstate);
                                    }else{
                                        scope.pathlist[pathcount].drawemecompare(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h, scope.comparecolor,layerstate,blockstate);
                                    }

                                } else {

                                    if(scope.pathlist[pathcount].type == "line"){
                                        drawvectorline(scope.pathlist[pathcount],scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                                    }else{
                                        scope.pathlist[pathcount].drawme(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate,drawprint);
                                    }

                                    /*if(scope.pathlist[pathcount]){

                                        scope.pathlist[pathcount].drawme(scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate);
                                    }*/

                                    /*if(scope.firstdraw){
                                     setTimeout(scope.pathlist[pathcount].drawme(offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h), 0);
                                     }else{
                                     scope.pathlist[pathcount].drawme(offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h);
                                     }*/

                                    //
                                }


                            pathcount ++;


                        }
                        /*for (tindx = 0; tindx < scope.textlist.length; tindx++) {
                            if(scope.textlist[tindx].draw){
                                drawtextmarker(scope.textlist[tindx],scope.offscreenctx, scalefactor, 0, 0, scope.x, scope.y, scope.h,layerstate,blockstate);
                            }
                        }*/



                    }
                    context.drawImage(this.offscreen, offsetx, offsety, this.width * scalefactor, this.height * scalefactor);

                }

            }
            scope.firstdraw = true;
            if(scope.docompare){
                scope.firstdrawcompare = true;

            }

            var vectorendrender = new Date().getTime();
            scope.vectorpagetime = (vectorendrender - vectorstartrender);
        };



        this.Close = function () {

            scope.layerlist = [];
            scope.blocklist = [];
            scope.filterblocklist = [];


            /*while (scope.layerlist.length != 0) {
                scope.layerlist.pop();
            }

            while (scope.blocklist.length != 0) {
                scope.blocklist.pop();
            }*/



            while (this.pathlist.length != 0) {
                this.pathlist[this.pathlist.length - 1].Close();
                this.pathlist.pop();
            }
            scope.pathlist = [];

        };

        parse2Dloop();


        function yieldingLoop(state, chunksize, callback, finished) {

            (function chunk() {
                var i = 0;
                //var end = Math.min(i + chunksize, count);
                var end = (i < chunksize );
                for (; i < chunksize; ++i) {
                    callback.call(null, state);

                    if(state.objectid == 32768){
                        break;
                    }
                }
                if (state.objectid != 32768) {

                    setTimeout(chunk, 0);
                } else {
                    //console.log(state.objectid);
                    finished.call(null);
                }
            })();
        }
    };

    var FirstPersonControl = function(){

        var scope = this;

        this.object = DocObj.pages[DocObj.currentpage].camera;
        this.domElement = renderer.domElement;

        this.target = new THREE.Vector3(0,0,0);
        //this.object.rotation.set(0, 0, 90 * Math.PI / 180);

        this.enabled = false;
        this.firstxyrecieved = false;

        this.movementSpeed = 1.0;
        this.lookSpeed = 0.005;

        this.lookVertical = true;
        this.autoForward = false;

        this.activeLook = true;

        this.heightSpeed = false;
        this.heightCoef = 1.0;
        this.heightMin = 0.0;
        this.heightMax = 1.0;

        this.constrainVertical = false;
        this.verticalMin = 0;
        this.verticalMax = Math.PI;

        this.autoSpeedFactor = 0.0;

        this.mouseX = 0;
        this.mouseY = 0;

        this.lat = 0;
        this.lon = 90;
        this.phi = 0;
        this.theta = 0;

        this.moveForward = false;
        this.moveBackward = false;
        this.moveLeft = false;
        this.moveRight = false;
        this.moveUp = false;
        this.moveDown = false;
        this.mouseMove = false;

        this.mouseDragOn = false;

        this.viewHalfX = 0;
        this.viewHalfY = 0;

        if ( this.domElement !== document ) {

            ///this.domElement.setAttribute( 'tabindex', - 1 );

        }

        this.reset = function(){
            this.lat = 0;
            this.lon = 90;
            this.phi = 0;
            this.theta = 0;
        };

        this.setInitial = function(lat,lon,phi,theta){
            this.lat = lat;
            this.lon = lon;
            this.phi = phi;
            this.theta = theta;
        };

        this.handleResize = function () {

            if ( this.domElement === document ) {

                this.viewHalfX = window.innerWidth / 2;
                this.viewHalfY = window.innerHeight / 2;

            } else {

                this.viewHalfX = this.domElement.offsetWidth / 2;
                this.viewHalfY = this.domElement.offsetHeight / 2;

            }

        };

        this.onMouseDown = function ( button ) {

            if ( this.domElement !== document ) {

                this.domElement.focus();

            }

            //event.preventDefault();
            //event.stopPropagation();

            if ( this.activeLook && this.mouseMove ) {

                switch ( button ) {

                    case 0: this.moveForward = true; break;
                    case 2: this.moveBackward = true; break;

                }

            }

            this.mouseDragOn = true;

        };

        this.onMouseUp = function ( button ) {

            //event.preventDefault();
            //event.stopPropagation();

            if ( this.activeLook && this.mouseMove ) {

                switch ( button ) {

                    case 0: this.moveForward = false; break;
                    case 2: this.moveBackward = false; break;

                }

            }

            this.mouseDragOn = false;

        };

        this.onMouseMove = function ( x,y ) {
            if(!scope.firstxyrecieved){

                scope.firstxyrecieved = true;
            }

            if ( this.domElement === document ) {

                scope.mouseX = -(x - scope.viewHalfX);
                scope.mouseY = -(y - scope.viewHalfY);

            } else {

                if(scope.mouseDragOn){
                    scope.mouseX = x - scope.domElement.offsetLeft - scope.viewHalfX;
                    scope.mouseY = y - scope.domElement.offsetTop - scope.viewHalfY;

                }else{
                    scope.mouseX = 0;
                    scope.mouseY = 0;
                }

            }

        };

        this.update = function( delta ) {

            if ( this.enabled === false || scope.firstxyrecieved === false) return;

            if ( this.heightSpeed ) {

                var z = THREE.Math.clamp( this.object.position.z, this.heightMin, this.heightMax );
                var heightDelta = z - this.heightMin;

                this.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );

            } else {

                this.autoSpeedFactor = 0.0;

            }

            var actualMoveSpeed = delta * this.movementSpeed;

            if ( this.moveForward || ( this.autoForward && ! this.moveBackward ) ) this.object.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );
            if ( this.moveBackward ) this.object.translateZ( actualMoveSpeed );

            if ( this.moveLeft ) this.object.translateX( - actualMoveSpeed );
            if ( this.moveRight ) this.object.translateX( actualMoveSpeed );

            if ( this.moveUp ) this.object.translateY( actualMoveSpeed );
            if ( this.moveDown ) this.object.translateY( - actualMoveSpeed );

            var actualLookSpeed = delta * this.lookSpeed;

            if ( ! this.activeLook ) {

                actualLookSpeed = 0;

            }

            var verticalLookRatio = 1;

            if ( this.constrainVertical ) {

                verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );

            }

            this.lon -= this.mouseX * actualLookSpeed;
            if ( this.lookVertical ) this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;

            this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
            this.phi = THREE.Math.degToRad( 90 - this.lat );
            //this.phi = THREE.Math.degToRad(  this.lat );


            this.theta = THREE.Math.degToRad( this.lon );

            if ( this.constrainVertical ) {

                this.phi = THREE.Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );

            }


            var targetPosition = this.target,position = this.object.position;


            targetPosition.x = position.x + 100 * (Math.sin( this.phi ) * Math.cos( this.theta ));
            //targetPosition.y = position.y + 100 * Math.cos( this.phi );
            //targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );
            targetPosition.y = position.y + 100 * Math.sin( this.phi ) * Math.sin( this.theta );
            targetPosition.z = position.z + 100 * Math.cos( this.phi );

            this.object.lookAt( targetPosition );
            //console.log(this.object.rotation.x, this.object.rotation.y, this.object.rotation.z);
            //console.log(targetPosition);

        };

        this.handleResize();
    };
    var WalkthroughControl = function () {
        this.object = DocObj.pages[DocObj.currentpage].camera;
        this.domElement = renderer.domElement;

        var scope = this;

        //controls.movementSpeed = 100;
        //controls.domElement = container;
        //controls.rollSpeed = Math.PI / 10;
        //controls.autoForward = false;
        //controls.dragToLook = true;

        //from oribit control
        this.rotateSpeed = 0.1;
        this.autoRotate = false;
        this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
        this.minPolarAngle = 0; // radians
        this.maxPolarAngle = Math.PI; // radians
        var EPS = 0.000001;
        this.rotateStart = new THREE.Vector2();
        var rotateEnd = new THREE.Vector2();
        var rotateDelta = new THREE.Vector2();
        this.phiDelta = 0;
        this.thetaDelta = 0;
        this.offset = new THREE.Vector3();


        var scale = 1;
        var lastPosition = new THREE.Vector3();
        var lastQuaternion = new THREE.Quaternion();


        //from oribit control


        this.movementSpeed = 100.0;
        this.rollSpeed = Math.PI / 10;

        this.dragToLook = true;
        this.autoForward = false;

        this.tmpQuaternion = new THREE.Quaternion();

        this.mouseStatus = 0;

        this.moveState = {
            up:0,
            down:0,
            left:0,
            right:0,
            forward:0,
            back:0,
            pitchUp:0,
            pitchDown:0,
            yawLeft:0,
            yawRight:0,
            rollLeft:0,
            rollRight:0
        };
        this.moveVector = new THREE.Vector3(0, 0, 0);
        this.rotationVector = new THREE.Vector3(0, 0, 0);
        this.quat = new THREE.Quaternion().setFromUnitVectors(this.object.up, new THREE.Vector3(0, 1, 0));
        this.quatInverse = this.quat.clone().inverse();


        function getAutoRotationAngle() {

            return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

        }


        this.rotateLeft = function (angle) {

            if (angle === undefined) {

                angle = getAutoRotationAngle();

            }

            scope.thetaDelta -= angle;

        };

        this.rotateUp = function (angle) {

            if (angle === undefined) {

                angle = getAutoRotationAngle();

            }

            scope.phiDelta -= angle;

        };

        this.StartRotate = function (x, y) {
            scope.rotateStart.set(x, y);
        };

        this.mousemove = function (x, y) {
            if (scope.mouseStatus > 0) {
                var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                //rotateStart.copy( rotStart );
                rotateEnd.set(x, y);

                rotateDelta.subVectors(rotateEnd, scope.rotateStart);

                // rotating across whole screen goes 360 degrees around
                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

                // rotating up and down along whole screen attempts to go 360, but limited to 180
                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

                scope.rotateStart.copy(rotateEnd);


                var container = scope.getContainerDimensions();

                var halfWidth = container.size[0] / 2;
                var halfHeight = container.size[1] / 2;
                scope.moveState.yawLeft = -((x - container.offset[0]) - halfWidth) / halfWidth;
                scope.moveState.pitchDown = ((y - container.offset[1]) - halfHeight) / halfHeight;

                scope.updateRotationVector();

            }

        };


        this.update = function (delta) {

            var moveMult = delta * scope.movementSpeed;
            var rotMult = delta * scope.rollSpeed;

            //var position = scope.object.position;
            //scope.offset.copy( position );

            //var position = this.object.position;
            //scope.offset.applyQuaternion( scope.quat );

            //scope.object.rotation.order = "YXZ";

            //var theta = scope.object.rotation.y;
            //var phi = scope.object.rotation.x;
            //var gamma = scope.object.rotation.z;

            //theta += scope.thetaDelta;
            //phi += scope.phiDelta * Math.cos(theta);
            //phi += scope.phiDelta;
            //gamma += scope.phiDelta;// * Math.sin(theta);

            //var camEuler = new THREE.Euler(phi, theta, gamma);

            //var camquat = new THREE.Quaternion();
            //camquat.setFromEuler(camEuler);


            //scope.offset.x = Math.sin( phi ) * Math.sin( theta );
            //scope.offset.y = Math.cos( phi );
            //scope.offset.z = Math.sin( phi ) * Math.cos( theta );

            //scope.offset.applyQuaternion(scope.quatInverse );

            //scope.object.lookAt( scope.offset );
            //scope.object.rotation.set(phi,theta,gamma, 'XYZ');
            //scope.object.quaternion.copy(camquat);

            //position.copy( 0,0,0 ).add( scope.offset );

            /*var targetPosition = new THREE.Vector3(),
             position = scope.object.position;

             targetPosition.x = position.x + 100 * Math.sin( phi ) * Math.cos( theta );
             targetPosition.y = position.y + 100 * Math.cos( phi );
             targetPosition.z = position.z + 100 * Math.sin( phi ) * Math.sin( theta );

             this.object.lookAt( targetPosition );*/


            //scope.object.rotation.z = theta;
            //scope.object.rotation.x = phi;
            //scope.object.rotation.y = gamma;

            //scope.object.updateMatrix();

            /*if (theta > 0){
             scope.object.rotation.z = phi * (phi/theta);
             }*/

            //scope.object.rotation.z = phi * Math.sin( phi ) * Math.sin( theta );


            //console.log( 'phi:', phi * (180/Math.PI) );
            //console.log( 'theta:', theta * (180/Math.PI) );
            //console.log( 'gamma:', gamma * (180/Math.PI) );
            //console.log( 'sintheta:', Math.sin(theta) );
            //console.log( 'costheta:', Math.cos(theta) );

            //console.log( 'phixtheta:', (phi * (180/Math.PI)) * (theta * (180/Math.PI)) );
            //console.log( 'phidividetheta:', (phi * (180/Math.PI)) / (theta * (180/Math.PI)) );

            //offset.x = radius * Math.sin( phi ) * Math.sin( theta );
            //offset.y = radius * Math.cos( phi );
            //offset.z = radius * Math.sin( phi ) * Math.cos( theta );
            //var direction = new THREE.Vector3();
            //direction.copy(scope.object.lookat);


            //console.log( 'direction:', [ direction.x , direction.y, direction.z ] );
            //console.log( 'angles:', [ Math.sin( phi ) * Math.sin( theta ), Math.cos( phi ), Math.sin( phi ) * Math.cos( theta )] );


            scope.object.translateX(scope.moveVector.x * moveMult);
            scope.object.translateY(scope.moveVector.y * moveMult);
            scope.object.translateZ(scope.moveVector.z * moveMult);


            //scope.tmpQuaternion.set( scope.rotationVector.x * rotMult, scope.rotationVector.y * rotMult, scope.rotationVector.z * rotMult, 1 ).normalize();
            scope.tmpQuaternion.set(scope.phiDelta, scope.thetaDelta, scope.rotationVector.z * rotMult, 1).normalize();
            scope.object.quaternion.multiply(this.tmpQuaternion);

            //console.log( 'rotate:', [ this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult ] );
            //console.log( 'phidelta:', scope.phiDelta );
            //console.log( 'thetadelta:', scope.thetaDelta );

            // expose the rotation vector for convenience
            scope.object.rotation.setFromQuaternion(scope.object.quaternion, scope.object.rotation.order);
            //console.log( 'camera:', [ scope.object.rotation.x, scope.object.rotation.y, scope.object.rotation.z * (180/Math.PI) ] );

            scope.thetaDelta = 0;
            scope.phiDelta = 0;



        };

        this.updateMovementVector = function () {

            var forward = (scope.moveState.forward || (scope.autoForward && !scope.moveState.back)) ? 1 : 0;

            scope.moveVector.x = (-scope.moveState.left + scope.moveState.right);
            scope.moveVector.y = (-scope.moveState.down + scope.moveState.up);
            scope.moveVector.z = (-forward + scope.moveState.back);
            //console.log(scope.object.position);

            //console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

        };

        this.updateRotationVector = function () {

            scope.rotationVector.x = (-scope.moveState.pitchDown + scope.moveState.pitchUp);
            scope.rotationVector.y = (-scope.moveState.yawRight + scope.moveState.yawLeft);
            scope.rotationVector.z = (-scope.moveState.rollRight + scope.moveState.rollLeft);

            //console.log( 'rotate:', [ this.rotationVector.x , this.rotationVector.y , this.rotationVector.z  ] );

        };

        this.getContainerDimensions = function () {

            if (scope.domElement != document) {

                return {
                    size:[scope.domElement.offsetWidth, scope.domElement.offsetHeight],
                    offset:[scope.domElement.offsetLeft, scope.domElement.offsetTop]
                };

            } else {
                return {
                    size:[window.innerWidth, window.innerHeight],
                    offset:[0, 0]
                };

            }

        };


    };

    var Part3DObjectMulti = function(xmldata, index, parent, binary) {
        var scope = this;
        this.id = index;
        this.selected = false;
        this.hasmesh = false;
        this.attributes = [];
        this.format = DocObj.Format.substring(0, 3);
        this.meshcolors = [];
        this.meshrefs = [];
        this.meshref = 0;
        this.openmesh = false;
        this.curTrset = 0;
        this.isLastBlock = false;
        this.isLoadComplete = false;
        this.vcentroid = new THREE.Vector3();

        this.minx = 1000000;
        this.maxx = 0;
        this.miny = 1000000;
        this.maxy = 0;
        this.minz = 1000000;
        this.maxz = 0;


        this.id = xmldata.id;
        this.name = xmldata.name;
        this.visible = xmldata.visible;
        this.transparent = xmldata.transparent;
        this.defaultcolor = decimalToHex(xmldata.color);
        this.facecolor = decimalToHex(xmldata.color);
        this.curColor = decimalToHex(xmldata.color);

        this.tempvisible = (this.visible == 1);
        this.tarray = [];

        this.addline = function(lineobj, ncolor){

            var facecolor = decimalToHex(ncolor);
            var x1 = lineobj.X1 - parent.x;
            var y1 = lineobj.Y1 - parent.y;
            var z1 = lineobj.Z1 - parent.z;

            var x2 = lineobj.X2 - parent.x;
            var y2 = lineobj.Y2 - parent.y;
            var z2 = lineobj.Z2 - parent.z;

            var linepos = new Float32Array([x1,y1,z1,x2,y2,z2]);

            var linegeometry = new THREE.BufferGeometry();
            linegeometry.addAttribute('position', new THREE.BufferAttribute(linepos, 3));
            linegeometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0,1]), 1));

            var material = new THREE.LineBasicMaterial( { color: facecolor,linewidth:2.0 } );
            var linesegment = new THREE.LineSegments(linegeometry, material);

            linesegment.scale.x = parent.scale;
            linesegment.scale.y = parent.scale;
            linesegment.scale.z = parent.scale;

            parent.scene.add(linesegment);


        };

        this.appendtriangles = function(partdv, numt, id, ncolor){
            var curlength = scope.tarray[scope.curTrset].vectors.length;
            var newlength = numt * 9;


            scope.tarray[scope.curTrset].vectors = new Float32Array(curlength + newlength);
            scope.tarray[scope.curTrset].dv.push(partdv);
            scope.tarray[scope.curTrset].triangles.push(numt);

        };

        this.addtriangles = function(partdv,numt,id,facecolor){
            var dvarr = [];
            var trianglearr = [];

            dvarr.push(partdv);
            trianglearr.push(numt);
            var newgeometry = new THREE.BufferGeometry();
            var vertices = new Float32Array(numt * 9);


            var tobject = {
                dv : dvarr,
                triangles : trianglearr,
                color : facecolor,
                vindex : 0,
                dvpos : 0,
                geometry : newgeometry,
                vectors : vertices
            };
            scope.tarray.push(tobject);
            this.curTrset = scope.tarray.length - 1;

        };

        this.addpart = function(partdv, numt, id, ncolor, newblock){
            if (partdv) {
                var facecolor = decimalToHex(ncolor);

                //var mstatus = scope.getmeshstatus();
                var dvarr = [];


                if(scope.tarray.length > 0){
                    if(scope.tarray[scope.curTrset].color == facecolor){
                        scope.facecolor = facecolor;
                        scope.appendtriangles(partdv, numt, id, ncolor);

                    }else{
                        scope.addtriangles(partdv,numt,id,facecolor);
                    }
                }else{
                    this.curColor = facecolor;
                    scope.addtriangles(partdv,numt,id,facecolor);


                }


            }
        };

        this.processmesh = function(){


            scope.curTrset = 0;

            for(var i = 0;i< scope.tarray.length;i++){
                for(var j = 0;j<scope.tarray[i].triangles.length;j++){

                    var dvsize = scope.tarray[i].triangles[j] * 9 * 4;
                    parsemeshbuffer(0, scope.tarray[i].dv[j], dvsize,i);
                }
            }

            scope.addmesh();
            bAnimateready = true;


            /*if(scope.tarray[scope.curTrset] != undefined){
                yieldingLoop((scope.tarray[scope.curTrset].triangles * 9 * 4), 1332, function() {
                    for(var i = 0;i< scope.tarray.length;i++){
                        for(var j = 0;j<scope.tarray[i].triangles.length;j++){
                            parsemeshbuffer(0, scope.tarray[i].dv[j], dvsize,i);
                        }
                    }


                }, function() {
                    scope.addmesh();
                    bAnimateready = true;

                });

            }*/



            /*(function timer() {

                bAnimateready = false;

                if(scope.tarray[scope.curTrset] != undefined){
                    if (scope.tarray[scope.curTrset].dvpos < (scope.tarray[scope.curTrset].triangles * 9 * 4)) {
                        setTimeout(timer, 10);
                    }
                }
            })();*/


        };

        this.resetvisible = function () {

            scope.tempvisible = (scope.visible == 1);


        };


        function maxmin(x,y,z){
            if(scope.maxx < x){
                scope.maxx = x;
            }

            if(scope.maxy < y){
                scope.maxy = y;
            }

            if(scope.maxz < z){
                scope.maxz = z;
            }

            if(scope.minx > x){
                scope.minx = x;
            }
            if(scope.miny > y){
                scope.miny = y;
            }

            if(scope.minz > z){
                scope.minz = z;
            }
        }

        function parsemeshbuffer(dvpos, dv, dvsize,tobjectnum){

            while(dvpos < dvsize){
                var x = dv.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                var y = dv.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                var z = dv.getFloat32(dvpos, true) - parent.z;

                maxmin(x,y,z);

                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex] = x;
                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex+1] = y;
                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex+2] = z;
                scope.tarray[tobjectnum].vindex += 3;

                dvpos += 4;
                x = dv.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                y = dv.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                z = dv.getFloat32(dvpos, true) - parent.z;

                maxmin(x,y,z);

                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex] = x;
                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex+1] = y;
                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex+2] = z;
                scope.tarray[tobjectnum].vindex += 3;

                dvpos += 4;
                x = dv.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                y = dv.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                z = dv.getFloat32(dvpos, true) - parent.z;
                dvpos += 4;

                maxmin(x,y,z);
                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex] = x;
                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex+1] = y;
                scope.tarray[tobjectnum].vectors[scope.tarray[tobjectnum].vindex+2] = z;
                scope.tarray[tobjectnum].vindex += 3;

            }

        }

        this.addmesh = function () {

            this.curTrset = 0;

            while(scope.tarray.length != 0){
                scope.hasmesh = true;
                var facecolor = scope.tarray[scope.curTrset].color;

                scope.material = new THREE.MeshPhongMaterial({
                    color:facecolor,
                    side:THREE.DoubleSide,
                    //vertexColors: THREE.VertexColors,
                    shininess:20,
                    shading:THREE.SmoothShading
                });

                if (scope.transparent != 0) {
                    scope.material.transparent = true;
                    scope.material.opacity = 0.3;
                }

                scope.tarray[scope.curTrset].geometry.addAttribute( 'position', new THREE.BufferAttribute( scope.tarray[scope.curTrset].vectors, 3 ) );
                //scope.tarray[scope.curTrset].geometry.computeFaceNormals();
                scope.tarray[scope.curTrset].geometry.computeVertexNormals();
                scope.tarray[scope.curTrset].geometry.computeBoundingSphere();

                scope.center = scope.tarray[scope.curTrset].geometry.boundingSphere.center.clone();

                scope.vcentroid.set(scope.minx,scope.miny,scope.minz);

                var maxvector = new THREE.Vector3((scope.maxx - scope.minx) * 0.5,(scope.maxy - scope.miny) * 0.5,(scope.maxz - scope.minz) * 0.5);

                scope.vcentroid.add(maxvector);


                var partmesh = new THREE.Mesh(scope.tarray[scope.curTrset].geometry, scope.material);

                partmesh.name = scope.id;

                partmesh.scale.x = parent.scale;
                partmesh.scale.y = parent.scale;
                partmesh.scale.z = parent.scale;

                if (this.visible == 0) {
                    partmesh.visible = false;
                    //partmesh.visible = false;
                    scope.tempvisible = false;
                }

                parent.scene.add(partmesh);

                scope.tarray.shift();
            }

            scope.isLoadComplete = true;

            if(scope.isLastBlock){
                parent.blockreadComplete();
            }


        };

        this.setlastblock = function(){
            scope.isLastBlock = true;

            if (scope.isLoadComplete || !scope.hasmesh){
                parent.blockreadComplete();
            }

        };


        this.addAtrib = function (attname, attvalue) {
            var attobj = {
                name:attname,
                value:attvalue
            };
            this.attributes.push(attobj);

            var spacecheck = attname.substring(0, 8);
            if (spacecheck == 'IfcSpace') {
                this.isSpace = true;
            }

        };


        function yieldingLoop(count, chunksize, callback, finished) {
            var i = 0;
            (function chunk() {
                var end = Math.min(i + chunksize, count);
                for (; i < end; ++i) {
                    callback.call(null, i);
                }
                if (i < count) {
                    setTimeout(chunk, 0);
                } else {
                    finished.call(null);
                }
            })();
        }

    };

    var Part3DObject = function (xmldata, index, parent, binary) {
        var scope = this;
        this.id = index;
        this.selected = false;
        this.isSpace = false;
        this.ifctype = 0;
        this.hasmesh = false;
        this.attributes = [];
        this.format = DocObj.Format.substring(0, 3);
        this.meshcolors = [];
        this.meshrefs = [];
        this.meshref = 0;
        this.openmesh = false;
        this.curTrset = 0;
        this.isLastBlock = false;
        this.isLoadComplete = false;
        this.centroid = new THREE.Vector3();
        this.vcentroid = new THREE.Vector3();

        this.minx = 1000000;
        this.maxx = 0;
        this.miny = 1000000;
        this.maxy = 0;
        this.minz = 1000000;
        this.maxz = 0;

        this.tempz = 0;

        this.id = xmldata.id;
        this.name = xmldata.name;
        this.visible = xmldata.visible;
        this.transparent = xmldata.transparent;
        this.defaultcolor = decimalToHex(xmldata.color);
        this.facecolor = decimalToHex(xmldata.color);

        this.tempvisible = (this.visible == 1);
        this.tarray = [];
        /*
         var opartobj ={
         id : blockid,
         visible : nvisbile,
         transparent : ntransparent,
         color : ncolor,
         name : szblockname,
         };
         */

        this.addline = function(lineobj, ncolor){


            var facecolor = decimalToHex(ncolor);
            var x1 = lineobj.X1 - parent.x;
            var y1 = lineobj.Y1 - parent.y;
            var z1 = lineobj.Z1 - parent.z;

            var x2 = lineobj.X2 - parent.x;
            var y2 = lineobj.Y2 - parent.y;
            var z2 = lineobj.Z2 - parent.z;

            var linepos = new Float32Array([x1,y1,z1,x2,y2,z2]);

            var linegeometry = new THREE.BufferGeometry();
            linegeometry.addAttribute('position', new THREE.BufferAttribute(linepos, 3));
            linegeometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0,1]), 1));

            var material = new THREE.LineBasicMaterial( { color: facecolor,linewidth:2.0 } );
            var linesegment = new THREE.LineSegments(linegeometry, material);

            linesegment.scale.x = parent.scale;
            linesegment.scale.y = parent.scale;
            linesegment.scale.z = parent.scale;

            parent.scene.add(linesegment);



        };

        this.addpart = function(partdv, numt, id, ncolor, newblock){
            if (partdv) {
                var facecolor = decimalToHex(ncolor);
                var mstatus = scope.getmeshstatus();
                var newgeometry = new THREE.BufferGeometry();
                var vertices = new Float32Array(numt * 9);


                var tobject = {
                   dv : partdv,
                   triangles : numt,
                   color : facecolor,
                   vindex : 0,
                   dvpos : 0,
                   geometry : newgeometry,
                   vectors : vertices
                };

                scope.tarray.push(tobject);

                /*if (!mstatus.meshexist) {
                    scope.createmesh(partdv, numt, facecolor, id);
                }else{
                    if (facecolor == mstatus.color) {
                        scope.appendmesh(partdv, numt, facecolor, id);
                    }else{
                        scope.addmesh();
                        scope.createmesh(partdv, numt, facecolor, id);
                    }
                }*/

            }
        };



        this.addAtrib = function (attname, attvalue) {
            var attobj = {
                name:attname,
                value:attvalue
            };
            this.attributes.push(attobj);

            var spacecheck = attname.substring(0, 8);
            if (spacecheck == 'IfcSpace') {
                this.isSpace = true;
            }

        };

        this.getmeshstatus = function () {
            return {
                meshexist:this.hasmesh,
                color:this.facecolor,
                open:this.openmesh
            };

        };


        this.appendmesh = function (binarydata, numt, facecolor, blockid) {


            var dvsize = numt * 9 * 4;
            var dvpos = 0;
            //var vindex = 0;
            //var newgeometry =  new THREE.Geometry();
            //newgeometry = pushmesh(dvpos,dvsize,vindex,binarydata,newgeometry);
            /*while (dvpos < dvsize) {
                //dvpos += 4;
                var x = binarydata.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                var y = binarydata.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                var z = binarydata.getFloat32(dvpos, true) - parent.z;

                newgeometry.vertices.push(new THREE.Vector3(x, y, z));
                dvpos += 4;
                x = binarydata.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                y = binarydata.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                z = binarydata.getFloat32(dvpos, true) - parent.z;
                newgeometry.vertices.push(new THREE.Vector3(x, y, z));
                dvpos += 4;
                x = binarydata.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                y = binarydata.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                z = binarydata.getFloat32(dvpos, true) - parent.z;
                dvpos += 4;
                newgeometry.vertices.push(new THREE.Vector3(x, y, z));


                newgeometry.faces.push(new THREE.Face3(vindex, vindex + 1, vindex + 2));
                vindex += 3;

            }*/

        };

        this.createmesh = function (binarydata, numt, facecolor, blockid) {
            /*
             0	4	LONG	Object ID	9
             4	4	LONG	NumTriangles		Number of triangles
             8	4	FLOAT	X1		Triangle coordinates
             12	4	FLOAT	Y1
             16	4	FLOAT	Z1
             20	4	FLOAT	X2
             24	4	FLOAT	Y2
             28	4	FLOAT	Z2
             32	4	FLOAT	X3
             36	4	FLOAT	Y3
             40	4	FLOAT	Z3
             44	4	FLOAT	X[N]
             */


            this.openmesh = true;
            //newgeometry = new THREE.Geometry();

            this.hasmesh = true;
            this.facecolor = facecolor;
            this.meshcolors.push(facecolor);
            this.meshref++;
            this.meshrefs.push(this.meshref);


            if (this.format == 'IFC') {
                this.material = new THREE.MeshPhongMaterial({
                    color:this.facecolor,
                    side:THREE.DoubleSide,
                    shininess:5,
                    shading:THREE.SmoothShading
                });
            } else {
                this.material = new THREE.MeshPhongMaterial({
                    color:this.facecolor,
                    side:THREE.DoubleSide,
                    shininess:40,
                    shading:THREE.SmoothShading
                });
                this.material.metal = true;
            }
            if (this.transparent != 0) {
                this.material.transparent = true;
                this.material.opacity = 0.3;
            }

            var dvsize = numt * 9 * 4;
            var dvpos = 0;
            //vindex = 0;

            //newgeometry = pushmesh(dvpos,dvsize,vindex,binarydata,newgeometry);

            /*while (dvpos < dvsize) {
                //dvpos += 4;
                var x = binarydata.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                var y = binarydata.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                var z = binarydata.getFloat32(dvpos, true) - parent.z;

                newgeometry.vertices.push(new THREE.Vector3(x, y, z));
                dvpos += 4;
                x = binarydata.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                y = binarydata.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                z = binarydata.getFloat32(dvpos, true) - parent.z;
                newgeometry.vertices.push(new THREE.Vector3(x, y, z));
                dvpos += 4;
                x = binarydata.getFloat32(dvpos, true) - parent.x;
                dvpos += 4;
                y = binarydata.getFloat32(dvpos, true) - parent.y;
                dvpos += 4;
                z = binarydata.getFloat32(dvpos, true) - parent.z;
                dvpos += 4;
                newgeometry.vertices.push(new THREE.Vector3(x, y, z));


                newgeometry.faces.push(new THREE.Face3(vindex, vindex + 1, vindex + 2));
                vindex += 3;

            }*/
            //return newgeometry;

            //parent.scene.updateMatrix();
            //renderer.render(parent.scene, camera,false);
        };

        this.processmesh = function(){


            scope.curTrset = 0;
            if(scope.tarray[scope.curTrset] != undefined){
                yieldingLoop((scope.tarray[scope.curTrset].triangles * 9 * 4), 1332, function() {
                    bAnimateready = false;
                    parsemeshbuffer();
                }, function() {
                    scope.addmesh();
                    bAnimateready = true;
                    //addmesh//document.getElementById('done').innerHTML = 'done!';
                });
            }


            //var t = document.getElementById('timer');
            (function timer() {
                //t.innerHTML = j;
                bAnimateready = true;
                //parsemesh(scope.tarray[scope.curTrset]);
                if(scope.tarray[scope.curTrset] != undefined){
                    if (scope.tarray[scope.curTrset].dvpos < (scope.tarray[scope.curTrset].triangles * 9 * 4)) {
                        setTimeout(timer, 10);
                    }
                }
            })();


        };

        this.addmesh = function () {

            /*
             0	4	LONG	Object ID	9
             4	4	LONG	NumTriangles		Number of triangles
             8	4	FLOAT	X1		Triangle coordinates
             12	4	FLOAT	Y1
             16	4	FLOAT	Z1
             20	4	FLOAT	X2
             24	4	FLOAT	Y2
             28	4	FLOAT	Z2
             32	4	FLOAT	X3
             36	4	FLOAT	Y3
             40	4	FLOAT	Z3
             44	4	FLOAT	X[N]
             */





            this.openmesh = true;
            this.hasmesh = true;
            //newgeometry = new THREE.Geometry();
            this.facecolor = scope.tarray[scope.curTrset].color;
            this.meshcolors.push(scope.tarray[scope.curTrset].color);
            this.meshref++;
            this.meshrefs.push(this.meshref);


            if (this.format == 'IFC') {
                this.material = new THREE.MeshPhongMaterial({
                    color:this.facecolor,
                    side:THREE.DoubleSide,
                    shininess:5,
                    shading:THREE.SmoothShading,
                });
            } else {
                this.material = new THREE.MeshPhongMaterial({
                    color:this.facecolor,
                    side:THREE.DoubleSide,
                    shininess:20,
                    shading:THREE.SmoothShading
                    //emissive: this.facecolor,
                    //emissiveIntensity : 0.5
                });
                //this.material.metal = true;
                //console.log(this.facecolor);
            }
            if (this.transparent != 0) {
                this.material.transparent = true;
                this.material.opacity = 0.3;
            }

            scope.tarray[scope.curTrset].geometry.addAttribute( 'position', new THREE.BufferAttribute( scope.tarray[scope.curTrset].vectors, 3 ) );
            //scope.tarray[scope.curTrset].geometry.computeFaceNormals();
            scope.tarray[scope.curTrset].geometry.computeVertexNormals();
            //scope.tarray[scope.curTrset].geometry.computeBoundingSphere();
            //scope.tarray[scope.curTrset].geometry.computeBoundingBox();

            //scope.center = scope.tarray[scope.curTrset].geometry.boundingSphere.center.clone();
            //scope.radius = scope.tarray[scope.curTrset].geometry.boundingSphere.radius;

            //scope.boxmax = scope.tarray[scope.curTrset].geometry.boundingBox.max.clone();


            //code for wireframe like material
            //this.wireframe = THREE.SceneUtils.createMultiMaterialObject( newgeometry, materials );

            var partmesh = new THREE.Mesh(scope.tarray[scope.curTrset].geometry, scope.material);
            partmesh.name = scope.id;

            partmesh.scale.x = parent.scale;
            partmesh.scale.y = parent.scale;
            partmesh.scale.z = parent.scale;

            partmesh.geometry.computeBoundingSphere();
            partmesh.geometry.computeBoundingBox();



            if (this.visible == 0) {
                partmesh.visible = false;
                //partmesh.visible = false;
                scope.tempvisible = false;
            }


            parent.scene.add(partmesh);

            //partmesh.updateMatrix();

            //var attribute = partmesh.geometry.attributes.position; // we want the position data
            //var index = 1; // index is zero-based, so this the the 2nd vertex
            //scope.centroid.fromAttribute( attribute, index ); // extract the x,y,z coordinates

            //scope.centroid.applyMatrix4( partmesh.matrixWorld );

            scope.center = partmesh.geometry.boundingSphere.center.clone();
            scope.radius = partmesh.geometry.boundingSphere.radius;

            scope.boxmax = partmesh.geometry.boundingBox.max.clone();



            scope.vcentroid.set(scope.minx,scope.miny,scope.minz);

            var maxvector = new THREE.Vector3((scope.maxx - scope.minx) * 0.5,(scope.maxy - scope.miny) * 0.5,(scope.maxz - scope.minz) * 0.5);

            scope.vcentroid.add(maxvector);


            //scope.worldpos = partmesh.worldToLocal(scope.centroid);


            parent.blockadded();
            scope.isLoadComplete = true;

            if(scope.isLastBlock){
                parent.blockreadComplete();
            }
            //var currentcolor = scope.tarray[scope.curTrset].color;

            if(scope.tarray.length > 1){
                //if(currentcolor == scope.tarray[scope.curTrset+1].color){
                    //scope.tarray[scope.curTrset+1].geometry = scope.tarray[scope.curTrset].geometry;
                //}
            }
            scope.tarray.shift();

            if(scope.tarray.length > 0){
                scope.processmesh();
            }


        };

        this.setlastblock = function(){
            scope.isLastBlock = true;
            if (scope.isLoadComplete || !scope.hasmesh){
                parent.blockreadComplete();
            }

        };

        this.resetvisible = function () {

            scope.tempvisible = (scope.visible == 1);


        };

        function maxmin(x,y,z){
            if(scope.maxx < x){
                scope.maxx = x;
            }

            if(scope.maxy < y){
                scope.maxy = y;
            }

            if(scope.maxz < z){
                scope.maxz = z;
            }

            if(scope.minx > x){
                scope.minx = x;
            }
            if(scope.miny > y){
                scope.miny = y;
            }

            if(scope.minz > z){
                scope.minz = z;
            }
        }

        function parsemeshbuffer(){

            var counter = 0;
            var meshobj = scope.tarray[scope.curTrset];
            if(meshobj.dvpos < (meshobj.triangles * 9 * 4)){
                var x = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.x;
                meshobj.dvpos += 4;
                var y = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.y;
                meshobj.dvpos += 4;
                var z = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.z;

                maxmin(x,y,z);


                meshobj.vectors[meshobj.vindex] = x;
                meshobj.vectors[meshobj.vindex+1] = y;
                meshobj.vectors[meshobj.vindex+2] = z;


                meshobj.vindex +=3;

                //meshobj.geometry.vertices.push(new THREE.Vector3(x, y, z));
                meshobj.dvpos += 4;
                x = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.x;
                meshobj.dvpos += 4;
                y = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.y;
                meshobj.dvpos += 4;
                z = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.z;

                maxmin(x,y,z);

                meshobj.vectors[meshobj.vindex] = x;
                meshobj.vectors[meshobj.vindex+1] = y;
                meshobj.vectors[meshobj.vindex+2] = z;



                meshobj.vindex +=3;

                //meshobj.geometry.vertices.push(new THREE.Vector3(x, y, z));
                meshobj.dvpos += 4;
                x = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.x;
                meshobj.dvpos += 4;
                y = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.y;
                meshobj.dvpos += 4;
                z = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.z;
                meshobj.dvpos += 4;

                maxmin(x,y,z);
                //meshobj.geometry.vertices.push(new THREE.Vector3(x, y, z));            }
                meshobj.vectors[meshobj.vindex] = x;
                meshobj.vectors[meshobj.vindex+1] = y;
                meshobj.vectors[meshobj.vindex+2] = z;


                meshobj.vindex +=3;

            }

            scope.tarray[scope.curTrset] = meshobj;
            return meshobj.dvpos;


        }


        function yieldingLoop(count,chunksize, callback, finished) {
            var i = 0;
            (function chunk() {
                var end = Math.min(i + chunksize, count);
                for (; i < end; ++i) {
                    callback.call(null, i);
                }
                if (i < count) {
                    setTimeout(chunk, 0);
                } else {
                    finished.call(null);
                }
            })();
        }

        //var j = 0; //scope.tarray[scope.curTrset].dvpos
        //var count = 1e6; //total meshobj.triangles * 9 * 4




    };


    var Block3DObject = function (name, index, state, level, listposition) {
        var block3Dref = this;

        this.name = name;
        this.index = index;
        this.state = state;
        this.level = level;
        this.position = listposition;
        this.selected = false;




        this.setSelected = function (selected) {

            block3Dref.selected = selected;

        };


    };


    var Vector3DPageObject = function (pagexmldata, binary, parent) {

        var vector3Dref = this;
        var breadbinaryready = false;
        var pageobject = parent;
        var dv = new DataView(pagexmldata);
        var header = String.fromCharCode(dv.getUint8(0));
        var i = 1;
        while (i <= 15) {
            header += String.fromCharCode(dv.getUint8(i));
            i++;
        }
        this.countparts = 0;
        this.binaryreadcomplete = false;
        this.selectedpart = -1;
        this.version = parseInt(dv.getInt32(16, true));
        this.clippingOn = false;

        this.x = parseFloat(dv.getFloat32(24, true));
        this.y = parseFloat(dv.getFloat32(28, true));
        this.z = parseFloat(dv.getFloat32(32, true));
        this.w = parseFloat(dv.getFloat32(36, true)) - this.x;
        this.h = parseFloat(dv.getFloat32(40, true)) - this.y;
        this.d = parseFloat(dv.getFloat32(44, true)) - this.z;


        if(this.w < 1000){
            this.unit = 1;
            //meter
        }else{
            this.unit = 0;
            //mm
        }

        this.orignalscale = parseFloat(dv.getFloat32(48, true));
        var headeroffset = 52;
        dv = null;

        var wscale = renderer.domElement.width / this.w;
        var hscale = renderer.domElement.height / this.h;
        this.scale = Math.min(wscale, hscale);

        parent.clock = new THREE.Clock();

        //this.scene = new JSC3D.Scene();
        this.scene = new THREE.Scene();
        var szShortformat = DocObj.Format.substring(0, 3);
        if (szShortformat == 'IFC') {
            this.scene.up.set(0, 0, 1);
        } else {
            this.scene.up.set(0, 1, 0);
        }

        //this.scene.up.set(0,0,1);
        //this.scene.rotation.set(0,1.57,0,'XYZ');
        this.explodefactor = 0;
        this.pxplodefactor = 0;
        this.partlist = [];
        this.blocklist = [];

        var curx = this.scene.position.x;
        var cury = this.scene.position.y;
        var curz = this.scene.position.z;

        curx += -(this.w / 2) * this.scale;
        cury += -(this.h / 2) * this.scale;
        curz += -(this.d / 2) * this.scale;

        this.scene.position.set(curx, cury, curz);
        this.originalpos = new THREE.Vector3();
        this.originalpos = this.scene.position.clone();


        this.scene.updateMatrix();

        this.globalPlaneX = new THREE.Plane( new THREE.Vector3( 1, 0, 0 ), 0 );
        this.globalPlaneY = new THREE.Plane( new THREE.Vector3( 0, 1, 0 ), 0 );
        this.globalPlaneZ = new THREE.Plane( new THREE.Vector3( 0, 0, -1 ), 0 );
        this.globalPlanes = [ this.globalPlaneX,this.globalPlaneY,this.globalPlaneZ ],
            Empty = Object.freeze( [] );


        this.xPlaneconst = this.w * this.scale;
        var safeadjust = this.xPlaneconst / 20; //10 percent additional space for clipping
        this.xPlaneconst += safeadjust;
        this.xPlaneEnd = curx;
        this.xPlaneStart = this.xPlaneconst - curx;
        this.xPlaneEnd -= safeadjust/2;

        this.yPlaneconst = this.h * this.scale;
        safeadjust = this.yPlaneconst / 20; //10 percent additional space for clipping
        this.yPlaneconst += safeadjust;
        this.yPlaneEnd = cury;
        this.yPlaneStart = this.yPlaneconst - cury;
        this.yPlaneEnd -= safeadjust/2;

        this.zPlaneconst = this.d * this.scale;
        safeadjust = this.zPlaneconst / 20; //10 percent additional space for clipping
        this.zPlaneconst += safeadjust;
        this.zPlaneEnd = curz;
        this.zPlaneStart = this.zPlaneconst - curz;
        this.zPlaneEnd -= safeadjust/2;

        this.globalPlaneX.constant = this.xPlaneStart;
        this.globalPlaneY.constant = this.yPlaneStart;
        this.globalPlaneZ.constant = this.zPlaneStart;

        this.cameraSaves = [];
        //var pointLight = new THREE.PointLight(0xFFFFFF);
        //pointLight.intensity = 0.8;

        //this.scene.add(pointLight);

        var directionalLight_1 = new THREE.DirectionalLight(0xffffff, 1.2);
        //directionalLight.intensity = 0.5;
        directionalLight_1.position.set(-500, -500, 500);
        //var helper_1 = new THREE.DirectionalLightHelper(directionalLight_1, 1);

        this.scene.add(directionalLight_1);
        //this.scene.add( helper_1 );

        var directionalLight_2 = new THREE.DirectionalLight(0xffffff, 1);
        //directionalLight.intensity = 0.3;
        directionalLight_2.position.set(1000, 1000, 1000);
        //var helper_2 = new THREE.DirectionalLightHelper(directionalLight_2, 1);
        this.scene.add(directionalLight_2);
        //this.scene.add( helper_2 );

        var directionalLight_3 = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight_3.position.set(0, 0, -1000);
        this.scene.add(directionalLight_3);

        parent.camera = new THREE.PerspectiveCamera(45, canvasowidth / canvasoheight, 1, 10000);

        var format = DocObj.Format.substring(0, 3);
        if (format == 'IFC') {
            var camerax = (vector3Dref.w / 2) * vector3Dref.scale;
            var cameray = -(vector3Dref.h) * vector3Dref.scale;
            var cameraz = (vector3Dref.d / 2) * vector3Dref.scale;
            var camerayorig = cameray;
            camerax = 0;
            cameray *= 2;
            cameraz = 0;

            parent.camera.up.set(0, 0, 1);
            //parent.camera.rotation.set(90 * Math.PI / 180, 0, 0);


        } else {
            camerax = (vector3Dref.w / 2) * vector3Dref.scale;
            cameray = (vector3Dref.h / 2) * vector3Dref.scale;
            cameraz = (vector3Dref.d) * vector3Dref.scale;

            camerax = 0;
            cameray = 0;
            cameraz *= 2;

            parent.camera.up.set(0, 1, 0);
            //parent.camera.rotation.set(0, 90 * Math.PI / 180, 0);


        }

        parent.camera.position.set(camerax, cameray, cameraz);
        parent.camera.lookAt(new THREE.Vector3(0,0,0));

        this.scene.updateMatrix();

        bAnimateready = false;

        //    this.scene = new JSC3D.Scene();
        //    this.partlist = [];

        var maindv = new DataView(pagexmldata, headeroffset);

        var dvpos = 0;
        var objid = parseInt(maindv.getInt32(dvpos, true));
        var newblock = false;
        var blockid = -1;
        var bimtype = -1;
        var facecolor = 0;


        var blockcounter = 0;
        var tottriangles = 0;


        if (pageobject.has3Dnav) {
            pageobject.load3dnavigator();
        }else{
            breadbinaryready = true;
        }

        //parse3Dloop();

        function parse3Dloop(){

            var readstate = {
                objectid : objid,
                blockpart : blockid,
                bnewblock : newblock,
                maindvpos :dvpos,
                facecolor : 0
            };

            yieldingLoop(readstate, 200, function() {
                readstate = parse3Dbinary(readstate);

            }, function() {
                readbinarycomplete();
            });

            (function timer() {

                if(maindv)

                    if (readstate.objectid != 32768) {
                        setTimeout(timer, 10);
                    }

            })();


        }


        function parse3Dbinary(readstate){
            switch (readstate.objectid) {
                case 9:
                    //trianglelist
                    readstate.maindvpos += 4;
                    var numtriangles = maindv.getInt32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var endrange = 9 * 4 * numtriangles;
                    var dvtriangles = new DataView(pagexmldata, headeroffset + readstate.maindvpos, endrange);

                    tottriangles += numtriangles;

                    /*if (blockcounter > 20) {
                     blockcounter = 0;
                     vector3Dref.scene.updateMatrix();
                     renderer.render(vector3Dref.scene, camera);
                     }*/
                    if(vector3Dref.partlist[readstate.blockpart] != undefined){
                        vector3Dref.partlist[readstate.blockpart].addpart(dvtriangles, numtriangles, readstate.blockpart, readstate.facecolor, readstate.bnewblock);
                        vector3Dref.countparts++;
                    }

                    //console.log(tottriangles);

                    /*vector3Dref.partlist[blockpart].promise.then(function(){
                     vector3Dref.scene.updateMatrix();
                     renderer.render(vector3Dref.scene, camera);

                     });*/

                    /*this.parse(maindv).then(function() {
                     //console.log("Success!", response);
                     maindv = null;
                     //console.log('read finished');
                     bAnimateready = true;
                     if (RxCore_GUI_Download != undefined) {
                     RxCore_GUI_Download.setDownload("hide");
                     }


                     }, function(id, position) {
                     //console.log(objid);
                     //console.log(maindvpos);

                     console.error("Failed!", id, position);
                     });*/

                    //getbpartdiredct(dvtriangles, numtriangles, blockpart, facecolor, bnewblock);

                    /*if(numtriangles < 1000 && tottriangles < 2000000 ){
                     getbpartdiredct(dvtriangles, numtriangles, blockpart, facecolor, bnewblock);
                     }else{
                     getbpartdelay(dvtriangles, numtriangles, blockpart, facecolor, 100);
                     }*/



                    //ncolor  = decimalToHex(facecolor);
                    //vector3Dref.partlist[blockpart].createmesh(dvtriangles,numtriangles,ncolor);
                    readstate.maindvpos += endrange;
                    readstate.bnewblock = false;


                    //maindvpos += 4;
                    readstate.objectid = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    break;
                case 10:
                    //Attribute
                    readstate.maindvpos += 4;
                    var nAttrbutenl = parseInt(maindv.getInt32(readstate.maindvpos, true));

                    readstate.maindvpos += 4;
                    var battrncount = readstate.maindvpos;
                    var szatrrname = "";


                    while (battrncount < readstate.maindvpos + nAttrbutenl * 2) {
                        if (maindv.getUint8(battrncount) != 0) {
                            szatrrname += String.fromCharCode(maindv.getUint16(battrncount, true));
                        }

                        battrncount += 2;

                    }
                    readstate.maindvpos = battrncount;
                    var nAttrbutevl = parseInt(maindv.getInt32(readstate.maindvpos, true));

                    readstate.maindvpos += 4;
                    var battrvcount = readstate.maindvpos;
                    var szatrtvalue = "";


                    while (battrvcount < readstate.maindvpos + nAttrbutevl * 2) {
                        if (maindv.getUint8(battrvcount) != 0) {
                            szatrtvalue += String.fromCharCode(maindv.getUint16(battrvcount, true));
                        }

                        battrvcount += 2;

                    }
                    readstate.maindvpos = battrvcount;

                    vector3Dref.partlist[readstate.blockpart].addAtrib(szatrrname, szatrtvalue);
                    /*
                     0	4	LONG	Object ID	10
                     4	4	LONG	NameLength		Number of characters in name
                     8	N	CHAR[N]	Name		Attribute Name
                     8+NameLength	4	LONG	ValueLength		Number of characters in value
                     8+NameLen+4	N	CHAR[N]	Value		Attribute Value

                     */


                    readstate.objectid = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    break;
                case 33:
                    readstate.maindvpos += 4;

                    var lineX1 = maindv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lineY1 = maindv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lineZ1 = maindv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lineX2 = maindv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lineY2 = maindv.getFloat32(readstate.maindvpos, true);
                    readstate.maindvpos += 4;
                    var lineZ2 = maindv.getFloat32(readstate.maindvpos, true);

                    var lineobj = {
                        X1 : lineX1,
                        Y1 : lineY1,
                        Z1 : lineZ1,
                        X2 : lineX2,
                        Y2 : lineY2,
                        Z2 : lineZ2
                    };

                    if(vector3Dref.partlist[readstate.blockpart] != undefined){
                        vector3Dref.partlist[readstate.blockpart].addline(lineobj, readstate.facecolor);
                        vector3Dref.countparts++;
                    }


                    /*4	4	FLOAT	X1		Line coordinates
                     8	4	FLOAT	Y1
                     12	4	FLOAT	Z1
                     16	4	FLOAT	X2
                     20	4	FLOAT	Y2
                     24	4	FLOAT	Z2*/
                    readstate.maindvpos += 4;
                    readstate.objectid = parseInt(maindv.getInt32(readstate.maindvpos, true));

                    break;
                case 74:
                    readstate.maindvpos += 4;
                    readstate.facecolor = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    /*
                     0	4	LONG	Object ID	74
                     4	4	LONG	Draw color		#RRGGBB

                     */
                    readstate.maindvpos += 4;
                    readstate.objectid = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    break;

                case 75:
                    //facecolor
                    readstate.maindvpos += 4;
                    bimtype = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    vector3Dref.partlist[readstate.blockpart].ifctype = bimtype;
                    //console.log(bimtype);
                    /*if (bimtype == 34){
                     var visibility = 0;
                     }*/
                    /*
                     0	4	LONG	Object ID	75
                     4	4	LONG	BimType		#RRGGBB

                     */
                    readstate.maindvpos += 4;
                    readstate.objectid = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    break;
                case 12288:

                    readstate.maindvpos += 4;
                    readstate.objectid = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    //objid = 12288;

                    if (vector3Dref.partlist.length > 0 && szShortformat == 'IFC') {
                        switch(vector3Dref.partlist[readstate.blockpart].ifctype){
                            case 34:
                                vector3Dref.partlist[readstate.blockpart].visible = 0;
                                break;
                            case 21:
                                if (vector3Dref.partlist[readstate.blockpart].tarray[vector3Dref.partlist[readstate.blockpart].curTrset].triangles > 5000){
                                    vector3Dref.partlist[readstate.blockpart].visible = 0;
                                    vector3Dref.partlist[readstate.blockpart].tempvisible = false;
                                }
                                break;
                        }

                    }
                    if (readstate.blockpart != -1 && vector3Dref.partlist.length > 0) {
                        if(vector3Dref.partlist[readstate.blockpart].tarray.length > 0){
                            vector3Dref.partlist[readstate.blockpart].processmesh();
                        }
                        /*var mstatus = vector3Dref.partlist[blockpart].getmeshstatus();
                         if (mstatus.open && mstatus.meshexist) {
                         //setTimeout(vector3Dref.partlist[blockpart].addmesh(),2);
                         vector3Dref.partlist[blockpart].addmesh();

                         }*/
                    }
                    //end of block;
                    break;
                case 4096:
                    readstate.maindvpos += 4;

                    /*if(blockpart != -1 && vector3Dref.partlist.length > 0){
                     var mstatus = vector3Dref.partlist[blockpart].getmeshstatus();
                     if(mstatus.open && mstatus.meshexist ){
                     vector3Dref.partlist[blockpart].addmesh();
                     console.log(blockpart);
                     }
                     }*/


                    readstate.blockpart = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    readstate.bnewblock = true;
                    readstate.maindvpos += 4;
                    readstate.maindvpos += 4;
                    var nvisbile = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    readstate.maindvpos += 4;
                    var ntransparent = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    readstate.maindvpos += 4;
                    var ncolor = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    readstate.maindvpos += 4;
                    var nNamelength = parseInt(maindv.getInt32(readstate.maindvpos, true));

                    readstate.maindvpos += 4;
                    var bnamecount = readstate.maindvpos;
                    var szblockname = "";

                    while (bnamecount < readstate.maindvpos + nNamelength * 2) {
                        if (maindv.getUint8(bnamecount) != 0) {
                            szblockname += String.fromCharCode(maindv.getUint16(bnamecount, true));
                        }

                        bnamecount += 2;

                    }
                    readstate.maindvpos = bnamecount;

                    var mesharr = [];


                    var opartobj = {
                        id:readstate.blockpart,
                        visible:nvisbile,
                        transparent:ntransparent,
                        color:ncolor,
                        name:szblockname
                    };



                    if(szShortformat == 'IFC'){
                        var part = new Part3DObject(opartobj, readstate.blockpart, vector3Dref, true);
                    }else{
                        part = new Part3DObjectMulti(opartobj, readstate.blockpart, vector3Dref, true);
                        part.addAtrib("Part name", szblockname);

                        //var blockitem = new Block3DObject(szblockname, readstate.blockpart, nvisbile, 0, 0);
                        //vector3Dref.blocklist.push(blockitem);

                    }

                    vector3Dref.partlist[readstate.blockpart] = part;
                    blockcounter++;



                    /*
                     0	4	LONG	Object ID	0x1000
                     4	4	LONG	Block ID
                     8	4	LONG	Flags		Reserved
                     12	4	LONG	Visible		Visible if non zero
                     16	4	LONG	Transparent		Transparent if non zero.
                     20	4	LONG	Color		Default block color
                     24	4	LONG	Length of name		Length of block name in Unicode characters including zero terminator.
                     28	[]	WCHAR	Name of block		Unicode
                     */

                    //block start
                    //objid = 4096;
                    //maindvpos += 4;
                    readstate.objectid = parseInt(maindv.getInt32(readstate.maindvpos, true));
                    break;
                case 32768:
                    //console.log('read finished');
                    //resolve();
                    //counter = 200;
                    //vector3Dref.partlist[vector3Dref.partlist.length-1].isLastBlock = true;
                    vector3Dref.partlist[vector3Dref.partlist.length-1].setlastblock();
                    /*if (pageobject.has3Dnav) {
                     pageobject.load3dnavigator();
                     }*/

                    break;

                default:
                    //console.log('default');
                    //console.log(objid);
                    //console.log(maindvpos);
                    readstate.objectid = 32768;
                    //reject(objid,maindvpos);
                    //counter = 200;
                    console.error("Failed!", readstate.objectid, readstate.maindvpos);
                    break;
            }
            return readstate;
        }


        function readbinarycomplete(){
            vector3Dref.partlist[vector3Dref.partlist.length-1].isLastBlock = true;
            vector3Dref.binaryreadcomplete = true;
            maindv = null;
            bAnimateready = true;


            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("hide");
            }

            if(vector3Dref.partlist[vector3Dref.partlist.length-1].isLoadComplete){
                vector3Dref.blockreadComplete();
            }

            vector3Dref.updateblocklist();

        }

         /*this.checkpartload = function(){
             vector3Dref.partlist[vector3Dref.partlist.length-1].isLastBlock = true;

             if(vector3Dref.partlist[vector3Dref.partlist.length-1].isLoadComplete){
                 vector3Dref.blockreadComplete();
             }
             console.log('part complete');


         };*/

        this.blockadded = function(){
            vector3Dref.countparts--;
            if(vector3Dref.binaryreadcomplete){
                if(vector3Dref.countparts == 0){
                    vector3Dref.blockreadComplete();
                    vector3Dref.updateblocklist();

                }
            }

        };


        this.blockreadComplete = function(){

            if (RxCore_GUI_Read3DComplete != undefined) {
                RxCore_GUI_Read3DComplete.readComplete();
            }

            parent.DocRef.SetActive();
            //console.log('last block added');
            /*if (pageobject.has3Dnav) {
                pageobject.load3dnavigator();
            }*/
            //vector3Dref.updateblocklist();

            /*if(szShortformat == 'IFC'){

            }

            if(szShortformat != 'IFC'){
                breadbinaryready = false;
                vector3Dref.updateblocklist();
            }*/


        };

        this.addblocks = function (pagexmldata) {
            this.blocklist = [];
            var rootnode = pagexmldata.getElementsByTagName('navigator');
            var rc = 0;
            var level = 0;
            var curlev = level;
            var partnodes = pagexmldata.getElementsByTagName('partref');
            for (var pc = 0; pc < partnodes.length; pc++) {
                var curnode = partnodes[pc];
                curlev = level;
                level = 0;
                while (curnode.parentNode.nodeName == 'partref') {
                    curnode = curnode.parentNode;
                    level++;
                }
                if (level < curlev) {
                    //BlocksContainer.AddULend();
                    //this.htmlcontent += "</ul>";
                }
                if (level > curlev) {
                    //BlocksContainer.AddULstart();
                    //this.htmlcontent += "<ul style='list-style: none; margin: 0; padding: 0;'>";
                }
                if (RxCore_GUI_3DParts != undefined) {
                    var listposition = pc * RxCore_GUI_3DParts.listheight;
                } else {
                    listposition = 0;
                }

                //var listposition = pc * BlocksContainer.listheight;
                //BlocksContainer.AddLIelement();
                //this.htmlcontent += "<li style='list-style: none; padding-left: 10px;'>";
                var blockname = partnodes[pc].attributes.getNamedItem('name').value;
                var partindex = partnodes[pc].attributes.getNamedItem('index').value;
                var partstate = partnodes[pc].attributes.getNamedItem('state').value;
                var blockitem = new Block3DObject(blockname, partindex, partstate, level, listposition);
                this.blocklist.push(blockitem);


            }
            //this.updateblocklist();
            parse3Dloop();
            /*if (RxCore_GUI_3DParts != undefined) {
                RxCore_GUI_3DParts.isupdate = false;
                RxCore_GUI_3DParts.set3DParts(this.blocklist);
            }*/



        };

        this.updateblocklist = function () {
            //BlocksContainer.init3D();

            //this.htmlcontent = "<ul style='list-style: none; margin: 0; padding: 0;'>";

            var level = 0;
            //var blocklistheight = BlocksContainer.Getheight();
            for (var pc = 0; pc < this.blocklist.length; pc++) {

                //curlev = level;
                //level = this.blocklist[pc].level;
                //var curnode =  this.blocklist[pc].;

                /*while(curnode.parentNode.nodeName == 'partref'){
                 curnode = curnode.parentNode;
                 level++;
                 }*/
                /*if (level < curlev ){
                 BlocksContainer.AddULend();
                 //this.htmlcontent += "</ul>";
                 }
                 if (level > curlev ){
                 BlocksContainer.AddULstart();
                 //this.htmlcontent += "<ul style='list-style: none; margin: 0; padding: 0;'>";
                 }*/
                //BlocksContainer.AddLIelement();
                //this.htmlcontent += "<li style='list-style: none; padding-left: 10px;'>";
                //var blockname = partnodes[pc].attributes.getNamedItem('name').value;
                //var partindex = partnodes[pc].attributes.getNamedItem('index').value;
                //var partstate = partnodes[pc].attributes.getNamedItem('state').value;
                //var blockitem  = new Block3DObject(blockname,partindex,partstate,level);
                //this.blocklist.push(blockitem);
                var index = this.blocklist[pc].index;

                if (this.partlist[index] != undefined) {
                    this.blocklist[pc].state = this.partlist[index].tempvisible;
                } else {
                    this.blocklist[pc].state = false;
                }


                //this.blocklist[pc].state = this.partlist[index].tempvisible;
                if (this.partlist[index].selected) {
                    /* if(this.blocklist[pc].position > (blocklistheight / 2)){
                     BlocklistScrollTo = this.blocklist[pc].position - (blocklistheight / 2);
                     }*/
                    this.blocklist[pc].setSelected(true);
                } else {
                    this.blocklist[pc].setSelected(false);
                }
                //this.htmlcontent += this.blocklist[pc].htmltext;


            }

            if (RxCore_GUI_3DParts != undefined) {
                RxCore_GUI_3DParts.isupdate = true;
                //RxCore_GUI_3DParts.scrollto = BlocklistScrollTo;
                RxCore_GUI_3DParts.set3DParts(this.blocklist);
                //RxCore_GUI_3DParts.scrollto = 0;
            }


        };


        this.searchAttribute = function(attribval){
            var id = -1;

            for (var pc = 0; pc < vector3Dref.partlist.length; pc++) {
                var part3D = vector3Dref.partlist[pc];
                for (var ac = 0; ac < part3D.attributes.length ; ac++){
                    if (part3D.attributes[ac].value == attribval){
                        id =  vector3Dref.partlist[pc].id;
                    }
                }
            }
            return id;
        };

        this.addpartbinary = function (bstream, lastpart) {

        };

        this.addpart = function (partxml, lastpart) {
            var partobj = partxml.getElementsByTagName('part');
            var i = 0;
            //var curlength = vector3Dref.partlist.length - 1;

            function getpart(partxml) {

                setTimeout(function () {

                    if (partxml.attributes.getNamedItem('id') != undefined) {
                        var pid = partxml.attributes.getNamedItem('id').value;
                    }
                    var part = new Part3DObject(partxml, pid, vector3Dref);
                    vector3Dref.partlist[pid] = part;
                    //vector3Dref.partlist.push(part);
                    if (part.hasmesh) {
                        try {
                            //vector3Dref.scene.add( part.mesh );
                        } catch (e) {
                            alert(e.message);
                        }

                        try {
                            //renderer.render(vector3Dref.scene, camera,false);
                        } catch (e) {
                            alert(e.message);
                        }

                        //console.log(pid);
                    }

                    bAnimateready = lastpart;

                    /*if(lastpart){
                     bAnimateready = true;
                     renderer.preserveDrawingBuffer = false;
                     renderer.autoClear = true;

                     }else{
                     renderer.render(vector3Dref.scene, camera,false);
                     }*/


                    //alert(i);
                }, 10);

            }

            while (i < partobj.length) {
                //bAnimateready = true;
                getpart(partobj[i]);

                i++;

            }
            /*
             if(lastpart){
             bAnimateready = true;
             renderer.preserveDrawingBuffer = false;
             renderer.autoClear = true;

             }else{
             renderer.render(vector3Dref.scene, camera,false);
             }
             */
            //bAnimateready = true;

            //alert(vector3Dref.partlist.length);
            //renderer.render(vector3Dref.scene, camera,false);
        };


        this.clipping = function (plane, constant, onoff ){

            vector3Dref.clippingOn = onoff;

            if(onoff){
                renderer.clippingPlanes = vector3Dref.globalPlanes;
            }else{

                renderer.clippingPlanes = Empty;
                return;
            }

            var percent = constant / 100;

            switch(plane){
                case 0: //x plane
                    var newval = vector3Dref.xPlaneEnd + (vector3Dref.xPlaneconst * percent);
                    vector3Dref.globalPlaneX.constant = newval;

                    break;
                case 1: //y plane
                    newval = vector3Dref.yPlaneEnd + (vector3Dref.yPlaneconst * percent);
                    vector3Dref.globalPlaneY.constant = newval;

                    break;
                case 2: //z plane
                    newval = vector3Dref.zPlaneEnd + (vector3Dref.zPlaneconst * percent);
                    vector3Dref.globalPlaneZ.constant = newval;


                    break;
            }



        };


        this.doexplode = false;


        this.saveCamera = function(){
            //const savedCamera = JSON.parse( localStorage.getItem( 'savedCamera' ) );
            //this.cameraSaves = [];
            //vector3Dref.cameraSaves.push(vector3Dref.parent.camera.position);
            //vector3Dref.cameraSaves.push(vector3Dref.parent.camera.matrix.toArray());
            //vector3Dref.cameraSaves.push(pageobject.camera.matrix.toArray());

            var geometry = new THREE.SphereBufferGeometry( 10, 32, 32 );
            var material = new THREE.MeshBasicMaterial( {color: 0xffff00} );
            var sphere = new THREE.Mesh( geometry, material );
            var posnum = vector3Dref.cameraSaves.length + 1;
            sphere.name = "markuppos_" + posnum;

            vector3Dref.cameraSaves.push({position : pageobject.camera.matrix.toArray(), name : sphere.name});


            var cposvector = new THREE.Vector3();
            cposvector.copy(pageobject.camera.position);
            cposvector.sub(vector3Dref.scene.position);

            sphere.position.copy(cposvector);

            //vector3Dref.scene.position

            //cposvector.x -= vector3Dref.x;
            //cposvector.y -= vector3Dref.y;
            //cposvector.z -= vector3Dref.z;
            //sphere.position.add(vector3Dref.scene.position);

            vector3Dref.scene.add(sphere);


            /*var x = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.x;
            meshobj.dvpos += 4;
            var y = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.y;
            meshobj.dvpos += 4;
            var z = meshobj.dv.getFloat32(meshobj.dvpos, true) - parent.z;*/



        };


        this.restoreCameraName = function(name){
            for(var i = 0; i < vector3Dref.cameraSaves.length; i++){
                if(vector3Dref.cameraSaves[i].name == name){
                    pageobject.camera.matrix.fromArray(vector3Dref.cameraSaves[i].position);
                    pageobject.camera.matrix.decompose(pageobject.camera.position, pageobject.camera.quaternion, pageobject.camera.scale);

                }

            }

        };

        this.restoreCamera = function(){

            //var camerapos = vector3Dref.cameraSaves.pop();
            //vector3Dref.parent.camera.position.copy(camerapos);
            //camera.position.copy( savedCamera.cameraPosition );
            //orbitControls.target.copy( savedCamera.targetPosition );

            if(vector3Dref.cameraSaves.length >= 1){
                var camerapos = vector3Dref.cameraSaves.pop();
                pageobject.camera.matrix.fromArray(camerapos.position);
                pageobject.camera.matrix.decompose(pageobject.camera.position, pageobject.camera.quaternion, pageobject.camera.scale);
            }

            /*savedCamera = JSON.stringify({
                cameraPosition: camera.position,
                targetPosition: orbitControls.target
            });*/
        };

        this.explode = function (distance) {


            if (!vector3Dref.doexplode) {
                return;
            }


            var scenepos = vector3Dref.originalpos.clone();



            if (distance == 0) {
                for (var partix = 0; partix < vector3Dref.scene.children.length; partix++) {

                    if (vector3Dref.scene.children[partix].type == "Mesh") {
                        vector3Dref.scene.children[partix].position.x = 0;
                        vector3Dref.scene.children[partix].position.y = 0;
                        vector3Dref.scene.children[partix].position.z = 0;

                    }

                }


                if (this.pxplodefactor != 0) {
                    var pscenepos = vector3Dref.originalpos.clone();
                    var psceneoffset = pscenepos.multiplyScalar(this.pxplodefactor);
                    vector3Dref.scene.position.sub(psceneoffset);

                }


                this.pxplodefactor = 0;


                return;
            }

            distance /= 10;

            //- vector3Dref.pxplodefactor;

            for (partix = 0; partix < vector3Dref.scene.children.length; partix++) {


                //var partcenter = this.partlist[partix].center;

                if(vector3Dref.scene.children[partix].name === ""){
                    continue;
                }

                if (vector3Dref.scene.children[partix].type == "Mesh") {

                    if (vector3Dref.partlist[vector3Dref.scene.children[partix].name].center != undefined) {
                        //original center stored in the partlist.

                        var partcenter = vector3Dref.partlist[vector3Dref.scene.children[partix].name].vcentroid.clone();


                        if (this.pxplodefactor != 0) {
                            var ppartcenter = partcenter.clone();
                            var ppartoffset = ppartcenter.multiplyScalar(this.pxplodefactor);
                            ppartcenter.multiplyScalar(vector3Dref.scale);
                            vector3Dref.scene.children[partix].position.sub(ppartoffset);

                        }
                        //get original center from partlist



                        var partoffset = partcenter.multiplyScalar(distance);
                        partoffset.multiplyScalar(vector3Dref.scale);

                        vector3Dref.scene.children[partix].position.add(partoffset);




                    }


                }


            }


            if (this.pxplodefactor != 0) {
                pscenepos = vector3Dref.originalpos.clone();
                psceneoffset = pscenepos.multiplyScalar(this.pxplodefactor);
                vector3Dref.scene.position.sub(psceneoffset);



            }


            var sceneoffset = scenepos.multiplyScalar(distance);

            //sceneoffset.x /= vector3Dref.scale;
            //sceneoffset.y /= vector3Dref.scale;
            //sceneoffset.z /= vector3Dref.scale;


            vector3Dref.scene.position.add(sceneoffset);



            vector3Dref.scene.updateMatrix();

            vector3Dref.pxplodefactor = distance;

        };

        this.setTransparency = function(value){


            for (var i = 0; i < vector3Dref.scene.children.length; i++) {
                if (vector3Dref.scene.children[i].type == "Mesh") {


                    if (vector3Dref.partlist[vector3Dref.scene.children[i].name].transparent == 0){

                        vector3Dref.scene.children[i].material.transparent = true;
                        //vector3Dref.scene.children[i].material.depthWrite = false;
                        vector3Dref.scene.children[i].material.opacity = value;
                        //renderer.sortObjects = false;


                    }

                }


            }

            // a small explode used to force correct transparency
            //workaround for now until a better solution present itself
            vector3Dref.doexplode = true;
            if (value == 0 ){
                vector3Dref.explode(0);
            }else{
                vector3Dref.explode(0.001);
            }

            vector3Dref.doexplode = false;



        };

        this.resetTransparency = function(){
            for (var i = 0; i < vector3Dref.scene.children.length; i++) {
                if (vector3Dref.scene.children[i].type == "Mesh") {
                    if (vector3Dref.partlist[vector3Dref.scene.children[i].name].transparent == 0){

                        vector3Dref.scene.children[i].material.transparent = false;
                        vector3Dref.scene.children[i].material.opacity = 1;


                    }

                }

            }

            // a small explode used to force correct transparency
            //workaround for now until a better solution present itself

            vector3Dref.doexplode = true;
            vector3Dref.explode(0);
            vector3Dref.doexplode = false;


        };


        this.setSelectedPart = function(name){
          this.selectedpart = name;
        };

        this.getSelectedPart = function(){
          return this.selectedpart;
        };

        this.Close = function () {

            while (this.partlist.length != 0) {
                this.partlist.pop();
            }
            while (this.blocklist.length != 0) {
                this.blocklist.pop();
            }

            while (this.scene.children.length != 0) {
                var obj = this.scene.children[this.scene.children.length - 1];
                this.scene.remove(obj);
                obj = null;
            }

            renderer.render(this.scene, parent.camera);
        };

        //parse3D(objid,blockid,newblock,dvpos);
        if(breadbinaryready){
            parse3Dloop();
        }



        function yieldingLoop(state, chunksize, callback, finished) {

            (function chunk() {
                var i = 0;
                //var end = Math.min(i + chunksize, count);
                var end = (i < chunksize );
                for (; i < chunksize; ++i) {
                    callback.call(null, state);
                }
                if (state.objectid != 32768) {

                    setTimeout(chunk, 0);
                } else {
                    //console.log(state.objectid);
                    finished.call(null);
                }
            })();
        }


    };

    var PageObject = function (pagexml, LayoutName, firstpage, path, pagenum, DocRef) {

        var thispage = this;
        var relpath = xmlurlrel;
        if(bUseCustomrelpath){
            relpath = xmlurlrelcustom;
        }

        this.DocRef = DocRef;
        this.pagenumber = pagenum;
        this.firstpage = firstpage;
        // 0 = large 1=small
        this.camera = null;
        this.walkthroughcontrol = {};

        this.currentimage = 1;

        //large image scale and offset
        this.dx = 0.0;
        this.dy = 0.0;
        this.dscale = 1.0;
        this.initialscale = 1.0;
        this.measurescale = MeasureScale;

        //vector image scale and offset
        this.dxvector = 0.0;
        this.dyvector = 0.0;

        this.dxpdf = 0.0;
        this.dypdf = 0.0;
        this.dscalepdf = 1.0;
        this.dscalebackup = 1.0;
        this.pdfpageref = null;

        this.magnifyrestscale = 1.0;
        this.dscalepdfabs = 1.0;

        this.dxbackup = 0.0;
        this.dybackup = 0.0;

        this.curpagescale = 1.0;
        this.curpagescalebackup = 1.0;
        this.pdfpageheight = 0.0;
        this.pdfpagewidth = 0.0;
        this.bMaxzoom = false;
        this.bMinzoom = false;
        this.nPDFMaxFactor = 4.0;

        this.pdfisrendered = false;
        this.pdfrenderopque = 0;
        this.pdfisfirstrendered = false;

        this.iscollapsed = true;

        this.offscreenwidth = 0.0;
        this.offscreenheight = 0.0;

        this.pdfstartrender = -1;
        this.pdfendrender = -1;
        this.pdfpagetime = -1;
        this.pdftimervar = null;
        this.PDFTextArea = undefined;
        this.PDFPointArray = [];
        this.PDFsnapTransform = null;
        this.bpointlistSet = false;
        this.PDFinternalScale = 1.0;
        this.PDFpageRotate = 0;
        this.pdfSnapScale = 1.0;
        this.TextSelectArea = undefined;

        this.snapEnabled = false;

        this.dscalevector = 1.0;
        this.fixedScale = 1.0;
        this.vectorisrendered = false;
        this.vectorischanged = false;
        this.vectorstartrender = -1;
        this.vectorendrender = -1;
        this.vectorpagetime = -1;
        this.vectortimervar = null;
        this.bDorescaleonsizeChange = bDoReScaleOnSize;
        this.width = 0;
        this.height = 0;
        //universal page original widht and height
        this.originalwidth = 0;
        this.originalheight = 0;

        //this.dscalevector = 1.0;
        this.initialzoom = 1;
        this.visible = false;

        //composite properties and reference.
        this.usedincomposite = false;
        this.compositereference = undefined;
        this.compositePrintreference = undefined;
        this.isbackground = false;
        this.isoverlay = false;

        //small image scale and offset
        this.dxextent = 0.0;
        this.dyextent = 0.0;
        this.startx = 0.0;
        this.starty = 0.0;
        this.endx = 0.0;
        this.endy = 0.0;
        this.dscaleextent = 1.0;
        this.bitmapratio = 1.0;

        //print scale and offset factors.
        this.dxprint = 0.0;
        this.dyprint = 0.0;
        this.dscaleprint = 1.0;

        //canvas thumbnail scale and offset.
        this.dxthumb=0.0;
        this.dythumb=0.0;
        this.dxthumbtemp=0.0;
        this.dythumbtemp=0.0;


        this.dscalethumb=1.0;
        this.pdftempthumbscale=1.0;

        this.drotation = 0;
        this.pagelockrotation = 0;
        this.textsearchindx = 0;
        this.usevectorxml = false;
        this.usevectorbinary = false;
        this.usepdfjs = false;
        this.usevector3Dxml = false;
        this.usevector3Dbinary = false;
        this.has3Dnav = false;
        this.pageloaded = false;
        this.pdfdiminitset = false;
        this.VectorPageObj = undefined;
        this.Vector3DPageObj = undefined;
        this.VectorPartfilelist = [];
        this.VectorBPartfilelist = [];

        this.largeimage = document.createElement('img'); //new Image();
        this.smallimage = document.createElement('img'); //new Image();
        this.smallimageloaded = false;
        this.largeimageloaded = false;
        this.vectorloaded = false;
        this.thumbnnailloaded = false;
        //this.imagethumb = document.createElement('img');//new Image();

        this.CurrentMarkup = 0;
        //MarkupZoom

        this.LayoutName = LayoutName;
        var arrayBuffer = null;
        if (pagexml.getElementsByTagName("PageName")[0] != undefined) {
            this.PageName = pagexml.getElementsByTagName("PageName")[0].firstChild.nodeValue;
        } else {
            this.PageName = LayoutName;
        }
        if (pagexml.getElementsByTagName("Compression")[0] != undefined) {
            this.Compression = pagexml.getElementsByTagName("Compression")[0].firstChild.nodeValue;
        }
        if (pagexml.getElementsByTagName("DPI")[0] != undefined) {
            this.DPI = pagexml.getElementsByTagName("DPI")[0].firstChild.nodeValue;
        }

        if (pagexml.getElementsByTagName("OffsetX")[0] != undefined) {
            this.OffsetX = pagexml.getElementsByTagName("OffsetX")[0].firstChild.nodeValue;
        }
        if (pagexml.getElementsByTagName("OffsetY")[0] != undefined) {
            this.OffsetY = pagexml.getElementsByTagName("OffsetY")[0].firstChild.nodeValue;
        }

        if (pagexml.getElementsByTagName("OriginalScale")[0] != undefined) {
            this.OriginalScale = pagexml.getElementsByTagName("OriginalScale")[0].firstChild.nodeValue;
        }

        if (pagexml.getElementsByTagName("VectorBinary2DSRC")[0] != undefined) {
            this.Vector2DBinarySRC = encodeURI(relpath + pagexml.getElementsByTagName("VectorBinary2DSRC")[0].firstChild.nodeValue);
            this.usevectorbinary = true;


        }
        if (pagexml.getElementsByTagName("Vector2DSRC")[0] != undefined) {
            this.Vector2DSRC = encodeURI(relpath + pagexml.getElementsByTagName("Vector2DSRC")[0].firstChild.nodeValue);
            if (!this.usevectorbinary) {
                this.usevectorxml = true;
            }

            //this.VectorDisplaylist = new VectorDisplaylist(this.Vector2DSRC);
        }
        //VectorBinary3DSRC
        if (pagexml.getElementsByTagName("VectorBinary3DSRC")[0] != undefined) {
            this.Vector3DBinarySRC = encodeURI(relpath + pagexml.getElementsByTagName("VectorBinary3DSRC")[0].firstChild.nodeValue);
            this.usevector3Dbinary = true;
            if (pagexml.getElementsByTagName("Navigator3DSRC")[0] != undefined) {
                this.Navigator3DSRC = encodeURI(relpath + pagexml.getElementsByTagName("Navigator3DSRC")[0].firstChild.nodeValue);
                this.has3Dnav = true;
            }

            /*if(pagexml.getElementsByTagName("Parts3D")[0] != undefined){
             var part3Dbinaryobj = pagexml.getElementsByTagName("SRC");
             for(j=0;j<part3Dbinaryobj.length;j++){
             this.VectorBPartfilelist[j] = encodeURI(xmlurlrel + part3Dxmlobj[j].firstChild.nodeValue);
             }
             }*/
            //this.VectorDisplaylist = new VectorDisplaylist(this.Vector2DSRC);
        }
        if (pagexml.getElementsByTagName("Vector3DSRC")[0] != undefined) {
            this.Vector3DSRC = encodeURI(relpath + pagexml.getElementsByTagName("Vector3DSRC")[0].firstChild.nodeValue);
            if (!this.usevector3Dbinary) {
                this.usevector3Dxml = true;
            }


            if (pagexml.getElementsByTagName("Parts3D")[0] != undefined) {
                var part3Dxmlobj = pagexml.getElementsByTagName("SRC");
                for (var j = 0; j < part3Dxmlobj.length; j++) {
                    this.VectorPartfilelist[j] = encodeURI(relpath + part3Dxmlobj[j].firstChild.nodeValue);
                }
            }
            //this.VectorDisplaylist = new VectorDisplaylist(this.Vector2DSRC);
        }

        if(thispage.DocRef.Type == "3" || thispage.DocRef.Type == "7"){
            this.TextSelectArea = document.createElement('div');
            this.TextSelectArea.className = "textLayer";
            //this.TextSelectArea.id = "Page" + this.pagenumber;
            this.TextSelectArea.addEventListener('wheel', ev_canvas, true);
            this.TextSelectArea.style.display = "none";

        }

        var szformatshort = thispage.DocRef.Format.substring(0, 9);
        if (szformatshort == "Adobe PDF") {
            this.usepdfjs = true;
            this.pagedrawCanvas = document.createElement('canvas');
            this.pagedrawctx = this.pagedrawCanvas.getContext('2d');
            this.pagecanvas = document.createElement('canvas');
            this.pagectx = this.pagecanvas.getContext('2d');
            this.magnifycanvas = document.createElement('canvas');
            this.magnifypagectx = this.magnifycanvas.getContext('2d');

            this.pageRendering = false;
            this.pagePrinting = false;
            this.pageNumPending = null;
            this.pagescale = 1.5;
            this.markupscaleadjust = 1.0;
            this.pdfdxtemp = 0.0;
            this.pdfdytemp = 0.0;
            this.pdfdscaletemp = 0.0;
            this.PDFTextArea = document.createElement('div');
            this.PDFTextArea.className = "textLayer";
            this.PDFTextArea.addEventListener('wheel', ev_canvas, true);



        } else {
            if (pagexml.getElementsByTagName("MainImageSRC")[0] != undefined) {
                this.MainImageSRC = encodeURI(relpath + pagexml.getElementsByTagName("MainImageSRC")[0].firstChild.nodeValue);
            }
            if (pagexml.getElementsByTagName("SmallImageSRC")[0] != undefined) {
                this.SmallImageSRC = encodeURI(relpath + pagexml.getElementsByTagName("SmallImageSRC")[0].firstChild.nodeValue);
            }
            if (pagexml.getElementsByTagName("SmallImageWidth")[0] != undefined) {
                this.SmallImageWidth = pagexml.getElementsByTagName("SmallImageWidth")[0].firstChild.nodeValue;
            }
            if (pagexml.getElementsByTagName("SmallImageHeight")[0] != undefined) {
                this.SmallImageHeight = pagexml.getElementsByTagName("SmallImageHeight")[0].firstChild.nodeValue;
            }
            if (pagexml.getElementsByTagName("SmallImageScaling")[0] != undefined) {
                this.SmallImageScaling = pagexml.getElementsByTagName("SmallImageScaling")[0].firstChild.nodeValue;
            }



        }


        //this.MainImageSRC = encodeURI(relpath  + pagexml.getElementsByTagName("MainImageSRC")[0].firstChild.nodeValue);
        //this.SmallImageSRC = encodeURI(relpath + pagexml.getElementsByTagName("SmallImageSRC")[0].firstChild.nodeValue);
        if (pagexml.getElementsByTagName("ThumbnailImageSRC")[0] != undefined) {

            if(pagexml.getElementsByTagName("ThumbnailImageSRC")[0].firstChild != undefined){
                this.ThumbnailImageSRC = relpath + pagexml.getElementsByTagName("ThumbnailImageSRC")[0].firstChild.nodeValue;
            }
        }
        if (pagexml.getElementsByTagName("MainImageWidth")[0] != undefined) {
            this.MainImageWidth = pagexml.getElementsByTagName("MainImageWidth")[0].firstChild.nodeValue;
        }

        if (pagexml.getElementsByTagName("MainImageHeight")[0] != undefined) {
            this.MainImageHeight = pagexml.getElementsByTagName("MainImageHeight")[0].firstChild.nodeValue;
        }

        if (pagexml.getElementsByTagName("MainImageScaling")[0] != undefined) {
            this.MainImageScaling = pagexml.getElementsByTagName("MainImageScaling")[0].firstChild.nodeValue;
        }
        if (pagexml.getElementsByTagName("MainImageOffsetX")[0] != undefined) {
            this.MainImageOffsetX = pagexml.getElementsByTagName("MainImageOffsetX")[0].firstChild.nodeValue;
        }
        if (pagexml.getElementsByTagName("MainImageOffsetY")[0] != undefined) {
            this.MainImageOffsetY = pagexml.getElementsByTagName("MainImageOffsetY")[0].firstChild.nodeValue;
        }







        //this.SmallImageWidth = pagexml.getElementsByTagName("SmallImageWidth")[0].firstChild.nodeValue;
        //this.SmallImageHeight = pagexml.getElementsByTagName("SmallImageHeight")[0].firstChild.nodeValue;
        //this.SmallImageScaling = pagexml.getElementsByTagName("SmallImageScaling")[0].firstChild.nodeValue;


        this.largeimagecnv = document.createElement('canvas');
        this.largeimagectx = this.largeimagecnv.getContext('2d');
        this.smallimagecnv = document.createElement('canvas');
        this.smallimagectx = this.smallimagecnv.getContext('2d');



        if (pagexml.getElementsByTagName("ThumbnailWidth")[0] != undefined) {
            this.ThumbnailWidth = pagexml.getElementsByTagName("ThumbnailWidth")[0].firstChild.nodeValue;
        }
        if (pagexml.getElementsByTagName("ThumbnailWidth")[0] != undefined) {
            this.ThumbnailHeight = pagexml.getElementsByTagName("ThumbnailHeight")[0].firstChild.nodeValue;
        }




        this.thumbcanvas = document.createElement('canvas');
        this.thumbcanvas.width = parseInt(this.ThumbnailWidth);
        this.thumbcanvas.height = parseInt(this.ThumbnailHeight);
        this.thumbctx = this.thumbcanvas.getContext('2d');

        this.thumbloaded = bAutoloadThumbnails;

        this.thumbnailobj = {
            thumbnail : document.createElement('canvas'),
            image : document.createElement('img'),
            canvasSource : document.createElement('img'),
            source : bAutoloadThumbnails ? this.ThumbnailImageSRC : null,
            name : this.PageName,
            number :pagenum,
            displaynum :  pagenum + 1,
            draw : function(ctx){
                thispage.thumbctx = ctx;
            }
        };

        this.printcanvas = document.createElement('canvas');
        this.printctx = this.printcanvas.getContext('2d');
        this.print3Dimage = document.createElement('img');

        this.printobj = {
            pagenumber : thispage.pagenumber,
            paperimage : thispage.printcanvas,
            paperwidth : 297,
            paperheight : 210,
            docwidth : 1,
            docheight : 1,
            inchtomm : 25.4,
            DPI : 300,
            scrDPI : 96,
            scaleSet : false,
            pdx : 0,
            pdy : 0,
            pscale : 1,
            printctx : thispage.printctx,
            setRes : function(dpi){
                this.DPI = dpi;
            },
            setPaperSize : function(width,height){
                this.paperwidth = width;
                this.paperheight = height;
                this.paperimage.width = (width / this.inchtomm)* this.DPI;
                this.paperimage.height = (height / this.inchtomm)* this.DPI;
            },
            setDocSize : function(width, height){
                this.docwidth = width;
                this.docheight = height;
            },
            setScale : function(){
                var xscale = this.paperimage.width / this.docwidth; //thispage.MainImageWidth;
                var yscale = this.paperimage.height / this.docheight; // thispage.MainImageHeight;

                this.pscale = Math.min(xscale, yscale);
                this.pdx = (this.paperimage.width - (this.docwidth * this.pscale)) / 2;
                this.pdy = (this.paperimage.height - (this.docheight * this.pscale)) / 2;
                this.scaleSet = true;
            },
            print : function(){
                if(!this.scaleSet){
                    return;
                }
                if(thispage.usepdfjs){
                    //thispage.renderPDFpagePrint();
                }else if (thispage.usevectorxml){
                    thispage.draw_vectorPrint();
                }else if(thispage.usevector3Dxml){
                    //get imageurl.
                    thispage.print3Dimage.addEventListener('load', thispage.load3Dimage, false);
                    thispage.print3Dimage.src = renderer.domElement.toDataURL();

                }else{
                    thispage.draw_imagePrint();
                }

            }

        };


        this.thumbnailobj.thumbnail.width = parseInt(this.ThumbnailWidth);
        this.thumbnailobj.thumbnail.height = parseInt(this.ThumbnailHeight);
        this.thumbctx = this.thumbnailobj.thumbnail.getContext('2d');


        //this.thumbnailobj.image.addEventListener('load',this.thumbload,false);
        //this.thumbnailobj.image.src = this.thumbnailobj.source;


        var bisLastPart = false;
        var nPartfilesLoaded = 0;


        this.setNotCollapsedArray = function(){

            if(thispage.DocRef.isNotCollapsed && thispage.DocRef.isNotCollapsed.length) {
                if(thispage.iscollapsed){
                    var isNotCollapsedIndex = thispage.DocRef.isNotCollapsed.indexOf(pagenum);
                    if (isNotCollapsedIndex !== -1) {
                        thispage.DocRef.isNotCollapsed.splice(isNotCollapsedIndex, 1);
                    }

                }else{
                    if(thispage.DocRef.isNotCollapsed.indexOf(thispage.pagenumber) === -1) {
                        thispage.DocRef.isNotCollapsed.push(thispage.pagenumber);
                    }

                }

            }else{
                if(!thispage.iscollapsed){
                    thispage.DocRef.isNotCollapsed = [thispage.pagenumber];
                }
            }
        };


        this.getThumbnail = function(){
          return thispage.thumbnailobj;
        };

        this.setMeasureScaledirect = function(value){

            thispage.measurescale = value;
        };

        this.getMeasureScale = function(){

            return thispage.measurescale;
        };

        this.setCalibration = function(val){

            if (val) {

                if (nCalibrateSet != 0) {
                    nCalibrateScale = nCalibrateMeasured / nCalibrateSet;
                    nCalibrateScale = 1 / nCalibrateScale;
                    //setCalibratebtn();
                    thispage.measurescale = nCalibrateScale;
                }

            } else {
                nCalibrateScale = 1;
            }


            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            return nCalibrateScale;

        };


        this.setCalibrateScale = function(scale){
            thispage.measurescale = scale;

            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);


        };
        this.setMeasureScale = function(scale){
            var numerator = 0;
            var denomintaor = 0;


            if (scale != 'Calibration') {
                var numarr = scale.split(":");
                numerator = numarr[0];
                denomintaor = numarr[1];
                if (bReverseScale) {
                    thispage.measurescale = denomintaor / numerator;
                } else {
                    thispage.measurescale = numerator / denomintaor;
                }

            } else {
                thispage.measurescale = nCalibrateScale;
            }
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);


        };
        this.rotatedRect = function(){

            var origx = this.startx;
            var origy = this.starty;
            var origw = this.endx;
            var origh = this.endy;

            var CanvRotRad = this.drotation * (Math.PI / 180);

            var cosangle = Math.cos(CanvRotRad);
            var sinangle = Math.sin(CanvRotRad);

            var centercanvX = (canvasowidth / 2);
            var centercanvY = (canvasoheight / 2);


            var hw = origx - centercanvX;
            var hh = origy - centercanvY;

            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);

            newx = centercanvX + newx;
            newy = centercanvY + newy;

            hw = origw - centercanvX;
            hh = origh - centercanvY;

            var neww = (hw * cosangle) - (hh * sinangle);
            var newh = (hw * sinangle) + (hh * cosangle);

            neww = centercanvX + neww;
            newh = centercanvY + newh;



            return {
                x:Math.min(newx,neww),
                y:Math.min(newy,newh),
                w:Math.max(neww,newx),
                h:Math.max(newh,newy)
            };

        };

        /*this.smallimageprogress = function (ev) {
            if (ev.lengthComputable) {
                //showDownloadDialog();
                if (RxCore_GUI_Download != undefined) {
                    //RxCore_GUI_Download.setDownload("show");
                }

                var percentComplete = Math.round(ev.loaded * 100 / ev.total);
                if (percentComplete == 100) {
                    //hideDownloadDialog();
                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }

                }
            } else {
                //document.getElementById('progressNumber').innerHTML = 'unable to compute';
            }

        };*/

        /*this.largeimageprogress = function (ev) {
            if (ev.lengthComputable) {
                //showDownloadDialog();
                if (RxCore_GUI_Download != undefined) {
                    //RxCore_GUI_Download.setDownload("show");
                }

                var percentComplete = Math.round(ev.loaded * 100 / ev.total);
                if (percentComplete == 100) {
                    //hideDownloadDialog();
                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }

                }

            } else {
                //document.getElementById('progressNumber').innerHTML = 'unable to compute';
            }


        };*/

        this.thumbload = function(){

            if (this.thumbnailobj.source){
                var oReq = new XMLHttpRequest();
                oReq.withCredentials = bUseCredentials;

                oReq.open("GET", this.thumbnailobj.source, true);

                oReq.responseType = "blob";
                var __this = this;
                oReq.onload = function (oEvent) {
                    var url = URL.createObjectURL(oReq.response);
                        if (url) {
                           __this.thumbnailobj.image.src = url;
                           thispage.draw_thumbnail();
                           thispage.thumbloaded = true;

                        }
                };
                oReq.send(null);

            }

          //thumbnail image loaded
            //thispage.draw_thumbnail();
            //thispage.thumbloaded = true;


        };

        this.load3Dimage = function (ev){
            thispage.printobj.printctx.drawImage(ev.currentTarget, thispage.printobj.pdx, thispage.printobj.pdy, thispage.printobj.docwidth * thispage.printobj.pscale, thispage.printobj.docheight * thispage.printobj.pscale);
            drawmarkupPrint(thispage.printobj.printctx,thispage.pagenumber,thispage.printobj.pdx,thispage.printobj.pdy,thispage.printobj.pscale);

        };

        //this.smallimage.addEventListener('load', this.smallimageload, false);

        this.smallimageloadevent = function(ev){
            var yscale = 0.0;
            var xscale = 0.0;
            var dxlocal = 0.0;
            var dylocal = 0.0;
            var dscalelocal = 0.0;
            var imagewidth = 0;
            var imageheight = 0;

            imagewidth = thispage.SmallImageWidth;
            imageheight = thispage.SmallImageHeight;

            thispage.smallimagecnv.width = imagewidth;
            thispage.smallimagecnv.height = imageheight;

            thispage.smallimagectx.drawImage(thispage.smallimage,0,0,imagewidth,imageheight);
            //console.log(canvasoheight);

            yscale = canvasoheight / thispage.SmallImageHeight;
            xscale = canvasowidth / thispage.SmallImageWidth;
            dscalelocal = Math.min(xscale, yscale);

            dxlocal = (canvasowidth - (thispage.SmallImageWidth * dscalelocal)) / 2;
            dylocal = (canvasoheight - (thispage.SmallImageHeight * dscalelocal)) / 2;

            thispage.setimagedimsmall(dxlocal, dylocal, dscalelocal);

            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("hide");
            }

        };

        this.smallimageload = function () {

            var oReq = new XMLHttpRequest();
            oReq.withCredentials = bUseCredentials;
            oReq.open("GET", thispage.SmallImageSRC, true);
            oReq.responseType = "blob";
            //var __this = this;

            oReq.onload = function (oEvent) {
                var url = oReq.response; // Note: not oReq.responseText
                if (url) {
                    thispage.smallimage.addEventListener('load', thispage.smallimageloadevent, false);
                    thispage.smallimage.src = URL.createObjectURL(url);
                }

            };

            oReq.onprogress = function(ev){
                if (ev.lengthComputable) {
                    //showDownloadDialog();
                    if (RxCore_GUI_Download != undefined) {
                        //RxCore_GUI_Download.setDownload("show");
                    }

                    var percentComplete = Math.round(ev.loaded * 100 / ev.total);
                    if (percentComplete == 100) {
                        //hideDownloadDialog();
                        if (RxCore_GUI_Download != undefined) {
                            RxCore_GUI_Download.setDownload("hide");
                        }

                    }
                } else {
                    //document.getElementById('progressNumber').innerHTML = 'unable to compute';
                }
            };


            oReq.send(null);


        };

        this.largeimageloadevent = function(ev){
            var yscale = 0.0;
            var xscale = 0.0;
            var dxlocal = 0.0;
            var dylocal = 0.0;
            var dscalelocal = 0.0;
            var imagewidth = 0;
            var imageheight = 0;

            imagewidth = thispage.MainImageWidth;
            imageheight = thispage.MainImageHeight;

            thispage.originalwidth = thispage.MainImageWidth;
            thispage.originalheight = thispage.MainImageHeight;

            thispage.largeimagecnv.width = imagewidth;
            thispage.largeimagecnv.height = imageheight;

            thispage.largeimagectx.drawImage(thispage.largeimage,0,0,imagewidth,imageheight);

            //set image fixed scale for markup
            yscale = fixedScaleSize.height / thispage.MainImageHeight; //thispage.MainImageHeight;
            xscale = fixedScaleSize.width / thispage.MainImageWidth; // thispage.MainImageWidth;
            thispage.fixedScale = Math.min(xscale, yscale);


            //console.log(canvasoheight);
            yscale = canvasoheight / thispage.MainImageHeight;
            xscale = canvasowidth / thispage.MainImageWidth;

            thispage.printobj.setDocSize(thispage.MainImageWidth,thispage.MainImageHeight);

            thispage.width = imagewidth;
            thispage.height = imageheight;

            dscalelocal = Math.min(xscale, yscale);

            dxlocal = (canvasowidth - (thispage.MainImageWidth * dscalelocal)) / 2;
            dylocal = (canvasoheight - (thispage.MainImageHeight * dscalelocal)) / 2;

            thispage.setimagedimlarge(dxlocal, dylocal, dscalelocal);

            yscale = thispage.thumbnailobj.thumbnail.height / thispage.MainImageHeight;
            xscale = thispage.thumbnailobj.thumbnail.width / thispage.MainImageWidth;
            dscalelocal = Math.min(xscale,yscale);

            dxlocal = (thispage.thumbnailobj.thumbnail.width - (thispage.MainImageWidth*dscalelocal)) / 2;
            dylocal = (thispage.thumbnailobj.thumbnail.height - (thispage.MainImageHeight*dscalelocal)) / 2;

            thispage.setthumbnail(dxlocal,dylocal,dscalelocal);

            /*
            rescale small image  to ensure we are using the same canvas size.

             */
            imagewidth = thispage.SmallImageWidth;
            imageheight = thispage.SmallImageHeight;

            thispage.smallimagecnv.width = imagewidth;
            thispage.smallimagecnv.height = imageheight;

            thispage.smallimagectx.drawImage(thispage.smallimage,0,0,imagewidth,imageheight);
            //console.log(canvasoheight);

            yscale = canvasoheight / thispage.SmallImageHeight;
            xscale = canvasowidth / thispage.SmallImageWidth;
            dscalelocal = Math.min(xscale, yscale);

            dxlocal = (canvasowidth - (thispage.SmallImageWidth * dscalelocal)) / 2;
            dylocal = (canvasoheight - (thispage.SmallImageHeight * dscalelocal)) / 2;

            thispage.setimagedimsmall(dxlocal, dylocal, dscalelocal);

            //hideDownloadDialog();
            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("hide");
            }
        };

        this.largeimageload = function () {
            var oReq = new XMLHttpRequest();
            oReq.withCredentials = bUseCredentials;
            oReq.open("GET", thispage.MainImageSRC, true);
            oReq.responseType = "blob";
            //var __this = thispage;

            oReq.onload = function (oEvent) {
                var url = oReq.response; // Note: not oReq.responseText
                if (url) {
                    thispage.largeimage.addEventListener('load', thispage.largeimageloadevent, false);
                    thispage.largeimage.src = URL.createObjectURL(url);
                }
            };

            oReq.onprogress = function (ev) {
                if (ev.lengthComputable) {
                    //showDownloadDialog();
                    /*if (RxCore_GUI_Download != undefined) {
                        //RxCore_GUI_Download.setDownload("show");
                    }*/

                    var percentComplete = Math.round(ev.loaded * 100 / ev.total);
                    if (percentComplete == 100) {
                        //hideDownloadDialog();
                        if (RxCore_GUI_Download != undefined) {
                            RxCore_GUI_Download.setDownload("hide");
                        }

                    }

                } else {
                    //document.getElementById('progressNumber').innerHTML = 'unable to compute';
                }
            };

            oReq.send(null);




        };

        this.turnLayerOnOff = function (index) {
            thispage.VectorPageObj.turnLayerOnOff(index);

            if (thispage.usedincomposite && thispage.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                thispage.compositereference.scaleToBackground(false);
            } else {
                thispage.draw_vector(false);
            }

            thispage.vectorischanged = true;

        };

        this.turnBlockAllOnOff = function(OnOff){
            thispage.VectorPageObj.turnBlockAllOnOff(OnOff);

            if (thispage.usedincomposite && thispage.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                thispage.compositereference.scaleToBackground(false);
            } else {
                thispage.draw_vector(false);
            }

            thispage.vectorischanged = true;

        };

        this.turnLayerAllOnOff = function(OnOff){

            thispage.VectorPageObj.turnLayerAllOnOff(OnOff);

            if (this.usedincomposite && this.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                this.compositereference.scaleToBackground(false);
            } else {
                this.draw_vector(false);
            }

            thispage.vectorischanged = true;

        };

        this.resetLayers = function () {
            thispage.VectorPageObj.resetLayers();

            if (thispage.usedincomposite && thispage.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                thispage.compositereference.scaleToBackground(false);
            } else {
                thispage.draw_vector(false);
            }

            thispage.vectorischanged = true;
        };


        this.getBlocks = function(){
            return thispage.VectorPageObj.getBlocks();
        };


        this.getpageRef = function(){

            return thispage.pdfpageref;

        };
        this.filterBlocks = function(szBlockLoadMask){


            thispage.VectorPageObj.filterBlocks(szBlockLoadMask);

        };

        this.turnBlockOnOff = function (index) {

            thispage.VectorPageObj.turnBlockOnOff(index);


            if (thispage.usedincomposite && thispage.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                thispage.compositereference.scaleToBackground(false);
            } else {
                thispage.draw_vector(false);
            }


            thispage.vectorischanged = true;

        };
        this.turn3DBlockOnOff = function (name) {
            for (var i = 0; i < thispage.Vector3DPageObj.scene.children.length; i++) {
                if (thispage.Vector3DPageObj.scene.children[i].name == name) {
                    if (!thispage.Vector3DPageObj.scene.children[i].visible) {
                        thispage.Vector3DPageObj.scene.children[i].visible = true;
                        this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].tempvisible = true;
                    } else {
                        thispage.Vector3DPageObj.scene.children[i].visible = false;
                        this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].tempvisible = false;
                    }
                    //thispage.Vector3DPageObj.scene.updateMatrix();
                    //Viewer3D.update();
                    if (Rxcore_GUI_3DPartInfo != undefined) {
                        Rxcore_GUI_3DPartInfo.set3DPartInfo(this.Vector3DPageObj.partlist[name]);
                    }

                    this.Vector3DPageObj.updateblocklist();
                    return;
                }
            }


            //Viewer3D.update();
        };

        this.restoreBlockStates = function(){

            thispage.VectorPageObj.restoreBlockStates();

            if (thispage.usedincomposite && thispage.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                thispage.compositereference.scaleToBackground(false);
            } else {
                thispage.draw_vector(false);
            }

            thispage.vectorischanged = true;

        };


        this.resetBlocks = function () {
            thispage.VectorPageObj.resetBlocks();


            if (thispage.usedincomposite && thispage.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                thispage.compositereference.scaleToBackground(false);
            } else {
                thispage.draw_vector(false);
            }


            thispage.vectorischanged = true;
        };

        this.reset3DParts = function () {
            var meshindex = 0;
            for (var i = 0; i < thispage.Vector3DPageObj.scene.children.length; i++) {
                if (thispage.Vector3DPageObj.scene.children[i].type == "Mesh") {

                    if (!this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].isSpace) {
                        this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].resetvisible();
                        thispage.Vector3DPageObj.scene.children[i].visible = this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].tempvisible;
                        thispage.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].selected = false;
                        if (thispage.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].meshcolors.length > 1) {
                            thispage.Vector3DPageObj.scene.children[i].material.color = new THREE.Color(this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].meshcolors[meshindex]);
                            if (meshindex < thispage.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].meshcolors.length) {
                                meshindex++;
                            }

                        } else {
                            thispage.Vector3DPageObj.scene.children[i].material.color = new THREE.Color(this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].facecolor);
                        }

                    }
                    //thispage.Vector3DPageObj.scene.children[i].visible = this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].tempvisible;
                    //thispage.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].tempvisible = thispage.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].visible;

                }

            }

            //Viewer3D.update();
            this.Vector3DPageObj.updateblocklist();

        };

        this.appendCustomBlockAttribute = function(blockid , name, value){

            if (thispage.usevectorxml) {
                thispage.VectorPageObj.appendCustomBlockAttribute(blockid , name, value);
            }

        };

        this.setBlockColor = function(blockid, Color,override){

            if (thispage.usevectorxml) {
                thispage.VectorPageObj.setBlockColor(blockid, Color,override);
                thispage.draw_vector(false);
                thispage.vectorischanged = true;
            }


        };

        this.FindBlockByAttr = function(attrname, attrvalue){

            if (thispage.usevectorxml) {
                return thispage.VectorPageObj.FindBlockByAttr(attrname, attrvalue);
            }

        };


        this.search3DAttribute = function(expr){

            return thispage.Vector3DPageObj.searchAttribute(expr);
        };


        this.set3DBlockColor = function (name, color, override){
            for (var i = 0; i < thispage.Vector3DPageObj.scene.children.length; i++) {
                if(thispage.Vector3DPageObj.scene.children[i].name === ""){
                    continue;
                }
                if (thispage.Vector3DPageObj.scene.children[i].name == name && thispage.Vector3DPageObj.scene.children[i].visible) {
                    if (override){
                        thispage.Vector3DPageObj.scene.children[i].material.color = new THREE.Color(color);
                    }else{
                        thispage.Vector3DPageObj.scene.children[i].material.color = new THREE.Color(this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].facecolor);
                    }

                }
            }
        };

        this.select3DBlock = function (name) {

            this.Vector3DPageObj.setSelectedPart(-1);
            for (var i = 0; i < thispage.Vector3DPageObj.scene.children.length; i++) {

                if(thispage.Vector3DPageObj.scene.children[i].name === ""){
                    continue;
                }
                if(thispage.Vector3DPageObj.scene.children[i].name == name && isNaN(name)){
                    this.Vector3DPageObj.restoreCameraName(name);
                    //console.log(name);
                }else{
                    if (thispage.Vector3DPageObj.scene.children[i].name == name && thispage.Vector3DPageObj.scene.children[i].visible) {

                        if (!this.Vector3DPageObj.partlist[name].selected) {
                            thispage.Vector3DPageObj.scene.children[i].material.color = new THREE.Color(0xf781f3);

                            this.Vector3DPageObj.partlist[name].selected = true;
                            this.Vector3DPageObj.setSelectedPart(name);
                            if (Rxcore_GUI_3DPartInfo != undefined) {
                                Rxcore_GUI_3DPartInfo.set3DPartInfo(this.Vector3DPageObj.partlist[name]);
                            }

                        } else {
                            this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].selected = false;
                            thispage.Vector3DPageObj.scene.children[i].material.color = new THREE.Color(this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].facecolor);
                        }

                    } else {
                        if (thispage.Vector3DPageObj.scene.children[i].type == "Mesh" && !isNaN(thispage.Vector3DPageObj.scene.children[i].name)) {
                            if (thispage.Vector3DPageObj.scene.children[i].visible && this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].selected) {
                                thispage.Vector3DPageObj.scene.children[i].material.color = new THREE.Color(this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].facecolor);

                                this.Vector3DPageObj.partlist[thispage.Vector3DPageObj.scene.children[i].name].selected = false;
                            }

                        }

                    }
                }


            }
            this.Vector3DPageObj.updateblocklist();

        };


        this.vectorbinaryload = function (ev) {
            var yscale = 0.0;
            var xscale = 0.0;
            var dxlocal = 0.0;
            var dylocal = 0.0;
            var dscalelocal = 0.0;
            var dscalelocalOne = 0.0;
            var imagewidth = 0;
            var imageheight = 0;

            if (ev.currentTarget.status == 200) {
                var arrayBuffer = ev.currentTarget.response;
                if (arrayBuffer) {
                    //var dv = new DataView(arrayBuffer);

                    thispage.VectorPageObj = new VectorPageObject(thispage, arrayBuffer, true);



                    if (thispage.VectorPageObj.height == 0 || thispage.VectorPageObj.width == 0) {
                        return;
                    }

                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }

                    thispage.originalwidth = thispage.VectorPageObj.width;
                    thispage.originalheight = thispage.VectorPageObj.height;

                    yscale = fixedScaleSize.height / thispage.VectorPageObj.height; //thispage.MainImageHeight;
                    xscale = fixedScaleSize.width / thispage.VectorPageObj.width; // thispage.MainImageWidth;
                    dscalelocalOne = Math.min(xscale, yscale);
                    thispage.fixedScale = dscalelocalOne;


                    yscale = canvasoheight / thispage.VectorPageObj.height; //thispage.MainImageHeight;
                    xscale = canvasowidth / thispage.VectorPageObj.width; // thispage.MainImageWidth;

                    dscalelocal = Math.min(xscale, yscale);

                    dxlocal = (canvasowidth - (thispage.VectorPageObj.width * dscalelocal)) / 2;
                    dylocal = (canvasoheight - (thispage.VectorPageObj.height * dscalelocal)) / 2;

                    thispage.width = thispage.VectorPageObj.width;
                    thispage.height = thispage.VectorPageObj.height;

                    thispage.setvectordim(dxlocal, dylocal, dscalelocal);
                    thispage.printobj.setDocSize(thispage.VectorPageObj.width,thispage.VectorPageObj.height);

                    yscale = thispage.thumbnailobj.thumbnail.height / thispage.VectorPageObj.height;
                    xscale = thispage.thumbnailobj.thumbnail.width / thispage.VectorPageObj.width;
                    dscalelocal = Math.min(xscale,yscale);

                    dxlocal = (thispage.thumbnailobj.thumbnail.width - (thispage.VectorPageObj.width*dscalelocal)) / 2;
                    dylocal = (thispage.thumbnailobj.thumbnail.height - (thispage.VectorPageObj.height*dscalelocal)) / 2;

                    thispage.setthumbnail(dxlocal,dylocal,dscalelocal);

                    //yscale = 1080 / thispage.VectorPageObj.height; //thispage.MainImageHeight;
                    //xscale = 1920 / thispage.VectorPageObj.width; // thispage.MainImageWidth;
                    //dscalelocalOne = Math.min(xscale, yscale);


                    /*var byteArray = new Uint8Array(arrayBuffer);
                     for (var i = 0; i < byteArray.byteLength; i++) {
                     // do something with each byte in the array
                     }*/
                }
            }
        };

        /*this.vectorload = function (ev) {
            var yscale = 0.0;
            var xscale = 0.0;
            var dxlocal = 0.0;
            var dylocal = 0.0;
            var dscalelocal = 0.0;
            var imagewidth = 0;
            var imageheight = 0;

            if (ev.currentTarget.status == 200) {

                var xmlDoc = ev.currentTarget.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    try {
                        xmlDoc = $.parseXML(this.responseText).documentElement;
                    } catch (e) {
                        alert("Error 1 - " + e);
                        console('file failed to load');
                        return;
                    }
                }

                thispage.VectorPageObj = new VectorPageObject(xmlDoc, false);

                yscale = canvasoheight / thispage.VectorPageObj.height; //thispage.MainImageHeight;
                xscale = canvasowidth / thispage.VectorPageObj.width; // thispage.MainImageWidth;

                dscalelocal = Math.min(xscale, yscale);

                dxlocal = (canvasowidth - (thispage.VectorPageObj.width * dscalelocal)) / 2;
                dylocal = (canvasoheight - (thispage.VectorPageObj.height * dscalelocal)) / 2;

                thispage.width = thispage.VectorPageObj.width;
                thispage.height = thispage.VectorPageObj.height;

                thispage.setvectordim(dxlocal, dylocal, dscalelocal);

            }

        };*/

        this.vectorbinprogress = function (ev) {
            if (ev.lengthComputable) {
                //showDownloadDialog();
                var percentComplete = Math.round(ev.loaded * 100 / ev.total);
                if (percentComplete == 100) {
                    //hideDownloadDialog();
                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }

                }

            }

        };

        this.vectorprogress = function (ev) {

            var contentSize = ev.currentTarget.getResponseHeader("Content-Length");
            if (contentSize > 10000000) {
                //console.log(contentSize);
                if ((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPad/i))) {
                    alert("This file is currently too large for your device. Check back for an update shortly ");
                    //hideDownloadDialog();
                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }

                    ev.currentTarget.abort();


                    //return;
                }

            }


            if (ev.lengthComputable) {
                //showDownloadDialog();
                var percentComplete = Math.round(ev.loaded * 100 / ev.total);
                if (percentComplete == 100) {
                    //hideDownloadDialog();
                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }

                }

            } else {
                //document.getElementById('progressNumber').innerHTML = 'unable to compute';
            }

        };
        this.vectorabort = function (ev) {
            RxCore_Closedocument();
        };

        this.vector3Dbinprogress = function (ev) {
            /*var contentSize = ev.currentTarget.getResponseHeader ("Content-Length");
             if (contentSize > 10000000){
             if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPad/i))) {
             alert("This file is currently too large for your device. Check back for an update shortly ");
             hideDownloadDialog();
             ev.currentTarget.abort();
             }

             }*/
            /*if(RxCore_GUI_Download != undefined){
             RxCore_GUI_Download.setDownload("hide");
             }*/

            renderer.domElement.style.visibility = 'visible';
            if (ev.lengthComputable) {
                //showDownloadDialog();
                var percentComplete = Math.round(ev.loaded * 100 / ev.total);

                if (percentComplete == 100) {

                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }
                    //hideDownloadDialog();
                    /*if(RxCore_GUI_Download != undefined){
                     RxCore_GUI_Download.setDownload("hide");
                     }*/

                }

            } else {
                //document.getElementById('progressNumber').innerHTML = 'unable to compute';
            }

        };

        this.vector3Dprogress = function (ev) {
            /*var contentSize = ev.currentTarget.getResponseHeader ("Content-Length");
             if (contentSize > 10000000){
             if((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPad/i))) {
             alert("This file is currently too large for your device. Check back for an update shortly ");
             hideDownloadDialog();
             ev.currentTarget.abort();
             }

             }*/

            if (ev.lengthComputable) {
                //showDownloadDialog();
                var percentComplete = Math.round(ev.loaded * 100 / ev.total);
                if (percentComplete == 100) {
                    //hideDownloadDialog();
                    if (RxCore_GUI_Download != undefined) {
                        RxCore_GUI_Download.setDownload("hide");
                    }

                }

            } else {
                //document.getElementById('progressNumber').innerHTML = 'unable to compute';
            }

        };

        this.vector3Dabort = function (ev) {
            RxCore_Closedocument();
        };



        this.vector3Dblocknavload = function (ev) {
            /*if(RxCore_GUI_Download != undefined){
             RxCore_GUI_Download.setDownload("hide");
             }*/
            if (ev.currentTarget.status == 200) {
                var xmlDoc = ev.currentTarget.responseXML;

                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    try {
                        xmlDoc = $.parseXML(this.responseText).documentElement;
                    } catch (e) {
                        alert("Error 1 - " + e);
                        return;
                    }
                }
                thispage.Vector3DPageObj.addblocks(xmlDoc);
            }
            //thispage.Vector3DPageObj.
        };

        this.vector3DBinaryload = function (ev) {
            var yscale = 0.0;
            var xscale = 0.0;
            var dxlocal = 0.0;
            var dylocal = 0.0;
            var dscalelocal = 0.0;
            var imagewidth = 0;
            var imageheight = 0;


            //hideDownloadDialog();


            if (ev.currentTarget.status == 200) {
                //console.log(contentSize);
                arrayBuffer = ev.currentTarget.response;
                if (arrayBuffer) {


                    thispage.Vector3DPageObj = new Vector3DPageObject(arrayBuffer, true,thispage);


                    thispage.walkthroughcontrol = new FirstPersonControl();

                    thispage.walkthroughcontrol.movementSpeed = 50;
                    thispage.walkthroughcontrol.lookSpeed = 0.125;
                    thispage.walkthroughcontrol.lookVertical = true;

                    thispage.printobj.setDocSize(canvasowidth,canvasoheight);

                    documentopen = true;
                    doResize(true);
                    RxCore_3DOrbit();

                    /*if (thispage.has3Dnav) {
                        thispage.load3dnavigator();
                    }*/
                }


            }

        };

        this.vectorpart3Dload = function (ev) {
            if (ev.currentTarget.status == 200) {
                var xmlDoc = ev.currentTarget.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    try {
                        xmlDoc = $.parseXML(this.responseText).documentElement;
                    } catch (e) {
                        alert("Error 1 - " + e);
                        return;
                    }
                }
                nPartfilesLoaded++;
                if (nPartfilesLoaded == thispage.VectorPartfilelist.length) {
                    bisLastPart = true;

                }

                //thispage.Vector3DPageObj.addpart(xmlDoc, bisLastPart);
                //renderer.render(thispage.Vector3DPageObj.scene, camera,false);
                //alert('new page loaded');

            }
        };

        this.vector3Dpartprogress = function (ev) {


        };

        this.load3dvectorPart = function () {
            //console.log(thispage.VectorPartfilelist.length);
            for (var i = 0; i < thispage.VectorPartfilelist.length; i++) {

                var xhr = new XMLHttpRequest();
                xhr.withCredentials = bUseCredentials;
                try {
                    //alert(thispage.VectorPartfilelist[i]);
                    xhr.open('GET', thispage.VectorPartfilelist[i], true);


                } catch (e) {
                    alert("Error 1 - " + e);
                }
                try {
                    xhr.responseType = '';
                } catch (e) {
                    //alert("Error 2 - " + e);
                }

                //console.log(i);
                xhr.addEventListener('load', thispage.vectorpart3Dload, false);
                xhr.addEventListener('progress', thispage.vector3Dpartprogress, false);
                xhr.send();

            }
            //bAnimateready = true;
        };
        this.load3dnavigator = function () {
            /*if(RxCore_GUI_Download != undefined){
             RxCore_GUI_Download.setDownload("show");
             }*/
            var xhr = new XMLHttpRequest();
            xhr.withCredentials = bUseCredentials;
            try {
                xhr.open('GET', this.Navigator3DSRC, true);
            } catch (e) {
                alert("Error 1 - " + e);
            }
            try {
                xhr.responseType = '';
            } catch (e) {
                //alert("Error 2 - " + e);
            }

            xhr.addEventListener('load', this.vector3Dblocknavload, false);
            xhr.addEventListener('progress', this.vector3Dprogress, false);
            xhr.addEventListener("abort", this.vector3Dabort, false);
            xhr.send();
        };

        this.loadvectors3DBinary = function () {
            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("show");
            }


            var xhr = new XMLHttpRequest();
            xhr.withCredentials = bUseCredentials;
            try {
                xhr.open('GET', this.Vector3DBinarySRC, true);
            } catch (e) {
                alert("Error 1 - " + e);
            }
            try {
                xhr.responseType = "arraybuffer";
            } catch (e) {
                //alert("Error 2 - " + e);
            }
            xhr.addEventListener('loadend', this.vector3DBinaryload, false);
            xhr.addEventListener('progress', this.vector3Dbinprogress, false);
            xhr.addEventListener("abort", this.vector3Dabort, false);
            xhr.send();
        };

        this.loadvectors3D = function () {
            //showDownloadDialog();
            /*if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("show");
            }*/


            var xhr = new XMLHttpRequest();
            xhr.withCredentials = bUseCredentials;
            try {
                xhr.open('GET', this.Vector3DSRC, true);
            } catch (e) {
                alert("Error 1 - " + e);
            }
            try {
                xhr.responseType = '';
            } catch (e) {
                //alert("Error 2 - " + e);
            }
            xhr.addEventListener('load', this.vector3Dload, false);
            xhr.addEventListener('progress', this.vector3Dprogress, false);
            xhr.addEventListener("abort", this.vector3Dabort, false);
            xhr.send();

        };

        this.loadbinvectors = function () {

            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("show");
            }


            var xhr = new XMLHttpRequest();
            xhr.withCredentials = bUseCredentials;
            try {
                xhr.open('GET', this.Vector2DBinarySRC, true);
            } catch (e) {
                alert("Error 1 - " + e);
                console.log('binary loading failed');
            }
            try {
                xhr.responseType = "arraybuffer";
                //xhr.responseType = '';
            } catch (e) {
                //alert("Error 2 - " + e);
            }

            xhr.addEventListener('load', this.vectorbinaryload, false);
            xhr.addEventListener('progress', this.vectorbinprogress, false);
            xhr.addEventListener("abort", this.vectorabort, false);
            xhr.send();


        };
        this.loadvectors = function () {
            //showDownloadDialog();


            var xhr = new XMLHttpRequest();
            xhr.withCredentials = bUseCredentials;
            try {
                xhr.open('GET', this.Vector2DSRC, true);
            } catch (e) {
                alert("Error 1 - " + e);
                console.log('xml loading failed');
            }
            try {
                xhr.responseType = '';
            } catch (e) {
                //alert("Error 2 - " + e);
            }


            xhr.addEventListener('load', this.vectorload, false);
            xhr.addEventListener('progress', this.vectorprogress, false);
            xhr.addEventListener("abort", this.vectorabort, false);
            xhr.send();
        };

        this.backupScaleAndOffset = function(){
            if (thispage.usevectorxml) {
                thispage.dscalebackup =  thispage.dscalevector;
                thispage.dxbackup = thispage.dxvector;
                thispage.dybackup = thispage.dyvector;

            } else if (thispage.usepdfjs) {
                thispage.dscalebackup =  thispage.dscalepdf;
                this.curpagescalebackup = thispage.curpagescale;
                thispage.dxbackup = thispage.dxpdf;
                thispage.dybackup = thispage.dypdf;

            } else {
                thispage.dscalebackup = thispage.dscale;
                thispage.dxbackup = thispage.dx;
                thispage.dybackup = thispage.dy;

            }

        };

        this.restoreScaleAndOffset = function(){
            if (thispage.usevectorxml) {
                thispage.dscalevector = thispage.dscalebackup;
                thispage.dxvector = thispage.dxbackup;
                thispage.dyvector = thispage.dybackup;

            } else if (thispage.usepdfjs) {
                thispage.dscalepdf = thispage.dscalebackup;
                thispage.curpagescale = thispage.curpagescalebackup;
                thispage.dxpdf = thispage.dxbackup;
                thispage.dypdf = thispage.dybackup;

            } else {
                thispage.dscalebackup = thispage.dscale = thispage.dscalebackup;
                thispage.dx = thispage.dxbackup;
                thispage.dy = thispage.dybackup;

            }

        };

        this.setPDFDiminit = function(dx,dy,dscale){
            this.pageloaded = false;
            this.dxpdf = dx;
            this.dypdf = dy;

            this.dscalepdf = dscale;
            //this.initialscale = dscale;
            //this.vectorloaded = true;

            this.startx = this.dxpdf;
            this.starty = this.dypdf;
            //dxlocal = (canvasowidth - (thispage.VectorPageObj.width*dscalelocal)) / 2;
            //dylocal = (canvasoheight - (thispage.VectorPageObj.height*dscalelocal)) / 2;

            this.endx = (thispage.offscreenwidth * this.dscalepdf) + this.startx;
            this.endy = (thispage.offscreenheight * this.dscalepdf) + this.starty;

            this.pdfdiminitset = true;

            if (firstpage) {

                if (doCompare) {
                    comparecheck(thispage.DocRef.FileName);
                } else {
                    DeactivateAll();
                    thispage.DocRef.SetActive();
                }

            }

            //var numpages = thispage.Docref.pages.length - 1;
            if (thispage.pagenumber == thispage.DocRef.pages.length - 1){
                //add new get all pagedim callback here.
                if (Rxcore_GUI_pagedimLoadComplete != undefined){
                    Rxcore_GUI_pagedimLoadComplete.loadComplete(thispage.DocRef.FileName, thispage.DocRef.bActive);
                }

            }


        };

        this.setPFDdimnodraw = function(dx,dy,dscale,bSetscale){
            //this.pageloaded = true;
            this.dxpdf = dx;
            this.dypdf = dy;

            if (bSetscale){
                this.dscalepdf = dscale;
            }

            //this.initialscale = dscale;
            //this.vectorloaded = true;

            this.startx = this.dxpdf;
            this.starty = this.dypdf;
            //dxlocal = (canvasowidth - (thispage.VectorPageObj.width*dscalelocal)) / 2;
            //dylocal = (canvasoheight - (thispage.VectorPageObj.height*dscalelocal)) / 2;


            this.endx = (thispage.offscreenwidth * this.dscalepdf) + this.startx;
            this.endy = (thispage.offscreenheight * this.dscalepdf) + this.starty;

            /*if (firstpage){
                thispage.DocRef.setDocumentPageScale(thispage.offscreenwidth, thispage.offscreenheight, thispage.dscalepdf);

            }*/


        };

        this.setPDFdim = function (dx, dy, dscale) {

            thispage.pageloaded = true;
            if(!thispage.pdfdiminitset){
                thispage.dxpdf = dx;
                thispage.dypdf = dy;


                //this.initialscale = dscale;
                //this.vectorloaded = true;

                thispage.startx = thispage.dxpdf;
                thispage.starty = thispage.dypdf;
                //dxlocal = (canvasowidth - (thispage.VectorPageObj.width*dscalelocal)) / 2;
                //dylocal = (canvasoheight - (thispage.VectorPageObj.height*dscalelocal)) / 2;


                thispage.endx = (thispage.offscreenwidth * thispage.dscalepdf) + thispage.startx;
                thispage.endy = (thispage.offscreenheight * thispage.dscalepdf) + thispage.starty;
                thispage.pdfdiminitset = true;

            }

            thispage.dscalepdf = 1;
            //console.log('if I get here somthing is wrong');


            if (firstpage && !thispage.DocRef.markuploaded) {


                if (bUsemarkupbyref) {

                    //getMarkupbyReference(path);
                    getMarkupbyReference(path, thispage.DocRef);
                } else if(bUsemarkupbyrefEx) {
                    getMarkupxmlurl(thispage.DocRef);
                    //getMarkupFilelist(path);

                }else{
                    getMarkupFilelist(path, thispage.DocRef);
                }



            }

            if (firstpage && !thispage.pdfdiminitset) {

                if (doCompare) {
                    comparecheck(thispage.DocRef.FileName);
                } else {
                    DeactivateAll();
                    thispage.DocRef.SetActive();
                }

            }

            if (firstpage){
                //thispage.DocRef.setDocumentPageScale(thispage.offscreenwidth, thispage.offscreenheight, thispage.dscalepdf);



                thispage.visible = true;
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }
                RxCore_default();

                if (Rxcore_GUI_fileLoadComplete != undefined) {
                    //Rxcore_GUI_fileLoadComplete.loadComplete(thispage.DocRef.OriginalURL);
                    Rxcore_GUI_fileLoadComplete.loadComplete(thispage.DocRef.OriginalURL, thispage.DocRef.bActive);
                }

                thispage.draw_canvas(true);
            }

            if (Rxcore_GUI_pageLoadComplete != undefined) {
                Rxcore_GUI_pageLoadComplete.loadComplete(thispage.pagenumber);
                thispage.DocRef.loadPageEvt(thispage.pagenumber);

            }

            if (RxCore_GUI_VectorBlocksLoaded != undefined) {
                RxCore_GUI_VectorBlocksLoaded.setVectorBlocks([]);
            }


            thispage.backupScaleAndOffset();
            //usepdfjs
            //hideDownloadDialog();



        };


        this.istextvisible = function(x,y){
            var isvisble = false;

            var left = Math.max(0, x);
            var right = Math.min(canvasowidth, x);
            var bottom = Math.max(canvasoheight, y);
            var top = Math.min(0, y);

            if(x > 0 && x < canvasowidth){
                if (y > 0 && y < canvasoheight){
                    isvisble = true;
                }
            }
            /*if(left <= right && bottom > top){

            }*/

            return isvisble;

        };
        this.ispagevisible = function () {
            var isvisble = false;

            if (thispage.usepdfjs) {
                var left = Math.max(0, thispage.dxpdf);
                var right = Math.min(canvasowidth, thispage.endx);
                var bottom = Math.max(canvasoheight, thispage.endy);
                var top = Math.min(0, thispage.dypdf);

                if(left < right && bottom > top){
                    isvisble = true;
                }
            }
            return isvisble;
        };

        this.changeinterval = function(newinterval){

            clearInterval(thispage.vectortimervar);
            thispage.vectorpagetime = newinterval;

            thispage.vectortimervar = setInterval(function () {
                thispage.vectortimer();
            }, thispage.vectorpagetime);

        };

        this.vectortimer = function () {
            if (thispage.DocRef != null && thispage.DocRef.bActive) {
                //console.log(thispage.pagenumber);
                //console.log(DocObj.currentpage);
                if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {
                    if (thispage.usedincomposite && thispage.compositereference != undefined) {
                        if(thispage.compositereference.printing && thispage.compositePrintreference != undefined){
                            if(thispage.compositereference.bisdvector){
                                var vectorscale = thispage.VectorPageObj.offscreenscale(thispage.compositePrintreference.overlayCScale);
                            }else if (thispage.compositereference.oisvector){
                                vectorscale = thispage.VectorPageObj.offscreenscale(thispage.compositePrintreference.overlayScale);
                            }else{
                                vectorscale = thispage.VectorPageObj.offscreenscale(thispage.dscalevector);
                            }

                        }else{
                            if(thispage.compositereference.bisdvector){
                                vectorscale = thispage.VectorPageObj.offscreenscale(thispage.compositereference.overlayCScale);
                            }else if (thispage.compositereference.oisvector){
                                vectorscale = thispage.VectorPageObj.offscreenscale(thispage.compositereference.overlayScale);
                            }else{
                                vectorscale = thispage.VectorPageObj.offscreenscale(thispage.dscalevector);
                            }

                        }

                    }else{
                        vectorscale = thispage.VectorPageObj.offscreenscale(thispage.dscalevector);
                    }

                    //var vectorscale = thispage.VectorPageObj.offscreenscale(thispage.dscalevector);

                    //console.log(vectorscale);
                    if (vectorscale < 0.95 || vectorscale > 1.05 || thispage.vectorischanged) {

                        //if( vectorscale != 1 || thispage.vectorischanged ){

                        if (thispage.usedincomposite && thispage.compositereference != undefined) {
                            if(thispage.compositereference.printing && thispage.compositePrintreference != undefined){
                                thispage.compositePrintreference.scaleToBackground(true);
                            }else{
                                thispage.compositereference.scaleToBackground(true);
                            }

                            //this.compositereference.draw_compare(true);
                        } else {
                            thispage.cleartextdivs();
                            thispage.draw_vector(true);
                            thispage.settextdivs();

                        }
                        thispage.vectorischanged = false;
                    }
                    //comparedrawcheck();
                }

            }
        };

        this.pdftimer = function () {
            if (thispage.DocRef != null){
                if (thispage.DocRef.bActive){
                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {
                        //console.log(thispage.dscalepdf);
                        //thispage.dscalepdf != 1 &&
                        if (!thispage.pdfisrendered) {
                            if(thispage.compositePrintreference != undefined){
                                if(thispage.compositereference.printing){
                                    thispage.compositePrintreference.renderPDFscale();
                                }
                            }else if(thispage.usedincomposite && thispage.compositereference != undefined){
                                thispage.compositereference.renderPDFscale();
                            }else{
                                if(!thispage.pageRendering){
                                    thispage.DocRef.draw_mpagepdf();
                                    thispage.DocRef.renderPDFscale();
                                }

                            }

                        }
                    }

                }else{
                    if(thispage.usedincomposite && thispage.compositereference != undefined ){
                        if(thispage.compositereference.bispdf){
                            if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {
                                if (!thispage.pdfisrendered) {
                                    if(thispage.compositereference.printing && thispage.compositePrintreference != undefined){
                                        thispage.compositePrintreference.renderPDFscale();
                                    }else{
                                        thispage.compositereference.renderPDFscale();
                                    }

                                }
                            }
                        }
                    }
                }

            }


        };
        /*this.pdftimer = function () {
            if (thispage.DocRef != null && thispage.DocRef.bActive) {
                if (thispage.pagenumber == thispage.DocRef.currentpage) {
                    //console.log(thispage.dscalepdf);
                    if (thispage.dscalepdf != 1 || !thispage.pdfisrendered) {
                        thispage.DocRef.renderPDFscale();
                    }
                }

            }
        };*/

        this.queRenderCompareScale = function (num){
            if (thispage.pageRendering) {
                thispage.pageNumPending = thispage.pagenumber + 1;
                //setTimeout(function(){thispage.pageRendering = false},3000);
                //console.log(thispage.pageNumPending);
            } else {
                thispage.renderPDFComparescale(num);
            }

        };

        this.queRenderPageScaled = function () {
            if (thispage.pageRendering) {
                thispage.pageNumPending = thispage.pagenumber + 1;
                //setTimeout(function(){thispage.pageRendering = false},3000);

            } else {

                thispage.renderPDFpagescale(true);
            }

        };

        this.setpagesize = function(w,h){

            //thispage.pagecanvas.width = w;
            //thispage.pagecanvas.height = h;

            thispage.pagedrawCanvas.width = w;
            thispage.pagedrawCanvas.height = h;

            thispage.offscreenwidth = w;
            thispage.offscreenheight = h;
            //console.log(thispage.pagenumber);
            //console.log(thispage.offscreenwidth);


        };

        this.collapsepage = function(){
            //thispage.pdfisfirstrendered = false;
            //thispage.pdfisrendered = false;

            if(thispage.iscollapsed){
                return;
            }
            thispage.iscollapsed = true;
            thispage.setNotCollapsedArray();

            thispage.pagectx.clearRect(0,0,thispage.offscreenwidth,thispage.offscreenheight);
            thispage.pagedrawctx.clearRect(0,0,thispage.offscreenwidth,thispage.offscreenheight);
            //console.log(thispage.pagenumber);
            //thispage.offscreenwidth = thispage.pagecanvas.width;
            //thispage.offscreenheight = thispage.pagecanvas.height;

            //canvas.width = canvas.width;
            thispage.pagecanvas.width = thispage.pagecanvas.width;
            thispage.pagecanvas.width = 1;
            thispage.pagecanvas.height = 1;
            thispage.pagedrawCanvas.width = thispage.pagedrawCanvas.width;
            thispage.pagedrawCanvas.width = 1;
            thispage.pagedrawCanvas.height = 1;
            thispage.PDFPointArray = [];
            thispage.bpointlistSet = false;

        };

        this.queueGetPageDim = function(num){
            thispage.getPDFdimensions(num);
            //console.log(num);
        };

        this.queueRenderPage = function (num) {
            if (!thispage.DocRef.bActive){
                return;
            }
            if (thispage.pageRendering) {
                thispage.pageNumPending = num;
            } else {
                thispage.renderPDFpage(num);
            }
        };

        this.renderPDFComparescale = function(num){

            if(thispage.pdfrenderopque > 1){
                thispage.pdfrenderopque -= 1;
                //console.log('render aborted',thispage.pdfrenderopque);
                return;
            }

            this.pageRendering = true;


            /*if (thispage.bMaxzoom && dscale == 1) {
             this.pageRendering = false;
             return;
             }*/

            thispage.DocRef.pdfDoc.getPage(thispage.pagenumber + 1).then(function (page) {

                if(page.view[3] != 0){
                    var pagewidth = Math.abs(page.view[2] - page.view[0]);
                    var pageheight = Math.abs(page.view[3] - page.view[1]);
                    var pagetemp = Math.abs(page.view[2] - page.view[0]);
                }else{
                    pagewidth = Math.abs(page.view[2] - page.view[0]);
                    pageheight = Math.abs(page.view[3] - page.view[1]);
                    pagetemp = Math.abs(page.view[2]- page.view[0]);

                }

                switch (page._pageInfo.rotate) {
                    case 0:
                        break;
                    case 90:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                    case 180:
                        break;
                    case 270:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                }


                thispage.pdfpagewidth = pagewidth;
                thispage.pdfpageheight = pageheight;

                if(thispage.compositereference == undefined){
                    console.log('overlay/compare reference not set');
                    return;
                }

                if(thispage.compositereference.printing && thispage.compositePrintreference != undefined){
                    switch(num){
                        case 1:
                            var dscale = thispage.compositePrintreference.overlayScale;
                            var wscale = (thispage.compositePrintreference.ovpagecanvas.width * dscale) / pagewidth;
                            var hscale = (thispage.compositePrintreference.ovpagecanvas.height * dscale) / pageheight;

                            break;
                        case 0:
                            dscale = thispage.compositePrintreference.backgroundScale;
                            wscale = (thispage.compositePrintreference.bgpagecanvas.width * dscale) / pagewidth;
                            hscale = (thispage.compositePrintreference.bgpagecanvas.height * dscale) / pageheight;

                            break;
                    }
                }else{
                    switch(num){
                        case 1:
                            dscale = thispage.compositereference.overlayScale;
                            wscale = (thispage.compositereference.ovpagecanvas.width * dscale) / pagewidth;
                            hscale = (thispage.compositereference.ovpagecanvas.height * dscale) / pageheight;

                            break;
                        case 0:
                            dscale = thispage.compositereference.backgroundScale;
                            wscale = (thispage.compositereference.bgpagecanvas.width * dscale) / pagewidth;
                            hscale = (thispage.compositereference.bgpagecanvas.height * dscale) / pageheight;

                            break;
                    }
                }

                var scale = Math.min(wscale, hscale);

                if (scale > thispage.nPDFMaxFactor ){
                    var restscale = scale / thispage.nPDFMaxFactor;
                    scale = thispage.nPDFMaxFactor;
                    thispage.bMaxzoom = true;
                }else{
                    restscale = 1;
                    thispage.bMaxzoom = false;
                }

                if(thispage.usedincomposite && thispage.compositereference != undefined){
                    //var viewport = page.getViewport(thispage.compositereference.overlayCScale);
                    var viewport = page.getViewport(scale);
                }

                if (isNaN(viewport.height) || isNaN(viewport.width)){
                    thispage.pageRendering = false;
                    return;
                }else{
                    if(thispage.compositereference.printing && thispage.compositePrintreference != undefined){
                        switch(num){
                            case 1:
                                thispage.compositePrintreference.ovpagecanvas.height = viewport.height;
                                thispage.compositePrintreference.ovpagecanvas.width = viewport.width;


                                break;
                            case 0:
                                thispage.compositePrintreference.bgpagecanvas.height = viewport.height;
                                thispage.compositePrintreference.bgpagecanvas.width = viewport.width;


                                break;
                        }

                    }else{
                        switch(num){
                            case 1:
                                thispage.compositereference.ovpagecanvas.height = viewport.height;
                                thispage.compositereference.ovpagecanvas.width = viewport.width;


                                break;
                            case 0:
                                thispage.compositereference.bgpagecanvas.height = viewport.height;
                                thispage.compositereference.bgpagecanvas.width = viewport.width;
                                //console.log(thispage.compositereference.bgpagecanvas.width);


                                break;
                        }

                    }

                }

                thispage.dscalepdf = restscale;
                //thispage.markupscaleadjust = scale / thispage.pagescale;
                if(thispage.compositereference.printing && thispage.compositePrintreference != undefined){
                    switch(num){
                        case 1:
                            thispage.compositePrintreference.overlayScale = restscale;
                            thispage.curpagescale = thispage.compositePrintreference.ovpagecanvas.width / thispage.pdfpagewidth;
                            thispage.curpagescale = thispage.compositePrintreference.ovpagecanvas.height / thispage.pdfpageheight;

                            var renderContext = {
                                canvasContext:thispage.compositePrintreference.ovpagectx,
                                viewport:viewport
                            };

                            break;
                        case 0:
                            thispage.compositePrintreference.backgroundScale = restscale;
                            thispage.compositePrintreference.overlayCScale = restscale;
                            thispage.curpagescale = thispage.compositePrintreference.bgpagecanvas.width / thispage.pdfpagewidth;
                            thispage.curpagescale = thispage.compositePrintreference.bgpagecanvas.height / thispage.pdfpageheight;

                            renderContext = {
                                canvasContext:thispage.compositePrintreference.bgpagectx,
                                viewport:viewport
                            };

                            break;
                    }
                }else{
                    switch(num){
                        case 1:
                            thispage.compositereference.overlayScale = restscale;
                            thispage.curpagescale = thispage.compositereference.ovpagecanvas.width / thispage.pdfpagewidth;
                            thispage.curpagescale = thispage.compositereference.ovpagecanvas.height / thispage.pdfpageheight;

                            renderContext = {
                                canvasContext:thispage.compositereference.ovpagectx,
                                viewport:viewport
                            };

                            break;
                        case 0:
                            thispage.compositereference.backgroundScale = restscale;
                            thispage.compositereference.overlayCScale = restscale;
                            thispage.curpagescale = thispage.compositereference.bgpagecanvas.width / thispage.pdfpagewidth;
                            thispage.curpagescale = thispage.compositereference.bgpagecanvas.height / thispage.pdfpageheight;

                            renderContext = {
                                canvasContext:thispage.compositereference.bgpagectx,
                                viewport:viewport
                            };

                            break;
                    }
                }




                var renderTask = page.render(renderContext);
                bPDFtemprender = true;

                renderTask.promise.then(function () {
                    thispage.pageRendering = false;
                    bPDFtemprender = false;
                    /*if (thispage.pageNumPending !== null) {
                        // New page rendering is pending
                        thispage.renderPDFComparescale(true);
                        thispage.pageNumPending = null;
                    }*/

                    thispage.pdfrenderopque -= 1;
                    if(thispage.pdfrenderopque <= 0){
                        thispage.pdfrenderopque = 0;
                        thispage.pdfisrendered = true;
                    }


                    if(thispage.compositereference.printing && thispage.compositePrintreference != undefined){
                        thispage.compositePrintreference.invertpdf();
                    }else if(thispage.usedincomposite && thispage.compositereference != undefined){

                        thispage.compositereference.invertpdf();

                        //thispage.compositereference.draw_compare(false);
                    }else{
                        thispage.DocRef.draw_mpagepdf();

                    }


                });

            });
        };

        this.renderPDFpagescale = function (draw) {
            /*if(!thispage.pdfisfirstrendered){
                console.log('not rendered');
                return;
            }*/

            if(thispage.pdfrenderopque > 1){
                thispage.pdfrenderopque -= 1;
                //console.log('render aborted',thispage.pdfrenderopque);
                return;
            }

            /*thispage.pdfrenderopque -= 1;
            console.log(thispage.pdfrenderopque);
            if(thispage.pdfrenderopque <= 0){
                thispage.pdfrenderopque = 0;
                thispage.pdfisrendered = true;
            }*/


            thispage.pdfstartrender = new Date().getTime();
            var renderstart = thispage.pdfstartrender;

            this.pageRendering = true;
            // Using promise to fetch the page
            /*if (thispage.bMaxzoom && thispage.dscalepdf == 1) {
                this.pageRendering = false;
                return;
            }*/


            thispage.DocRef.pdfDoc.getPage(thispage.pagenumber + 1).then(function (page) {

                page.cleanupAfterRender = true;

                if (bAbortPageload){
                    return;
                }




                //var TextLayerBuilder = pdfjsLib.pdfjsWebTextLayerBuilder.TextLayerBuilder;

                //var TextLayerBuilder = _text_layer_builder.TextLayerBuilder;
                //var viewport = page.getViewport(scale);
                //canvas.height = viewport.height;
                //canvas.width = viewport.width;

                //PDFJS page scaling not to be confused with scaling of canvas image.
                //this.pagescale = thispage.pagescale;

                //page.view[0] = -dxlocal/scale;
                //page.view[1] = -dylocal/scale;
                if(page.view[3] != 0){
                    var pagewidth = Math.abs(page.view[2] - page.view[0]);
                    var pageheight = Math.abs(page.view[3] - page.view[1]);
                    var pagetemp = Math.abs(page.view[2] - page.view[0]);
                }else{
                    pagewidth = Math.abs(page.view[2] - page.view[0]);
                    pageheight = Math.abs(page.view[3] - page.view[1]);
                    pagetemp = Math.abs(page.view[2]- page.view[0]);

                }


                switch (page._pageInfo.rotate) {
                    case 0:
                        break;
                    case 90:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                    case 180:
                        break;
                    case 270:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                }

                thispage.pdfpagewidth = pagewidth;
                thispage.pdfpageheight = pageheight;

                var centerdocx =  thispage.pdfpagewidth * 0.5;
                var centerdocy =  thispage.pdfpageheight  * 0.5;
                //var anglerad = (360 - thispage.PDFpageRotate) * (Math.PI / 180);


                page.setPointlistCallback(function(x,y){
                    if(thispage.PDFsnapTransform != null){

                        x += thispage.PDFsnapTransform.e;
                        y += thispage.PDFsnapTransform.f;

                        switch (page._pageInfo.rotate) {
                            case 0:

                                //thispage.PDFPointArray.push({x:x,y:y});
                                break;
                            case 90:
                                var tempx = x;
                                x = y;
                                y = -tempx;

                                //thispage.PDFPointArray.push({x:x,y:y});
                                //localx = y;
                                //localy = -x;

                                break;
                            case 180:
                                x = -x;
                                y = -y;

                                //thispage.PDFPointArray.push({x:x,y:y});
                                //localx = -x;
                                //localy = -y;

                                break;
                            case 270:
                                var tempx = x;
                                x = -y;
                                y = tempx;

                                //var anglerad = (180) * (Math.PI / 180);
                                //var rotsnap = getRotPoint(centerdocx, centerdocy, x, y,  anglerad);
                                //localx = -y;
                                //localy = x;
                                //thispage.PDFPointArray.push({x:rotsnap.x,y:rotsnap.y});

                                break;
                        }

                        x *= thispage.PDFsnapTransform.a;
                        y *= thispage.PDFsnapTransform.d;

                        thispage.PDFPointArray.push({x:x,y:y});

                    }

                    //thispage.PDFPointArray.push({x:x,y:y});
                    /*if (page._pageInfo.rotate == 0){
                        thispage.PDFPointArray.push({x:x,y:y});
                    }else{
                        var rotsnap = getRotPoint(centerdocx, centerdocy, x, y,  anglerad);
                        thispage.PDFPointArray.push({x:rotsnap.x,y:rotsnap.y});
                    }*/
                });

                page.setTransformCallback(function(transobject){
                   if(thispage.PDFinternalScale = 1){
                        thispage.PDFinternalScale = {x:transobject.a, y:transobject.d};
                   }
                   thispage.PDFsnapTransform = transobject;

                });

                if(thispage.iscollapsed){
                    //console.log('renderPDFpagescale');
                    thispage.setpagesize(thispage.offscreenwidth,thispage.offscreenheight);
                }

                //var wscale = (thispage.pagecanvas.width * thispage.dscalepdf) / pagewidth;
                //var hscale = (thispage.pagecanvas.height * thispage.dscalepdf) / pageheight;

                var wscale = (thispage.offscreenwidth * thispage.dscalepdf) / pagewidth;
                var hscale = (thispage.offscreenheight * thispage.dscalepdf) / pageheight;


                var scale = Math.min(wscale, hscale);
                thispage.pdfSnapScale = scale;

                var txtviewport = page.getViewport(scale);
                if (scale > thispage.nPDFMaxFactor ){
                    var restscale = scale / thispage.nPDFMaxFactor;
                    scale = thispage.nPDFMaxFactor;
                    thispage.bMaxzoom = true;
                }else{
                    restscale = 1;
                    thispage.bMaxzoom = false;
                }

                //thispage.pagecanvas.height *= this.dscalepdf;
                //thispage.pagecanvas.width *= this.dscalepdf;
                //var tempscale = 1 / thispage.pagescale;

                //tempscale *= thispage.dscalepdf;
                //thispage.pagescale *= thispage.dscalepdf;


                var viewport = page.getViewport(scale);

                thispage.setpagesize(viewport.width,viewport.height);

                //thispage.pagecanvas.height = viewport.height;
                //thispage.pagecanvas.width = viewport.width;
                thispage.dscalepdf = restscale;
                thispage.markupscaleadjust = scale / thispage.pagescale;
                //thispage.pdfSnapScale = scale;

                //thispage.markupscaleadjust = scale / thispage.pagescale;
                /*if ((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPad/i))) {
                    if (viewport.height * viewport.width < 5000000) {
                        thispage.pagecanvas.height = viewport.height;
                        thispage.pagecanvas.width = viewport.width;
                        thispage.dscalepdf = 1;
                        thispage.markupscaleadjust = scale / thispage.pagescale;
                    } else {
                        thispage.pageRendering = false;
                        //thispage.dscalepdf = scale;
                        return;

                    }

                } else {
                    thispage.pagecanvas.height = viewport.height;
                    thispage.pagecanvas.width = viewport.width;
                    thispage.dscalepdf = 1;
                    thispage.markupscaleadjust = scale / thispage.pagescale;
                }*/


                if (thispage.offscreenwidth <= canvasowidth && !thispage.DocRef.pagelocked) {
                    thispage.dxpdf = (canvasowidth - viewport.width) / 2;
                }
                thispage.curpagescale = thispage.offscreenwidth / thispage.pdfpagewidth;
                //thispage.curpagescale = thispage.offscreenheight / thispage.pdfpageheight;


                /*thispage.curthumbscale = 160 / thispage.pdfpagewidth;

                 thispage.thumbcanvas.width = 160;
                 thispage.thumbcanvas.height = thispage.pdfpageheight * thispage.curthumbscale;*/


                //var wscale = thispage.pagecanvas.width / viewport.width;
                //var hscale = thispage.pagecanvas.height / viewport.height;
                //thispage.pdfdscaletemp = Math.min(wscale,hscale);

                //thispage.pdfdxtemp = (canvasowidth - (viewport.width*thispage.pdfdscaletemp)) / 2;
                //thispage.pdfdytemp = (canvasoheight - (viewport.height*thispage.pdfdscaletemp)) / 2;


                //canvasoheight = viewport.height;
                //canvasowidth = viewport.width;

                // Render PDF page into canvas context
                //this.pagecanvas = document.createElement('canvas');
                //this.pagectx = this.pagecanvas.getContext('2d');

                //thispage.pagectx.clearRect(0, 0, thispage.pagecanvas.width, thispage.pagecanvas.height);
                //thispage.pagectx.fillStyle = 'white';
                //thispage.pagectx.fillRect(0, 0, thispage.pagecanvas.width, thispage.pagecanvas.height);


                //var getPoints = page.getPointsList();



                /*getPoints(function(points){
                    console.log(points);
                });*/

                /*getPoints.promise.then(function(points){
                    console.log(points);
                });*/


                var renderContext = {
                    canvasContext:thispage.pagedrawctx,
                    //canvasContext:thispage.pagectx,
                    viewport:viewport
                };


                var renderTask = page.render(renderContext);
                bPDFtemprender = true;

                // Wait for rendering to finish
                renderTask.promise.then(function () {
                    thispage.pageRendering = false;
                    bPDFtemprender = false;
                    if (thispage.pageNumPending !== null) {
                        // New page rendering is pending
                        thispage.renderPDFpagescale(true);
                        thispage.pageNumPending = null;
                    }
                    thispage.pdfrenderopque -= 1;
                    //console.log(thispage.pdfrenderopque);
                    if(thispage.pdfrenderopque <= 0){
                        thispage.pdfrenderopque = 0;
                        thispage.pdfisrendered = true;
                    }

                    thispage.pagecanvas.width = thispage.pagedrawCanvas.width;
                    thispage.pagecanvas.height = thispage.pagedrawCanvas.height;

                    thispage.pagectx.drawImage(thispage.pagedrawCanvas, 0,0);

                    thispage.pagedrawCanvas.width = 1;
                    thispage.pagedrawCanvas.height = 1;

                    if(thispage.PDFPointArray.length != 0){
                        thispage.bpointlistSet = true;
                        //thispage.PDFPointArray = page.pointArray;
                        //thispage.PDFPointArray = page.pointArray.slice();
                        //thispage.PDFinternalScale = page.internalscale;
                        //page.pointArray = [];

                    }


                    //thispage.pdfSnapScale = thispage.pagescale;


                    //thispage.pdfisrendered = true;
                    thispage.iscollapsed = false;
                    if (!thispage.pageloaded){
                        thispage.pdfisfirstrendered = true;
                        thispage.setPDFdim(thispage.dxpdf,thispage.dypdf,1);
                    }

                    thispage.setNotCollapsedArray();

                    thispage.backupScaleAndOffset();
                    var renderend = new Date().getTime();

                    var pagedata = {
                        page : thispage.pagenumber,
                        start : renderstart,
                        end : renderend
                    };

                    thispage.pdfpagetime = 10;

                    thispage.pdftimervar = setInterval(function () {
                        thispage.pdftimer()
                    }, thispage.pdfpagetime);

                    if(Rxcore_GUI_PDFRenderComplete != undefined){
                        Rxcore_GUI_PDFRenderComplete.RenderComplete(pagedata);
                        //thispage.DocRef.pgChangeLoop();
                    }

                    thispage.DocRef.draw_mpagepdf();


                    /*if(draw){
                     thispage.draw_canvas(true);
                     }*/

                });

                //thispage.PDFTextArea.id = "PDFpage" + thispage.pagenumber + 1;
                var pgnum = thispage.pagenumber + 1;
                //var textareaid = "PDFpage" + pgnum;

                //thispage.PDFTextArea = document.getElementById(textareaid);

                    thispage.PDFTextArea.style.left = thispage.startx + "px";
                    thispage.PDFTextArea.style.top = thispage.starty + "px";
                    //thispage.PDFTextArea.style.width = thispage.pagecanvas.width + "px";
                    //thispage.PDFTextArea.style.height = thispage.pagecanvas.height + "px";
                    thispage.PDFTextArea.style.width = thispage.offscreenwidth * thispage.dscalepdf + "px";
                    thispage.PDFTextArea.style.height = thispage.offscreenheight * thispage.dscalepdf + "px";


                while (thispage.PDFTextArea.firstChild) {
                        thispage.PDFTextArea.removeChild(thispage.PDFTextArea.firstChild);
                    }



                page.getTextContent().then(function(textContent){


                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: thispage.PDFTextArea,
                        viewport: viewport,
                        textDivs: []
                    }).promise.then(function (){
                        if(thispage.DocRef.searchobj.active){
                            thispage.showSearch();
                        }
                    });


                        //thispage.textLayer = new TextLayerBuilder(thispage.PDFTextArea, pgnum - 1);

                        /*thispage.textLayer = new TextLayerBuilder({
                            textLayerDiv : thispage.PDFTextArea,
                            pageIndex : pgnum - 1,
                            viewport : txtviewport
                        });*/
                        //thispage.textLayer.textLayerDiv = thispage.PDFTextArea;
                        //thispage.textLayer.pageIndex = pgnum - 1;
                        //thispage.textLayer.viewport = viewport;
                        //thispage.textLayer.setTextContent(textContent);


                        /*thispage.textLayer.eventBus.on('textlayerrendered', function(e){
                        //if text search on reapply text search markers
                            if(thispage.DocRef.searchobj.active){
                                thispage.showSearch();
                             }
                        });*/

                        //thispage.textLayer.render();


                });


            });



            // Update page counters
            //document.getElementById('page_num').textContent = pageNum;

        };

        this.renderPDFMagnify = function(magnifyscale){


            thispage.DocRef.pdfDoc.getPage(thispage.pagenumber + 1).then(function (page) {
                page.cleanupAfterRender = true;

                if(page.view[3] != 0){
                    var pagewidth = Math.abs(page.view[2] - page.view[0]);
                    var pageheight = Math.abs(page.view[3] - page.view[1]);
                    var pagetemp = Math.abs(page.view[2] - page.view[0]);
                }else{
                    pagewidth = Math.abs(page.view[2] - page.view[0]);
                    pageheight = Math.abs(page.view[3] - page.view[1]);
                    pagetemp = Math.abs(page.view[2]- page.view[0]);

                }


                switch (page._pageInfo.rotate) {
                    case 0:
                        break;
                    case 90:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                    case 180:
                        break;
                    case 270:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                }

                //thispage.pdfpagewidth = pagewidth;
                //thispage.pdfpageheight = pageheight;

                if(thispage.usedincomposite && thispage.compositereference != undefined){
                    if(thispage.isbackground){
                        var dscale = thispage.compositereference.backgroundScale;
                        wscale = (thispage.compositereference.bgpagecanvas.width * dscale) / pagewidth;
                        hscale = (thispage.compositereference.bgpagecanvas.height * dscale) / pageheight;

                    }
                    if(thispage.isoverlay){
                        dscale = thispage.compositereference.overlayScale;
                        wscale = (thispage.compositereference.ovpagecanvas.width * dscale) / pagewidth;
                        hscale = (thispage.compositereference.ovpagecanvas.height * dscale) / pageheight;

                    }
                }else{

                    var wscale = (thispage.offscreenwidth * thispage.dscalepdf) / pagewidth;
                    var hscale = (thispage.offscreenheight * thispage.dscalepdf) / pageheight;


                }

                var scale = Math.min(wscale, hscale);
                scale *= magnifyscale;

                if (scale > thispage.nPDFMaxFactor ){
                    var restscale = scale / thispage.nPDFMaxFactor;
                    scale = thispage.nPDFMaxFactor;
                    thispage.bMaxzoom = true;
                }else{
                    restscale = 1.0;
                    thispage.bMaxzoom = false;
                }


                var viewport = page.getViewport(scale);

                if (isNaN(viewport.height) || isNaN(viewport.width)){
                    thispage.pageRendering = false;
                    return;

                }else{
                    thispage.magnifycanvas.height = viewport.height;
                    thispage.magnifycanvas.width = viewport.width;

                }
                thispage.magnifyrestscale = restscale;
                /*if ((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPad/i))) {
                    if (viewport.height * viewport.width < 5000000) {
                        thispage.magnifycanvas.height = viewport.height;
                        thispage.magnifycanvas.width = viewport.width;
                        //thispage.dscalepdf = 1;
                        //thispage.markupscaleadjust = scale / thispage.pagescale;
                    } else {
                        //thispage.pageRendering = false;
                        //thispage.dscalepdf = scale;
                        return;

                    }

                } else {
                    thispage.magnifycanvas.height = viewport.height;
                    thispage.magnifycanvas.width = viewport.width;
                    //thispage.dscalepdf = 1;
                    //thispage.markupscaleadjust = scale / thispage.pagescale;
                }*/

                /*if (thispage.magnifycanvas.width <= canvasowidth) {
                 thispage.dxpdf = (canvasowidth - viewport.width) / 2;
                 }*/

                //thispage.curpagescale = thispage.magnifycanvas.width / pagewidth;
                //thispage.curpagescale = thispage.magnifycanvas.height / pageheight;

                var renderContext = {
                    canvasContext : thispage.magnifypagectx,
                    viewport : viewport
                };


                var renderTask = page.render(renderContext);
                bPDFtemprendermag = true;

                // Wait for rendering to finish
                renderTask.promise.then(function () {
                    //thispage.pageRendering = false;
                    bPDFtemprendermag = false;

                    if(thispage.usedincomposite && thispage.compositereference != undefined){
                        if(thispage.isbackground){
                            thispage.invertpdfmagnify(1);
                        }
                        if(thispage.isoverlay){
                            thispage.invertpdfmagnify(2);
                        }
                    }
                    /*if (thispage.pageNumPending !== null) {
                     // New page rendering is pending
                     thispage.renderPDFMagnify(true);
                     thispage.pageNumPending = null;
                     }*/
                    //thispage.pdfisrendered = true;
                    //thispage.DocRef.draw_mpagepdf();
                    /*if(draw){
                     thispage.draw_canvas(true);
                     }*/

                });


            });

        };

        this.getPDFdimensions = function (num){


            thispage.DocRef.pdfDoc.getPage(num).then(function (page) {

                if (bAbortPageload){
                    return;
                }
                //PDFJS page scaling not to be confused with scaling of canvas image.
                //this.pagescale = thispage.pagescale;

                if(page.view[3] != 0){
                    var pagewidth = Math.abs(page.view[2] - page.view[0]);
                    var pageheight = Math.abs(page.view[3] - page.view[1]);
                    var pagetemp = Math.abs(page.view[2] - page.view[0]);
                }else{
                    pagewidth = Math.abs(page.view[2] - page.view[0]);
                    pageheight = Math.abs(page.view[3] - page.view[1]);
                    pagetemp = Math.abs(page.view[2]- page.view[0]);

                }

                thispage.pdfpageref = page._pageInfo.ref;
                thispage.PDFpageRotate = page._pageInfo.rotate;

                switch (page._pageInfo.rotate) {
                    case 0:
                        break;
                    case 90:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                    case 180:
                        break;
                    case 270:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                }

                thispage.pdfpagewidth = pagewidth;
                thispage.pdfpageheight = pageheight;

                thispage.originalwidth = pagewidth;
                thispage.originalheight = pageheight;


                thispage.nPDFMaxFactor = Math.sqrt(nMaximageArea / (pagewidth * pageheight));

                //test if current page scale 1.5 fit within canvas if not scale down until it does.

                var temppagescale = thispage.pagescale;
                var viewport = page.getViewport(thispage.pagescale);

                var yscale = fixedScaleSize.height / thispage.pdfpageheight; //thispage.MainImageHeight;
                var xscale = fixedScaleSize.width / thispage.pdfpagewidth; // thispage.MainImageWidth;
                thispage.fixedScale = Math.min(xscale, yscale);


                if ((viewport.height > canvasoheight && viewport.width > canvasowidth) || bPDFZoomAllinit) {
                    var tempwscale = canvasowidth / pagewidth;
                    var temphscale = canvasoheight / pageheight;
                    if(bPDFZoomAllinit){
                        thispage.pagescale = Math.min(tempwscale, temphscale);
                    }else{
                        thispage.pagescale = Math.max(tempwscale, temphscale);
                    }

                    //thispage.pagescale = Math.max(tempwscale, temphscale);
                    viewport = page.getViewport(thispage.pagescale);
                }

                thispage.offscreenheight = viewport.height;
                thispage.offscreenwidth = viewport.width;

                //console.log(thispage.pagenumber, thispage.offscreenheight, thispage.offscreenwidth);


                //thispage.pagecanvas.height = viewport.height;
                //thispage.pagecanvas.width = viewport.width;

                thispage.width = viewport.width;
                thispage.height = viewport.height;


                var wscale = thispage.width / viewport.width;
                var hscale = thispage.height / viewport.height;
                thispage.pdfdscaletemp = Math.min(wscale, hscale);

                thispage.pdfdxtemp = (canvasowidth - viewport.width) / 2;
                thispage.pdfdytemp = (canvasoheight - viewport.height) / 2;

                thispage.curpagescale = thispage.pagescale;

                wscale = thispage.thumbnailobj.thumbnail.width / viewport.width;
                hscale = thispage.thumbnailobj.thumbnail.height / viewport.height;
                thispage.pdftempthumbscale = Math.min(wscale,hscale);
                thispage.pdftempthumbscale *= thispage.pagescale;

                thispage.dxthumbtemp = (thispage.thumbnailobj.thumbnail.width - viewport.width) / 2;
                thispage.dythumbtemp = (thispage.thumbnailobj.thumbnail.height - viewport.height) / 2;


                //set up and scale div for text then use function below to create text divs.
                thispage.PDFTextArea.id = "PDFpage" + num;
                //thispage.PDFTextArea.style.top = thispage.pdfdytemp + "px";
                thispage.PDFTextArea.style.left = thispage.pdfdxtemp + "px";
                thispage.PDFTextArea.style.width = thispage.width + "px";
                thispage.PDFTextArea.style.height = thispage.height + "px";

                rxcontainer.appendChild(thispage.PDFTextArea);

                if(num == 1 && thispage.DocRef.textselect){
                    thispage.PDFTextArea.style.display = szdispvalue;
                }else{
                    thispage.PDFTextArea.style.display = "none";
                }

                thispage.setPDFDiminit(thispage.pdfdxtemp, 0, thispage.pdfdscaletemp);


                page.getTextContent().then(function(textContent){

                    /*if (textContent.items.length > 0 ){
                        if (RxCore_GUI_HasText != undefined){

                            RxCore_GUI_HasText.hastext = true;
                            thispage.DocRef.hastext = true;
                        }

                    }*/

                    /*if (RxCore_GUI_HasText != undefined){
                        RxCore_GUI_HasText.hasText(thispage.DocRef.hastext, thispage.DocRef.bActive);
                    }*/

                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: thispage.PDFTextArea,
                        viewport: viewport,
                        textDivs: []
                    });

                });

            });
        };

        this.PDFrenderpage = function (page){

            page.cleanupAfterRender = true;

            thispage.pageRendering = true;
            thispage.pdfstartrender = new Date().getTime();
            var num = thispage.pagenumber + 1;

            //PDFJS page scaling not to be confused with scaling of canvas image.
            //this.pagescale = thispage.pagescale;

            //var TextLayerBuilder = pdfjsWebLibs.pdfjsWebTextLayerBuilder.TextLayerBuilder;
            //var TextLayerBuilder = PDFViewerApplication.TextLayerBuilder;
            //var TextLayerBuilder = pdfjsLib.pdfjsWebTextLayerBuilder.TextLayerBuilder;

            if(page.view[3] != 0){
                var pagewidth = Math.abs(page.view[2] - page.view[0]);
                var pageheight = Math.abs(page.view[3] - page.view[1]);
                var pagetemp = Math.abs(page.view[2] - page.view[0]);
            }else{
                pagewidth = Math.abs(page.view[2] - page.view[0]);
                pageheight = Math.abs(page.view[3] - page.view[1]);
                pagetemp = Math.abs(page.view[2]- page.view[0]);

            }

            switch (page._pageInfo.rotate) {
                case 0:
                    break;
                case 90:
                    pagewidth = pageheight;
                    pageheight = pagetemp;
                    break;
                case 180:
                    break;
                case 270:
                    pagewidth = pageheight;
                    pageheight = pagetemp;
                    break;
            }

            thispage.pdfpagewidth = pagewidth;// * thispage.dscalepdf;
            thispage.pdfpageheight = pageheight;// * thispage.dscalepdf;

            thispage.originalwidth = pagewidth;
            thispage.originalheight = pageheight;


            thispage.nPDFMaxFactor = Math.sqrt(nMaximageArea / (thispage.pdfpagewidth * thispage.pdfpageheight));

            //set fixed scale for markup
            var yscale = fixedScaleSize.height / thispage.pdfpageheight; //thispage.MainImageHeight;
            var xscale = fixedScaleSize.width / thispage.pdfpagewidth; // thispage.MainImageWidth;
            thispage.fixedScale = Math.min(xscale, yscale);


            //test if current page scale 1.5 fit within canvas if not scale down until it does.

            var temppagescale = thispage.pagescale;
            var viewport = page.getViewport(thispage.pagescale * thispage.dscalepdf);
            //console.log(thispage.dscalepdf);

            if ((viewport.height > canvasoheight && viewport.width > canvasowidth) || bPDFZoomAllinit) {
                var tempwscale = canvasowidth / thispage.pdfpagewidth;
                var temphscale = canvasoheight / thispage.pdfpageheight;

                if (bPDFZoomAllinit){
                    thispage.pagescale = Math.min(tempwscale, temphscale);
                }else{
                    thispage.pagescale = Math.max(tempwscale, temphscale);
                }

                viewport = page.getViewport(thispage.pagescale);
            }

            thispage.setpagesize(viewport.width,viewport.height);

            thispage.width = thispage.offscreenwidth;
            thispage.height = thispage.offscreenheight;


            var wscale = (thispage.offscreenwidth) / viewport.width;
            var hscale = (thispage.offscreenheight) / viewport.height;
            thispage.pdfdscaletemp = Math.min(wscale, hscale);

            thispage.pdfdxtemp = (canvasowidth - viewport.width) / 2;
            thispage.pdfdytemp = (canvasoheight - viewport.height) / 2;

            thispage.curpagescale = thispage.pagescale;

            wscale = thispage.thumbnailobj.thumbnail.width / viewport.width;
            hscale = thispage.thumbnailobj.thumbnail.height / viewport.height;
            thispage.pdftempthumbscale = Math.min(wscale,hscale);
            thispage.pdftempthumbscale *= thispage.pagescale;

            thispage.dxthumbtemp = (thispage.thumbnailobj.thumbnail.width - viewport.width) / 2;
            thispage.dythumbtemp = (thispage.thumbnailobj.thumbnail.height - viewport.height) / 2;

            thispage.PDFTextArea.id = "PDFpage" + num;

            //thispage.PDFTextArea.style.top = thispage.pdfdytemp + "px";
            thispage.PDFTextArea.style.left = thispage.pdfdxtemp + "px";
            thispage.PDFTextArea.style.width = thispage.width + "px";
            thispage.PDFTextArea.style.height = thispage.height + "px";

            rxcontainer.appendChild(thispage.PDFTextArea);

            if(num == 1 && thispage.DocRef.textselect){
                thispage.PDFTextArea.style.display = szdispvalue;
            }else{
                thispage.PDFTextArea.style.display = "none";
            }

            var renderContext = {
                //canvasContext: thispage.pagectx,
                canvasContext: thispage.pagedrawctx,
                viewport: viewport
            };

            //thispage.setPFDdimnodraw(thispage.pdfdxtemp, 0, thispage.pdfdscaletemp,false);
            thispage.setPFDdimnodraw(thispage.pdfdxtemp, 0, 1,true);
            bPDFtemprender = true;

            var renderTask = page.render(renderContext);


            renderTask.promise.then(function () {
                thispage.pageRendering = false;
                bPDFtemprender = false;
                if (thispage.pageNumPending !== null) {
                    // New page rendering is pending

                    thispage.renderPDFpage(thispage.pageNumPending);
                    thispage.pageNumPending = null;

                }
                thispage.pagecanvas.width = thispage.pagedrawCanvas.width;
                thispage.pagecanvas.height = thispage.pagedrawCanvas.height;

                thispage.pagectx.drawImage(thispage.pagedrawCanvas, 0,0);
                thispage.pagedrawCanvas.width = 1;
                thispage.pagedrawCanvas.height = 1;

                thispage.pdfisrendered = true;
                thispage.iscollapsed = false;
                thispage.setNotCollapsedArray();

                thispage.pdfisfirstrendered = true;
                thispage.setPDFdim(thispage.pdfdxtemp, 0, thispage.pdfdscaletemp);



                //console.log(thispage.pagenumber + 1);
                thispage.pdfendrender = new Date().getTime();
                thispage.pdfpagetime = (thispage.pdfendrender - thispage.pdfstartrender) - 200;
                thispage.pdfpagetime = 10;

                thispage.pdftimervar = setInterval(function () {
                    thispage.pdftimer()
                }, thispage.pdfpagetime);

                thispage.setthumbnail(0,0,thispage.pdftempthumbscale);
                //thispage.DocRef.draw
            });

            page.getTextContent().then(function(textContent){
                //if(num == 1){
                //callback call to determine if page has text.

                if (textContent.items.length > 0 ){
                    if (RxCore_GUI_HasText != undefined){

                        RxCore_GUI_HasText.hastext = true;
                        thispage.DocRef.hastext = true;
                    }

                }

                if (RxCore_GUI_HasText != undefined){
                    RxCore_GUI_HasText.hasText(thispage.DocRef.hastext, thispage.DocRef.bActive);
                }

                pdfjsLib.renderTextLayer({
                    textContent: textContent,
                    container: thispage.PDFTextArea,
                    viewport: viewport,
                    textDivs: []
                });


                //thispage.textLayer = new TextLayerBuilder(thispage.PDFTextArea, num - 1);

                /*thispage.textLayer = new TextLayerBuilder({
                    textLayerDiv : thispage.PDFTextArea,
                    pageIndex : num - 1,
                    viewport : viewport
                });*/

                //thispage.textLayer.setTextContent(textContent);
                //thispage.textLayer.render();

                //}
            });

        };

        this.renderPDFpage = function (num) {
            this.pageRendering = true;
            //console.log('should only be one of these');

            thispage.pdfstartrender = new Date().getTime();
            // Using promise to fetch the page
            thispage.DocRef.pdfDoc.getPage(num).then(function (page) {

                page.cleanupAfterRender = true;

                if (bAbortPageload){
                    return;
                }




                //PDFJS page scaling not to be confused with scaling of canvas image.
                //this.pagescale = thispage.pagescale;

                //var TextLayerBuilder = pdfjsWebLibs.pdfjsWebTextLayerBuilder.TextLayerBuilder;
                //var TextLayerBuilder = pdfjsLib.pdfjsWebTextLayerBuilder.TextLayerBuilder;
                //var TextLayerBuilder = PDFViewerApplication.TextLayerBuilder;


                if(page.view[3] != 0){
                    var pagewidth = Math.abs(page.view[2] - page.view[0]);
                    var pageheight = Math.abs(page.view[3] - page.view[1]);
                    var pagetemp = Math.abs(page.view[2] - page.view[0]);
                }else{
                    pagewidth = Math.abs(page.view[2] - page.view[0]);
                    pageheight = Math.abs(page.view[3] - page.view[1]);
                    pagetemp = Math.abs(page.view[2]- page.view[0]);

                }

                thispage.pdfpageref = page._pageInfo.ref;

                thispage.PDFpageRotate = page._pageInfo.rotate;
                switch (page._pageInfo.rotate) {
                    case 0:
                        break;
                    case 90:
                        pagewidth = pageheight;
                        pageheight = pagetemp;

                        break;
                    case 180:
                        break;
                    case 270:
                        pagewidth = pageheight;
                        pageheight = pagetemp;
                        break;
                }


                thispage.pdfpagewidth = pagewidth;
                thispage.pdfpageheight = pageheight;

                thispage.originalwidth = pagewidth;
                thispage.originalheight = pageheight;

                var centerdocx =  thispage.pdfpagewidth * 0.5;
                var centerdocy =  thispage.pdfpageheight  * 0.5;
                //var anglerad = (360 - thispage.PDFpageRotate) * (Math.PI / 180);

                page.setPointlistCallback(function(x,y){
                    if(!thispage.bpointlistSet){
                        if(thispage.PDFsnapTransform != null){

                            x += thispage.PDFsnapTransform.e;
                            y += thispage.PDFsnapTransform.f;

                            switch (page._pageInfo.rotate) {
                                case 0:

                                    break;
                                case 90:
                                    var tempx = x;
                                    x = y;
                                    y = -tempx;

                                    break;
                                case 180:
                                    x = -x;
                                    y = -y;


                                    break;
                                case 270:
                                    var tempx = x;
                                    x = -y;
                                    y = tempx;

                                    break;
                            }

                            x *= thispage.PDFsnapTransform.a;
                            y *= thispage.PDFsnapTransform.d;

                            thispage.PDFPointArray.push({x:x,y:y});

                            //x += thispage.PDFsnapTransform.e;
                            //y += thispage.PDFsnapTransform.f;

                        }


                        /*if (page._pageInfo.rotate == 0){
                            thispage.PDFPointArray.push({x:x,y:y});
                        }else{
                            var rotsnap = getRotPoint(centerdocx, centerdocy, x, y,  anglerad);
                            thispage.PDFPointArray.push({x:rotsnap.x,y:rotsnap.y});

                        }*/

                    }

                });

                page.setTransformCallback(function(transobject){
                   if(thispage.PDFinternalScale = 1){
                        thispage.PDFinternalScale = {x:transobject.a, y:transobject.d};
                   }

                   thispage.PDFsnapTransform = transobject;

                });

                var yscale = fixedScaleSize.height / thispage.pdfpageheight; //thispage.MainImageHeight;
                var xscale = fixedScaleSize.width / thispage.pdfpagewidth; // thispage.MainImageWidth;
                thispage.fixedScale = Math.min(xscale, yscale);
                //thispage.fixedScale = dscalelocalOne;


                thispage.nPDFMaxFactor = Math.sqrt(nMaximageArea / (pagewidth * pageheight));

                //test if current page scale 1.5 fit within canvas if not scale down until it does.

                var temppagescale = thispage.pagescale;


                if(thispage.pdfdiminitset){
                    var viewport = page.getViewport(thispage.pagescale * thispage.dscalepdf);
                    //console.log(thispage.dscalepdf);
                }else{
                    viewport = page.getViewport(thispage.pagescale);
                }


                if ((viewport.height > canvasoheight && viewport.width > canvasowidth) || bPDFZoomAllinit) {
                    var tempwscale = canvasowidth / thispage.pdfpagewidth;
                    var temphscale = canvasoheight / thispage.pdfpageheight;

                    if(bPDFZoomAllinit){
                        thispage.pagescale = Math.min(tempwscale, temphscale);
                    }else{
                        thispage.pagescale = Math.max(tempwscale, temphscale);
                    }


                    viewport = page.getViewport(thispage.pagescale);
                }

                //console.log('renderPDFpage ' + thispage.dscalepdf,thispage.pdfdiminitset);

                thispage.setpagesize(viewport.width,viewport.height);

                //thispage.pagecanvas.height = viewport.height;
                //thispage.pagecanvas.width = viewport.width;

                thispage.width = thispage.offscreenwidth;
                thispage.height = thispage.offscreenheight;


                var wscale = thispage.offscreenwidth / viewport.width;
                var hscale = thispage.offscreenheight / viewport.height;
                thispage.pdfdscaletemp = Math.min(wscale, hscale);

                thispage.pdfdxtemp = (canvasowidth - viewport.width) / 2;
                thispage.pdfdytemp = (canvasoheight - viewport.height) / 2;

                thispage.curpagescale = thispage.pagescale;

                wscale = thispage.thumbnailobj.thumbnail.width / viewport.width;
                hscale = thispage.thumbnailobj.thumbnail.height / viewport.height;

                thispage.pdftempthumbscale = Math.min(wscale,hscale);
                thispage.pdftempthumbscale *= thispage.pagescale;

                thispage.dxthumbtemp = (thispage.thumbnailobj.thumbnail.width - viewport.width) / 2;
                thispage.dythumbtemp = (thispage.thumbnailobj.thumbnail.height - viewport.height) / 2;

                // Render PDF page into canvas context

                //thispage.pagectx.clearRect(0, 0, thispage.pagecanvas.width, thispage.pagecanvas.height);
                //thispage.pagectx.fillStyle = 'white';
                //thispage.pagectx.fillRect(0, 0, thispage.pagecanvas.width, thispage.pagecanvas.height);

                //thispage.PDFTextArea = document.getElementById("PDFTextArea");
                //if(num == 1){
                thispage.PDFTextArea.id = "PDFpage" + num;

                //thispage.PDFTextArea.style.top = thispage.pdfdytemp + "px";
                thispage.PDFTextArea.style.left = thispage.pdfdxtemp + "px";
                thispage.PDFTextArea.style.width = thispage.width + "px";
                thispage.PDFTextArea.style.height = thispage.height + "px";

                rxcontainer.appendChild(thispage.PDFTextArea);



                if(num == 1 && thispage.DocRef.textselect){
                    thispage.PDFTextArea.style.display = szdispvalue;
                }else{
                    thispage.PDFTextArea.style.display = "none";
                }
                //}

                /*var renderContext = {
                 canvasContext:thispage.pagectx,
                 viewport:viewport
                 };*/

                //set up and scale div for text then use function below to create text divs.

                var renderContext = {
                    //canvasContext: thispage.pagectx,
                    canvasContext: thispage.pagedrawctx,
                    viewport: viewport
                };

                /*page.render({
                 canvasContext : context,
                 viewport : viewport
                 });*/

                var renderTask = page.render(renderContext);
                //page.render(renderContext);
                if(!thispage.pdfdiminitset){
                    //thispage.setPFDdimnodraw(thispage.pdfdxtemp, 0, thispage.pdfdscaletemp,false);
                    thispage.setPFDdimnodraw(thispage.pdfdxtemp, 0, 1,true);
                }

                bPDFtemprender = true;
                //temp test to check animate on first render.
                //bAnimatePDFrender = true;
                //thispage.iscollapsed = false;

                renderTask.promise.then(function () {



                    thispage.pageRendering = false;
                    bPDFtemprender = false;
                    //bAnimatePDFrender = false;
                    if (thispage.pageNumPending !== null) {
                        // New page rendering is pending

                        thispage.renderPDFpage(thispage.pageNumPending);
                        thispage.pageNumPending = null;

                    }

                    thispage.pagecanvas.width = thispage.pagedrawCanvas.width;
                    thispage.pagecanvas.height = thispage.pagedrawCanvas.height;

                    thispage.pagectx.drawImage(thispage.pagedrawCanvas, 0,0);
                    thispage.pagedrawCanvas.width = 1;
                    thispage.pagedrawCanvas.height = 1;

                    //var dup_array = original_array.slice();
                    //thispage.PDFPointArray = page.pointArray.slice();
                    //thispage.PDFinternalScale = page.internalscale;

                    thispage.bpointlistSet = true;
                    thispage.pdfSnapScale = thispage.pagescale;

                    //page.pointArray = [];

                    thispage.pdfisrendered = true;
                    thispage.iscollapsed = false;
                    thispage.setNotCollapsedArray();
                    thispage.pdfisfirstrendered = true;

                    thispage.setPDFdim(thispage.pdfdxtemp, 0, thispage.pdfdscaletemp);
                    /*if(!thispage.pdfdiminitset){

                    }*/

                    thispage.pdfendrender = new Date().getTime();
                    thispage.pdfpagetime = (thispage.pdfendrender - thispage.pdfstartrender) + 10;
                    thispage.pdfpagetime = 10;
                    //console.log(thispage.pdfpagetime);
                    thispage.pdftimervar = setInterval(function () {
                        thispage.pdftimer()
                    }, thispage.pdfpagetime);

                    //console.log(page.pointArray);
                    //thispage.curpagescale

                    //thispage.DocRef.draw_mpagepdf();


                    thispage.setthumbnail(0,0,thispage.pdftempthumbscale);
                });

                page.getTextContent().then(function(textContent){
                    //if(num == 1){
                    //callback call to determine if page has text.

                    if (textContent.items.length > 0 ){
                        if (RxCore_GUI_HasText != undefined){
                            thispage.DocRef.hastext = true;

                            RxCore_GUI_HasText.hastext = true;
                        }

                    }

                    if (RxCore_GUI_HasText != undefined){
                        RxCore_GUI_HasText.hasText(thispage.DocRef.hastext,thispage.DocRef.bActive );
                    }

                    pdfjsLib.renderTextLayer({
                        textContent: textContent,
                        container: thispage.PDFTextArea,
                        viewport: viewport,
                        textDivs: []
                    });

                    //thispage.textLayer = new TextLayerBuilder(thispage.PDFTextArea, num - 1);
                    /*thispage.textLayer = new TextLayerBuilder({
                        textLayerDiv : thispage.PDFTextArea,
                        pageIndex : num - 1,
                        viewport : viewport
                    });*/

                    //thispage.textLayer.setTextContent(textContent);
                    //thispage.textLayer.render();

                    //}
                });



                // Wait for rendering to finish


            });

            // Update page counters
            //document.getElementById('page_num').textContent = pageNum;

        };

        this.drawpoints = function(pointarray,  scale){

            /*if(thispage.dscalepdf != 1){
                scale /= thispage.dscalepdf;
            }*/

            if(thispage.PDFinternalScale.x > 0){
                var localscalex = scale * thispage.PDFinternalScale.x;
            }else{
                localscalex = scale * 0.12;

            }
            if (thispage.PDFinternalScale.y > 0){
                var localscaley = scale * thispage.PDFinternalScale.y;
            }else{
                localscaley = scale * 0.12;
            }



            //thispage.

            var cheight = thispage.offscreenheight * thispage.dscalepdf;
            var cwidth = thispage.offscreenwidth * thispage.dscalepdf;

            //context.save();
            //context.translate(thispage.startx, canvas.height);

            //context.scale(1,-1);

            if (thispage.PDFpageRotate != 0) {
                //page.pageInfo.rotate
                //localscalex *= 0.1;
                //localscaley *= 0.1;
                //var txcanv = (canvasowidth / 2);
                //var tycanv = (canvasoheight / 2);
                //context.save();
                //context.translate(txcanv, tycanv);
                //context.rotate((360-thispage.PDFpageRotate) * (Math.PI / 180));
                //context.translate(-txcanv, -tycanv);

            }

            for(var i = 0;i<pointarray.length;i++){

                if (thispage.PDFpageRotate != 0) {

                    if(thispage.PDFpageRotate == 90){
                        var transy = thispage.starty + (-(pointarray[i].y*scale));
                        var transx = thispage.startx + (pointarray[i].x*scale);

                    }else{
                        transy = thispage.starty + (-(pointarray[i].y*scale) + cheight);
                        transx = thispage.startx + (pointarray[i].x*scale) + cwidth;

                    }
                    //var transy = thispage.starty + (-(pointarray[i].y*scale));

                    //var transy = thispage.startx + (-(pointarray[i].y*scale) + cheight);
                    //var transx = thispage.starty + (pointarray[i].x*scale);

                    //var transx = thispage.starty + (-(pointarray[i].y*localscaley) + cheight);
                    //var transx = thispage.starty + (-(pointarray[i].y*scale) + cheight);
                    //var transy = thispage.startx + (pointarray[i].x*localscalex);
                    //var transy = thispage.startx + (pointarray[i].x*scale);
                }else{
                    if (pointarray[i].y < 0){
                        transy = thispage.starty + (-(pointarray[i].y*scale));
                    }else{
                        transy = thispage.starty + (-(pointarray[i].y*scale) + cheight);
                    }
                    if (pointarray[i].x < 0){
                        transx = thispage.startx + (pointarray[i].x*scale) + cwidth;
                    }else{
                        transx = thispage.startx + (pointarray[i].x*scale);

                    }


                    //transy = thispage.starty + (-(pointarray[i].y*localscaley) + cheight);
                    //transy = thispage.starty + (-(pointarray[i].y*scale) + cheight);
                    /*if (thispage.PDFinternalScale.y > 0){

                    }else{

                        transy = thispage.starty + ((pointarray[i].y*localscaley));
                    }*/


                    //transx = thispage.startx + (pointarray[i].x*localscalex);
                    //transx = thispage.startx + (pointarray[i].x*scale);

                }

                //var transy = thispage.starty + (-(pointarray[i].y*scale) + cheight);
                //var transy = thispage.starty + (-(pointarray[i].y*scale));
                //var transx = thispage.startx + (pointarray[i].x*scale) + cwidth;

                drawpoints(context,0,{x:transx,y:transy});

                //drawsnap(context,{x:transx,y:transy});
                //drawpoints(context,thispage.PDFpageRotate,{x:transx,y:transy});

            }
            //context.restore();
        };

        this.getdivpos = function(indx){
            var divpos = {
                x : 0,
                y : 0
            };

            thispage.pan_update(0,0);

            if(thispage.PDFTextArea != undefined){
                if(thispage.PDFTextArea.children[indx] != undefined){
                    var divtext = thispage.PDFTextArea.children[indx];
                    var topdivy = thispage.PDFTextArea.offsetTop;
                    var topdivx = thispage.PDFTextArea.offsetLeft;
                    divpos.y = divtext.offsetTop + topdivy;
                    divpos.x = divtext.offsetLeft + topdivx;
                }
            }

            if (thispage.TextSelectArea != undefined){
                if(thispage.TextSelectArea.children[indx] != undefined){
                    var vdivtext = thispage.TextSelectArea.children[indx];
                    var vtopdivy = thispage.TextSelectArea.offsetTop;
                    var vtopdivx = thispage.TextSelectArea.offsetLeft;
                    divpos.y = vdivtext.offsetTop + vtopdivy;
                    divpos.x = vdivtext.offsetLeft + vtopdivx;
                }

            }
            return divpos;
        };

        this.indexdivTexts = function(){
            var pagetexts = [];
            if(thispage.PDFTextArea != undefined){
                var children = thispage.PDFTextArea.children;
                for (var i = 0; i < children.length; i++) {
                    children[i].style.backgroundColor = null;
                    var textChild = children[i];
                    pagetexts.push(textChild.textContent);
                    // Do stuff
                }
            }
            if (thispage.TextSelectArea != undefined){
                var vchildren = thispage.TextSelectArea.children;
                for (var vi = 0; vi < vchildren.length; vi++) {
                    vchildren[vi].style.backgroundColor = null;
                    var vtextChild = vchildren[vi];
                    pagetexts.push(vtextChild.textContent);

                }
            }
            return pagetexts;
        };

        this.clearmarktextdiv = function(indx,str){
            if(thispage.PDFTextArea != undefined){
                if(thispage.PDFTextArea.children[indx] != undefined){
                    thispage.PDFTextArea.children[indx].innerHTML = "";
                    var textnode = document.createTextNode(str);
                    thispage.PDFTextArea.children[indx].appendChild(textnode);
                }
            }

            if (thispage.TextSelectArea != undefined){
                if(thispage.TextSelectArea.children[indx] != undefined){
                    thispage.TextSelectArea.children[indx].innerHTML = "";
                    var vtextnode = document.createTextNode(str);
                    thispage.TextSelectArea.children[indx].appendChild(vtextnode);
                }
            }


        };

        this.marktextdiv = function(indx,str,pos,length){
            if(thispage.PDFTextArea != undefined){

                var spantext = str.substring(pos, length+pos);
                var splittext = str.split(" ");
                if(thispage.PDFTextArea.children[indx] != undefined){
                    thispage.PDFTextArea.children[indx].innerHTML = "";

                    var numwords = 0;
                    for (var i = 0;i<splittext.length;i++){

                        var subpos = splittext[i].search(spantext);
                        if (subpos == -1) {
                            if(numwords>0){
                                var textnode = document.createTextNode(splittext[i] + " ");
                            }else{
                                textnode = document.createTextNode(splittext[i]);
                            }

                            thispage.PDFTextArea.children[indx].appendChild(textnode);
                            numwords++;

                        } else if (subpos >= 0) {
                            var node = document.createElement("span");
                            node.className = "highlight";                   // Create a <span> node
                            textnode = document.createTextNode(spantext);         // Create a text node
                            node.appendChild(textnode);                              // Append the text to <li>
                            thispage.PDFTextArea.children[indx].appendChild(node);
                            numwords = 0;
                        }
                    }
                }


            }

            if(thispage.TextSelectArea != undefined){
                var vspantext = str.substring(pos, length+pos);
                var vsplittext = str.split(" ");
                if(thispage.TextSelectArea.children[indx] != undefined){
                    thispage.TextSelectArea.children[indx].innerHTML = "";

                    var vnumwords = 0;
                    for (var vi = 0;vi<vsplittext.length;vi++){
                        var vsubpos = vsplittext[vi].search(vspantext);
                        if (vsubpos == -1) {
                            if(vnumwords>0){
                                var vtextnode = document.createTextNode(vsplittext[vi] + " ");
                            }else{
                                vtextnode = document.createTextNode(vsplittext[vi]);
                            }
                            thispage.TextSelectArea.children[indx].appendChild(vtextnode);
                            vnumwords++;
                        }else if (vsubpos >= 0){
                            var vnode = document.createElement("span");
                            vnode.className = "highlight";                   // Create a <span> node
                            vtextnode = document.createTextNode(vspantext);         // Create a text node
                            vnode.appendChild(vtextnode);                              // Append the text to <li>
                            thispage.TextSelectArea.children[indx].appendChild(vnode);
                            vnumwords = 0;

                        }
                    }
                }


            }

        };


        this.getVectorSearchList = function(){
            var searcharray = thispage.indexdivTexts();

            var casesense = thispage.DocRef.searchobj.casesens;
            var str = thispage.DocRef.searchobj.expr;

            for (var txtcnt = 0;txtcnt < searcharray.length;txtcnt++){

                if(!casesense){
                    var searchexpr = str.toLowerCase();
                    var searchstr = searcharray[txtcnt].toLowerCase();
                }else{
                    searchexpr = str;
                    searchstr = searcharray[txtcnt];

                }
                var found = false;
                var pos = searchstr.search(searchexpr);
                if (pos == -1) {
                    found = false;
                } else if (pos >= 0) {
                    found = true;
                }

                if (found){

                    var resultobj = {
                        page : thispage.pagenumber,
                        indx : txtcnt,
                        searchtext : searcharray[txtcnt],
                        pos : pos,
                        length : str.length
                    };
                    thispage.DocRef.searchobj.matcharray.push(resultobj);

                }
            }

        };
        this.getPDFSearchList = function(){
            //var resultarray = [];
            var searcharray = thispage.indexdivTexts();

            var casesense = thispage.DocRef.searchobj.casesens;
            var str = thispage.DocRef.searchobj.expr;

            for (var txtcnt = 0;txtcnt < searcharray.length;txtcnt++){

                if(!casesense){
                    var searchexpr = str.toLowerCase();
                    var searchstr = searcharray[txtcnt].toLowerCase();
                }else{
                    searchexpr = str;
                    searchstr = searcharray[txtcnt];

                }
                var found = false;
                var pos = searchstr.search(searchexpr);
                if (pos == -1) {
                    found = false;
                } else if (pos >= 0) {
                    found = true;
                }

                if (found){

                    var resultobj = {
                        page : thispage.pagenumber,
                        indx : txtcnt,
                        searchtext : searcharray[txtcnt],
                        pos : pos,
                        length : str.length
                    };
                    thispage.DocRef.searchobj.matcharray.push(resultobj);


                }
            }
            //return resultarray;

        };

        this.getrotcoords = function(cx, cy, x, y, angle){
            var radians = (Math.PI / 180) * angle,
                cos = Math.cos(radians),
                sin = Math.sin(radians),
                nx = (cos * (x - cx)) + (sin * (y - cy)) + cx,
                ny = (cos * (y - cy)) - (sin * (x - cx)) + cy;
            return  {
                x:nx,
                y:ny
            }
        };

        this.showSearch = function(){
            if(thispage.DocRef.searchobj.page == thispage.pagenumber){

                if(thispage.usevectorxml){
                    thispage.settextdivs();
                }

                var text = thispage.DocRef.searchobj.matcharray[thispage.DocRef.searchobj.indx].searchtext;
                var counter = thispage.DocRef.searchobj.matcharray[thispage.DocRef.searchobj.indx].indx;
                var pos = thispage.DocRef.searchobj.matcharray[thispage.DocRef.searchobj.indx].pos;
                var length = thispage.DocRef.searchobj.matcharray[thispage.DocRef.searchobj.indx].length;
                //thispage.marktextdiv(counter,text,pos,length);
                var divpos = thispage.getdivpos(counter);


                 //var visible = this.istextvisible(divpos.x, divpos.y);
                 /*
                 0 = right
                 1 = left
                 2 = up
                 3 = down
                */

                var centery = canvasoheight / 2;
                var centerx = canvasowidth / 2;
                var panx = 0;
                var pany = 0;



                if(thispage.drotation != 0){
                    var rotpos = thispage.getrotcoords(centerx,centery,divpos.x,divpos.y, -thispage.drotation);
                    //divpos.x = rotpos.x;
                    //divpos.y = rotpos.y;
                    distancexright = Math.max(rotpos.x,canvasowidth) - Math.min(rotpos.x,canvasowidth);
                    if (Math.max(rotpos.x,canvasowidth) == rotpos.x){

                        move = 1;
                        //panx =  distancexright + 300;
                        panx = rotpos.x - centerx;
                    }else if(distancexright < 300) {
                        move = 1;
                        panx = rotpos.x - centerx;
                    }
                    distanceybottom = Math.max(rotpos.y,canvasoheight) - Math.min(rotpos.y,canvasoheight);
                    if (Math.max(rotpos.y,canvasoheight) == rotpos.y){
                        move = 2;
                        pany = rotpos.y - centery;
                    }else if(distanceybottom < 100){
                        move = 2;
                        pany = rotpos.y - centery;

                    }
                    distancexleft = Math.max(rotpos.x,0) - Math.min(rotpos.x,0);
                    if (Math.min(rotpos.x,0) == rotpos.x){
                        move = 0;
                        panx = -(centerx - rotpos.x);

                    }else if(distancexleft < 100) {
                        move = 0;
                        panx = -(centerx - rotpos.x);
                    }
                    distanceytop = Math.max(rotpos.y,0) - Math.min(rotpos.y,0);
                    if (Math.min(rotpos.y,0) == rotpos.y){
                        move = 3;
                        pany = -(centery - rotpos.y);
                    }else if(distanceytop < 100){
                        move = 3;
                        pany = -(centery - rotpos.y);
                    }

                    /*switch (thispage.drotation) {
                        case 90:
                            //this.dxvector -= sy;
                            //this.dyvector += sx;
                            thispage.pan_update(pany,-panx);

                            break;
                        case 180:
                            //this.dxvector += sx;
                            //this.dyvector += sy;
                            thispage.pan_update(-panx,-pany);
                            break;
                        case 270:
                            //this.dxvector += sy;
                            //this.dyvector -= sx;
                            thispage.pan_update(-pany,panx);
                            break;
                    }*/
                    thispage.pan_update(panx,pany);

                }else{
                    var distancexright = Math.max(divpos.x,canvasowidth) - Math.min(divpos.x,canvasowidth);
                    if (Math.max(divpos.x,canvasowidth) == divpos.x){

                        move = 1;
                        //panx =  distancexright + 300;
                        panx = divpos.x - centerx;


                    }else if(distancexright < 300) {
                        move = 1;
                        panx = divpos.x - centerx;

                    }
                    var distanceybottom = Math.max(divpos.y,canvasoheight) - Math.min(divpos.y,canvasoheight);
                    if (Math.max(divpos.y,canvasoheight) == divpos.y){
                        move = 2;
                        pany = divpos.y - centery;

                    }else if(distanceybottom < 100){
                        move = 2;
                        pany = divpos.y - centery;
                    }

                    var distancexleft = Math.max(divpos.x,0) - Math.min(divpos.x,0);
                    if (Math.min(divpos.x,0) == divpos.x){

                        var move = 0;
                        panx = -(centerx - divpos.x);
                        //var panx = distancexleft - 200;

                    }else if(distancexleft < 100) {
                        move = 0;
                        panx = -(centerx - divpos.x);
                   }

                    var distanceytop = Math.max(divpos.y,0) - Math.min(divpos.y,0);
                    if (Math.min(divpos.y,0) == divpos.y){
                        move = 3;
                        pany = -(centery - divpos.y);
                    }else if(distanceytop < 100){
                        move = 3;
                        pany = -(centery - divpos.y);
                    }
                    thispage.pan_update(panx,pany);
                }




                thispage.marktextdiv(counter,text,pos,length);





                /*if(visible){
                    thispage.pan_update();
                }*/

                //console.log(visible);
                //console.log(divpos.y);
                //console.log(canvas.height);

            }

        };
        this.clearSearch = function(){
            if(thispage.DocRef.searchobj.page == thispage.pagenumber){
                var text = thispage.DocRef.searchobj.matcharray[thispage.DocRef.searchobj.indx].searchtext;
                var counter = thispage.DocRef.searchobj.matcharray[thispage.DocRef.searchobj.indx].indx;
                thispage.clearmarktextdiv(counter,text);
            }


        };


        /*this.getPDFpagetext = function (){

            var resultarray = [];
            var searcharray = thispage.indexdivTexts();

            var casesense = thispage.DocRef.searchobj.casesens;
            var str = thispage.DocRef.searchobj.expr;

            for (var txtcnt = DocRef.searchobj.indx;txtcnt < searcharray.length;txtcnt++){

                if(!casesense){
                    var searchexpr = str.toLowerCase();
                    var searchstr = searcharray[txtcnt].toLowerCase();
                }else{
                    searchexpr = str;
                    searchstr = searcharray[txtcnt];

                }
                var found = false;
                var pos = searchstr.search(searchexpr);
                if (pos == -1) {
                    found = false
                } else if (pos >= 0) {
                    found = true;
                }

                if (found){
                    //console.log(thispage.pagenumber + 1,txtcnt, searchstr);
                    var resultobj = {
                      page : thispage.pagenumber,
                      indx : txtcnt,
                      searchtext : searcharray[txtcnt],
                      pos : pos,
                      length : str.length
                    };
                    resultarray.push(resultobj);

                    if(thispage.DocRef.searchobj.page == thispage.pagenumber){
                        thispage.marktextdiv(txtcnt,searcharray[txtcnt],pos,str.length);
                    }
                    DocRef.searchobj.indx = txtcnt;


                }
            }

        };*/



        this.loadimages = function () {
            //get_image(this.SmallImageSRC,this.smallimage);
            //showDownloadDialog();
            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("show");
            }

            //this.smallimage.addEventListener('load', this.smallimageload, false);
            //this.smallimage.addEventListener('progress', this.smallimageprogress, false);
            //this.smallimage.src = this.SmallImageSRC;
            thispage.smallimageload();

            //draw_image(ev.srcElement);
            //get_image(this.MainImageSRC,this.largeimage);
            //showDownloadDialog();
            /*if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("show");
            }*/
            thispage.largeimageload();

            //this.largeimage.addEventListener('load', this.largeimageload, false);
            //this.largeimage.addEventListener('progress', this.largeimageprogress, false);
            //this.largeimage.src = this.MainImageSRC;

            //get_image(this.ThumbnailImageSRC,this.imagethumb);


        };
        //this.loadvector = function(this.Vector2DSRC){


        //  DrawVectors(this.VectorSRC);
        //};

        this.setvectordim = function (dx, dy, dscale) {
            this.dxvector = dx;
            this.dyvector = dy;
            this.dscalevector = dscale;
            this.initialscale = dscale;
            this.vectorloaded = true;


            this.startx = this.dxvector;
            this.starty = this.dyvector;
            //dxlocal = (canvasowidth - (thispage.VectorPageObj.width*dscalelocal)) / 2;
            //dylocal = (canvasoheight - (thispage.VectorPageObj.height*dscalelocal)) / 2;


            this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
            this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;



            //thispage.vectorstartrender = new Date().getTime();

            if (this.usedincomposite && this.compositereference != undefined) {
                //this.compositereference.draw_compare(true);
                this.compositereference.scaleToBackground(true);
            } else {
                this.draw_vector(true);
            }



            //this.draw_vector(true);
            //thispage.vectorendrender = new Date().getTime();
            //thispage.vectorpagetime = (thispage.vectorendrender - thispage.vectorstartrender);
            thispage.vectorpagetime = thispage.VectorPageObj.vectorpagetime;


            thispage.vectortimervar = setInterval(function () {
                thispage.vectortimer();
            }, thispage.vectorpagetime);


            var textwidth = thispage.endx - thispage.startx;
            var textheight = thispage.endy - thispage.starty;

            if (thispage.VectorPageObj.textlist.length > 0 ){
                thispage.settextdivs(true);
            }

            if(thispage.TextSelectArea != undefined){
                thispage.TextSelectArea.style.top = thispage.starty + "px";
                thispage.TextSelectArea.style.left = thispage.startx + "px";
                thispage.TextSelectArea.style.width = textwidth + "px";
                thispage.TextSelectArea.style.height = textheight + "px";
                rxcontainer.appendChild(thispage.TextSelectArea);
                //thispage.TextSelectArea.parentNode = rxcontainer;

                if(firstpage && thispage.DocRef.textselect){
                    thispage.TextSelectArea.style.display = szdispvalue;
                }else{
                    thispage.TextSelectArea.style.display = "none";
                }

            }




            if (firstpage && !thispage.DocRef.markuploaded) {

                if (bUsemarkupbyref) {
                    getMarkupbyReference(path, thispage.DocRef);
                } else if(bUsemarkupbyrefEx){
                    getMarkupxmlurl(thispage.DocRef);
                }else{
                    getMarkupFilelist(path, thispage.DocRef);
                }


                //getMarkupFilelist(path);
            }



            if (doCompare) {
                comparecheck(thispage.DocRef.FileName);
            } else {
                DeactivateAll();
                thispage.DocRef.SetActive();
            }
            if(thispage.DocRef.bDoPrint){
                if (thispage.DocRef.checkprintready()){
                    printCanvas(PrintPageURL);
                }

            }

            RxCore_default();

            if (firstpage){

                if (Rxcore_GUI_fileLoadComplete != undefined) {
                    //Rxcore_GUI_fileLoadComplete.loadComplete(thispage.DocRef.FileName);
                    Rxcore_GUI_fileLoadComplete.loadComplete(thispage.DocRef.FileName, thispage.DocRef.bActive);
                }
            }

            if (Rxcore_GUI_pageLoadComplete != undefined) {
                Rxcore_GUI_pageLoadComplete.loadComplete(thispage.pagenumber);
            }


        };

        this.removetext = function(){
            if(thispage.TextSelectArea == undefined){
                return;
            }

            thispage.TextSelectArea.removeEventListener('wheel', ev_canvas, true);
            //rxcontainer.removeChild(thispage.TextSelectArea);
            thispage.TextSelectArea.remove();
        };

        this.selecttext = function(){
            if(thispage.TextSelectArea == undefined){
                return;
            }

            if(thispage.DocRef.textselect){
                thispage.TextSelectArea.style.display = szdispvalue;
            }else{
                thispage.TextSelectArea.style.display = "none";
            }

        };


        this.movetextdivs = function(){
            if(thispage.TextSelectArea == undefined){
                return;
            }

            var centery = canvasoheight / 2;
            var centerx = canvasowidth / 2;

            thispage.TextSelectArea.removeAttribute("style");

            var textwidth = thispage.endx - thispage.startx;
            var textheight = thispage.endy - thispage.starty;
            var centerxoff = centerx - thispage.startx;
            var centeryoff = centery - thispage.starty;

            thispage.TextSelectArea.style.top = thispage.starty + "px";
            thispage.TextSelectArea.style.left = thispage.startx + "px";


            thispage.TextSelectArea.style.width = textwidth + "px";
            thispage.TextSelectArea.style.height = textheight + "px";

            if(thispage.DocRef.textselect){
                thispage.TextSelectArea.style.display = szdispvalue;
            }else{
                thispage.TextSelectArea.style.display = "none";
            }


            if(this.drotation != 0){
                var szcentertrans = centerxoff + "px" + " " + centeryoff + "px";
                //thispage.TextSelectArea.style.transformOrigin="50% 50%";
                thispage.TextSelectArea.style.transformOrigin = szcentertrans;
                thispage.TextSelectArea.style.transform = "rotate(" + this.drotation + "deg)";
            }


        };


        this.settextdivs = function(){
            if(thispage.TextSelectArea == undefined){
                return;
            }

            thispage.TextSelectArea.removeAttribute("style");

            var textwidth = thispage.endx - thispage.startx;
            var textheight = thispage.endy - thispage.starty;
            thispage.TextSelectArea.style.top = thispage.starty + "px";
            thispage.TextSelectArea.style.left = thispage.startx + "px";
            thispage.TextSelectArea.style.width = textwidth + "px";
            thispage.TextSelectArea.style.height = textheight + "px";

            if(thispage.DocRef.textselect){
                thispage.TextSelectArea.style.display = szdispvalue;
            }else{
                thispage.TextSelectArea.style.display = "none";
            }


            if(this.drotation != 0){
                thispage.TextSelectArea.style.transformOrigin="50% 50%";
                thispage.TextSelectArea.style.transform = "rotate(" + this.drotation + "deg)";
            }


            var textdata = {
                textLayerDiv : thispage.TextSelectArea,
                scale : this.dscalevector,
                dx : this.dxvector,
                dy : this.dyvector
            };

            thispage.VectorPageObj.TextLayerBuilder(textdata);
        };

        this.cleartextdivs = function(){
            if(thispage.TextSelectArea == undefined){
                return;
            }

            var textdata = {
                textLayerDiv : thispage.TextSelectArea,
                scale : this.dscalevector,
                dx : this.dxvector,
                dy : this.dyvector
            };

            thispage.VectorPageObj.TextLayerClear(textdata);

        };

        this.setimagedimlarge = function (dx, dy, dscale) {
            this.dx = dx;
            this.dy = dy;
            this.dscale = dscale;
            this.largeimageloaded = true;
            //redraw markup here in case scaling is available after markup is loaded.
            //documentopen = true;
            //drawmarkupAll(cntximg);
            if (firstpage && !thispage.DocRef.markuploaded) {


                if (bUsemarkupbyref) {
                    getMarkupbyReference(path, thispage.DocRef);
                } else if(bUsemarkupbyrefEx) {
                    getMarkupxmlurl(thispage.DocRef);

                }else{


                    getMarkupFilelist(path, thispage.DocRef);
                }



                //getMarkupFilelist(path);
            }

            if (this.initialzoom == 1) {

            } else {
                this.ZoomRealSize();
            }
            this.draw_image(true);

            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("hide");
            }

            if (doCompare) {
                comparecheck(thispage.DocRef.FileName);
            } else {
                DeactivateAll();
                thispage.DocRef.SetActive();
            }
            //this.draw_image();
            if(thispage.DocRef.bDoPrint){
                if (thispage.DocRef.checkprintready()){
                    printCanvas(PrintPageURL);
                }
            }

            RxCore_default();

            if (firstpage){

                if (Rxcore_GUI_fileLoadComplete != undefined) {
                    Rxcore_GUI_fileLoadComplete.loadComplete(thispage.DocRef.FileName, thispage.DocRef.bActive);
                }
            }

            if (Rxcore_GUI_pageLoadComplete != undefined) {
                Rxcore_GUI_pageLoadComplete.loadComplete(thispage.pagenumber);
            }


            if (RxCore_GUI_VectorBlocksLoaded != undefined) {
                RxCore_GUI_VectorBlocksLoaded.setVectorBlocks([]);
            }


        };

        this.setthumbnail = function(dx,dy,dscale){

            thispage.dxthumb=dx;
            thispage.dythumb=dy;
            thispage.dscalethumb=dscale;

            if(!thispage.usevector3Dxml){
                thispage.draw_thumbnail();
            }

        };


        this.setimagedimsmall = function (dx, dy, dscale) {
            this.dxextent = dx;
            this.dyextent = dy;
            this.dscaleextent = dscale;
            this.initialscale = dscale;
            this.startx = this.dxextent;
            this.starty = this.dyextent;
            this.endx = (this.SmallImageWidth * this.dscaleextent) + this.startx;
            this.endy = (this.SmallImageHeight * this.dscaleextent) + this.starty;
            this.smallimageloaded = true;
            //draw image on screen for the first time after loading here.

            if(thispage.largeimageloaded){
                thispage.dscale = (thispage.smallimagecnv.width * thispage.dscaleextent) / thispage.largeimagecnv.width;
                thispage.dx = thispage.dxextent;
                thispage.dy = thispage.dyextent;
                thispage.bitmapratio = thispage.dscale / thispage.dscaleextent;
            }else{
                thispage.dscale = thispage.dscaleextent;
                thispage.dx = thispage.dxextent;
                thispage.dy = thispage.dyextent;

                thispage.bitmapratio = 1;
            }



            this.draw_image(true);
            //this.draw_image();

            //drawmarkupAll(cntximg);


        };

        this.checkimageswitch = function () {

            if (this.usedincomposite && this.compositereference != undefined && this.isbackground) {
                if(this.currentimage == 1){
                    var tempfactor = imageswitchfactor;
                }else{
                    tempfactor  = imageswitchfactor / (this.MainImageWidth / this.SmallImageWidth);
                }

                if (this.compositereference.backgroundScale < tempfactor) {
                    this.currentimage = 1;


                } else {
                    this.currentimage = 0;
                    //alert("switching to large image");
                }
                this.startx = this.dx;
                this.starty = this.dy;
                this.endx = (this.MainImageWidth * this.dscale) + this.startx;
                this.endy = (this.MainImageHeight * this.dscale) + this.starty;

            }else{
                if ((this.dscale / thispage.bitmapratio) < imageswitchfactor) {
                    this.currentimage = 1;

                } else {
                    this.currentimage = 0;
                    //alert("switching to large image");
                }
                this.startx = this.dx;
                this.starty = this.dy;
                this.endx = (this.MainImageWidth * this.dscale) + this.startx;
                this.endy = (this.MainImageHeight * this.dscale) + this.starty;
            }

        };
        /*this.checkimageswitch = function () {
            if (this.dscaleextent < imageswitchfactor) {
                this.currentimage = 1;
                this.startx = this.dxextent;
                this.starty = this.dyextent;
                this.endx = (this.SmallImageWidth * this.dscaleextent) + this.startx;
                this.endy = (this.SmallImageHeight * this.dscaleextent) + this.starty;


            } else {
                this.currentimage = 0;
                this.startx = this.dx;
                this.starty = this.dy;
                this.endx = (this.MainImageWidth * this.dscale) + this.startx;
                this.endy = (this.MainImageHeight * this.dscale) + this.starty;

                //alert("switching to large image");
            }

            /*if (this.dscale > 0.3){
             this.currentimage = 0;
             //alert("switching to large image");
             }else{
             this.currentimage = 1;
             }

        };*/

        this.ZoomRealSize = function () {
            //xscale = canvasowidth / thispage.MainImageWidth;
            var originalwidthpx = thispage.MainImageWidth / this.MainImageScaling;
            var originalinch = originalwidthpx / thispage.DPI;
            //assume 96 dpi for canvas
            var canvaswidthpx = originalinch * 96;
            this.dscale = canvaswidthpx / thispage.MainImageWidth;

            /*originalwidthpx = thispage.SmallImageWidth / this.SmallImageScaling;
            originalinch = originalwidthpx / thispage.DPI;
            canvaswidthpx = originalinch * 96;
            this.dscaleextent = canvaswidthpx / this.SmallImageWidth;*/

            this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
            this.dy = 0;

            /*this.dxextent = (canvasowidth - (this.SmallImageWidth * this.dscaleextent)) / 2;
            this.dyextent = 0;*/


        };

        this.getdx = function () {
            if (this.usevectorxml) {
                return this.dxvector;
            } else if (this.usepdfjs) {
                return this.dxpdf;
            } else {
                return this.dx;
            }
        };

        this.getdy = function () {
            if (this.usevectorxml) {
                return this.dyvector;
            } else if (this.usepdfjs) {
                return this.dypdf;
            } else {
                return this.dy;
            }

        };

        this.getdscale = function () {
            if (this.usevectorxml) {
                return this.dscalevector;
            } else if (this.usepdfjs) {
                return this.dscalepdf * this.curpagescale;
            } else {
                return this.dscale;
                /*if (this.currentimage == 0){

                }else{
                    return this.dscaleextent;
                }*/

            }

        };


        this.setpagedim = function(height, width,  x, y ){
            var pgdim = thispage.getpagedim();

            var scalew = width / pgdim.w;
            var scaleh = height / pgdim.h;



            if (scalew > 1){
                thispage.ZoomIn(scalew,true,true);
            }else{
                scalew = 1/scalew;
                thispage.ZoomOut(scalew,true,true);
            }

            thispage.pan_position(x,y);
            //console.log(scaleh, scalew);

        };

        this.getpagedim = function(){
            var dpi = thispage.DPI;
            if (thispage.usepdfjs){
                dpi = 72;
            }

           var pagerect = thispage.getpagerect();

            var pgdim = {
                x : pagerect.x,
                y : pagerect.y,
                w : pagerect.w,
                h : pagerect.h,
                origw : thispage.originalwidth,
                origh : thispage.originalheight,
                scale : thispage.getdscale(),
                dpi : dpi,
                rotation : thispage.drotation
            };

            return pgdim;

        };


        this.redraw = function(){

            if (this.usevectorxml) {
                this.draw_vector(true);
            }else if (this.usepdfjs) {
                thispage.pdfisrendered = false;
                thispage.pdfrenderopque += 1;
            }else{
              this.draw_image(true);
            }

            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

        };



        this.zoomall = function (bexternal) {
            //SetImageDim(myimage);

            if(RxCore_GUI_ZoomUpdate != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();

                var zoomparams = {rect : pagerect};
                RxCore_GUI_ZoomUpdate.zoomUpdate(zoomparams, 3);
            }


            var yscale = this.dscale;
            var xscale = this.dscale;

            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;


                }
            }


            switch (this.drotation) {
                case 0:
                    yscale = canvasoheight / this.MainImageHeight;
                    xscale = canvasowidth / this.MainImageWidth;
                    this.dscale = Math.min(xscale, yscale);

                    break;
                case 90:
                    yscale = canvasoheight / this.MainImageWidth;
                    xscale = canvasowidth / this.MainImageHeight;
                    this.dscale = Math.min(xscale, yscale);

                    break;
                case 180:
                    yscale = canvasoheight / this.MainImageHeight;
                    xscale = canvasowidth / this.MainImageWidth;
                    this.dscale = Math.min(xscale, yscale);

                    break;
                case 270:
                    yscale = canvasoheight / this.MainImageWidth;
                    xscale = canvasowidth / this.MainImageHeight;
                    this.dscale = Math.min(xscale, yscale);

                    break;

            }

            this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
            this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


            if (this.usevectorxml) {
                yscale = this.dyvector;
                xscale = this.dxvector;
                switch (this.drotation) {
                    case 0:
                        yscale = canvasoheight / thispage.VectorPageObj.height;
                        xscale = canvasowidth / thispage.VectorPageObj.width;
                        this.dscalevector = Math.min(xscale, yscale);

                        break;
                    case 90:
                        yscale = canvasoheight / thispage.VectorPageObj.width;
                        xscale = canvasowidth / thispage.VectorPageObj.height;
                        this.dscalevector = Math.min(xscale, yscale);

                        break;
                    case 180:
                        yscale = canvasoheight / thispage.VectorPageObj.height;
                        xscale = canvasowidth / thispage.VectorPageObj.width;
                        this.dscalevector = Math.min(xscale, yscale);

                        break;
                    case 270:
                        yscale = canvasoheight / thispage.VectorPageObj.width;
                        xscale = canvasowidth / thispage.VectorPageObj.height;
                        this.dscalevector = Math.min(xscale, yscale);

                        break;

                }


                this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

            }

            if (this.usepdfjs) {
                yscale = this.dypdf;
                xscale = this.dxpdf;
                switch (this.drotation) {
                    case 0:

                        yscale = canvasoheight / pcanvheight;
                        xscale = canvasowidth / pcanvwidth;

                        this.dscalepdf = Math.min(xscale, yscale);

                        break;
                    case 90:
                        yscale = canvasoheight / pcanvwidth;
                        xscale = canvasowidth / pcanvheight;

                        this.dscalepdf = Math.min(xscale, yscale);

                        break;
                    case 180:
                        yscale = canvasoheight / pcanvheight;
                        xscale = canvasowidth / pcanvwidth;

                        this.dscalepdf = Math.min(xscale, yscale);

                        break;
                    case 270:
                        yscale = canvasoheight / pcanvwidth;
                        xscale = canvasowidth / pcanvheight;

                        this.dscalepdf = Math.min(xscale, yscale);

                        break;

                }

                thispage.pdfisrendered = false;
                thispage.pdfrenderopque += 1;

                this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


            }


            //this.currentimage = 1;
            if (this.usevector3Dxml) {
                return;
            }

            if (!this.usevectorxml) {
                if (this.usepdfjs) {
                    //DocObj.draw_mpagepdf();
                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;
                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.dscalepdf = this.compositereference.getoverlayScaleFactor(3);
                            this.compositereference.scaleToBackground(true);
                        }else{
                            thispage.DocRef.zoomall();
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            //this.dscale = this.compositereference.getoverlayScaleFactor(3);
                            this.compositereference.scaleToBackground(true);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }
            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {
                    //this.dscalevector = this.compositereference.getoverlayScaleFactor(3);
                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }

            }

            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            if(RxCore_GUI_ZoomUpdated != undefined && bexternal == undefined){


                var pagerect = thispage.getpagerect();

                var zoomparams = {rect : pagerect};
                RxCore_GUI_ZoomUpdated.zoomUpdate(zoomparams, 3);


            }


        };

        this.ZoomPageUpdate = function(zoomparams, type){
            switch(type){
                case 0 :
                    thispage.ZoomIn(zoomparams.factor, zoomparams.center,true, zoomparams.mousepos);
                    break;
                case 1 :
                    thispage.ZoomOut(zoomparams.factor, zoomparams.center,true, zoomparams.mousepos);
                    break;
                case 2 :
                    thispage.zoom_update(zoomparams.sx, zoomparams.sy, zoomparams.sWide, zoomparams.sHi,true);
                    //zoom window
                    break;
                case 3 :
                    thispage.zoomall(true);
                    break;
                case 4 :
                    thispage.zoomwidth(true);
                    //zoom width
                    break;
                case 5 :
                    thispage.zoomheight(true);
                    break;

            }
        };



        this.ZoomIn = function (factor, center, bexternal, mousepos) {

            if (this.usevector3Dxml) {
                return;
            }

            if(RxCore_GUI_ZoomUpdate != undefined && bexternal == false ){


                var pagerect = thispage.getpagerect();

                var zoomparams = {factor : factor, center : center, mousepos : mousepos, rect : pagerect};
                RxCore_GUI_ZoomUpdate.zoomUpdate(zoomparams, 0);
            }

            if (mousepos){
                var rotatedpoint = {x:mousepos.x,y:mousepos.y};

                if(thispage.drotation != 0){
                    rotatedpoint = mouse_rotated(mousepos.x,mousepos.y);
                }

                var mouseposdiffx = (((canvasowidth / 2) - rotatedpoint.x) * factor) - ((canvasowidth / 2) - rotatedpoint.x);
                var mouseposdiffy = (((canvasoheight / 2) - rotatedpoint.y) * factor) - ((canvasoheight / 2) - rotatedpoint.y);

            }


            //imagescale

            var prevcenterx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
            var prevcentery = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;

            var diffx = prevcenterx - this.dx;
            var diffy = prevcentery - this.dy;



            this.dscale = this.dscale * factor;
            var centerx = ((canvasowidth - (this.MainImageWidth * this.dscale)) / 2);
            var centery = ((canvasoheight - (this.MainImageHeight * this.dscale)) / 2);

            if (center) {

                this.dx = centerx;
                this.dy = centery;

            } else {
                this.dx = centerx - (diffx * factor);
                this.dy = centery - (diffy * factor);
            }

            if (mousepos){
                this.dx += mouseposdiffx;
                this.dy += mouseposdiffy;
            }

            //vectorscale

            if (this.usevectorxml) {
                var prevcenterxv = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                var prevcenteryv = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                var diffxv = prevcenterxv - this.dxvector;
                var diffyv = prevcenteryv - this.dyvector;


                this.dscalevector = this.dscalevector * factor;

                var centerxv = ((canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2);
                var centeryv = ((canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2);


                if (center) {
                    this.dxvector = centerxv;
                    this.dyvector = centeryv;
                } else {
                    this.dxvector = centerxv - (diffxv * factor);
                    this.dyvector = centeryv - (diffyv * factor);
                }

                if (mousepos){
                    this.dxvector += mouseposdiffx;
                    this.dyvector += mouseposdiffy;

                }

            }
            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;



                }

                var bScaleChanged = false;
                this.bMinzoom = false;
                var prevcenterxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                var prevcenterypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                var diffxpdf = prevcenterxpdf - this.dxpdf;
                var diffypdf = prevcenterypdf - this.dypdf;

                var wscale = ((pcanvwidth * this.dscalepdf) / thispage.pdfpagewidth) * factor;
                var hscale = ((pcanvheight * this.dscalepdf) / thispage.pdfpageheight) * factor;

                var scale = Math.min(wscale, hscale);

                this.dscalepdf = this.dscalepdf * factor;

                bScaleChanged = true;


                /*if (scale < this.nPDFMaxFactor) {
                    this.dscalepdf = this.dscalepdf * factor;
                    bScaleChanged = true;
                    thispage.pdfisrendered = false;
                    this.bMaxzoom = false;
                } else {
                    if (!this.bMaxzoom) {
                        thispage.DocRef.renderPDFscale();
                    }

                    this.bMaxzoom = true;

                }*/


                var centerxpdf = ((canvasowidth - (pcanvwidth * this.dscalepdf)) / 2);
                var centerypdf = ((canvasoheight - (pcanvheight * this.dscalepdf)) / 2);



                if (center) {
                    this.dxpdf = centerxpdf;
                    this.dypdf = centerypdf;
                } else {
                    if (bScaleChanged) {
                        this.dxpdf = centerxpdf - (diffxpdf * factor);
                        this.dypdf = centerypdf - (diffypdf * factor);
                    } else {
                        this.dxpdf = centerxpdf - diffxpdf;
                        this.dypdf = centerypdf - diffypdf;
                    }
                }


                if (pcanvwidth <= canvasowidth) {
                    if (!thispage.DocRef.pagelocked){
                        this.dxpdf = centerxpdf;
                    }
                    var bWidthlocked = true;
                }



                if (pcanvwidth * this.dscalepdf <= canvasowidth) {
                    if (!thispage.DocRef.pagelocked){
                        thispage.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                    }
                    bWidthlocked = true;
                }

                if (mousepos){
                    if(!bWidthlocked || (thispage.DocRef.pagelocked && !bRestrictPan)){
                        this.dxpdf += mouseposdiffx;
                    }

                    this.dypdf += mouseposdiffy;
                }


                if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                    if (this.usedincomposite && this.compositereference != undefined) {
                        //this.compositereference.ZoomIn(factor, center);
                    }else{
                        thispage.DocRef.ZoomIn(factor, center);

                    }


                }
                thispage.pdfrenderopque += 1;
                thispage.pdfisrendered = false;


                //DocObj.draw_mpagepdf();
                //thispage.renderPDFpagescale();
            }
            //vectorscale
            if (this.usevector3Dxml) {
                return;
            }

            if (!this.usevectorxml) {
                if (this.usepdfjs) {

                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.dscalepdf = this.compositereference.getoverlayScaleFactor(0);

                            var overlayoffset = this.compositereference.getoverlayOffsets(0);
                            this.dxpdf = overlayoffset.x;
                            this.dypdf = overlayoffset.y;
                            this.startx = this.dxpdf;
                            this.starty = this.dypdf;
                            this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                            this.endy = (pcanvheight * this.dscalepdf) + this.starty;


                            this.compositereference.scaleToBackground(true);


                        }else{
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            //this.dscale = this.compositereference.getoverlayScaleFactor(0);

                            //var overlayoffset = this.compositereference.getoverlayOffsets(0);
                            //this.dx = overlayoffset.x;
                            //this.dy = overlayoffset.y;


                            this.compositereference.scaleToBackground(true);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }
            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {
                    //this.dscalevector = this.compositereference.getoverlayScaleFactor(0);

                    //var overlayoffset = this.compositereference.getoverlayOffsets(0);

                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }


            }
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            if(RxCore_GUI_ZoomUpdated != undefined && bexternal == false ){

                var pagerect = thispage.getpagerect();

                var zoomparams = {factor : factor, center : center, mousepos : mousepos, rect : pagerect};
                RxCore_GUI_ZoomUpdated.zoomUpdate(zoomparams, 0);
            }


        };

        this.getBlockCentroid = function(blockId){
            if (this.usevectorxml) {
                var centroid = thispage.VectorPageObj.getblockcentroid(blockId,thispage.dscalevector, thispage.dxvector, thispage.dyvector);
            }
             return centroid;

        };
        this.ZoomToBlock = function(blockId){

            if (this.usevectorxml) {
                var zoomrect = thispage.VectorPageObj.getBlockRect(blockId,thispage.dscalevector, thispage.dxvector, thispage.dyvector);
                if(zoomrect.found){
                    this.zoom_update(zoomrect.x - zoomrect.wp, zoomrect.y - zoomrect.hp, zoomrect.w + (zoomrect.wp*2),zoomrect.h + (zoomrect.hp*2));
                }
            }

            /*return  {
                found : true,
                x : minx,
                y : miny,
                w : maxx - minx,
                h : maxy - miny,
                wp : (maxx - minx) / 10,
                hp : (maxy - miny) / 10
            };*/


        };

        this.ZoomOutTest = function(factor, center, mousepos){

            if (this.usevector3Dxml) {
                return;
            }

            if (mousepos){
                var rotatedpoint = {x:mousepos.x,y:mousepos.y};

                if(thispage.drotation != 0){
                    rotatedpoint = mouse_rotated(mousepos.x,mousepos.y);
                }

                var mouseposdiffx = (((canvasowidth / 2) - rotatedpoint.x) / factor) - ((canvasowidth / 2) - rotatedpoint.x);
                var mouseposdiffy = (((canvasoheight / 2) - rotatedpoint.y) / factor) - ((canvasoheight / 2) - rotatedpoint.y);
            }

            var prevcenterx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
            var prevcentery = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;

            var diffx = prevcenterx - this.dx;
            var diffy = prevcentery - this.dy;

            var localdscale = this.dscale / factor;

            var centerx = (canvasowidth - (this.MainImageWidth * localdscale)) / 2;
            var centery = (canvasoheight - (this.MainImageHeight * localdscale)) / 2;


            if (center) {
                var localdx = centerx;
                var localdy = centery;
            } else {
                localdx = centerx - (diffx / factor);
                localdy = centery - (diffy / factor);
            }

            if (mousepos){
                localdx += mouseposdiffx;
                localdy += mouseposdiffy;
            }

            if (this.usevectorxml) {
                var prevcenterxv = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                var prevcenteryv = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                var diffxv = prevcenterxv - this.dxvector;
                var diffyv = prevcenteryv - this.dyvector;


                var localdscalevector = this.dscalevector / factor;

                var centerxv = ((canvasowidth - (thispage.VectorPageObj.width * localdscalevector)) / 2);
                var centeryv = ((canvasoheight - (thispage.VectorPageObj.height * localdscalevector)) / 2);


                if (center) {
                    var localdxvector = centerxv;
                    var localdyvector = centeryv;
                } else {
                    localdxvector = centerxv - (diffxv / factor);
                    localdyvector = centeryv - (diffyv / factor);
                }
                if (mousepos){
                    localdxvector += mouseposdiffx;
                    localdyvector += mouseposdiffy;
                }

            }
            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;


                }
                var prevcenterxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                var prevcenterypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                var diffxpdf = prevcenterxpdf - this.dxpdf;
                var diffypdf = prevcenterypdf - this.dypdf;
                var tempdx = this.dxpdf;
                var tempdy = this.dypdf;

                var yscale = canvasoheight / pcanvheight;
                var xscale = canvasowidth / pcanvwidth;
                var dscale = Math.min(xscale, yscale);

                var wscale = ((pcanvwidth * this.dscalepdf) / thispage.pdfpagewidth) * factor;
                var hscale = ((pcanvheight * this.dscalepdf) / thispage.pdfpageheight) * factor;
                var scale = Math.min(wscale, hscale);

                /*if (scale < this.nPDFMaxFactor) {
                    this.bMaxzoom = false;
                    //console.log('maxzoom ' + this.bMaxzoom);
                } else {
                    if (!this.bMaxzoom) {
                        thispage.DocRef.renderPDFscale();
                    }

                    this.bMaxzoom = true;
                    //console.log('maxzoom ' + this.bMaxzoom);
                }*/

                //01.11.2018 disabled for new zoom control

                var singlepage = (thispage.DocRef.pages.length == 1);
                if ((thispage.usedincomposite && thispage.compositereference != undefined) || singlepage){
                    var localdscalepdf = this.dscalepdf / factor;
                    this.bMinzoom = false;
                }else{


                    if (this.dscalepdf / factor < dscale) {
                        localdscalepdf = dscale;
                        //this.bMinzoom = true;
                    } else {
                        localdscalepdf = this.dscalepdf / factor;
                        //this.bMinzoom = false;
                        //thispage.pdfisrendered = false;
                    }
                }

                var centerxpdf = ((canvasowidth - (pcanvwidth * this.dscalepdf)) / 2);
                var centerypdf = ((canvasoheight - (pcanvheight * this.dscalepdf)) / 2);

                if (center) {
                    var localdxpdf = centerxpdf;
                    var localdypdf = centerypdf;
                } else {
                    localdxpdf = centerxpdf - (diffxpdf / factor);
                    localdypdf = centerypdf - (diffypdf / factor);
                }
                if (pcanvwidth <= canvasowidth) {
                    localdxpdf = centerxpdf;
                    var bWidthlocked = true;
                }
                if (pcanvwidth * this.dscalepdf <= canvasowidth) {
                    localdxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                    bWidthlocked = true;
                }
                if (mousepos){
                    if(!bWidthlocked){
                        localdxpdf += mouseposdiffx;
                    }

                    localdypdf += mouseposdiffy;

                }





            }


            if (!this.usevectorxml) {
                if (this.usepdfjs) {
                    var localstartx = localdxpdf;
                    var localstarty = localdypdf;
                    var localendx = (pcanvwidth * localdscalepdf) + localstartx;
                    var localendy = (pcanvheight * localdscalepdf) + localstarty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            localdscalepdf = this.compositereference.getoverlayScaleFactor(1);
                            var overlayoffset = this.compositereference.getoverlayOffsets(1);
                            localdxpdf = overlayoffset.x;
                            localdypdf = overlayoffset.y;
                            localstartx = localdxpdf;
                            localstarty = localdypdf;
                            localendx = (pcanvwidth * localdscalepdf) + localstartx;
                            localendy = (pcanvheight * localdscalepdf) + localstarty;

                        }else{

                        }

                    }

                } else {



                }
            } else {
                localstartx = localdxvector;
                localstarty = localdyvector;

                localendx = (thispage.VectorPageObj.width * localdscalevector) + localstartx;
                localendy = (thispage.VectorPageObj.height * localdscalevector) + localstarty;

            }

            //new method to work on local start and end variables.
            var pagerect = thispage.getpagetestrect({startx : localstartx, starty : localstarty, endx : localendx, endy : localendy});

            return pagerect;
            //var rotrect = {x1:rect.startx,y1: rect.starty,x2: rect.endx,y2:rect.endy};


        };


        this.ZoomOut = function (factor, center,bexternal,mousepos) {

            if (this.usevector3Dxml) {
                return;
            }

            if(RxCore_GUI_ZoomUpdate != undefined && bexternal == false){

                var pagerect = thispage.getpagerect();

                var zoomparams = {factor : factor, center : center, mousepos : mousepos, rect : pagerect};
                RxCore_GUI_ZoomUpdate.zoomUpdate(zoomparams, 1);
            }

            if (mousepos){

                var rotatedpoint = {x:mousepos.x,y:mousepos.y};

                if(thispage.drotation != 0){
                    rotatedpoint = mouse_rotated(mousepos.x,mousepos.y);
                }


                var mouseposdiffx = (((canvasowidth / 2) - rotatedpoint.x) / factor) - ((canvasowidth / 2) - rotatedpoint.x);
                var mouseposdiffy = (((canvasoheight / 2) - rotatedpoint.y) / factor) - ((canvasoheight / 2) - rotatedpoint.y);

            }


            var prevcenterx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
            var prevcentery = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;

            var diffx = prevcenterx - this.dx;
            var diffy = prevcentery - this.dy;

            this.dscale = this.dscale / factor;

            var centerx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
            var centery = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


            if (center) {
                this.dx = centerx;
                this.dy = centery;
            } else {
                this.dx = centerx - (diffx / factor);
                this.dy = centery - (diffy / factor);
            }

            if (mousepos){
                this.dx += mouseposdiffx;
                this.dy += mouseposdiffy;
            }

            if (this.usevectorxml) {
                var prevcenterxv = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                var prevcenteryv = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                var diffxv = prevcenterxv - this.dxvector;
                var diffyv = prevcenteryv - this.dyvector;


                this.dscalevector = this.dscalevector / factor;

                var centerxv = ((canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2);
                var centeryv = ((canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2);


                if (center) {
                    this.dxvector = centerxv;
                    this.dyvector = centeryv;
                } else {
                    this.dxvector = centerxv - (diffxv / factor);
                    this.dyvector = centeryv - (diffyv / factor);
                }
                if (mousepos){
                    this.dxvector += mouseposdiffx;
                    this.dyvector += mouseposdiffy;


                }

            }
            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;


                }
                var prevcenterxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                var prevcenterypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                var diffxpdf = prevcenterxpdf - this.dxpdf;
                var diffypdf = prevcenterypdf - this.dypdf;
                var tempdx = this.dxpdf;
                var tempdy = this.dypdf;

                var yscale = canvasoheight / pcanvheight;
                var xscale = canvasowidth / pcanvwidth;
                var dscale = Math.min(xscale, yscale);

                var wscale = ((pcanvwidth * this.dscalepdf) / thispage.pdfpagewidth) * factor;
                var hscale = ((pcanvheight * this.dscalepdf) / thispage.pdfpageheight) * factor;
                var scale = Math.min(wscale, hscale);

                /*if (scale < this.nPDFMaxFactor) {
                    this.bMaxzoom = false;
                    //console.log('maxzoom ' + this.bMaxzoom);
                } else {
                    if (!this.bMaxzoom) {
                        thispage.DocRef.renderPDFscale();
                    }

                    this.bMaxzoom = true;
                    //console.log('maxzoom ' + this.bMaxzoom);
                }*/

                //01.11.2018 disabled for new zoom control

                var singlepage = (thispage.DocRef.pages.length == 1);
                if ((thispage.usedincomposite && thispage.compositereference != undefined) || singlepage){
                    this.dscalepdf = this.dscalepdf / factor;
                    this.bMinzoom = false;
                }else{


                    if (this.dscalepdf / factor < dscale) {
                        this.dscalepdf = dscale;
                        this.bMinzoom = true;
                    } else {
                        this.dscalepdf = this.dscalepdf / factor;
                        this.bMinzoom = false;
                        //thispage.pdfisrendered = false;
                    }
                }

                var centerxpdf = ((canvasowidth - (pcanvwidth * this.dscalepdf)) / 2);
                var centerypdf = ((canvasoheight - (pcanvheight * this.dscalepdf)) / 2);

                if (center) {
                    this.dxpdf = centerxpdf;
                    this.dypdf = centerypdf;
                } else {
                    this.dxpdf = centerxpdf - (diffxpdf / factor);
                    this.dypdf = centerypdf - (diffypdf / factor);
                }
                if (pcanvwidth <= canvasowidth) {
                    if(!thispage.DocRef.pagelocked){
                        this.dxpdf = centerxpdf;
                    }

                    var bWidthlocked = true;
                }
                if (pcanvwidth * this.dscalepdf <= canvasowidth) {
                    if(!thispage.DocRef.pagelocked){
                        thispage.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                    }
                    bWidthlocked = true;
                }
                if (mousepos){
                    if(!bWidthlocked || (thispage.DocRef.pagelocked && !bRestrictPan)){
                        this.dxpdf += mouseposdiffx;
                    }

                    this.dypdf += mouseposdiffy;
                }

                if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                    if (this.usedincomposite && this.compositereference != undefined) {
                        //this.compositereference.ZoomOut(factor, center);
                    }else{
                        thispage.DocRef.ZoomOut(factor, center,false);
                    }

                }

                //DocObj.draw_mpagepdf();
                //thispage.renderPDFpagescale();
                thispage.pdfrenderopque += 1;
                thispage.pdfisrendered = false;
            }


            if (!this.usevectorxml) {
                if (this.usepdfjs) {
                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.dscalepdf = this.compositereference.getoverlayScaleFactor(1);
                            var overlayoffset = this.compositereference.getoverlayOffsets(1);
                            this.dxpdf = overlayoffset.x;
                            this.dypdf = overlayoffset.y;
                            this.startx = this.dxpdf;
                            this.starty = this.dypdf;
                            this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                            this.endy = (pcanvheight * this.dscalepdf) + this.starty;


                            this.compositereference.scaleToBackground(true);

                        }else{
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            //this.dscale = this.compositereference.getoverlayScaleFactor(1);
                            this.compositereference.scaleToBackground(true);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }
            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {
                    //this.dscalevector = this.compositereference.getoverlayScaleFactor(1);
                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }


            }

            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            if(RxCore_GUI_ZoomUpdated != undefined && bexternal == false){

                var pagerect = thispage.getpagerect();

                var zoomparams = {factor : factor, center : center, mousepos : mousepos, rect : pagerect};
                RxCore_GUI_ZoomUpdated.zoomUpdate(zoomparams, 1);
            }


        };


        this.zoomwidth = function (bexternal) {

            if(RxCore_GUI_ZoomUpdate != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();

                var zoomparams = {rect : pagerect};

                RxCore_GUI_ZoomUpdate.zoomUpdate(zoomparams, 4);
            }


            var xscale = 0.0;

            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;


                }

            }

            switch (this.drotation) {
                case 0:
                    xscale = canvasowidth / this.MainImageWidth;
                    this.dscale = xscale;


                    if (this.usevectorxml) {
                        xscale = canvasowidth / thispage.VectorPageObj.width;
                        this.dscalevector = xscale;

                    } else if (this.usepdfjs) {

                        xscale = canvasowidth / pcanvwidth;
                        this.dscalepdf = xscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;

                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;

                    }


                    break;
                case 90:

                    xscale = canvasowidth / this.MainImageHeight;
                    this.dscale = xscale;


                    if (this.usevectorxml) {
                        xscale = canvasowidth / thispage.VectorPageObj.height;
                        this.dscalevector = xscale;

                    } else if (this.usepdfjs) {
                        xscale = canvasowidth / pcanvheight;
                        this.dscalepdf = xscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                    }


                    break;
                case 180:
                    xscale = canvasowidth / this.MainImageWidth;
                    this.dscale = xscale;

                    if (this.usevectorxml) {
                        xscale = canvasowidth / thispage.VectorPageObj.width;
                        this.dscalevector = xscale;

                    } else if (this.usepdfjs) {
                        xscale = canvasowidth / pcanvwidth;
                        this.dscalepdf = xscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                    }


                    break;
                case 270:
                    xscale = canvasowidth / this.MainImageHeight;
                    this.dscale = xscale;

                    if (this.usevectorxml) {
                        xscale = canvasowidth / thispage.VectorPageObj.height;
                        this.dscalevector = xscale;

                    } else if (this.usepdfjs) {
                        xscale = canvasowidth / pcanvheight;
                        this.dscalepdf = xscale;
                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;

                    }


                    break;
                default:
                    xscale = canvasowidth / this.MainImageWidth;
                    this.dscale = xscale;


                    if (this.usevectorxml) {
                        xscale = canvasowidth / thispage.VectorPageObj.width;
                        this.dscalevector = xscale;

                    } else if (this.usepdfjs) {
                        xscale = canvasowidth / pcanvwidth;
                        this.dscalepdf = xscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                    }


                    break;

            }
            if (this.usevector3Dxml) {
                return;
            }

            if (!this.usevectorxml) {
                if (this.usepdfjs) {
                    //DocObj.draw_mpagepdf();
                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.dscalepdf = this.compositereference.getoverlayScaleFactor(4);
                            this.compositereference.scaleToBackground(true);
                        }else{
                            thispage.DocRef.zoomwidth();
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            //this.dscale = this.compositereference.getoverlayScaleFactor(4);
                            this.compositereference.scaleToBackground(true);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }

            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {
                    //this.dscalevector = this.compositereference.getoverlayScaleFactor(4);
                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }


            }

            if (this.usepdfjs) {
                thispage.pdfrenderopque += 1;
                thispage.pdfisrendered = false;
            }

            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            if(RxCore_GUI_ZoomUpdated != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();

                var zoomparams = {rect : pagerect};

                RxCore_GUI_ZoomUpdated.zoomUpdate(zoomparams, 4);
            }


        };

        this.zoomheight = function (bexternal) {

            if(RxCore_GUI_ZoomUpdate != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();
                var zoomparams = {rect : pagerect};
                RxCore_GUI_ZoomUpdate.zoomUpdate(zoomparams, 5);
            }

            var yscale = 0.0;

            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;

                }

            }

            switch (this.drotation) {
                case 0:
                    yscale = canvasoheight / this.MainImageHeight;
                    this.dscale = yscale;


                    if (this.usevectorxml) {
                        yscale = canvasoheight / thispage.VectorPageObj.height;
                        this.dscalevector = yscale;

                    } else if (this.usepdfjs) {
                        yscale = canvasoheight / pcanvheight;
                        this.dscalepdf = yscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;

                    }

                    break;
                case 90:
                    yscale = canvasoheight / this.MainImageWidth;
                    this.dscale = yscale;

                    if (this.usevectorxml) {
                        yscale = canvasoheight / thispage.VectorPageObj.width;
                        this.dscalevector = yscale;

                    } else if (this.usepdfjs) {
                        yscale = canvasoheight / pcanvwidth;
                        this.dscalepdf = yscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                    }


                    break;
                case 180:
                    yscale = canvasoheight / this.MainImageHeight;
                    this.dscale = yscale;

                    if (this.usevectorxml) {
                        yscale = canvasoheight / thispage.VectorPageObj.height;
                        this.dscalevector = yscale;

                    } else if (this.usepdfjs) {
                        yscale = canvasoheight / pcanvheight;
                        this.dscalepdf = yscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;

                    }


                    break;
                case 270:
                    yscale = canvasoheight / this.MainImageWidth;
                    this.dscale = yscale;


                    if (this.usevectorxml) {
                        yscale = canvasoheight / thispage.VectorPageObj.width;
                        this.dscalevector = yscale;

                    } else if (this.usepdfjs) {

                        yscale = canvasoheight / pcanvwidth;
                        this.dscalepdf = yscale;

                    }


                    this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                    this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;


                    if (this.usevectorxml) {
                        this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                        this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

                    } else if (this.usepdfjs) {
                        this.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        this.dypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;

                    }

                    break;

            }
            if (this.usevector3Dxml) {
                return;
            }


            if (!this.usevectorxml) {
                if (this.usepdfjs) {
                    //DocObj.draw_mpagepdf();
                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.dscalepdf = this.compositereference.getoverlayScaleFactor(5);
                            this.compositereference.scaleToBackground(true);

                        }else{
                            thispage.DocRef.zoomheight();
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            //this.dscale = this.compositereference.getoverlayScaleFactor(5);
                            this.compositereference.scaleToBackground(true);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }

            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {
                    //this.dscalevector = this.compositereference.getoverlayScaleFactor(5);
                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }


            }

            if (this.usepdfjs) {
                thispage.pdfrenderopque += 1;
                thispage.pdfisrendered = false;
            }

            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            if(RxCore_GUI_ZoomUpdated != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();

                var zoomparams = {rect : pagerect};
                RxCore_GUI_ZoomUpdated.zoomUpdate(zoomparams, 5);
            }


        };

        this.mtzoom_update = function (diagdiff, startscalelarge, startscalesmall) {

            //change to calculate change factor and maintain centre the same way as with zoom in and out.

            //image
            var curdiffh = (startscalelarge * this.MainImageHeight) - canvasoheight;
            var currdiffw = (startscalelarge * this.MainImageWidth) - canvasowidth;

            var mainimagediag = Math.sqrt((Math.pow(this.MainImageHeight, 2) + Math.pow(this.MainImageWidth, 2)));
            var canvasdiag = Math.sqrt((Math.pow(canvasoheight, 2) + Math.pow(canvasowidth, 2)));

            var curdiagdiff = (startscalelarge * mainimagediag) - canvasdiag;

            this.dscale = (canvasdiag + curdiagdiff + diagdiff) / mainimagediag;



            //vector

            if (this.usevectorxml) {
                curdiffh = (startscalesmall * thispage.VectorPageObj.height) - canvasoheight;
                currdiffw = (startscalesmall * thispage.VectorPageObj.width) - canvasowidth;
                var vectordiag = Math.sqrt((Math.pow(thispage.VectorPageObj.height, 2) + Math.pow(thispage.VectorPageObj.width, 2)));

                curdiagdiff = (startscalesmall * vectordiag) - canvasdiag;

                this.dscalevector = (canvasdiag + curdiagdiff + diagdiff) / vectordiag;

            }
            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;

                }

                curdiffh = (startscalesmall * pcanvheight) - canvasoheight;
                currdiffw = (startscalesmall * pcanvwidth) - canvasowidth;
                var pdfdiag = Math.sqrt((Math.pow(pcanvheight, 2) + Math.pow(pcanvheight, 2)));


                curdiagdiff = (startscalesmall * pdfdiag) - canvasdiag;

                this.dscalepdf = (canvasdiag + curdiagdiff + diagdiff) / pdfdiag;
                thispage.pdfrenderopque += 1;
                thispage.pdfisrendered = false;

                //thispage.renderPDFpagescale();

            }

            if (this.usevector3Dxml) {
                return;
            }

            if (!this.usevectorxml) {
                if (this.usepdfjs) {
                    //DocObj.draw_mpagepdf();
                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth) + this.startx;
                    this.endy = (pcanvheight) + this.starty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.compositereference.scaleToBackground(true);

                        }else{
                            thispage.DocRef.draw_mpagepdf();
                        }


                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.compositereference.scaleToBackground(true);

                        } else {
                            this.draw_image(true);
                        }

                    }

                }

            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {

                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }


            }


            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);
            //context.clearRect(0, 0, canvas.width, canvas.height);

        };

        this.getRotatedPoint = function (width, height, x, y, anglerad) {
            var cosangle = Math.cos(anglerad);
            var sinangle = Math.sin(anglerad);

            var hw = x - width;
            var hh = y - height;

            var newx = (hw * cosangle) - (hh * sinangle);
            var newy = (hw * sinangle) + (hh * cosangle);

            var transpoint = new point(newx, newy);
            transpoint.x = width + transpoint.x;
            transpoint.y = height + transpoint.y;
            return transpoint;

        };


        this.zoom_update = function (sx, sy, sWide, sHi, bexternal) {

            if(RxCore_GUI_ZoomUpdate != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();
                var zoomparams = {sx : sx, sy : sy, sWide : sWide, sHi: sHi, rect : pagerect};

                RxCore_GUI_ZoomUpdate.zoomUpdate(zoomparams, 2);
            }

            var newscale = 1.0;
            var newscaleext = 1.0;
            var newscalev = 1.0;
            var newscalepdf = 1.0;
            var factor = 0.0;

            var pointXtoCenter = 0;
            var pointYtoCenter = 0;


            var canvdiv2H = canvasoheight / 2;
            var canvdiv2W = canvasowidth / 2;
            var CanvRotRad = this.drotation * (Math.PI / 180);


            //point to align to centre in display coordinates.
            var rectCenterX = sx + (sWide / 2);
            var rectCenterY = sy + (sHi / 2);

            var ox1 = sx / this.dscale;
            var oy1 = sy / this.dscale;
            var ox2 = (sx + sWide) / this.dscale;
            var oy2 = (sy + sHi) / this.dscale;
            var hscale = sHi / this.dscale;
            var wscale = sWide / this.dscale;

            var ox1v = sx / this.dscalevector;
            var oy1v = sy / this.dscalevector;
            var ox2v = (sx + sWide) / this.dscalevector;
            var oy2v = (sy + sHi) / this.dscalevector;
            var hscalev = sHi / this.dscalevector;
            var wscalev = sWide / this.dscalevector;

            var ox1pdf = sx / this.dscalepdf;
            var oy1pdf = sy / this.dscalepdf;
            var ox2pdf = (sx + sWide) / this.dscalepdf;
            var oy2pdf = (sy + sHi) / this.dscalepdf;
            var hscalepdf = sHi / this.dscalepdf;
            var wscalepdf = sWide / this.dscalepdf;


            var yscale = canvasoheight / this.MainImageHeight;
            var xscale = canvasowidth / this.MainImageWidth;
            var imagescaleheight = this.MainImageHeight * this.dscale;

            if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;


                }

            }


            switch (this.drotation) {
                case 90:

                    pointXtoCenter = rectCenterX - canvdiv2W;
                    pointYtoCenter = rectCenterY - canvdiv2H;

                    if (!this.usepdfjs) {
                        //move point to center
                        // x = y direction for 90 degrees

                        oy1 = (this.dy + pointXtoCenter);
                        ox1 = (this.dx - pointYtoCenter);


                        oy1v = (this.dyvector + pointXtoCenter);
                        ox1v = (this.dxvector - pointYtoCenter);

                        this.dx = ox1;
                        this.dy = oy1;

                        this.dxvector = ox1v;
                        this.dyvector = oy1v;

                        if (hscale > 0 && wscale > 0) {
                            yscale = this.dscale * canvasoheight / sHi;
                            xscale = this.dscale * canvasowidth / sWide;
                        }
                        newscale = Math.min(yscale, xscale);


                        if (hscalev > 0 && wscalev > 0) {
                            yscale = this.dscalevector * canvasoheight / sHi;
                            xscale = this.dscalevector * canvasowidth / sWide;

                        }
                        newscalev = Math.min(yscale, xscale);

                        factor = newscale / this.dscale;
                        if (this.usevectorxml) {
                            factor = newscalev / this.dscalevector;
                        }

                        this.ZoomIn(factor, false, false);

                    } else {
                        //ox1pdf = +((rectCenterX+this.dypdf)/this.dscalepdf);
                        //oy1pdf = -((rectCenterY-this.dxpdf)/this.dscalepdf);
                        pointXtoCenter = rectCenterX - canvdiv2W;
                        pointYtoCenter = rectCenterY - canvdiv2H;


                        oy1pdf = (this.dypdf + rectCenterX) - canvdiv2W;
                        ox1pdf = (this.dxpdf - rectCenterY) + canvdiv2H;

                        this.dxpdf = ox1pdf;
                        this.dypdf = oy1pdf;


                        if (hscalepdf > 0 && wscalepdf > 0) {
                            yscale = this.dscalepdf * canvasoheight / sHi;
                            xscale = this.dscalepdf * canvasowidth / sWide;

                        }

                        newscalepdf = Math.min(yscale, xscale);
                        factor = newscalepdf / this.dscalepdf;

                        var prevcenterxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        var prevcenterypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                        var diffxpdf = prevcenterxpdf - this.dxpdf;
                        var diffypdf = prevcenterypdf - this.dypdf;

                        this.dscalepdf = newscalepdf;

                        var centerxpdf = ((canvasowidth - (pcanvwidth * this.dscalepdf)) / 2);
                        var centerypdf = ((canvasoheight - (pcanvheight * this.dscalepdf)) / 2);


                        this.dxpdf = centerxpdf - (diffxpdf * factor);
                        this.dypdf = centerypdf - (diffypdf * factor);


                    }


                    break;
                case 270:
                    if (this.usepdfjs) {
                        pointXtoCenter = rectCenterX - canvdiv2W;
                        pointYtoCenter = rectCenterY - canvdiv2H;


                        oy1pdf = (this.dypdf - rectCenterX) + canvdiv2W;
                        ox1pdf = (this.dxpdf + rectCenterY) - canvdiv2H;

                        this.dxpdf = ox1pdf;
                        this.dypdf = oy1pdf;


                        if (hscalepdf > 0 && wscalepdf > 0) {
                            yscale = this.dscalepdf * canvasoheight / sHi;
                            xscale = this.dscalepdf * canvasowidth / sWide;

                        }

                        newscalepdf = Math.min(yscale, xscale);
                        factor = newscalepdf / this.dscalepdf;

                        prevcenterxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        prevcenterypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                        diffxpdf = prevcenterxpdf - this.dxpdf;
                        diffypdf = prevcenterypdf - this.dypdf;

                        this.dscalepdf = newscalepdf;

                        centerxpdf = ((canvasowidth - (pcanvwidth * this.dscalepdf)) / 2);
                        centerypdf = ((canvasoheight - (pcanvheight * this.dscalepdf)) / 2);

                        this.dxpdf = centerxpdf - (diffxpdf * factor);
                        this.dypdf = centerypdf - (diffypdf * factor);

                    } else {
                        //move point to center
                        // x = y direction for 270 degrees
                        pointXtoCenter = rectCenterX - canvdiv2W;
                        pointYtoCenter = rectCenterY - canvdiv2H;

                        oy1 = (this.dy - pointXtoCenter);
                        ox1 = (this.dx + pointYtoCenter);

                        oy1v = (this.dyvector - pointXtoCenter);
                        ox1v = (this.dxvector + pointYtoCenter);

                        ox1pdf = (this.dypdf - pointXtoCenter);
                        oy1pdf = (this.dxpdf + pointYtoCenter);


                        this.dx = ox1;
                        this.dy = oy1;

                        this.dxvector = ox1v;
                        this.dyvector = oy1v;

                        this.dxpdf = ox1pdf;
                        this.dypdf = oy1pdf;


                        if (hscale > 0 && wscale > 0) {
                            yscale = this.dscale * canvasoheight / sHi;
                            xscale = this.dscale * canvasowidth / sWide;
                        }
                        newscale = Math.min(yscale, xscale);


                        if (hscalev > 0 && wscalev > 0) {
                            yscale = this.dscalevector * canvasoheight / sHi;
                            xscale = this.dscalevector * canvasowidth / sWide;
                        }
                        newscalev = Math.min(yscale, xscale);

                        if (hscalepdf > 0 && wscalepdf > 0) {
                            yscale = this.dscalepdf * canvasoheight / sHi;
                            xscale = this.dscalepdf * canvasowidth / sWide;

                        }
                        newscalepdf = Math.min(yscale, xscale);


                        factor = newscale / this.dscale;
                        if (this.usevectorxml) {
                            factor = newscalev / this.dscalevector;
                        }
                        if (this.usepdfjs) {
                            factor = newscalepdf / this.dscalepdf;
                        }


                        this.ZoomIn(factor, false, false);
                    }

                    break;

                case 180:
                    if (this.usepdfjs) {
                        pointXtoCenter = rectCenterX - canvdiv2W;
                        pointYtoCenter = rectCenterY - canvdiv2H;


                        oy1pdf = (this.dypdf + rectCenterY) - canvdiv2H;
                        ox1pdf = (this.dxpdf + rectCenterX) - canvdiv2W;

                        this.dxpdf = ox1pdf;
                        this.dypdf = oy1pdf;


                        if (hscalepdf > 0 && wscalepdf > 0) {
                            yscale = this.dscalepdf * canvasoheight / sHi;
                            xscale = this.dscalepdf * canvasowidth / sWide;

                        }
                        newscalepdf = Math.min(yscale, xscale);
                        factor = newscalepdf / this.dscalepdf;

                        prevcenterxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        prevcenterypdf = (canvasoheight - (pcanvheight * this.dscalepdf)) / 2;


                        diffxpdf = prevcenterxpdf - this.dxpdf;
                        diffypdf = prevcenterypdf - this.dypdf;

                        this.dscalepdf = newscalepdf;

                        centerxpdf = ((canvasowidth - (pcanvwidth * this.dscalepdf)) / 2);
                        centerypdf = ((canvasoheight - (pcanvheight * this.dscalepdf)) / 2);


                        this.dxpdf = centerxpdf - (diffxpdf * factor);
                        this.dypdf = centerypdf - (diffypdf * factor);
                    } else {
                        //move point to center
                        pointXtoCenter = rectCenterX - canvdiv2W;
                        pointYtoCenter = rectCenterY - canvdiv2H;

                        oy1 = (this.dy + pointYtoCenter);
                        ox1 = (this.dx + pointXtoCenter);

                        oy1v = (this.dyvector + pointYtoCenter);
                        ox1v = (this.dxvector + pointXtoCenter);

                        ox1pdf = (this.dypdf + pointYtoCenter);
                        oy1pdf = (this.dxpdf + pointXtoCenter);


                        this.dx = ox1;
                        this.dy = oy1;

                        this.dxvector = ox1v;
                        this.dyvector = oy1v;

                        this.dxpdf = ox1pdf;
                        this.dypdf = oy1pdf;


                        if (hscale > 0 && wscale > 0) {
                            yscale = this.dscale * canvasoheight / sHi;
                            xscale = this.dscale * canvasowidth / sWide;
                        }
                        newscale = Math.min(yscale, xscale);

                        if (hscalev > 0 && wscalev > 0) {
                            yscale = this.dscalevector * canvasoheight / sHi;
                            xscale = this.dscalevector * canvasowidth / sWide;
                        }
                        newscalev = Math.min(yscale, xscale);

                        if (hscalepdf > 0 && wscalepdf > 0) {
                            yscale = this.dscalepdf * canvasoheight / sHi;
                            xscale = this.dscalepdf * canvasowidth / sWide;

                        }
                        newscalepdf = Math.min(yscale, xscale);


                        factor = newscale / this.dscale;
                        if (this.usevectorxml) {
                            factor = newscalev / this.dscalevector;
                        }
                        if (this.usepdfjs) {
                            factor = newscalepdf / this.dscalepdf;
                        }

                        this.ZoomIn(factor, false, false);
                    }


                    break;
                case 0:

                    //offset in current scale
                    ox1 = -((rectCenterX - this.dx) / this.dscale);
                    oy1 = -((rectCenterY - this.dy) / this.dscale);

                    ox1v = -((rectCenterX - this.dxvector) / this.dscalevector);
                    oy1v = -((rectCenterY - this.dyvector) / this.dscalevector);

                    ox1pdf = -((rectCenterX - this.dxpdf) / this.dscalepdf);
                    oy1pdf = -((rectCenterY - this.dypdf) / this.dscalepdf);


                    if (hscale > 0 && wscale > 0) {
                        yscale = this.dscale * canvasoheight / sHi;
                        xscale = this.dscale * canvasowidth / sWide;
                    }
                    this.dscale = Math.min(yscale, xscale);

                    this.dx = (ox1 * this.dscale) + (canvasowidth / 2);
                    this.dy = (oy1 * this.dscale) + (canvasoheight / 2);


                    if (hscalev > 0 && wscalev > 0) {
                        yscale = this.dscalevector * canvasoheight / sHi;
                        xscale = this.dscalevector * canvasowidth / sWide;
                    }
                    this.dscalevector = Math.min(yscale, xscale);

                    this.dxvector = (ox1v * this.dscalevector) + (canvasowidth / 2);
                    this.dyvector = (oy1v * this.dscalevector) + (canvasoheight / 2);

                    if (hscalepdf > 0 && wscalepdf > 0) {
                        yscale = this.dscalepdf * canvasoheight / sHi;
                        xscale = this.dscalepdf * canvasowidth / sWide;

                    }
                    this.dscalepdf = Math.min(yscale, xscale);

                    this.dxpdf = (ox1pdf * this.dscalepdf) + (canvasowidth / 2);
                    this.dypdf = (oy1pdf * this.dscalepdf) + (canvasoheight / 2);


                    break;

            }


            //context.clearRect(0, 0, canvas.width, canvas.height);
            if (this.usevector3Dxml) {
                return;
            }

            if (!this.usevectorxml) {
                if (this.usepdfjs) {

                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.dscalepdf = this.compositereference.getoverlayScaleFactor(2);
                            this.compositereference.scaleToBackground(true);

                        }else{
                            thispage.DocRef.zoom_update(sx, sy, sWide, sHi);
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            //this.dscale = this.compositereference.getoverlayScaleFactor(2);
                            this.compositereference.scaleToBackground(true);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }

            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {
                    //this.dscalevector = this.compositereference.getoverlayScaleFactor(2);
                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }


            }
            if (this.usepdfjs) {
                thispage.pdfrenderopque += 1;
                thispage.pdfisrendered = false;
            }

            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            if(RxCore_GUI_ZoomUpdated != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();

                var zoomparams = {sx : sx, sy : sy, sWide : sWide, sHi: sHi, rect : pagerect};

                RxCore_GUI_ZoomUpdated.zoomUpdate(zoomparams, 2);
            }



        };


        this.MarkupFind = function (SearchExpr) {
            var textfound = false;
            while (this.CurrentMarkup < thispage.DocRef.nummarkups && !textfound) {
                if (thispage.DocRef.markuplist[this.CurrentMarkup].FindText(SearchExpr)) {
                    textfound = true;
                    this.zoomall();
                    var hscaled = thispage.DocRef.markuplist[this.CurrentMarkup].hscaled;
                    var wscaled = thispage.DocRef.markuplist[this.CurrentMarkup].wscaled;
                    var xscaled = thispage.DocRef.markuplist[this.CurrentMarkup].xscaled;
                    var yscaled = thispage.DocRef.markuplist[this.CurrentMarkup].yscaled;
                    var npage = thispage.DocRef.markuplist[this.CurrentMarkup].pagenumber;
                    switch (this.drotation) {
                        case 0:
                            switch (thispage.DocRef.markuplist[this.CurrentMarkup].type) {
                                case 0:

                                    wscaled = wscaled - xscaled;
                                    hscaled = hscaled - yscaled;

                                    break;
                                case 1:

                                    wscaled = wscaled - xscaled;
                                    hscaled = hscaled - yscaled;
                                    break;
                                case 2:

                                    wscaled = wscaled - xscaled;
                                    hscaled = hscaled - yscaled;
                                    break;
                                case 6:

                                    wscaled = wscaled - xscaled;
                                    hscaled = hscaled - yscaled;

                                    break;
                                case 7:

                                    wscaled = wscaled - xscaled;
                                    hscaled = hscaled - yscaled;

                                    break;
                                case 8:
                                    wscaled = wscaled - xscaled;
                                    hscaled = hscaled - yscaled;

                                    break;
                                case 9:

                                    yscaled = yscaled - hscaled;
                                    break;
                                default:

                                    break;
                            }

                            break;
                        case 90:
                            //all values are absolute for all markup types.

                            hscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.h;
                            wscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.w;
                            xscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.x;
                            yscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.y;


                            //switch rect values to comply with orientation
                            //switch x and w
                            var wxtemp = xscaled;
                            xscaled = wscaled;
                            wscaled = wxtemp;

                            //change absolute rect values to relative
                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;

                            break;
                        case 180:
                            //all values are absolute for all markup types.
                            hscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.h;
                            wscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.w;
                            xscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.x;
                            yscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.y;

                            //switch rect values to comply with orientation
                            //both x,w and y,h is switched
                            var xtemp = xscaled;
                            var ytemp = yscaled;
                            xscaled = wscaled;
                            yscaled = hscaled;
                            wscaled = xtemp;
                            hscaled = ytemp;

                            //change absolute rect values to relative
                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;

                            break;
                        case 270:
                            //all values are absolute for all markup types.
                            hscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.h;
                            wscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.w;
                            xscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.x;
                            yscaled = thispage.DocRef.markuplist[this.CurrentMarkup].rotatedrect.y;

                            //switch rect values to comply with orientation
                            var wytemp = yscaled;
                            yscaled = hscaled;
                            hscaled = wytemp;


                            //yscaled -= wscaled;
                            //var hwtemp = wscaled;
                            //wscaled = hscaled;
                            //hscaled = hwtemp;

                            //change absolute rect values to relative
                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;

                            break;
                    }

                    hscaled = hscaled + 100;
                    wscaled = wscaled + 50;
                    xscaled = xscaled - 50;
                    yscaled = yscaled - 50;


                    this.zoom_update(xscaled, yscaled, wscaled, hscaled);
                }
                this.CurrentMarkup++;
            }
            this.CurrentMarkup = 0;

        };

        this.SetMarkupZoom = function (dx, dy, dscale) {

            if (this.usevectorxml) {
                if (thispage.vectorloaded) {
                    this.dscalevector = dscale;
                    this.dxvector = dx;
                    this.dyvector = dy;
                    this.startx = this.dxvector;
                    this.starty = this.dyvector;
                    this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                    this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;
                    this.draw_vector(false);

                } else {
                    thispage.loadbinvectors();
                }

            } else if (this.usepdfjs) {
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;

                }

                this.dscalepdf = dscale;
                this.dxpdf = dx;
                this.dypdf = dy;
                this.startx = this.dxpdf;
                this.starty = this.dypdf;
                this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                this.endy = (pcanvheight * this.dscalepdf) + this.starty;
                thispage.pdfrenderopque += 1;
                thispage.pdfisrendered = false;

                if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                    if (this.usedincomposite && this.compositereference != undefined) {
                        this.compositereference.scaleToBackground(true);
                    }else{
                        thispage.DocRef.draw_mpagepdf();
                    }

                }

            } else {
                this.dscale = dscale;
                this.dx = dx;
                this.dy = dy;
                this.checkimageswitch();
                if (thispage.DocRef.Type == 0) {
                    thispage.DocRef.draw_mpage();
                } else {
                    if (this.usedincomposite && this.compositereference != undefined) {
                        this.compositereference.scaleToBackground(true);
                    } else {
                        this.draw_image(true);
                    }

                }

            }

            //drawmarkupAll(cntximg);
            //DrawMarkupSelected(context);


        };

        this.MarkupZoombyMarkup = function (markupobj) {

            this.zoomall();

            //var npage = markupobj.pagenumber;
            var scalefactor = this.dscale / markupobj.scaling;
            if (this.usevectorxml) {
                scalefactor = this.dscalevector / markupobj.scaling;
            } else if (this.usepdfjs) {
                scalefactor = this.dscalepdf / markupobj.scaling;
            } else {
                scalefactor = this.dscale / markupobj.scaling;
            }

            var xscaled = markupobj.xscaled;
            var wscaled = markupobj.wscaled;
            var yscaled = markupobj.yscaled;
            var hscaled = markupobj.hscaled;

            switch (this.drotation) {
                case 0:
                    switch (markupobj.type) {
                        case 0:
                            xscaled = Math.min(markupobj.xscaled, markupobj.wscaled);
                            wscaled = Math.max(markupobj.xscaled, markupobj.wscaled);
                            yscaled = Math.min(markupobj.yscaled, markupobj.hscaled);
                            hscaled = Math.max(markupobj.yscaled, markupobj.hscaled);

                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;

                            break;
                        case 1:
                            xscaled = Math.min(markupobj.xscaled, markupobj.wscaled);
                            wscaled = Math.max(markupobj.xscaled, markupobj.wscaled);
                            yscaled = Math.min(markupobj.yscaled, markupobj.hscaled);
                            hscaled = Math.max(markupobj.yscaled, markupobj.hscaled);

                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;
                            break;
                        case 2:
                            xscaled = Math.min(markupobj.xscaled, markupobj.wscaled);
                            wscaled = Math.max(markupobj.xscaled, markupobj.wscaled);
                            yscaled = Math.min(markupobj.yscaled, markupobj.hscaled);
                            hscaled = Math.max(markupobj.yscaled, markupobj.hscaled);

                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;
                            break;
                        case 6:
                            xscaled = Math.min(markupobj.xscaled, markupobj.wscaled);
                            wscaled = Math.max(markupobj.xscaled, markupobj.wscaled);
                            yscaled = Math.min(markupobj.yscaled, markupobj.hscaled);
                            hscaled = Math.max(markupobj.yscaled, markupobj.hscaled);

                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;
                            if (hscaled == 0) {
                                hscaled = 1;
                            }
                            if (wscaled == 0) {
                                wscaled = 1;
                            }


                            break;
                        case 7:
                            xscaled = Math.min(markupobj.xscaled, markupobj.wscaled);
                            wscaled = Math.max(markupobj.xscaled, markupobj.wscaled);
                            yscaled = Math.min(markupobj.yscaled, markupobj.hscaled);
                            hscaled = Math.max(markupobj.yscaled, markupobj.hscaled);

                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;
                            if (hscaled == 0) {
                                hscaled = 1;
                            }
                            if (wscaled == 0) {
                                wscaled = 1;
                            }

                            break;
                        case 8:
                            xscaled = Math.min(markupobj.xscaled, markupobj.wscaled);
                            wscaled = Math.max(markupobj.xscaled, markupobj.wscaled);
                            yscaled = Math.min(markupobj.yscaled, markupobj.hscaled);
                            hscaled = Math.max(markupobj.yscaled, markupobj.hscaled);

                            wscaled = wscaled - xscaled;
                            hscaled = hscaled - yscaled;

                            break;
                        case 9:
                            if (markupobj.textrotate == 0) {
                                xscaled = markupobj.rotatedrect.x;
                                wscaled = markupobj.rotatedrect.w;
                                yscaled = markupobj.rotatedrect.y;
                                hscaled = markupobj.rotatedrect.h;
                            }
                            if (markupobj.textrotate / (Math.PI / 180) == 90) {
                                xscaled = markupobj.xscaled;
                                yscaled = markupobj.yscaled;
                                wscaled = markupobj.wscaled;
                                hscaled = markupobj.hscaled;
                                var switchval = wscaled;
                                wscaled = hscaled;
                                hscaled = switchval;
                                //xscaled = xscaled + wscaled;
                                //yscaled = yscaled + hscaled;


                            }

                            if (markupobj.textrotate / (Math.PI / 180) == 270) {
                                xscaled = markupobj.xscaled;
                                yscaled = markupobj.yscaled;
                                wscaled = markupobj.wscaled;
                                hscaled = markupobj.hscaled;
                                switchval = wscaled;
                                wscaled = hscaled;
                                hscaled = switchval;
                                xscaled = xscaled - wscaled;
                                yscaled = yscaled - hscaled;
                            }

                            if (markupobj.textrotate / (Math.PI / 180) == 180) {
                                xscaled = markupobj.xscaled;
                                yscaled = markupobj.yscaled;
                                wscaled = markupobj.wscaled;
                                hscaled = markupobj.hscaled;

                                xscaled = xscaled - wscaled;
                                yscaled = yscaled - hscaled;
                            }


                            //yscaled = yscaled - hscaled;
                            break;
                        default:

                            break;
                    }

                    break;
                case 90:
                    //all values are absolute for all markup types.


                    xscaled = Math.min(markupobj.rotatedrect.x, markupobj.rotatedrect.w);
                    wscaled = Math.max(markupobj.rotatedrect.x, markupobj.rotatedrect.w);
                    yscaled = Math.min(markupobj.rotatedrect.y, markupobj.rotatedrect.h);
                    hscaled = Math.max(markupobj.rotatedrect.y, markupobj.rotatedrect.h);
                    //switch rect values to comply with orientation
                    //switch x and w
                    /*var wxtemp = xscaled;
                     xscaled = wscaled;
                     wscaled = wxtemp;*/

                    //change absolute rect values to relative
                    wscaled = wscaled - xscaled;
                    hscaled = hscaled - yscaled;

                    if (hscaled == 0) {
                        hscaled = 1;
                    }
                    if (wscaled == 0) {
                        wscaled = 1;
                    }


                    break;
                case 180:
                    //all values are absolute for all markup types.
                    xscaled = Math.min(markupobj.rotatedrect.x, markupobj.rotatedrect.w);
                    wscaled = Math.max(markupobj.rotatedrect.x, markupobj.rotatedrect.w);
                    yscaled = Math.min(markupobj.rotatedrect.y, markupobj.rotatedrect.h);
                    hscaled = Math.max(markupobj.rotatedrect.y, markupobj.rotatedrect.h);

                    //switch rect values to comply with orientation
                    //both x,w and y,h is switched
                    /*var xtemp = xscaled;
                     var ytemp = yscaled;
                     xscaled = wscaled;
                     yscaled = hscaled;
                     wscaled = xtemp;
                     hscaled = ytemp;*/

                    //change absolute rect values to relative
                    wscaled = wscaled - xscaled;
                    hscaled = hscaled - yscaled;
                    if (hscaled == 0) {
                        hscaled = 1;
                    }
                    if (wscaled == 0) {
                        wscaled = 1;
                    }


                    break;
                case 270:
                    //all values are absolute for all markup types.
                    xscaled = Math.min(markupobj.rotatedrect.x, markupobj.rotatedrect.w);
                    wscaled = Math.max(markupobj.rotatedrect.x, markupobj.rotatedrect.w);
                    yscaled = Math.min(markupobj.rotatedrect.y, markupobj.rotatedrect.h);
                    hscaled = Math.max(markupobj.rotatedrect.y, markupobj.rotatedrect.h);

                    //switch rect values to comply with orientation
                    /*var wytemp = yscaled;
                     yscaled = hscaled;
                     hscaled = wytemp;*/


                    //yscaled -= wscaled;
                    //var hwtemp = wscaled;
                    //wscaled = hscaled;
                    //hscaled = hwtemp;

                    //change absolute rect values to relative
                    wscaled = wscaled - xscaled;
                    hscaled = hscaled - yscaled;

                    if (hscaled == 0) {
                        hscaled = 1;
                    }
                    if (wscaled == 0) {
                        wscaled = 1;
                    }


                    break;

            }
            //Call zoom update with values.
            this.zoom_update(xscaled, yscaled, wscaled, hscaled);
            this.ZoomOut(3, false,false);


        };

        this.MarkupZoom = function () {
            //get current markup from list
            //GetCurMarkup(this.CurrentMarkup);
            if (this.CurrentMarkup > thispage.DocRef.nummarkups - 1) {
                this.CurrentMarkup = 0;
            }
            var npage = thispage.DocRef.markuplist[this.CurrentMarkup].pagenumber;
            while (npage != this.pagenumber && this.CurrentMarkup >= thispage.DocRef.nummarkups - 1) {
                this.CurrentMarkup++;
                npage = thispage.DocRef.markuplist[this.CurrentMarkup].pagenumber;
            }

            if (this.CurrentMarkup <= thispage.DocRef.nummarkups - 1) {


                this.MarkupZoombyMarkup(thispage.DocRef.markuplist[this.CurrentMarkup]);


                this.CurrentMarkup++;
                if (this.CurrentMarkup <= thispage.DocRef.nummarkups - 1) {
                    npage = thispage.DocRef.markuplist[this.CurrentMarkup].pagenumber;
                    while (npage != this.pagenumber && this.CurrentMarkup <= thispage.DocRef.nummarkups - 1) {
                        this.CurrentMarkup++;
                        if (this.CurrentMarkup >= thispage.DocRef.nummarkups - 1) {
                            break;
                        }
                        npage = thispage.DocRef.markuplist[this.CurrentMarkup].pagenumber;
                    }
                    if (this.CurrentMarkup >= thispage.DocRef.nummarkups - 1) {
                        this.CurrentMarkup = 0;
                    }

                }

            }

        };

        this.resize = function () {
            if (this.usevector3Dxml) {
                return;
            }

            if (thispage.bDorescaleonsizeChange) {

                var yscale = canvasoheight / this.MainImageHeight;
                var xscale = canvasowidth / this.MainImageWidth;

                this.dscale = Math.min(xscale, yscale);
                this.dx = (canvasowidth - (this.MainImageWidth * this.dscale)) / 2;
                this.dy = (canvasoheight - (this.MainImageHeight * this.dscale)) / 2;

            }

            if (this.usevectorxml && thispage.bDorescaleonsizeChange) {
                yscale = canvasoheight / thispage.VectorPageObj.height;
                xscale = canvasowidth / thispage.VectorPageObj.width;
                this.dscalevector = Math.min(xscale, yscale);

                this.dxvector = (canvasowidth - (thispage.VectorPageObj.width * this.dscalevector)) / 2;
                this.dyvector = (canvasoheight - (thispage.VectorPageObj.height * this.dscalevector)) / 2;

            }
            if (this.usepdfjs) {
                //yscale = canvasoheight / thispage.pagecanvas.height;
                //xscale = canvasowidth / thispage.pagecanvas.width;
                //this.dscalepdf = Math.min(xscale,yscale);


                //this.dxpdf = (canvasowidth - (thispage.pagecanvas.width * this.dscalepdf)) / 2;
                //this.dypdf = (canvasoheight - (thispage.pagecanvas.height * this.dscalepdf)) / 2;
                if (thispage.usedincomposite && thispage.compositereference != undefined){
                    var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                    var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                }else{
                    pcanvheight = thispage.offscreenheight;
                    pcanvwidth = thispage.offscreenwidth;

                }


                if (this.dxpdf > 1){
                    this.pan_update(((canvasowidth - (pcanvwidth * this.dscalepdf)) / 2)-this.dxpdf,0);
                }


                //DocObj.draw_mpagepdf();
            }


            if (!this.usevectorxml) {
                if (this.usepdfjs) {
                    //DocObj.draw_mpagepdf();
                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {
                        if (canvasoheight > pcanvheight) {
                            this.zoomall();
                        } else {
                            if (this.usedincomposite && this.compositereference != undefined) {
                                this.dscalepdf = this.compositereference.getoverlayScaleFactor(6);
                                this.compositereference.scaleToBackground(true);

                            }else{
                                thispage.DocRef.draw_mpagepdf();
                            }

                        }


                    }

                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            //this.dscale = this.compositereference.getoverlayScaleFactor(6);
                            this.compositereference.scaleToBackground(true);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }

            } else {
                if(thispage.VectorPageObj == undefined){
                    return;
                }
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                if (this.usedincomposite && this.compositereference != undefined) {
                    //this.dscalevector = this.compositereference.getoverlayScaleFactor(6);
                    this.compositereference.scaleToBackground(true);
                } else {
                    this.draw_vector(false);
                }


            }
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);


        };

        this.pan_page = function(sx,sy, bexternal){
            thispage.pan_update(sx,sy, bexternal);
        };

        this.pan_page_pos = function(sx,sy, bexternal){
            thispage.pan_position(sx,sy, bexternal);
        };


        this.pan_position = function(sx, sy, bexternal){

            var pgdim = thispage.getpagedim();

            var diffx = pgdim.x - sx;
            var diffy = pgdim.y - sy;

            thispage.pan_update(diffx,diffy, true);


        };

        this.getpagetestrect = function(rect){
            var rotrect = {x1:rect.startx,y1: rect.starty,x2: rect.endx,y2:rect.endy};

            var pagerect = {
                x : rotrect.x1,
                y : rotrect.y1,
                w : rotrect.x2 - rotrect.x1,
                h : rotrect.y2 - rotrect.y1
            };

            if(thispage.drotation != 0){
                rotrect = rect_rotated(rect.startx,rect.starty, rect.endx,rect.endy);

                pagerect.x = rotrect.x1;
                pagerect.y = rotrect.y1;
                pagerect.w = rotrect.x2 - rotrect.x1;
                pagerect.h = rotrect.y2 - rotrect.y1;

                switch(thispage.drotation){
                    case 90:
                        pagerect.y = -((pagerect.y + pagerect.h) - canvasoheight);
                        pagerect.x = -((pagerect.x + pagerect.w) - canvasowidth);
                        break;

                    case 270:
                        pagerect.y = -((pagerect.y + pagerect.h) - canvasoheight);
                        pagerect.x = -((pagerect.x + pagerect.w) - canvasowidth);
                        break;
                }

            }

            return pagerect;
        };
        this.getpagerect = function(){

            var rotrect = {x1:this.startx,y1: this.starty,x2: this.endx,y2:this.endy};

            var pagerect = {
                x : rotrect.x1,
                y : rotrect.y1,
                w : rotrect.x2 - rotrect.x1,
                h : rotrect.y2 - rotrect.y1
            };

            if(thispage.drotation != 0){
                rotrect = rect_rotated(this.startx,this.starty, this.endx,this.endy);

                pagerect.x = rotrect.x1;
                pagerect.y = rotrect.y1;
                pagerect.w = rotrect.x2 - rotrect.x1;
                pagerect.h = rotrect.y2 - rotrect.y1;

                switch(thispage.drotation){
                    case 90:
                        pagerect.y = -((pagerect.y + pagerect.h) - canvasoheight);
                        pagerect.x = -((pagerect.x + pagerect.w) - canvasowidth);
                        break;

                    case 270:
                        pagerect.y = -((pagerect.y + pagerect.h) - canvasoheight);
                        pagerect.x = -((pagerect.x + pagerect.w) - canvasowidth);
                        break;
                }


            }

            return pagerect;

        };

        this.pan_update = function (sx, sy, bexternal) {
            if (this.usevector3Dxml) {
                return;
            }

            if(RxCore_GUI_PanUpdate != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();

                RxCore_GUI_PanUpdate.panUpdate(sx,sy, pagerect);

            }

            var curpdfdx = this.dxpdf;
            switch (this.drotation) {
                case 0:
                    this.dx = this.dx - sx;
                    this.dy = this.dy - sy;
                    this.dxvector -= sx;
                    this.dyvector -= sy;
                    this.dxpdf -= sx;
                    this.dypdf -= sy;


                    break;
                case 90:
                    this.dx = this.dx - sy;
                    this.dy = this.dy + sx;
                    this.dxvector -= sy;
                    this.dyvector += sx;
                    this.dxpdf -= sy;
                    this.dypdf += sx;

                    break;
                case 180:
                    this.dx = this.dx + sx;
                    this.dy = this.dy + sy;
                    this.dxvector += sx;
                    this.dyvector += sy;
                    this.dxpdf += sx;
                    this.dypdf += sy;

                    break;
                case 270:
                    this.dx = this.dx + sy;
                    this.dy = this.dy - sx;
                    this.dxvector += sy;
                    this.dyvector -= sx;
                    this.dxpdf += sy;
                    this.dypdf -= sx;

                    break;
            }

            if (!this.usevectorxml) {
                if (this.usepdfjs) {

                    if (thispage.usedincomposite && thispage.compositereference != undefined){
                        var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                        var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                    }else{
                        pcanvheight = thispage.offscreenheight;
                        pcanvwidth = thispage.offscreenwidth;

                    }
0
                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    thispage.PDFTextArea.style.left = thispage.startx + "px";
                    thispage.PDFTextArea.style.top = thispage.starty + "px";

                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;


                    if ((thispage.usedincomposite && thispage.compositereference != undefined) || (thispage.DocRef.pagelocked && !bRestrictPan)){
                        //allow free position for PDF when used with overlay/compare
                    }else{
                        if (pcanvwidth * this.dscalepdf <= canvasowidth && this.drotation == 0) {
                            thispage.dxpdf = (canvasowidth - (pcanvwidth * this.dscalepdf)) / 2;
                        }

                    }

                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.compositereference.scaleToBackground(false);

                        }else{
                            thispage.DocRef.pan_update(sx, sy);
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                    //DocObj.draw_mpagepdf();

                    var left = Math.max(0, thispage.dxpdf);
                    var right = Math.min(canvasowidth, thispage.endx);
                    var bottom = Math.max(canvasoheight, thispage.endy);
                    var top = Math.min(0, thispage.dypdf);

                    if(left < right && bottom > top){
                        thispage.visible = true;
                        if(thispage.DocRef.textselect){
                            thispage.PDFTextArea.style.display = szdispvalue;
                        }


                    }else{
                        thispage.visible = false;
                        if(thispage.DocRef.textselect){
                           thispage.PDFTextArea.style.display = "none";
                        }

                    }

                    /*if ((thispage.dxpdf < canvasowidth && thispage.dxpdf > 0) || (thispage.endx > 0 && thispage.endx < canvasowidth)) {
                        if ((thispage.dypdf < canvasoheight && thispage.dypdf > 0) || (thispage.endy > 0 && thispage.endy < canvasoheight)) {
                            thispage.visible = true;
                            thispage.PDFTextArea.style.display = "initial";
                            console.log('pan visible on');
                            //console.log('visible ' + thispage.pagenumber);
                        } else {
                            thispage.visible = false;
                            thispage.PDFTextArea.style.display = "none";
                            console.log('pan visible off');

                        }
                    }*/


                } else {
                    this.checkimageswitch();
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.compositereference.scaleToBackground(false);
                        } else {
                            this.draw_image(true);
                        }

                    }

                }
            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                //thispage.TextSelectArea.style.left = thispage.startx + "px";
                //thispage.TextSelectArea.style.top = thispage.starty + "px";
                thispage.movetextdivs();


                if (this.usedincomposite && this.compositereference != undefined) {
                    this.compositereference.scaleToBackground(false);
                } else {
                    this.draw_vector(false);
                }


                left = Math.max(0, thispage.dxvector);
                right = Math.min(canvasowidth, thispage.endx);
                bottom = Math.max(canvasoheight, thispage.endy);
                top = Math.min(0, thispage.dyvector);

                if(left < right && bottom > top){
                    thispage.visible = true;
                    if(thispage.DocRef.textselect){

                        thispage.TextSelectArea.style.display = szdispvalue;
                    }


                }else{
                    thispage.visible = false;
                    if(thispage.DocRef.textselect){
                        thispage.TextSelectArea.style.display = "none";
                    }

                }


            }
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

            if(RxCore_GUI_PanUpdated != undefined && bexternal == undefined){

                var pagerect = thispage.getpagerect();

                RxCore_GUI_PanUpdated.panUpdate(sx,sy, pagerect);

            }


        };

        this.rotateCanvas = function () {
            var localdx = 0.0;
            var localdy = 0.0;
            var localdscale = 0.0;


            contexto.save();
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);
            contexto.translate(tx, ty);
            contexto.rotate(this.drotation * (Math.PI / 180));
            contexto.translate(-tx, -ty);
            contexto.fillStyle = "rgb(238,243,250)";
            contexto.fillRect(0, 0, canvasowidth, canvasoheight);


            switch (this.currentimage) {
                case 0:
                    //localdx = this.dx;
                    //localdy = this.dy;
                    //localdscale = this.dscale;
                    contexto.drawImage(this.largeimage, this.dx, this.dy, this.MainImageWidth * this.dscale, this.MainImageHeight * this.dscale);
                    break;
                case 1:
                    //localdx = this.dxextent;
                    //localdy = this.dyextent;
                    //localdscale = this.dscaleextent;
                    localdscale = this.dscale / thispage.bitmapratio;
                    contexto.drawImage(this.smallimage, this.dx, this.dy, this.SmallImageWidth * localdscale, this.SmallImageHeight * localdscale);
                    break;
            }


            contexto.restore();
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

        };



        this.rotateimage = function (degree) {

            var bsinglepage = (this.DocRef.pages.length == 1);
            //console.log(bsinglepage);

            if((this.usepdfjs && !this.DocRef.pagelocked) && (this.usepdfjs && !bsinglepage)){
                this.pagelockrotation = degree;
                return;
            }

            var i = 0;
            switch (this.drotation) {
                case 0:
                    if (degree == 90) {
                        for (i = 0; i <= 90; i = i + 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 180) {
                        for (i = 0; i <= 180; i = i + 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 270) {
                        for (i = 0; i <= 270; i = i + 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    break;
                case 90:
                    if (degree == 0) {
                        for (i = 90; i >= 0; i = i - 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 180) {
                        for (i = 90; i <= 180; i = i + 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 270) {
                        for (i = 90; i <= 270; i = i + 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }

                    break;
                case 180:
                    if (degree == 0) {
                        for (i = 180; i >= 0; i = i - 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 270) {
                        for (i = 180; i <= 270; i = i + 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 90) {
                        for (i = 180; i >= 90; i = i - 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }

                    break;
                case 270:
                    if (degree == 0) {
                        for (i = 270; i >= 0; i = i - 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 180) {
                        for (i = 270; i >= 180; i = i - 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }
                    if (degree == 90) {
                        for (i = 270; i >= 90; i = i - 10) {
                            this.drotation = i;
                            this.rotateCanvas();
                        }
                    }

                    break;
            }

            //this.draw_image();
            if (this.usevector3Dxml) {
                return;
            }
            if (!this.usevectorxml) {
                if (this.usepdfjs) {

                    if (thispage.usedincomposite && thispage.compositereference != undefined){
                        var pcanvheight = thispage.compositereference.ovpagecanvas.height;
                        var pcanvwidth = thispage.compositereference.ovpagecanvas.width;
                    }else{
                        pcanvheight = thispage.offscreenheight;
                        pcanvwidth = thispage.offscreenwidth;
                    }

                    var centery = canvasoheight / 2;
                    var centerx = canvasowidth / 2;

                    this.startx = this.dxpdf;
                    this.starty = this.dypdf;
                    this.endx = (pcanvwidth * this.dscalepdf) + this.startx;
                    this.endy = (pcanvheight * this.dscalepdf) + this.starty;


                    thispage.PDFTextArea.style.left = thispage.startx + "px";
                    thispage.PDFTextArea.style.top = thispage.starty + "px";

                    var centerxoff = centerx - thispage.startx;
                    var centeryoff = centery - thispage.starty;

                    //var centerx = this.startx + ((this.endx - this.startx)/2);
                    //var centery = this.starty + ((this.endy - this.starty)/2);

                    thispage.PDFTextArea.style.transformOrigin= centerxoff + "px" + " " + centeryoff + "px";
                    thispage.PDFTextArea.style.transform = "rotate(" + this.drotation + "deg)";


                    if (thispage.pagenumber == thispage.DocRef.pages[thispage.DocRef.currentpage].pagenumber) {

                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.compositereference.scaleToBackground(false);

                        } else {
                            thispage.DocRef.draw_mpagepdf();
                        }

                    }

                } else {
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    } else {
                        if (this.usedincomposite && this.compositereference != undefined) {
                            this.compositereference.scaleToBackground(false);
                        } else {
                            this.draw_image(true);
                        }

                    }
                    //this.checkimageswitch();

                }
            } else {
                this.startx = this.dxvector;
                this.starty = this.dyvector;
                this.endx = (thispage.VectorPageObj.width * this.dscalevector) + this.startx;
                this.endy = (thispage.VectorPageObj.height * this.dscalevector) + this.starty;

                thispage.movetextdivs();


                if (this.usedincomposite && this.compositereference != undefined) {
                    this.compositereference.scaleToBackground(false);

                } else {
                    this.draw_vector(false);
                }

            }

            if (RxCore_GUI_RotatePage != undefined){
                RxCore_GUI_RotatePage.onRotate(degree, thispage.pagenumber);
            }

        };

        this.get_layers_html = function () {
            return this.VectorPageObj.layerhtml;
        };

        this.enableSnap = function(state){

            thispage.snapEnabled = state;

            /*if (state && thispage.usevectorxml){
                thispage.VectorPageObj.getInterSections();
            }*/


        };
        this.getSnapState = function(){
            return thispage.snapEnabled;
        };

        this.setViewMode = function(OnOff){
            if (thispage.usevectorxml){
                thispage.VectorPageObj.ViewMode(OnOff);

                thispage.draw_vector(false);
                thispage.vectorischanged = true;

            }

        };

        this.blockAttributes = function(blockid){

            if (thispage.usevectorxml){
                return thispage.VectorPageObj.blockAttributes(blockid);
            }

        };

        this.selectBlock = function(blockid){
            if (thispage.usevectorxml){
                thispage.VectorPageObj.selectBlock(blockid);

                thispage.draw_vector(false);
                thispage.vectorischanged = true;

            }
        };

        this.getpixeldist = function(length){
            if (thispage.usevectorxml){
                var origlength = length * thispage.VectorPageObj.scale;
                var pixelLength = origlength * thispage.dscalevector;
                return pixelLength;
            }else{
                return length;
            }

        };

        this.getpolygonPointsbyblockID = function(blockid){
            var points = [];
            if (thispage.usevectorxml){

                points =  thispage.VectorPageObj.getpathPointsBybId(blockid);

            }

            return points;

        };

        this.getpolygonPathbyblockID = function(blockid){
            var path = null;
            if (thispage.usevectorxml){

                path =  thispage.VectorPageObj.getpathbybId(blockid);

            }

            return path;

        };

        this.getpolygonPath = function(x,y){
            var path = null;

            if (thispage.usevectorxml){
                path =  thispage.VectorPageObj.getpath(x, y, thispage.dscalevector, thispage.dxvector, thispage.dyvector);
            }

            return path;

        }

        this.getpolygonPoints = function(x,y){
            var points = [];
            if (thispage.usevectorxml){
                points =  thispage.VectorPageObj.getpathPoints(x, y, thispage.dscalevector, thispage.dxvector, thispage.dyvector);
            }

            return points;
        };



        this.getpolygon = function(x,y,multi){
            if (thispage.usevectorxml){
                var within =  thispage.VectorPageObj.getinsidePolygon(x, y, thispage.dscalevector, thispage.dxvector, thispage.dyvector,multi);

                thispage.draw_vector(false);
                thispage.vectorischanged = true;

                //thispage.vectorischanged = true;
                if (within){
                    //thispage.draw_vector_selected();

                    return within;
                }
            }
        };

        this.unSelectAllBlocks = function (notify){
            if (thispage.usevectorxml){
                thispage.VectorPageObj.unSelectAllBlocks(notify);

                thispage.draw_vector(false);
                thispage.vectorischanged = true;

            }
        }
        this.getPDFsnapPoint = function(x,y){
            var snappoint = {
                found:false,
                x:0,
                y:0,
                type : 1
            };

            var rotatey = false;
            var snappoints = [];

            var rotatedpoint = {x:x,y:y};

            if(thispage.drotation != 0){
                rotatedpoint = mouse_rotated(x,y);
            }

            x = rotatedpoint.x;
            y = rotatedpoint.y;

            /*if(thispage.PDFinternalScale == undefined || thispage.PDFPointArray == undefined){
                return snappoint;
            }*/

            if(thispage.PDFPointArray == undefined){
                return snappoint;
            }

            var snapradius = 10;
            if(thispage.PDFinternalScale.x > 0){
                var localscalex = thispage.pdfSnapScale * thispage.PDFinternalScale.x;
            }else{
                localscalex = thispage.pdfSnapScale;
            }
            if(thispage.PDFinternalScale.y > 0){
                var localscaley = thispage.pdfSnapScale * thispage.PDFinternalScale.y;
            }else{
                localscaley = thispage.pdfSnapScale;
                rotatey = true;

            }

            var cheight = thispage.offscreenheight * thispage.dscalepdf;
            var cwidth = thispage.offscreenwidth * thispage.dscalepdf;

            //var cheight = thispage.offscreenheight;
            //var cwidth = thispage.offscreenwidth;

            for(var i = 0;i<thispage.PDFPointArray.length;i++){
                /*if (rotatey){
                    //var transy = thispage.starty + ((thispage.PDFPointArray[i].y*localscaley) + cheight);
                    var transy = thispage.starty + ((thispage.PDFPointArray[i].y*thispage.pdfSnapScale) + cheight);
                }else{
                    //transy = thispage.starty + (-(thispage.PDFPointArray[i].y*localscaley) + cheight);
                    transy = thispage.starty + (-(thispage.PDFPointArray[i].y*thispage.pdfSnapScale) + cheight);
                }

                //var transx = thispage.startx + (thispage.PDFPointArray[i].x*localscalex);
                if(thispage.PDFpageRotate != 0){
                    var transx = thispage.startx + (thispage.PDFPointArray[i].x*thispage.pdfSnapScale) + cwidth;
                }else{
                    transx = thispage.startx + (thispage.PDFPointArray[i].x*thispage.pdfSnapScale);
                }*/

                if (thispage.PDFpageRotate != 0) {

                    if(thispage.PDFpageRotate == 90){
                        var transy = thispage.starty + (-(thispage.PDFPointArray[i].y*thispage.pdfSnapScale));
                        var transx = thispage.startx + (thispage.PDFPointArray[i].x*thispage.pdfSnapScale);

                    }else{
                        transy = thispage.starty + (-(thispage.PDFPointArray[i].y*thispage.pdfSnapScale) + cheight);
                        transx = thispage.startx + (thispage.PDFPointArray[i].x*thispage.pdfSnapScale) + cwidth;

                    }
                }else{
                    if (thispage.PDFPointArray[i].y < 0){
                        transy = thispage.starty + (-(thispage.PDFPointArray[i].y*thispage.pdfSnapScale));
                    }else{
                        transy = thispage.starty + (-(thispage.PDFPointArray[i].y*thispage.pdfSnapScale) + cheight);
                    }
                    if (thispage.PDFPointArray[i].x < 0){
                        transx = thispage.startx + (thispage.PDFPointArray[i].x*thispage.pdfSnapScale) + cwidth;
                    }else{
                        transx = thispage.startx + (thispage.PDFPointArray[i].x*thispage.pdfSnapScale);

                    }

                }


                var a = x - transx;
                var b = y - transy;
                var tempdist = Math.sqrt(a*a + b*b);
                if (tempdist < snapradius){
                    snappoints.push({x:transx,y:transy});
                }

            }

            if(snappoints.length > 0){
                a = x - snappoints[0].x;
                b = y - snappoints[0].y;
                var curdist = Math.sqrt(a*a + b*b);
                tempdist = Math.sqrt(a*a + b*b);
                var snapindx = 0;

                for (i = 0;i<snappoints.length;i++){

                        a = x - snappoints[i].x;
                        b = y - snappoints[i].y;
                        tempdist = Math.sqrt(a*a + b*b);

                        if (tempdist < curdist){
                            curdist = tempdist;
                            snapindx = i;
                        }
                }

                snappoint = {
                    found : true,
                    x:snappoints[snapindx].x,
                    y:snappoints[snapindx].y,
                    type : 1
                };

            }else{
                snappoint = {
                    found:false,
                    x:0,
                    y:0,
                    type : 1
                };

            }
            return snappoint;

        };

        this.getsnap = function (x, y) {
            if (thispage.usevectorxml && thispage.snapEnabled ) {
                return thispage.VectorPageObj.getsnapPoint(x, y, thispage.dscalevector, thispage.dxvector, thispage.dyvector);
            }else if(thispage.usepdfjs && thispage.snapEnabled){
                return thispage.getPDFsnapPoint(x,y);
            }else{
                return {found:false,x:0,y:0};
            }

            //var snapPoint = this.VectorPageObj.getsnapPoint(x,y,this.dscalevector,this.dxvector,this.dyvector);
            //return this.VectorPageObj.getsnapPoint(x, y, this.dscalevector, this.dxvector, this.dyvector);

        };


        this.draw_vectorPrint = function(){
            thispage.printobj.printctx.fillStyle = "rgb(255,255,255)";
            thispage.printobj.printctx.fillRect(0, 0, thispage.printobj.paperimage.width, thispage.printobj.paperimage.height);

            if (this.VectorPageObj == undefined) {
                return;
            }

            this.VectorPageObj.drawallnew(thispage.printobj.printctx,thispage.printobj.pscale,thispage.printobj.pdx,thispage.printobj.pdy,true,true);
            //this.VectorPageObj.drawall(thispage.printobj.printctx,thispage.printobj.pscale,thispage.printobj.pdx,thispage.printobj.pdy,true,true);

            drawmarkupPrint(thispage.printobj.printctx,thispage.pagenumber,thispage.printobj.pdx,thispage.printobj.pdy,thispage.printobj.pscale);
            //possible callback here.



        };

        this.magnifyoff = function(){
            if (thispage.usevector3Dxml) {
                return;
            }
            //context.clearRect(0, 0, canvas.width, canvas.height);

            if (thispage.usedincomposite && thispage.compositereference != undefined) {
                //thispage.compositereference.draw_compare(false);
                thispage.compositereference.scaleToBackground(true);
            } else {

                if (thispage.usevectorxml) {
                    thispage.draw_vector(true);
                } else if(thispage.usepdfjs) {
                    thispage.DocRef.draw_mpagepdf();

                } else {
                    if (thispage.DocRef.Type == 0) {
                        thispage.DocRef.draw_mpage();
                    }else{
                        thispage.draw_image(true);
                    }

                }

            }

        };

        this.drawmagnify = function(mousepos,ctx,magnificationScale){

            if (thispage.usevector3Dxml) {
                return;
            }



            if (thispage.drotation == 0) {
                var rectCenterX = (mousepos.x - ((magcanvas.width / 2)/magnificationScale));
                var rectCenterY = (mousepos.y - ((magcanvas.height / 2)/magnificationScale));

            }else{
                var rotpos = rotate_point(mousepos,(canvasowidth / 2),(canvasoheight / 2),(360 - thispage.drotation));
                rectCenterX = (rotpos.x - ((magcanvas.width / 2)/magnificationScale));
                rectCenterY = (rotpos.y - ((magcanvas.height / 2)/magnificationScale));

            }


            ctx.fillStyle = thispage.DocRef.backgroundColor;
            ctx.fillRect(0, 0, magcanvas.width, magcanvas.height);

            var tx = (magcanvas.width / 2);
            var ty = (magcanvas.height / 2);

            if (thispage.usevectorxml){
                var drawscale = thispage.dscalevector * magnificationScale;
                var xoffset =  -(rectCenterX) + (thispage.dxvector); // - (thispage.dxvector + wscale);
                var yoffset =  -(rectCenterY) + (thispage.dyvector);// - (thispage.dyvector + hscale);
                xoffset *= magnificationScale;
                yoffset *= magnificationScale;

                if (thispage.drotation == 0) {
                    thispage.VectorPageObj.drawallmagnify(ctx, drawscale, xoffset, yoffset);
                }else{
                    ctx.save();
                    ctx.translate(tx, ty);
                    ctx.rotate(thispage.drotation * (Math.PI / 180));
                    ctx.translate(-tx, -ty);
                    thispage.VectorPageObj.drawallmagnify(ctx, drawscale, xoffset, yoffset);
                    //ctx.restore();

                }

            }else if(thispage.usepdfjs){

                drawscale = thispage.dscalepdf * thispage.curpagescale  * magnificationScale;
                var drawwidth = thispage.magnifycanvas.width * thispage.magnifyrestscale;
                var drawheight = thispage.magnifycanvas.height * thispage.magnifyrestscale;
                //DocObj.pages[DocObj.currentpage].curpagescale
                xoffset =  -(rectCenterX) + (thispage.dxpdf);
                yoffset =  -(rectCenterY) + (thispage.dypdf);

                xoffset *= magnificationScale;
                yoffset *= magnificationScale;

                if (thispage.drotation == 0) {
                    ctx.drawImage(thispage.magnifycanvas, xoffset, yoffset);
                }else{
                    ctx.save();
                    ctx.translate(tx, ty);
                    ctx.rotate(thispage.drotation * (Math.PI / 180));
                    ctx.translate(-tx, -ty);
                    ctx.drawImage(thispage.magnifycanvas, xoffset, yoffset);
                    //ctx.restore();

                }

            }else{
                switch (thispage.currentimage) {
                    case 0:
                        drawscale = thispage.dscale * magnificationScale;
                        xoffset =  -(rectCenterX) + (thispage.dx);
                        yoffset =  -(rectCenterY) + (thispage.dy);
                        xoffset *= magnificationScale;
                        yoffset *= magnificationScale;
                        if (thispage.drotation == 0) {
                            ctx.drawImage(thispage.largeimagecnv, xoffset, yoffset,thispage.MainImageWidth * drawscale,thispage.MainImageHeight * drawscale);
                        }else{
                            ctx.save();
                            ctx.translate(tx, ty);
                            ctx.rotate(thispage.drotation * (Math.PI / 180));
                            ctx.translate(-tx, -ty);
                            ctx.drawImage(thispage.largeimagecnv, xoffset, yoffset,thispage.MainImageWidth * drawscale,thispage.MainImageHeight * drawscale);
                            //ctx.restore();

                        }

                        break;
                    case 1:
                        drawscale = (thispage.dscale / thispage.bitmapratio) * magnificationScale;
                        //var drawscale = thispage.dscale / thispage.bitmapratio;
                        xoffset =  -(rectCenterX) + (thispage.dx);
                        yoffset =  -(rectCenterY) + (thispage.dy);
                        xoffset *= magnificationScale;
                        yoffset *= magnificationScale;

                        if (thispage.drotation == 0) {
                            ctx.drawImage(thispage.smallimagecnv, xoffset, yoffset,thispage.SmallImageWidth * drawscale,thispage.SmallImageHeight * drawscale);
                        }else{
                            ctx.save();
                            ctx.translate(tx, ty);
                            ctx.rotate(thispage.drotation * (Math.PI / 180));
                            ctx.translate(-tx, -ty);
                            ctx.drawImage(thispage.smallimagecnv, xoffset, yoffset,thispage.SmallImageWidth * drawscale,thispage.SmallImageHeight * drawscale);


                        }


                        break;
                }
                drawscale = thispage.dscale * magnificationScale;

            }


            if (thispage.drotation == 0) {
                drawmarkupMagnify(ctx,thispage.pagenumber,xoffset,yoffset,drawscale,thispage.drotation);
            }else{
                drawmarkupMagnify(ctx,thispage.pagenumber,xoffset,yoffset,drawscale,thispage.drotation);
                ctx.restore();
            }

            //drawmarkupPrint(ctx,thispage.pagenumber,xoffset,yoffset,drawscale);

            //drawscale = thispage.dscalevector;

            //var wscale = ((thispage.VectorPageObj.width * drawscale) - (thispage.VectorPageObj.width * thispage.dscalevector)) / 2;
            //var hscale = ((thispage.VectorPageObj.height * drawscale) - (thispage.VectorPageObj.height * thispage.dscalevector)) / 2;

            //ctx.clearRect(0, 0, magcanvas.width, magcanvas.height);

            //this.VectorPageObj.drawall(ctx, drawscale, xoffset, yoffset, false,false);

        };

        this.draw_vector_selected = function(){
            thispage.backupScaleAndOffset();
            contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);

            if (this.VectorPageObj == undefined) {
                return;
            }

            if (this.drotation == 0) {

                //this.VectorPageObj.drawall(contexto, this.dscalevector, this.dxvector, this.dyvector, refresh,false);
                this.VectorPageObj.drawSelected(contexto, this.dscalevector, this.dxvector, this.dyvector);

            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(this.drotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);
                //this.VectorPageObj.drawall(contexto, this.dscalevector, this.dxvector, this.dyvector, refresh,false);
                this.VectorPageObj.drawSelected(contexto, this.dscalevector, this.dxvector, this.dyvector);

                contexto.restore();

            }

        };

        this.draw_vector = function (refresh) {

            thispage.backupScaleAndOffset();

            if(thispage.DocRef.bSopenSilent){
                return;
            }



            contexto.fillStyle = displayBGColor;

            contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);
            documentopen = true;

            if (this.VectorPageObj == undefined) {
                return;
            }
            //thispage.cleartextdivs();

            if (bSuspendDraw){
                return;
            }


            if (this.drotation == 0) {

                //this.VectorPageObj.drawall(contexto, this.dscalevector, this.dxvector, this.dyvector, refresh,false);
                this.VectorPageObj.drawallnew(contexto, this.dscalevector, this.dxvector, this.dyvector, refresh,false);

            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(this.drotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);
                //this.VectorPageObj.drawall(contexto, this.dscalevector, this.dxvector, this.dyvector, refresh,false);
                this.VectorPageObj.drawallnew(contexto, this.dscalevector, this.dxvector, this.dyvector, refresh,false);

                contexto.restore();

            }
            //thispage.settextdivs();
        };

        /*this.draw_vector = function (refresh) {
            contexto.fillStyle = "rgb(62,62,62)";
            //contexto.fillStyle = "rgb(160,160,160)";
            contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);
            documentopen = true;

            if (thispage.VectorPageObj == undefined) {
                return;
            }
            //context,scalefactor,offsetx,offsety
            //this.dxvector = dx;
            //this.dyvector = dy;
            //this.dscalevector = dscale;


            if (this.drotation == 0) {

                if(refresh || !thispage.VectorPageObj.backgroundrender ){


                    thispage.VectorPageObj.drawall(contexto, thispage.dscalevector, thispage.dxvector, thispage.dyvector, refresh);

                }
                if(thispage.VectorPageObj.backgroundrender){
                    contexto.drawImage(thispage.VectorPageObj.offscreen, thispage.dxvector, thispage.dyvector, thispage.VectorPageObj.width * thispage.dscalevector, thispage.VectorPageObj.height * thispage.dscalevector);
                }


            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(thispage.drotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);

                if(refresh || !thispage.VectorPageObj.backgroundrender){

                    thispage.VectorPageObj.drawall(contexto, thispage.dscalevector, thispage.dxvector, thispage.dyvector, refresh);
                }
                if(thispage.VectorPageObj.backgroundrender){
                    contexto.drawImage(thispage.VectorPageObj.offscreen, thispage.dxvector, thispage.dyvector, thispage.VectorPageObj.width * thispage.dscalevector, thispage.VectorPageObj.height * thispage.dscalevector);
                }




                contexto.restore();

            }
            if(refresh && thispage.VectorPageObj.vectorpagetime > thispage.vectorpagetime){
                thispage.changeinterval(thispage.VectorPageObj.vectorpagetime);

            }


        };*/

        this.draw_canvas = function (clear) {

            thispage.backupScaleAndOffset();

            if(thispage.DocRef.bSopenSilent){
                return;
            }



            if (clear) {
                contexto.fillStyle = displayBGColor; //contexto.fillStyle = "rgb(238,243,250)";
                contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            }
            //console.log(this.pagenumber);
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);


            documentopen = true;
            var bsinglepage = (this.DocRef.pages.length == 1);

            if (this.DocRef.pagelocked || bsinglepage){
               var rotation = this.drotation;
            }else{
                rotation = 0;
            }

            if (bSuspendDraw){
                return;
            }
            if (!thispage.pdfdiminitset){
                return;
            }


            if (rotation == 0) {

                if(thispage.iscollapsed || !thispage.pdfisfirstrendered){
                    if(!thispage.pdfisfirstrendered && bAnimatePDFrender){
                        contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                        contexto.fillRect(this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                        contexto.drawImage(thispage.pagedrawCanvas, this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                    }else {
                        contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                        contexto.fillRect(this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                    }

                }else{
                    contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                    contexto.fillRect(this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                    contexto.drawImage(this.pagecanvas, this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                }

                /*if (thispage.pdfisrendered){
                    contexto.drawImage(this.pagecanvas, this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                }else{
                    contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                    contexto.fillRect(this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);

                }*/

                //contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                //contexto.fillRect(this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);



            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(rotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);
                if (thispage.pdfisrendered && !thispage.iscollapsed){
                    contexto.drawImage(this.pagecanvas, this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                }else{
                    contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                    contexto.fillRect(this.dxpdf, this.dypdf, thispage.offscreenwidth * this.dscalepdf, thispage.offscreenheight * this.dscalepdf);
                }

                contexto.restore();

            }


        };

        this.transparent = function(data){
            for (var i = 0; i < data.length; i += 4) {
                if(data[i] == 255 && data[i + 1] == 255 && data[i + 2] == 255){
                    data[i + 3] = 100;// - data[i + 2]; // transparent
                    //do nothting with white
                }
            }
        };

        this.setcolor = function(data, color){
            //var c = color; // 16712640
            /*var components = {
                r: (color & 0xff0000) >> 16,
                g: (color & 0x00ff00) >> 8,
                b: (color & 0x0000ff)
            };*/

            var components = convertHexrgb(color);

            for (var i = 0; i < data.length; i += 4) {

                if(data[i] == 255 && data[i + 1] == 255 && data[i + 2] == 255){
                    data[i + 3] = 100;// - data[i + 2]; // transparent
                    //do nothting with white
                }else{
                    data[i]     = components.r; //255 - data[i];     // red
                    data[i + 1] = components.g;//255 - data[i + 1]; // green
                    data[i + 2] = components.b;// - data[i + 2]; // blue
                    //this.overlayColor = '#ff8000';
                }
            }

        };

        this.setred = function (data){

            for (var i = 0; i < data.length; i += 4) {

                if(data[i] == 255 && data[i + 1] == 255 && data[i + 2] == 255){
                    data[i + 3] = 100;// - data[i + 2]; // transparent
                    //do nothting with white
                }else{
                    data[i]     =  255; //255 - data[i];     // red
                    data[i + 1] = 128;//255 - data[i + 1]; // green
                    data[i + 2] = 0;// - data[i + 2]; // blue
                    //this.overlayColor = '#ff8000';
                }

            }


        };


        this.setblue = function (data){

            for (var i = 0; i < data.length; i += 4) {

                if(data[i] == 255 && data[i + 1] == 255 && data[i + 2] == 255){
                    //do nothting with white
                    //data[i + 3] = 100;// - data[i + 2]; // transparent
                }else{
                    data[i]     =  0; //255 - data[i];     // red
                    data[i + 1] = 0;//255 - data[i + 1]; // green
                    data[i + 2] = 255;// - data[i + 2]; // blue

                }

            }

        };

        this.setinvert = function (data){

            for (var i = 0; i < data.length; i += 4) {

                data[i]     = 255 - data[i];     // red
                data[i + 1] = 255 - data[i + 1]; // green
                data[i + 2] = 255 - data[i + 2]; // blue

            }


        };
        this.invertpdfmagnify = function(background){


            //var data = imageData.data;
            try{
                var imageData = thispage.magnifypagectx.getImageData(0, 0, thispage.magnifycanvas.width, thispage.magnifycanvas.height);
            }catch (e) {
                alert("Error 1 - " + e);
                console.log(e, thispage.magnifycanvas.width, thispage.magnifycanvas.height);
                background = -1;
            }

            var cmprcolors = thispage.compositereference.getColors();

            switch(background){
                case 0 :
                    thispage.setinvert(imageData.data);
                    break;
                case 1 :
                    //thispage.setblue(imageData.data);
                    thispage.setcolor(imageData.data,cmprcolors.bg);
                    break;
                case 2 :
                    //thispage.setred(imageData.data);
                    thispage.setcolor(imageData.data,cmprcolors.fg);
                    break;
            }

            if(background != -1){
                thispage.magnifypagectx.putImageData(imageData, 0, 0);



            }
        };

        this.invertpdfprint = function(background){
            switch(background){
                case 1 :
                    try{
                        var imageData = thispage.compositePrintreference.bgpagectx.getImageData(0, 0, thispage.compositePrintreference.bgpagecanvas.width, thispage.compositePrintreference.bgpagecanvas.height);
                    }catch (e) {
                        alert("Error 1 - " + e);
                        console.log(e, thispage.compositePrintreference.bgpagecanvas.width, thispage.compositePrintreference.bgpagecanvas.height);
                        background = -1;
                    }
                    //thispage.compositereference.bgpagecanvas
                    break;
                case 2 :
                    try{
                        imageData = thispage.compositePrintreference.ovpagectx.getImageData(0, 0, thispage.compositePrintreference.ovpagecanvas.width, thispage.compositePrintreference.ovpagecanvas.height);
                    }catch (e) {
                        alert("Error 1 - " + e);
                        console.log(e, thispage.compositePrintreference.ovpagecanvas.width, thispage.compositePrintreference.ovpagecanvas.height);
                        background = -1;
                    }

                    //thispage.compositereference.ovpagecanvas
                    break;
            }

            //var data = imageData.data;
            var cmprcolors = thispage.compositereference.getColors();

            switch(background){
                case 0 :
                    thispage.setinvert(imageData.data);
                    break;
                case 1 :
                    thispage.setcolor(imageData.data,cmprcolors.bg);
                    //thispage.setblue(imageData.data);
                    break;
                case 2 :
                    thispage.setcolor(imageData.data,cmprcolors.fg);
                    //thispage.setred(imageData.data);
                    break;
            }

            if(background != -1){
                switch(background){
                    case 1 :

                        thispage.compositePrintreference.bgpagectx.putImageData(imageData, 0, 0);
                        break;
                    case 2 :
                        thispage.compositePrintreference.ovpagectx.putImageData(imageData, 0, 0);
                        break;
                }


            }


            if (this.usedincomposite && this.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                //console.log('draw compare invert pdf' );
            } else {
                //this.draw_image(true);
            }
            //imageData = null;
        };

        this.transparentpdf = function(background){

            switch(background){
                case 1 :
                    try{
                        var imageData = thispage.compositereference.bgpagectx.getImageData(0, 0, thispage.compositereference.bgpagecanvas.width, thispage.compositereference.bgpagecanvas.height);
                    }catch (e) {
                        alert("Error 1 - " + e);
                        console.log(e, thispage.compositereference.bgpagecanvas.width, thispage.compositereference.bgpagecanvas.height);
                        background = -1;
                    }
                    //thispage.compositereference.bgpagecanvas
                    break;
                case 2 :
                    try{
                        imageData = thispage.compositereference.ovpagectx.getImageData(0, 0, thispage.compositereference.ovpagecanvas.width, thispage.compositereference.ovpagecanvas.height);
                    }catch (e) {
                        alert("Error 1 - " + e);
                        console.log(e, thispage.compositereference.ovpagecanvas.width, thispage.compositereference.ovpagecanvas.height);
                        background = -1;
                    }

                    //thispage.compositereference.ovpagecanvas
                    break;
            }

            switch(background){
                case 0 :
                    thispage.setinvert(imageData.data);
                    break;
                case 1 :
                    thispage.transparent(imageData.data);
                    break;
                case 2 :
                    thispage.transparent(imageData.data);
                    break;
            }

            if(background != -1){
                switch(background){
                    case 1 :
                        thispage.compositereference.bgpagectx.putImageData(imageData, 0, 0);
                        break;
                    case 2 :
                        thispage.compositereference.ovpagectx.putImageData(imageData, 0, 0);
                        break;
                }


            }

        };

        this.invertpdf = function(background){


            switch(background){
                case 1 :
                    try{
                        var imageData = thispage.compositereference.bgpagectx.getImageData(0, 0, thispage.compositereference.bgpagecanvas.width, thispage.compositereference.bgpagecanvas.height);
                    }catch (e) {
                        alert("Error 1 - " + e);
                        console.log(e, thispage.compositereference.bgpagecanvas.width, thispage.compositereference.bgpagecanvas.height);
                        background = -1;
                    }
                    //thispage.compositereference.bgpagecanvas
                    break;
                case 2 :
                    try{
                        imageData = thispage.compositereference.ovpagectx.getImageData(0, 0, thispage.compositereference.ovpagecanvas.width, thispage.compositereference.ovpagecanvas.height);
                    }catch (e) {
                        alert("Error 1 - " + e);
                        console.log(e, thispage.compositereference.ovpagecanvas.width, thispage.compositereference.ovpagecanvas.height);
                        background = -1;
                    }

                    //thispage.compositereference.ovpagecanvas
                    break;
            }

            //var data = imageData.data;
            var cmprcolors = thispage.compositereference.getColors();

            switch(background){
                case 0 :
                    thispage.setinvert(imageData.data);
                    break;
                case 1 :
                    thispage.setcolor(imageData.data,cmprcolors.bg);
                    //thispage.setblue(imageData.data);
                    break;
                case 2 :
                    thispage.setcolor(imageData.data,cmprcolors.fg);
                    //thispage.setred(imageData.data);
                    break;
            }

            if(background != -1){
                switch(background){
                    case 1 :

                        thispage.compositereference.bgpagectx.putImageData(imageData, 0, 0);
                        break;
                    case 2 :
                        thispage.compositereference.ovpagectx.putImageData(imageData, 0, 0);
                        break;
                }


            }


            if (this.usedincomposite && this.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
                //console.log('draw compare invert pdf' );
            } else {
                //this.draw_image(true);
            }
            //imageData = null;

        };

        this.transparentimage = function(background){
            var imageDatalarge = thispage.largeimagectx.getImageData(0, 0, thispage.largeimagecnv.width, thispage.largeimagecnv.height);
            var imageDatasmall = thispage.smallimagectx.getImageData(0, 0, thispage.smallimagecnv.width, thispage.smallimagecnv.height);

            var data = imageDatasmall.data;


            switch(background){
                case 0 :
                    thispage.setinvert(data);
                    break;
                case 1 :
                    //thispage.setblue(data);
                    thispage.transparent(data);
                    break;
                case 2 :
                    //thispage.setred(data);
                    thispage.transparent(data);
                    break;
            }
            thispage.smallimagectx.putImageData(imageDatasmall, 0, 0);

            data = imageDatalarge.data;

            switch(background){
                case 0 :
                    thispage.setinvert(data);
                    break;
                case 1 :
                    //thispage.setblue(data);
                    thispage.transparent(data);
                    break;
                case 2 :
                    thispage.transparent(data);
                    //thispage.setred(data);
                    break;
            }
            thispage.largeimagectx.putImageData(imageDatalarge, 0, 0);

            thispage.largeimagectx.putImageData(imageDatalarge, 0, 0);
            if (this.usedincomposite && this.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
            } else {
                this.draw_image(true);
            }


        };

        this.invert = function(background){


            var imageDatalarge = thispage.largeimagectx.getImageData(0, 0, thispage.largeimagecnv.width, thispage.largeimagecnv.height);
            var imageDatasmall = thispage.smallimagectx.getImageData(0, 0, thispage.smallimagecnv.width, thispage.smallimagecnv.height);

            //var imageData = contexto.getImageData(0, 0, canvasowidth, canvasoheight);
            var data = imageDatasmall.data;
            //thispage.setinvert(data);

            var cmprcolors = thispage.compositereference.getColors();

            switch(background){
                case 0 :
                    thispage.setinvert(data);
                    break;
                case 1 :
                    //thispage.setblue(data);
                    thispage.setcolor(data,cmprcolors.bg);
                    break;
                case 2 :
                    //thispage.setred(data);
                    thispage.setcolor(data,cmprcolors.fg);
                    break;
            }

            thispage.smallimagectx.putImageData(imageDatasmall, 0, 0);

            data = imageDatalarge.data;

            switch(background){
                case 0 :
                    thispage.setinvert(data);
                    break;
                case 1 :
                    //thispage.setblue(data);
                    thispage.setcolor(data,cmprcolors.bg);
                    break;
                case 2 :
                    thispage.setcolor(data,cmprcolors.fg);
                    //thispage.setred(data);
                    break;
            }

            thispage.largeimagectx.putImageData(imageDatalarge, 0, 0);
            if (this.usedincomposite && this.compositereference != undefined) {
                //this.compositereference.draw_compare(false);
            } else {
                this.draw_image(true);
            }

            //this.draw_image(true);


        };

        this.resetimage = function(){
            var imagewidth = thispage.MainImageWidth;
            var imageheight = thispage.MainImageHeight;

            thispage.largeimagecnv.width = imagewidth;
            thispage.largeimagecnv.height = imageheight;

            thispage.largeimagectx.drawImage(thispage.largeimage,0,0,imagewidth,imageheight);

            imagewidth = thispage.SmallImageWidth;
            imageheight = thispage.SmallImageHeight;

            thispage.smallimagecnv.width = imagewidth;
            thispage.smallimagecnv.height = imageheight;

            thispage.smallimagectx.drawImage(thispage.smallimage,0,0,imagewidth,imageheight);

        };


        this.draw_thumbnail = function(){
            //thispage.thumbctx = this.thumbcanvas.getContext('2d');
            /*
             draw to thumbnail once with the appropriate method.
             */
            thispage.thumbctx.clearRect(0, 0, thispage.thumbnailobj.thumbnail.width, thispage.thumbnailobj.thumbnail.height);
            if(thispage.thumbloaded){
                thispage.thumbctx.drawImage(thispage.thumbnailobj.image, 0, 0);
            }


        };

        this.draw_imagePrint = function(){

            thispage.printobj.printctx.drawImage(this.largeimage, thispage.printobj.pdx, thispage.printobj.pdy, thispage.printobj.docwidth * thispage.printobj.pscale, thispage.printobj.docheight * thispage.printobj.pscale);

            drawmarkupPrint(thispage.printobj.printctx,thispage.pagenumber,thispage.printobj.pdx,thispage.printobj.pdy,thispage.printobj.pscale);

        };

        this.draw_image = function (clear) {

            thispage.backupScaleAndOffset();

            if(thispage.DocRef.bSopenSilent){
                return;
            }

            if (clear) {
                contexto.fillStyle = displayBGColor;
                contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            }

            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);

            documentopen = true;

            if (bSuspendDraw){
                return;
            }

            switch (this.currentimage) {
                case 0:
                    if (this.drotation == 0) {

                        contexto.drawImage(this.largeimagecnv, this.dx, this.dy, this.MainImageWidth * this.dscale, this.MainImageHeight * this.dscale);

                    } else {
                        contexto.save();
                        contexto.translate(tx, ty);
                        contexto.rotate(this.drotation * (Math.PI / 180));
                        contexto.translate(-tx, -ty);
                        contexto.drawImage(this.largeimagecnv, this.dx, this.dy, this.MainImageWidth * this.dscale, this.MainImageHeight * this.dscale);
                        contexto.restore();

                    }
                    break;
                case 1:
                    var drawscale = thispage.dscale / thispage.bitmapratio;
                    if (this.drotation == 0) {
                        contexto.drawImage(this.smallimagecnv, this.dx, this.dy, this.SmallImageWidth * drawscale, this.SmallImageHeight * drawscale);


                    } else {
                        contexto.save();
                        contexto.translate(tx, ty);
                        contexto.rotate(this.drotation * (Math.PI / 180));
                        contexto.translate(-tx, -ty);
                        contexto.drawImage(this.smallimagecnv, this.dx, this.dy, this.SmallImageWidth * drawscale, this.SmallImageHeight * drawscale);
                        contexto.restore();

                    }

                    break;
            }

        };

        //prevent automatic loading of thumbnails SO175

        if (bAutoloadThumbnails){
            thispage.thumbload();
        }


    };

    var DocumentObject = function (xmlDoc) {

        //File Information section
        var thisdocument = this;
        var relpath = xmlurlrel;
        var nummarkupfiles = 0;
        var markupfilesreceived = 0;
        var bMultiMarkupselected  = false;

        if(bUseCustomrelpath){
            relpath = xmlurlrelcustom;
        }

        this.usepagesload = false;
        this.fileindex = 0;
        this.relativepath = undefined;
        this.bActive = true;
        //SetActive
        this.bSopenSilent = false;
        this.textselect = false;
        this.hastext = false;
        this.markuploaded = false;
        this.pagelocked = false;
        this.lockedpage = thisdocument.currentpage;


        this.currentpage = 0;
        this.restorecurpage = 0;
        this.backgroundColor = backgroundColor;

        this.bMarkupchanged = false;
        this.curcontrol3D = 'orbitControl';
        this.bMarkupLocked = false;
        this.bDoPrint = false;
        this.bLargePDF = false;
        this.largePDFPagerange = 4;
        this.endpagerange = 4;
        this.startpagerange = 0;
        this.pagerangelimit = 1;
        this.pdfLoadingTask = null;
        this.PDFWrapper = null;
        this.bdestroyPDFonClose = false;
        this.PDFpagescale = {width : 1, height: 1, scale : 1};

        this.xrefs = [];
        this.fonts = [];

        this.searchobj = {
            matcharray : [],
            active : false,
            forward : true,
            casesens : false,
            expr : "",
            indx : 0,
            page : 0,
            next : function(){
                if(this.matcharray.length == 0){
                    return;
                }
                this.indx++;
                if(this.indx > this.matcharray.length - 1){
                    this.indx = 0;
                }


                this.page = this.matcharray[this.indx].page;
            },
            previous : function(){
                if(this.matcharray.length == 0){
                    return;
                }

                this.indx--;
                if(this.indx < 0){
                    this.indx = this.matcharray.length - 1;
                }
                this.page = this.matcharray[this.indx].page;
            },
            start : function(){
                if(this.matcharray.length == 0){
                    return;
                }

                this.page = this.matcharray[this.indx].page;
            }

        };

        this.Version = xmlDoc.getElementsByTagName('Version')[0].firstChild.nodeValue;
        this.NumPages = xmlDoc.getElementsByTagName('NumPages')[0].firstChild.nodeValue;
        this.NumLayouts = xmlDoc.getElementsByTagName('NumLayouts')[0].firstChild.nodeValue;
        this.FileName = xmlDoc.getElementsByTagName('FileName')[0].firstChild.nodeValue;
        this.CacheFileName = this.FileName;


        var szFileName = getFileName(this.FileName);
        this.CachePath = getPath(this.FileName);

        if(bUseCustomrelpath){
            this.FileName = szFileName;
        }

        this.OriginalURL = xmlDoc.getElementsByTagName('OriginalURL')[0].firstChild.nodeValue;
        this.Format = xmlDoc.getElementsByTagName('Format')[0].firstChild.nodeValue;
        this.Filter = xmlDoc.getElementsByTagName('Filter')[0].firstChild.nodeValue;
        this.FileSizeLow = xmlDoc.getElementsByTagName('FileSizeLow')[0].firstChild.nodeValue;
        this.FileSizeHigh = xmlDoc.getElementsByTagName('FileSizeHigh')[0].firstChild.nodeValue;
        this.Type = xmlDoc.getElementsByTagName('Type')[0].firstChild.nodeValue;


        if (xmlDoc.getElementsByTagName('XREFS') != undefined) {
            var xmlxrefs = xmlDoc.getElementsByTagName('XREF');
            for (var i = 0; i < xmlxrefs.length; i++) {
                if(xmlxrefs[i].getElementsByTagName('FileName')[0].firstChild != null){
                    var szpath = xmlxrefs[i].getElementsByTagName('FileName')[0].firstChild.nodeValue;
                    var bfound = (xmlxrefs[i].getElementsByTagName('Found')[0].firstChild.nodeValue == 'true');

                    var xrefobject = {
                        path:szpath,
                        found:bfound
                    };
                    this.xrefs.push(xrefobject);

                }
            }
        }

        if (xmlDoc.getElementsByTagName('Fonts') != undefined) {
            var xmlfonts = xmlDoc.getElementsByTagName('Font');
            for (i = 0; i < xmlfonts.length; i++) {
                var szfontpath = xmlfonts[i].getElementsByTagName('FileName')[0].firstChild.nodeValue;
                var bffound = (xmlfonts[i].getElementsByTagName('Found')[0].firstChild.nodeValue == 'true');
                var fontobject = {
                    path:szfontpath,
                    found:bffound
                };
                this.fonts.push(fontobject);
            }
        }

        if (xmlDoc.getElementsByTagName('Summary') != undefined) {
            var summaryprops = xmlDoc.getElementsByTagName('Property');
            for (i = 0; i < summaryprops.length; i++) {

                if(summaryprops[i].getElementsByTagName('Name') != undefined && summaryprops[i].getElementsByTagName('Name')[0].firstChild != null){
                    var szname = summaryprops[i].getElementsByTagName('Name')[0].firstChild.nodeValue;
                }else{
                    szname = "";
                }

                if(summaryprops[i].getElementsByTagName('Value') != undefined && summaryprops[i].getElementsByTagName('Value')[0].firstChild != null){
                    var szvalue = summaryprops[i].getElementsByTagName('Value')[0].firstChild.nodeValue;
                }else{
                    szvalue = "";
                }

                if(szname == "ACAD_MEASUREMENT"){
                    this.CadMeasurement = parseInt(szvalue);
                    //0 = inch
                    //1 = metric
                }
            }
        }

        if (xmlDoc.getElementsByTagName('FileNameSRC')[0] != undefined) {
            this.FileNameSRC = encodeURI(relpath + xmlDoc.getElementsByTagName('FileNameSRC')[0].firstChild.nodeValue);
            this.CacheURL = getURLPath(this.FileNameSRC);
        }


        this.thumbnails = [];
        this.Drawmarkup = true;
        this.thumbnailhtmlsource = "";
        this.layerhtmlsource = "";

        //Arrays for layouts and pages
        this.layouts = [];
        this.pages = [];
        this.markuplist = [];
        this.markupdraworder = [];

        //this.selectedmarkup = [];

        this.selectedmarkup = {
            id : -1,
            selected : false,
            edit : false
        };

        this.rangeupdated = {
            start : 0,
            end : 0,
            operation : 'none'
        };

        this.markupdraworder = [];
        this.markupundolist = [];
        this.documentproperties = [];
        this.nummarkups = 0;
        this.pdfDoc = null;
        this.pdfURL = "";
        this.pageNum = 1;
        this.pageRendering = false;
        this.pageNumPending = null;
        this.scale = 0.8;

        this.pdftimervar = null;
        this._pagesRefCache = Object.create(null);
        this.pdfoutline = undefined;


        this.setnummarkupfiles = function(num){
            nummarkupfiles = num;
        };

        this.getnummarkupfiles = function(){
            return nummarkupfiles;
        };

        this.setmarkupfilesreceived = function(){
            markupfilesreceived ++;

        };

        this.getmarkupfilesreceived = function(){

            return markupfilesreceived;
        };

        this.textsearchend = function(){

            if(thisdocument.searchobj.active){
                thisdocument.pages[thisdocument.currentpage].clearSearch();
            }
            thisdocument.searchobj.matcharray = [];
            thisdocument.searchobj.expr = "";
            thisdocument.searchobj.forward = true;
            thisdocument.searchobj.casesens = false;
            thisdocument.searchobj.active = false;
            thisdocument.searchobj.indx = 0;
            thisdocument.searchobj.page = 0;


            if (thisdocument.pages[thisdocument.currentpage].usepdfjs){
                thisdocument.enableTextSelect(false);
            }
            if(thisdocument.pages[thisdocument.currentpage].usevectorxml){
                thisdocument.enableTextSelect(false);
            }

            if(RxCore_GUI_NumMathces != undefined){
                RxCore_GUI_NumMathces.numTextFound(thisdocument.searchobj.matcharray.length);
            }



        };

        this.textsearch = function (text,forward,casesens){

            if(text == thisdocument.searchobj.expr && thisdocument.searchobj.active){

                if(forward){
                    thisdocument.pages[thisdocument.currentpage].clearSearch();
                    thisdocument.searchobj.next();

                    if(thisdocument.searchobj.page != thisdocument.currentpage){
                        thisdocument.GotoPage(thisdocument.searchobj.page);
                    }
                    //thisdocument.pages[thisdocument.currentpage].clearSearch();
                    thisdocument.pages[thisdocument.currentpage].showSearch();
                }

                if (!forward){
                    thisdocument.pages[thisdocument.currentpage].clearSearch();
                    thisdocument.searchobj.previous();

                    if(thisdocument.searchobj.page != thisdocument.currentpage){
                        thisdocument.GotoPage(thisdocument.searchobj.page);
                    }


                    thisdocument.pages[thisdocument.currentpage].showSearch();
                }

            }else{
                if(thisdocument.searchobj.active){
                    thisdocument.pages[thisdocument.currentpage].clearSearch();
                }

                thisdocument.searchobj.matcharray = [];
                thisdocument.searchobj.expr = text;
                thisdocument.searchobj.forward = forward;
                thisdocument.searchobj.casesens = casesens;
                thisdocument.searchobj.active = false;
                thisdocument.searchobj.indx = 0;
                thisdocument.searchobj.page = 0;

                if (thisdocument.pages[thisdocument.currentpage].usepdfjs){
                    if (!thisdocument.textselect){
                        thisdocument.enableTextSelect(true);
                    }

                    for (var pagecnt = 0; pagecnt < thisdocument.pages.length;pagecnt++){
                        thisdocument.pages[pagecnt].getPDFSearchList();

                    }
                    if(RxCore_GUI_NumMathces != undefined){
                        RxCore_GUI_NumMathces.numTextFound(thisdocument.searchobj.matcharray.length);
                    }
                    //thisdocument.searchobj.matcharray
                }

                if (thisdocument.pages[thisdocument.currentpage].usevectorxml){
                    if (!thisdocument.textselect){
                        thisdocument.enableTextSelect(true);
                    }
                    for (var vpagecnt = 0; vpagecnt < thisdocument.pages.length;vpagecnt++){
                        thisdocument.pages[vpagecnt].getVectorSearchList();
                    }

                    if(RxCore_GUI_NumMathces != undefined){
                        RxCore_GUI_NumMathces.numTextFound(thisdocument.searchobj.matcharray.length);
                    }

                }

                if(thisdocument.searchobj.matcharray.length > 0){
                    thisdocument.searchobj.active = true;
                    thisdocument.searchobj.start();

                    if(thisdocument.searchobj.page != thisdocument.currentpage){
                        thisdocument.GotoPage(thisdocument.searchobj.page);
                    }

                    thisdocument.pages[thisdocument.currentpage].showSearch();

                }


            }

        };

        this.getcurPage = function(){
            var curpage = thisdocument.currentpage;

            if(thisdocument.usepagesload){
              curpage = thisdocument.pages[thisdocument.currentpage].pagenumber;
            }else{
              curpage = thisdocument.currentpage;
            }

            return curpage;
        };

        this.setDocumentPageScale = function(width, height, scale){

            //this.PDFpagescale = {width : 1, height: 1, pdfscale : 1};
            thisdocument.PDFpagescale.width = width;
            thisdocument.PDFpagescale.height = height;
            thisdocument.PDFpagescale.scale = scale;

            //thispage.offscreenwidth, thispage.offscreenheight, thispage.dscalepdf
        };

        this.getAllPageDim = function(){
            var pagedims = [];

            for(var i = 0;i < thisdocument.pages.length;i++){
                pagedims.push(thisdocument.pages[i].getpagedim());
            }

            return pagedims;
        };

        this.getPageDim = function(pagenumber){

            var pgobj = thisdocument.getPageObject(pagenumber);


            if (pgobj != undefined){
                var pgdim = pgobj.getpagedim();
            }else{
                pgdim = undefined;
            }

            return pgdim;

        };

        this.setPageDim = function(pagenumber, height, width,  x, y){
            var pgobj = thisdocument.getPageObject(pagenumber);

            if (pgobj != undefined){
                var pgdim = pgobj.setpagedim(height, width,  x, y);
            }

        };

        this.getFirstLoadedPage = function(){
            var curpageobj = undefined;

            curpageobj = thisdocument.pages[0];
            return curpageobj;

        };

        this.getPageObject = function(pagenumber){
            var curpageobj = undefined;

            if(!thisdocument.usepagesload){
                curpageobj = thisdocument.pages[pagenumber];
            }else{
              for(var i = 0;i < thisdocument.pages.length;i++){
                if (thisdocument.pages[i].pagenumber == pagenumber){
                  curpageobj = thisdocument.pages[i];
                }
              }
            }

            return curpageobj;
        };


        this.addProperties = function(properties){

            var format = thisdocument.Format.substring(0, 9);
            if (format == 'Adobe PDF'){


                for (var k in properties.info) {
                    if (typeof properties.info[k] !== 'function') {
                        thisdocument.documentproperties.push({name : k, value : properties.info[k]})

                    }

                }

            }


        };

        this.inpagerange = function(pagenum){

            var pagerange = thisdocument.pagerange();
            return (pagenum > pagerange.start && pagenum < pagerange.end);

        };

        /*function shortpgupdateloop(){

            var pagesstate = {
                pagenum : thisdocument.currentpage,
                pagerange : thisdocument.pagerange(),
                bpageshort : true,
                pagearray : thisdocument.pagerangearray()
            };

            yieldingLoop(pagesstate, 10, function() {
                pagesstate = pagechangeloop(pagesstate);

            }, function() {
                pageupdatecomplete();
            });

        }*/

        this.loadPageEvt = function(pagenumber){
            var currentPage = thisdocument.pages[thisdocument.currentpage].pagenumber;

            if(pagenumber === currentPage) {
                thisdocument.getPageObject(pagenumber).redraw();
                thisdocument.pgChangeLoop();
            }

        };

        this.pgChangeLoop = function(){
            var pagesstate = {
                pagenum : 0,
                pagerange : thisdocument.pagerange(),
                bpageshort : false,
                //exludedpages : parr
            };

            /*var list = [];

            for (var i = pagesstate.pagerange.start; i <= pagesstate.pagerange.end; i++) {
                list.push(i);
            }
            var newList = [...new Set([...list, ...thisdocument.isNotCollapsed])];

            for(var e=0;e<newList.length;e++){
                pagesstate.pagenum = newList[e];
                pagechangeloop(pagesstate);
            }*/

            var list = thisdocument.isNotCollapsed || [];

            for (var i = pagesstate.pagerange.start; i <= pagesstate.pagerange.end; i++) {
               if(list.indexOf(i) == -1) {
                   list.push(i);
               }

            }

            for(var e=0;e<list.length;e++){
               pagesstate.pagenum = list[e];
               pagechangeloop(pagesstate);
            }


            /*newList.forEach(function(e){
                pagesstate.pagenum = e;
                pagechangeloop(pagesstate);
            });*/

            /*newList.forEach(e => {
                pagesstate.pagenum = e
                pagechangeloop(pagesstate);
            });*/
        };


        function pgupdateloop(){

            //var parr  = pagechangeloopshort();

            var pagesstate = {
                pagenum : 0,
                pagerange : thisdocument.pagerange(),
                bpageshort : false,
                //exludedpages : parr
            };

            //added code for quick update of current page
            if(!thisdocument.pages[thisdocument.currentpage].pdfisfirstrendered){
                //thisdocument.pages[i].queueRenderPage(i + 1);
                //thisdocument.pages[thisdocument.currentpage].queueRenderPage(thisdocument.currentpage + 1);
                thisdocument.pages[thisdocument.currentpage].queRenderPageScaled();
                //thisdocument.pages[pagestate.pagenum].queRenderPageScaled();

            }else{
                if(thisdocument.pages[thisdocument.currentpage].iscollapsed){

                    thisdocument.pages[thisdocument.currentpage].pdfisrendered = false;
                    //thisdocument.pages[pagestate.pagenum].queRenderPageScaled();
                }
                //thisdocument.pages[i].pdfisrendered = false;
            }


            /*yieldingLoop(pagesstate, 10, function() {
                pagesstate = pagechangeloop(pagesstate);

            }, function() {
                pageupdatecomplete();
            });*/

        }

        function pageupdatecomplete(){
            //console.log('page range update complete');
            thisdocument.draw_mpagepdf();
        }

        function pagechangeloopshort(){
            var curpage = thisdocument.currentpage;

            if(thisdocument.bLargePDF){

                if (curpage == 0){
                    var parr = [curpage, curpage+1,curpage+2];
                }else if (curpage == (thisdocument.pages.length - 1)){
                    var parr = [curpage, curpage-1,curpage-2];
                }else if (curpage > 0 && curpage < (thisdocument.pages.length - 1)){
                    var parr = [curpage, curpage+1,curpage-1];
                }
            }else{
                parr = [thisdocument.currentpage];
            }

            for (var pc = 0; pc < parr.length; pc++){
                if (thisdocument.pages[pc] == undefined){
                    continue;
                }
                if(!thisdocument.pages[pc].pdfisfirstrendered){
                    //thisdocument.pages[i].queueRenderPage(i + 1);
                    thisdocument.pages[pc].queueRenderPage(pc + 1);
                    //thisdocument.pages[pc].queRenderPageScaled();

                }else{
                    if(thisdocument.pages[pc].iscollapsed){
                        thisdocument.pages[pc].pdfisrendered = false;
                        thisdocument.pages[pc].queRenderPageScaled();
                    }
                    //thisdocument.pages[i].pdfisrendered = false;
                }
            }

            return parr;
        }

        function pagechangeloop(pagestate){

            /*if (pagestate.exludedpages.indexOf(pagestate.pagenum) >= 0){
                pagestate.pagenum ++;
                return pagestate;
            }*/


            if(pagestate.pagenum >= pagestate.pagerange.start && pagestate.pagenum <= pagestate.pagerange.end){

                if (thisdocument.pages[pagestate.pagenum] && pagestate.pagenum != thisdocument.currentpage){
                    if(!thisdocument.pages[pagestate.pagenum].pdfisfirstrendered){
                        //thisdocument.pages[i].queueRenderPage(i + 1);
                        //thisdocument.pages[pagestate.pagenum].queueRenderPage(pagestate.pagenum + 1);
                        thisdocument.pages[pagestate.pagenum].queRenderPageScaled();

                    }else{
                        if(thisdocument.pages[pagestate.pagenum].iscollapsed){

                            thisdocument.pages[pagestate.pagenum].pdfisrendered = false;
                            //thisdocument.pages[pagestate.pagenum].queRenderPageScaled();
                        }
                        //thisdocument.pages[i].pdfisrendered = false;
                    }

                }

            }else{
                if(pagestate.pagenum<thisdocument.pages.length){
                    thisdocument.pages[pagestate.pagenum].collapsepage();
                }
            }


            if (pagestate.bpageshort){
                pagestate.pagearray.shift();
                pagestate.pagenum = pagestate.pagearray[0];

            }else{
                pagestate.pagenum ++;
            }

            return pagestate;
        }

        this.pagerangearray = function(){
            var curpage = this.currentpage;
            var halfrange = thisdocument.largePDFPagerange / 2;
            var endtrigger = thisdocument.endpagerange - thisdocument.pagerangelimit;
            var starttrigger = thisdocument.startpagerange + thisdocument.pagerangelimit;

            if (thisdocument.bLargePDF){
                if (curpage <= halfrange){
                    thisdocument.startpagerange = 0;
                    thisdocument.endpagerange = thisdocument.largePDFPagerange;

                }else if(curpage >= (thisdocument.pages.length - halfrange)){
                    thisdocument.startpagerange = thisdocument.pages.length - thisdocument.largePDFPagerange;
                    thisdocument.endpagerange = thisdocument.pages.length;
                }else if (curpage == endtrigger){
                    thisdocument.startpagerange = endtrigger - halfrange;
                    thisdocument.endpagerange = endtrigger + halfrange;
                }else if (curpage == starttrigger){
                    thisdocument.startpagerange = starttrigger - halfrange;
                    thisdocument.endpagerange = starttrigger + halfrange;
                }else if (curpage > thisdocument.endpagerange){
                    thisdocument.startpagerange = curpage - halfrange;
                    thisdocument.endpagerange = curpage + halfrange;
                }else if (curpage < thisdocument.startpagerange){
                    thisdocument.startpagerange = curpage - halfrange;
                    thisdocument.endpagerange = curpage + halfrange;

                }

            }else{
                thisdocument.startpagerange = 0;
                thisdocument.endpagerange = thisdocument.pages.length;
            }

            var pagearray = [thisdocument.currentpage];
            for(var pc = 1; pc < halfrange; pc++ ){

                pagearray.push(thisdocument.currentpage + pc);
                if ((thisdocument.currentpage - pc) >= 0){
                    pagearray.push(thisdocument.currentpage - pc);
                }

            }

            return pagearray;

        };

        this.pagerange = function(){
            var curpage = this.currentpage;

            //this.largePDFPagerange = 30;
            //this.endpagerange = 30;
            //this.startpagerange = 0;
            //this.pagerangelimit = 2;
            var halfrange = thisdocument.largePDFPagerange / 2;
            var endtrigger = thisdocument.endpagerange - thisdocument.pagerangelimit;
            var starttrigger = thisdocument.startpagerange + thisdocument.pagerangelimit;

            if (thisdocument.bLargePDF){
                if (curpage <= halfrange){
                    thisdocument.startpagerange = 0;
                    thisdocument.endpagerange = thisdocument.largePDFPagerange;

                }else if(curpage >= (thisdocument.pages.length - halfrange)){
                    thisdocument.startpagerange = thisdocument.pages.length - thisdocument.largePDFPagerange;
                    thisdocument.endpagerange = thisdocument.pages.length;
                }else if (curpage == endtrigger){
                    thisdocument.startpagerange = endtrigger - halfrange;
                    thisdocument.endpagerange = endtrigger + halfrange;
                }else if (curpage == starttrigger){
                    thisdocument.startpagerange = starttrigger - halfrange;
                    thisdocument.endpagerange = starttrigger + halfrange;
                }else if (curpage > thisdocument.endpagerange){
                    thisdocument.startpagerange = curpage - halfrange;
                    thisdocument.endpagerange = curpage + halfrange;
                }else if (curpage < thisdocument.startpagerange){
                    thisdocument.startpagerange = curpage - halfrange;
                    thisdocument.endpagerange = curpage + halfrange;

                }

            }else{
                thisdocument.startpagerange = 0;
                thisdocument.endpagerange = thisdocument.pages.length;
            }

            //console.log(thisdocument.startpagerange,'-' ,thisdocument.endpagerange);
            return {
                start : thisdocument.startpagerange,
                end : thisdocument.endpagerange,
                nextstart : thisdocument.endpagerange + 1,
                nextend : thisdocument.endpagerange + thisdocument.largePDFPagerange + 1
            };
        };

        this.pagelock = function(onOff){
            thisdocument.pagelocked = onOff;
            thisdocument.lockedpage = thisdocument.currentpage;


        };


        this.mpzoom = function (dx, dy, dscale) {
            if (thisdocument.pagelocked){
                return;
            }

            for (var i = 0; i < this.pages.length; i++) {
                this.pages[i].dypdf = dy;
                this.pages[i].dxpdf = dx;
                this.pages[i].dscalepdf = dscale;
                this.pages[i].pdfisrendered = false;

            }
        };

        this.zoom_update = function (sx, sy, sWide, sHi) {
            if (thisdocument.pagelocked){
                return;
            }

            for (var i = 0; i < this.pages.length; i++) {
                if (i != this.currentpage) {
                    this.pages[i].zoom_update(sx, sy, sWide, sHi);
                }
            }

        };

        this.zoomall = function () {
            if (thisdocument.pagelocked){
                return;
            }

            for (var i = 0; i < this.pages.length; i++) {
                if (i != this.currentpage) {
                    this.pages[i].zoomall();
                }
                //console.log(i,this.pages[i].dscalepdf);
            }

        };

        this.pan_position = function(sx,sy){
            if (thisdocument.pagelocked){
                return;
            }

            if(this.currentpage == 0){
                var startrange = 0;
            } else{
                startrange = this.currentpage - 1;
            }
            if (this.currentpage == this.pages.length - 1){
                var endrange  = this.pages.length - 1;
            }else{
                endrange  = this.currentpage + 1;
            }

            for (var i = startrange; i < endrange; i++) {
                if (i != this.currentpage) {
                    this.pages[i].pan_position(sx, sy);
                    if (this.pages[i].usepdfjs) {
                        if(this.textselect){
                            this.pages[i].PDFTextArea.style.display = "none";
                        }

                    }

                }
            }

        };

        this.pan_update = function (sx, sy) {
            if (thisdocument.pagelocked){
                return;
            }

            //var pagerange = thisdocument.pagerange();

            if(this.currentpage == 0){
                var startrange = 0;
            } else{
                startrange = this.currentpage - 1;
            }
            if (this.currentpage == this.pages.length - 1){
                var endrange  = this.pages.length - 1;
            }else{
                endrange  = this.currentpage + 1;
            }


            for (var i = startrange; i < endrange; i++) {
                if (i != this.currentpage) {
                    this.pages[i].pan_update(sx, sy);
                    if (this.pages[i].usepdfjs) {
                        if(this.textselect){
                            this.pages[i].PDFTextArea.style.display = "none";
                        }

                    }

                }
            }

            //for (var i = 0; i < this.pages.length; i++) {
            /*for (var i = pagerange.start; i < pagerange.end; i++) {
                if (i != this.currentpage) {
                    this.pages[i].pan_update(sx, sy);
                    if (this.pages[i].usepdfjs) {
                        if(this.textselect){
                            this.pages[i].PDFTextArea.style.display = "none";
                        }

                    }

                }
            }*/
        };

        this.ZoomIn = function (factor, center) {
            if (thisdocument.pagelocked){
                return;
            }

            for (var i = 0; i < this.pages.length; i++) {
                if (i != this.currentpage) {
                    this.pages[i].ZoomIn(factor, center, false);
                }
            }

        };

        this.zoomheight = function () {
            if (thisdocument.pagelocked){
                return;
            }

            for (var i = 0; i < this.pages.length; i++) {
                if (i != this.currentpage) {
                    this.pages[i].zoomheight();
                }
            }

        };

        this.zoomwidth = function () {
            if (thisdocument.pagelocked){
                return;
            }

            for (var i = 0; i < this.pages.length; i++) {
                if (i != this.currentpage) {
                    this.pages[i].zoomwidth();
                }
            }

        };


        this.ZoomOut = function (factor, center) {

            if (thisdocument.pagelocked){
                return;
            }

            for (var i = 0; i < this.pages.length; i++) {
                if (i != this.currentpage) {
                    this.pages[i].ZoomOut(factor, center, false);
                }
            }

        };

        this.recalcPages = function (factor, zoomin, xdiff) {
            if (thisdocument.pagelocked){
                return;
            }

            var dscale = this.pages[this.currentpage].dscalepdf;
            var dx = this.pages[this.currentpage].dxpdf;
            var dy = this.pages[this.currentpage].dypdf;


            for (var i = 0; i < this.pages.length; i++) {
                if (i != this.currentpage) {

                    //this.pages[i].dscalepdf = (this.pages[this.currentpage].pagecanvas.width * dscale) / this.pages[i].pagecanvas.width;
                    if (zoomin) {
                        this.pages[i].dscalepdf = this.pages[i].dscalepdf * factor;
                    } else {
                        this.pages[i].dscalepdf = this.pages[i].dscalepdf / factor;
                    }
                    this.pages[i].dxpdf = this.pages[i].dxpdf - xdiff;
                    this.pages[i].pdfisrendered = false;
                    //this.dscalepdf = this.dscalepdf / factor;

                    /*if(this.pages[i].pagecanvas.width * this.pages[i].dscalepdf != this.pages[this.currentpage].pagecanvas.width * dscale){
                     if(this.pages[i].pagecanvas.width != this.pages[this.currentpage].pagecanvas.width){
                     console.log(this.pages[i].dscalepdf);
                     }
                     }*/

                    //this.pages[i].dscalepdf = dscale;
                    //this.pages[i].dxpdf = dx;

                    //var wscale = (this.pages[this.currentpage].pagecanvas.width * this.pages[this.currentpage].dscalepdf) / Math.abs(page.view[2]);
                    //var hscale = (this.pages[this.currentpage].pagecanvas.height * this.pages[this.currentpage].dscalepdf) / Math.abs(page.view[3]);


                }
            }


        };

        this.renderPDFscale = function () {

            var pagerange = thisdocument.pagerange();
            var dscale = this.pages[this.currentpage].dscalepdf;
            var dx = this.pages[this.currentpage].dxpdf;
            var dy = this.pages[this.currentpage].dypdf;



            /*for(var i=0;i<this.pages.length;i++){
             if (i != this.currentpage){
             this.pages[i].dscalepdf = dscale;
             this.pages[i].dxpdf = dx;*/

            /*if((this.pages[i].dxpdf < canvasowidth && this.pages[i].dxpdf > 0) || (this.pages[i].endx > 0 && this.pages[i].endx < canvasowidth) ){
             if((this.pages[i].dypdf < canvasoheight && this.pages[i].dypdf > 0) || (this.pages[i].endy > 0 && this.pages[i].endy < canvasoheight)){
             //thispage.visible = true;
             console.log('visible ' + this.pages[i].pagenumber);
             }else{
             //thispage.visible = false;
             }
             }*/


            //this.pages[i].queRenderPageScaled();


            //this.pages[i].renderPDFpagescale(false);
            /*}
             }*/
            if (thisdocument.pages.length > 1 && !thisdocument.pagelocked) {
                if (thisdocument.bLargePDF){
                    for (var i=pagerange.start;i<pagerange.end;i++ ){
                        if (!thisdocument.pages[i].pdfisrendered) {
                            thisdocument.pages[i].queRenderPageScaled();
                        }

                    }

                }else{
                    if (this.currentpage == 0) {
                        this.pages[this.currentpage].queRenderPageScaled();
                        this.pages[this.currentpage + 1].queRenderPageScaled();
                    }else if (this.currentpage == this.pages.length - 1) {
                        this.pages[this.currentpage].queRenderPageScaled();
                        this.pages[this.currentpage - 1].queRenderPageScaled();
                    }else if (this.currentpage > 0 && this.currentpage < this.pages.length - 1) {
                        this.pages[this.currentpage].queRenderPageScaled();
                        this.pages[this.currentpage + 1].queRenderPageScaled();
                        this.pages[this.currentpage - 1].queRenderPageScaled();
                    }
                }


            }else{
                this.pages[this.currentpage].queRenderPageScaled();
            }


            //this.draw_mpagepdf();
        };

        //this.returbookmarknpage = function()

        this.get_bookmark_pageref = function(destRef){

            var pageidx = null;
            var destrefpage = destRef[0];

            for ( var i = 0; i < thisdocument.pages.length; i++) {

                var pageref = thisdocument.pages[i].getpageRef();
                if(isObjectEqual(destrefpage, pageref)){
                    pageidx = thisdocument.pages[i].pagenumber;
                }

                //thisdocument.pages[i].getPDF_PageRef(destRef)
                //thisdocument.pages[i].queueGetPageDim(thisdocument.pages[i].pagenumber + 1);

            }

            /*var cacheKey = destRef.num + ' ' + destRef.gen + ' R';
            thisdocument.pdfDoc.getPageIndex(cacheKey).then(function (pageIndex) {
                return pageIndex;
            });*/
            return pageidx;
        };

        this.getPDF_PageRef = function (destRef, last) {


            thisdocument.pdfDoc.getPageIndex(destRef).then(function (pageIndex) {
                //var pageNum = pageIndex;
                var cacheKey = destRef.num + ' ' + destRef.gen + ' R';
                thisdocument._pagesRefCache[cacheKey] = pageIndex;

                if (RxCore_GUI_PDFBookmarks != undefined) {
                    RxCore_GUI_PDFBookmarks.setPageRef(thisdocument._pagesRefCache);
                }

                //pdfoutline
                if (last) {
                    if (RxCore_GUI_PDFBookmarks != undefined) {
                        RxCore_GUI_PDFBookmarks.setPDFBookmarks(thisdocument.pdfoutline);
                    }

                }

                //goToDestination(destRef);
            });

        };


        this.getPDFDocument = function(){

            return thisdocument.pdfDoc;

        };

        this.loadPDFpages = function(){

            if(thisdocument.pages.length > nLargePDF){

                thisdocument.pages[0].queueRenderPage(thisdocument.pages[0].pagenumber + 1);
                if (bAbortPageload){
                    console.log('page load terminated', i);
                    bAbortPageload = false;
                }

                thisdocument.bLargePDF = true;
                for ( var i = 0; i < thisdocument.pages.length; i++) {

                    thisdocument.pages[i].queueGetPageDim(thisdocument.pages[i].pagenumber + 1);
                    if (bAbortPageload){
                        console.log('page load terminated', i);
                        bAbortPageload = false;
                        break;
                    }

                }

            }else{

                thisdocument.pages[0].queueRenderPage(thisdocument.pages[0].pagenumber + 1);
                if (bAbortPageload){
                     console.log('page load terminated', i);
                     bAbortPageload = false;
                }


                for ( var i = 0; i < thisdocument.pages.length; i++) {

                    thisdocument.pages[i].queueGetPageDim(thisdocument.pages[i].pagenumber + 1);
                    if (bAbortPageload){
                        console.log('page load terminated', i);
                        bAbortPageload = false;
                        break;
                    }

                }


            }


            thisdocument.pdfDoc.getMetadata().then(function(properties){
                  //console.log(properties);
                  thisdocument.addProperties(properties);
            });


            thisdocument.pdfDoc.getOutline().then(function (outline) {

                if (outline) {
                    thisdocument.pdfoutline = outline;


                    if (RxCore_GUI_PDFBookmarks != undefined) {
                        RxCore_GUI_PDFBookmarks.setPDFBookmarks(thisdocument.pdfoutline);
                    }



                }
            });

            thisdocument.SetActive();


        };

        this.setPDFdocument = function(PDFDoc, pagesloaded){

            thisdocument.busesetpdfdoc = true;
            thisdocument.pdfDoc = PDFDoc;

            if(pagesloaded){
                thisdocument.loadPDFpages();
            }

            /*if(thisdocument.pages.length > nLargePDF){

                thisdocument.pages[0].queueRenderPage(thisdocument.pages[0].pagenumber + 1);
                if (bAbortPageload){
                    console.log('page load terminated', i);
                    bAbortPageload = false;
                }

                thisdocument.bLargePDF = true;
                for ( var i = 0; i < thisdocument.pages.length; i++) {

                    thisdocument.pages[i].queueGetPageDim(thisdocument.pages[i].pagenumber + 1);
                    if (bAbortPageload){
                        console.log('page load terminated', i);
                        bAbortPageload = false;
                        break;
                    }

                }

            }else{

                thisdocument.pages[0].queueRenderPage(thisdocument.pages[0].pagenumber + 1);
                if (bAbortPageload){
                     console.log('page load terminated', i);
                     bAbortPageload = false;
                }


                for ( var i = 0; i < thisdocument.pages.length; i++) {

                    thisdocument.pages[i].queueGetPageDim(thisdocument.pages[i].pagenumber + 1);
                    if (bAbortPageload){
                        console.log('page load terminated', i);
                        bAbortPageload = false;
                        break;
                    }

                }


            }


            thisdocument.pdfDoc.getMetadata().then(function(properties){
                  //console.log(properties);
                  thisdocument.addProperties(properties);
            });


            thisdocument.pdfDoc.getOutline().then(function (outline) {

                if (outline) {
                    thisdocument.pdfoutline = outline;


                    if (RxCore_GUI_PDFBookmarks != undefined) {
                        RxCore_GUI_PDFBookmarks.setPDFBookmarks(thisdocument.pdfoutline);
                    }



                }
            });

            thisdocument.SetActive();*/

        };


        this.addpage = function (PageObject, loadimage) {
            PageObject.DocRef = thisdocument;

            thisdocument.pages.push(PageObject);
            var pagnum = thisdocument.pages.length - 1;
            var displaypage = pagnum + 1;
            //this.thumbnailhtmlsource += "<img src='" + PageObject.ThumbnailImageSRC + "'" + " alt='"+ this.PageName + "' onclick='getpage(" + pagnum + ")'>" + "<p style='text-indent: 80px;color:white'>"  + displaypage + "</p>";

            //ThumbnailpagesContainer.Addpage(PageObject.ThumbnailImageSRC,this.PageName, pagnum, displaypage);
            thisdocument.thumbnails.push(PageObject.getThumbnail);

            //PageObject.loadvector();
            /*if (PageObject.usevectorxml){
             loadimage = false;
             PageObject.loadvectors();


             }*/
            if (loadimage) {

                if (PageObject.usevector3Dbinary) {
                    PageObject.loadvectors3DBinary();
                    /*if(PageObject.has3Dnav){
                     PageObject.load3dnavigator();
                     }*/

                } else if (PageObject.usevector3Dxml) {
                    //PageObject.loadvectors3D();
                } else if (PageObject.usevectorbinary) {
                    setSmoothingEnabled(false);
                    // contexto.imageSmoothingEnabled = false;
                    // contexto.mozImageSmoothingEnabled = false;
                    // contexto.msImageSmoothingEnabled = false;
                    PageObject.loadbinvectors();



                    //PageObject.loadbinvectors();

                } else if (PageObject.usevectorxml) {
                    setSmoothingEnabled(false);
                    // contexto.imageSmoothingEnabled = false;
                    // contexto.mozImageSmoothingEnabled = false;
                    // //contexto.webkitImageSmoothingEnabled = false;
                    // contexto.msImageSmoothingEnabled = false;

                    PageObject.loadbinvectors();
                    if (PageObject.VectorPageObj.height == 0 || PageObject.VectorPageObj.width == 0){
                        thisdocument.pages.pop();
                        //return;
                    }

                    //PageObject.loadvectors();
                } else if (PageObject.usepdfjs) {

                    setSmoothingEnabled(false);

                    PageObject.setNotCollapsedArray();
                    // contexto.imageSmoothingEnabled = false;
                    // contexto.mozImageSmoothingEnabled = false;
                    // //contexto.webkitImageSmoothingEnabled = false;
                    // contexto.msImageSmoothingEnabled = false;

                    //backgroundColor = "#FFFFFF";
                    //this.backgroundColor = backgroundColor;
                    thisdocument.backgroundColor = "#FFFFFF";
                    var file = getFileName(thisdocument.FileName);
                    var cachfolder = getURLPath(PageObject.ThumbnailImageSRC);

                    if(thisdocument.relativepath != undefined){
                        cachfolder = thisdocument.relativepath;
                    }
                    var noCachFolder = RxConfig.noCachFolder;

                    if(noCachFolder) {
                        thisdocument.pdfURL = RxConfig.xmlurlrel + thisdocument.FileNameSRC;
                    }else{
                        thisdocument.pdfURL = cachfolder + file;
                    }

                    if (PageObject.firstpage) {
                        //PDFJS.cMapUrl = '/pdfjs/web/cmaps/';
                        if (thisdocument.pdfDoc == null || !thisdocument.busesetpdfdoc){

                            thisdocument.PDFWrapper = new PDFDocObject(thisdocument);
                            thisdocument.PDFWrapper.initiate(RxConfig.PDFcmap);
                            thisdocument.PDFWrapper.openDocument(thisdocument.pdfURL);
                            thisdocument.bdestroyPDFonClose = true;

                        }else{
                            thisdocument.loadPDFpages();

                        }

                        //PDFJS.cMapUrl = RxConfig.PDFcmap;
                        //PDFJS.cMapPacked = true;
                        //PDFJS.disableWorker = true;
                        /*if (RxCore_GUI_Download != undefined) {
                            RxCore_GUI_Download.setDownload("show");
                        }*/

                        //this.pdfLoadingTask = PDFJS.getDocument({url:thisdocument.pdfURL,worker:docworker});



                    }

                } else {
                    if (thisdocument.Type == 0) {
                        PageObject.initialzoom = 2;
                    }
                    //backgroundColor = "#FFFFFF";
                    //this.backgroundColor = backgroundColor;
                    thisdocument.backgroundColor = "#FFFFFF";
                    setSmoothingEnabled(true);
                    // contexto.imageSmoothingEnabled = true;
                    // contexto.mozImageSmoothingEnabled = true;
                    // //contexto.webkitImageSmoothingEnabled = true;
                    // contexto.msImageSmoothingEnabled = true;


                    //PageObject.loadimages(thisdocument.pageNum);
                    PageObject.loadimages(thisdocument.pageNum);
                    //PageObject.loadimages();


                }

            }
            /*if (PageObject.usepdfjs &&  thisdocument.pdfDoc != null){
             PageObject.loadimages();
             }*/

             /*if (PageObject.usepdfjs && thisdocument.pdfDoc != null) {
                PageObject.loadimages(thisdocument.pageNum);
            }*/

            if (PageObject.usevectorbinary) {
                PageObject.usevectorxml = true;
            }
            if (PageObject.usevector3Dbinary) {
                PageObject.usevector3Dxml = true;
            }




        };
        this.addlayout = function (Name) {
            thisdocument.layouts.push(Name);
        };


        this.loadpage = function (pagenum) {
            if (!this.pages[this.currentpage].usevectorxml && !this.pages[this.currentpage].usevectorbinary) {

                if (pagenum != 0) {
                    if (this.pages[this.currentpage].usepdfjs) {
                        if(thisdocument.bLargePDF){
                            this.pages[pagenum].queRenderPageScaled();
                        }else{
                            this.pages[pagenum].queueRenderPage(pagenum + 1);
                        }


                    } else {
                        if (!this.pages[pagenum].largeimageloaded || !this.pages[pagenum].smallimageloaded) {

                            if (this.Type == 0) {
                                this.pages[pagenum].initialzoom = 2;
                            }
                            this.pages[pagenum].loadimages();
                        }

                    }

                    //this.pages[pagenum].dscale = this.pages[0].dscale;
                    //this.pages[pagenum].dx = this.pages[0].dx;
                    //this.pages[pagenum].dy = this.pages[0].dy;
                    //this.pages[pagenum].dscaleextent = this.pages[0].dscaleextent;
                    //this.pages[pagenum].dxextent = this.pages[0].dxextent;
                    //this.pages[pagenum].dyextent = this.pages[0].dyextent;
                    //this.pages[pagenum].checkimageswitch();

                    //this.pages[this.currentpage].currentimage = this.pages[this.currentpage-1].currentimage;
                }
                //this.pages[this.currentpage].draw_image(true);
                /*if (this.Type == 0){
                 this.draw_allpages();
                 }else{
                 this.pages[this.currentpage].draw_image();
                 }*/

            } else {
                if (!this.pages[this.currentpage].vectorloaded) {
                    this.pages[this.currentpage].loadbinvectors();
                } else {
                    if (this.pages[this.currentpage].VectorPageObj.width == 0 || this.pages[this.currentpage].VectorPageObj.height == 0) {
                        //this.currentpage = prevpage;
                        return;
                    }

                    this.pages[this.currentpage].draw_vector(true);

                }

                //this.pages[this.currentpage].draw_vector(true);
            }


            //drawmarkupAll(cntximg);
        };

        this.PageDown = function () {
            /*if (thisdocument.pagelocked){
                return;
            }*/


            var prevpage = this.currentpage;
            if (this.pages[this.currentpage].usepdfjs) {
                if(this.textselect){
                    this.pages[this.currentpage].PDFTextArea.style.display = "none";
                }

            }


            if (this.currentpage + 1 <= this.pages.length - 1) {
                this.currentpage++;
                if (this.pages[this.currentpage].usevector3Dxml) {
                    if (this.pages[this.currentpage].Vector3DPageObj == undefined ) {
                        this.pages[this.currentpage].loadvectors3DBinary();
                    } else {
                        /*if (this.pages[this.currentpage].VectorPageObj.width == 0 || this.pages[this.currentpage].VectorPageObj.height == 0) {
                         this.currentpage = prevpage;
                         return;
                         }*/
                        this.restorecurpage = this.currentpage;
                        this.SetActive();

                    }

                }else if (this.pages[this.currentpage].usevectorxml || this.pages[this.currentpage].usevectorbinary) {
                    if (!this.pages[this.currentpage].vectorloaded) {
                        this.pages[this.currentpage].loadbinvectors();
                    } else {
                        if (this.pages[this.currentpage].VectorPageObj.width == 0 || this.pages[this.currentpage].VectorPageObj.height == 0) {
                            this.currentpage = prevpage;
                            return;
                        }
                        this.restorecurpage = this.currentpage;
                        this.SetActive();

                        //this.pages[this.currentpage].draw_vector(true);

                    }


                    //this.pages[this.currentpage].draw_vector(true);

                } else if (this.pages[this.currentpage].usepdfjs) {
                    if(!thisdocument.pagelocked){
                        this.pages[this.currentpage].dxpdf = this.pages[prevpage].dxpdf;
                        this.pages[this.currentpage].dypdf = 0;

                    }
                    this.pages[this.currentpage].draw_canvas(true);
                    //shortpgupdateloop();

                    if (!this.pages[this.currentpage].iscollapsed) {
                        thisdocument.pgChangeLoop();
                    }

                    pgupdateloop();
                    if(this.textselect){
                        this.pages[this.currentpage].PDFTextArea.style.display = szdispvalue;
                    }


                } else {
                    //if (!this.pages[this.currentpage].usevectorxml){
                    if (this.currentpage != 0) {
                        if (!this.pages[this.currentpage].largeimageloaded || !this.pages[this.currentpage].smallimageloaded) {

                            if (this.Type == 0) {
                                this.pages[this.currentpage].initialzoom = 2;
                            }
                            this.pages[this.currentpage].loadimages();
                        }

                        this.pages[this.currentpage].dscale = this.pages[this.currentpage - 1].dscale;
                        this.pages[this.currentpage].dx = this.pages[this.currentpage - 1].dx;
                        this.pages[this.currentpage].dy = this.pages[this.currentpage - 1].dy;
                        this.pages[this.currentpage].checkimageswitch();

                        //this.pages[this.currentpage].currentimage = this.pages[this.currentpage-1].currentimage;
                    }
                    this.pages[this.currentpage].draw_image(true);

                }
                /*else{
                 if (!this.pages[this.currentpage].vectorloaded){
                 this.pages[this.currentpage].loadvectors();
                 }

                 this.pages[this.currentpage].draw_vector(true);
                 }*/


                drawmarkupAll(cntximg);

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:this.pages[thisdocument.currentpage].usepdfjs,
                    is3D:this.pages[thisdocument.currentpage].usevector3Dxml,
                    is2D:this.pages[thisdocument.currentpage].usevectorxml,
                    numpages:this.pages.length,
                    currentpage:this.currentpage,
                    activefile : this.bActive
                };

                /*if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }*/

                var pagingobject = {
                    numpages:this.pages.length,
                    currentpage:this.currentpage
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }

            }

            this.restorecurpage = this.currentpage;

        };

        this.checkprintready = function(){
            var allpagesloaded = true;
            for(var i = 0;i<this.pages.length;i++ ){
                if(this.pages[i].usevector3Dxml){
                    allpagesloaded = true;
                }else if(this.pages[i].usevectorxml){
                    if (!this.pages[i].vectorloaded){
                        allpagesloaded = false;
                    }
                }else if (this.pages[i].usepdfjs){
                    allpagesloaded = true;
                }else{
                    if (!this.pages[i].largeimageloaded || !this.pages[i].smallimageloaded) {
                        allpagesloaded = false;
                    }
                }

            }

            return allpagesloaded;

        };


        this.loadAllPages = function(){
            //var allpagesloaded = true;
            this.bDoPrint = true;
            for(var i = 0;i<this.pages.length;i++ ){
                if(this.pages[i].usevectorxml){
                    if (!this.pages[i].vectorloaded){
                        this.GotoPage(i);
                        //allpagesloaded = false;
                    }

                }else if (this.pages[i].usepdfjs){

                }else{
                    if (!this.pages[i].largeimageloaded || !this.pages[i].smallimageloaded) {
                        this.GotoPage(i);
                    }
                }
            }
            this.GotoPage(0);
            //return allpagesloaded;
        };


        this.printDocument = function(paper){
            var i = 0;

            do {
                this.pages[i].printobj.setRes(300);
                this.pages[i].printobj.setPaperSize(paper.width,paper.height);
                this.pages[i].printobj.setScale();
                this.pages[i].printobj.print();

                i++;
            }
            while (i < this.pages.length);
            this.bDoPrint = false;
            /*for (var i = 0; i < this.pages.length-1; i++) {
             this.pages[i].printobj.setRes(300);
             this.pages[i].printobj.setPaperSize(paper.width,paper.height);
             this.pages[i].printobj.setScale();
             this.pages[i].printobj.print();
             }*/

        };

        this.GotoPage = function (pagenum) {
            /*if (thisdocument.pagelocked){
                return;
            }*/

            if(pagenum > this.pages.length - 1 || pagenum < 0){
                return;
            }


            var prevpage = this.currentpage;



            if (this.pages[this.currentpage].usepdfjs) {
                if(this.textselect){
                    this.pages[this.currentpage].PDFTextArea.style.display = "none";
                }

            }

            this.currentpage = pagenum;

            if (this.pages[this.currentpage].usevector3Dxml) {
                if (this.pages[this.currentpage].Vector3DPageObj == undefined) {
                    this.pages[this.currentpage].loadvectors3DBinary();
                } else {
                    /*if (this.pages[this.currentpage].VectorPageObj.width == 0 || this.pages[this.currentpage].VectorPageObj.height == 0) {
                     this.currentpage = prevpage;
                     return;
                     }*/
                    this.restorecurpage = this.currentpage;
                    this.SetActive();

                }


            }else if (this.pages[this.currentpage].usevectorxml) {
                if (!this.pages[this.currentpage].vectorloaded) {
                    this.pages[this.currentpage].loadbinvectors();
                } else {
                    if (this.pages[this.currentpage].VectorPageObj.width == 0 || this.pages[this.currentpage].VectorPageObj.height == 0) {
                        this.currentpage = prevpage;
                        return;
                    }

                    this.restorecurpage = this.currentpage;
                    this.SetActive();



                }

                //this.pages[this.currentpage].draw_vector(true);

            } else if (this.pages[this.currentpage].usepdfjs) {
                //this.pages[this.currentpage].dscalepdf = this.pages[prevpage].dscalepdf;

                if (thisdocument.bLargePDF){
                    //this.pages[this.currentpage].dxpdf = this.pages[prevpage].dxpdf;
                    //this.pages[this.currentpage].dypdf = 0;
                    if(!thisdocument.pagelocked){
                            this.pages[this.currentpage].setPFDdimnodraw(this.pages[prevpage].dxpdf,0,1,false);
                    }

                }else{
                    if(!thisdocument.pagelocked){
                        this.pages[this.currentpage].setPFDdimnodraw(this.pages[prevpage].dxpdf,0,1,true);
                    }

                }

                this.pages[this.currentpage].draw_canvas(true);
                //shortpgupdateloop();

                if (!this.pages[this.currentpage].iscollapsed) {
                    thisdocument.pgChangeLoop();
                }

                pgupdateloop();

                if (thisdocument.bLargePDF){
                    thisdocument.pages[thisdocument.currentpage].pdfisrendered = false;
                }


                if(this.textselect){

                    this.pages[this.currentpage].PDFTextArea.style.display = szdispvalue;
                }


            } else {
                if (!this.pages[this.currentpage].largeimageloaded || !this.pages[this.currentpage].smallimageloaded) {
                    if (this.Type == 0) {
                        this.pages[this.currentpage].initialzoom = 2;
                    }
                    this.pages[this.currentpage].loadimages();

                }

                if (this.currentpage != 0) {
                    this.pages[this.currentpage].dscale = this.pages[0].dscale;
                    this.pages[this.currentpage].dx = this.pages[0].dx;
                    this.pages[this.currentpage].dy = this.pages[0].dy;
                    this.pages[this.currentpage].checkimageswitch();
                    //this.pages[this.currentpage].currentimage = this.pages[this.currentpage-1].currentimage;
                }
                this.pages[this.currentpage].draw_image(true);

            }
            /*if (!this.pages[this.currentpage].usevectorxml){



             }else{
             if (!this.pages[this.currentpage].vectorloaded){
             this.pages[this.currentpage].loadvectors();
             }

             this.pages[this.currentpage].draw_vector(true);
             }*/

            drawmarkupAll(cntximg);
            var stateobj = {
                iscompare:documentcompare,
                numOpenFiles:OpenFiles.length,
                isPDF:this.pages[thisdocument.currentpage].usepdfjs,
                is3D:this.pages[thisdocument.currentpage].usevector3Dxml,
                is2D:this.pages[thisdocument.currentpage].usevectorxml,
                numpages:this.pages.length,
                currentpage:this.currentpage,
                activefile : this.bActive
            };

            /*if (RxCore_GUI_State != undefined) {
                RxCore_GUI_State.setGUIState(stateobj);
            }*/

            var pagingobject = {
                numpages:this.pages.length,
                currentpage:this.currentpage
            };

            if(RxCore_GUI_Page != undefined){
                RxCore_GUI_Page.pageEvent(pagingobject);
            }

            this.restorecurpage = this.currentpage;

        };


        /*this.GotoPage = function(pagenum){
         var prevpage = this.currentpage;
         this.currentpage = pagenum;
         if (!this.pages[this.currentpage].usevectorxml){
         //this.checkimageswitch();
         if (!this.pages[this.currentpage].largeimageloaded || !this.pages[this.currentpage].smallimageloaded){
         if (this.Type == 0){
         this.pages[this.currentpage].initialzoom = 2;
         }
         this.pages[this.currentpage].loadimages();

         }

         if (this.currentpage != 0){
         this.pages[this.currentpage].dscale = this.pages[0].dscale;
         this.pages[this.currentpage].dx = this.pages[0].dx;
         this.pages[this.currentpage].dy = this.pages[0].dy;
         this.pages[this.currentpage].dscaleextent = this.pages[0].dscaleextent;
         this.pages[this.currentpage].dxextent = this.pages[0].dxextent;
         this.pages[this.currentpage].dyextent = this.pages[0].dyextent;
         this.pages[this.currentpage].checkimageswitch();
         //this.pages[this.currentpage].currentimage = this.pages[this.currentpage-1].currentimage;
         }

         this.pages[this.currentpage].draw_image();
         }else{
         if (!this.pages[this.currentpage].vectorloaded){
         this.pages[this.currentpage].loadvectors();
         }

         this.pages[this.currentpage].draw_vector(true);
         }

         drawmarkupAll(cntximg);


         };*/

        this.PageUp = function () {
            /*if (thisdocument.pagelocked){
                return;
            }*/

            var prevpage = this.currentpage;
            if (this.pages[this.currentpage].usepdfjs) {
                if(this.textselect){
                    this.pages[this.currentpage].PDFTextArea.style.display = "none";
                }

            }

            if (this.currentpage - 1 >= 0) {
                this.currentpage--;

                if (this.pages[this.currentpage].usevector3Dxml) {
                    if (this.pages[this.currentpage].Vector3DPageObj == undefined) {
                        this.pages[this.currentpage].loadvectors3DBinary();
                    } else {
                        /*if (this.pages[this.currentpage].VectorPageObj.width == 0 || this.pages[this.currentpage].VectorPageObj.height == 0) {
                         this.currentpage = prevpage;
                         return;
                         }*/
                        //this.pages[this.currentpage].SetActive();
                        this.restorecurpage = this.currentpage;
                        this.SetActive();

                    }


                }else if (this.pages[this.currentpage].usevectorxml) {
                    if (!this.pages[this.currentpage].vectorloaded) {
                        this.pages[this.currentpage].loadbinvectors();
                    } else {
                        if (this.pages[this.currentpage].VectorPageObj.width == 0 || this.pages[this.currentpage].VectorPageObj.height == 0) {
                            this.currentpage = prevpage;
                            return;
                        }
                        this.restorecurpage = this.currentpage;
                        this.SetActive();

                        //this.pages[this.currentpage].draw_vector(true);

                    }

                    //this.pages[this.currentpage].draw_vector(true);

                } else if (this.pages[this.currentpage].usepdfjs) {
                    //this.pages[this.currentpage].dscalepdf = this.pages[prevpage].dscalepdf;
                    if(!thisdocument.pagelocked){
                        this.pages[this.currentpage].dxpdf = this.pages[prevpage].dxpdf;
                        this.pages[this.currentpage].dypdf = 0;
                    }
                    this.pages[this.currentpage].draw_canvas(true);

                    if (!this.pages[this.currentpage].iscollapsed) {
                        thisdocument.pgChangeLoop();
                    }

                    //shortpgupdateloop();
                    pgupdateloop();
                    if(this.textselect){
                        this.pages[this.currentpage].PDFTextArea.style.display = szdispvalue;
                    }

                } else {
                    if (!this.pages[this.currentpage].largeimageloaded || !this.pages[this.currentpage].smallimageloaded) {
                        if (this.Type == 0) {
                            this.pages[this.currentpage].initialzoom = 2;
                        }
                        this.pages[this.currentpage].loadimages();
                    }
                    this.pages[this.currentpage].checkimageswitch();
                    //this.checkimageswitch();
                    this.pages[this.currentpage].draw_image(true);

                }


                //this.pages[this.currentpage].draw_image();
                drawmarkupAll(cntximg);
                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:this.pages[thisdocument.currentpage].usepdfjs,
                    is3D:this.pages[thisdocument.currentpage].usevector3Dxml,
                    is2D:this.pages[thisdocument.currentpage].usevectorxml,
                    numpages:this.pages.length,
                    currentpage:this.currentpage,
                    activefile : this.bActive
                };

                /*if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }*/

                var pagingobject = {
                    numpages:this.pages.length,
                    currentpage:this.currentpage
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }

            }
            this.restorecurpage = this.currentpage;
        };

        this.getpage = function (pagenum) {
            return this.pages[pagenum];
        };

        this.lockMarkupbyGUID = function(GUID,onOff){
            var i = 0;

            for (i = 0; i < this.markuplist.length; i++) {
                if (this.markuplist[i].uniqueID == GUID) {
                    this.markuplist[i].locked = onOff;
                }
            }
            //return markupobj;

        };

        this.getmarkupbyGUIDXML = function(GUID){
            var i = 0;
            //var markupobj = -1;
            var xmlmarkup = "";
            for (i = 0; i < this.markuplist.length; i++) {
                if (this.markuplist[i].uniqueID == GUID) {
                    xmlmarkup = createxmlmarkupentity(this.markuplist[i],thisdocument, false);
                }
            }
            return xmlmarkup;

        };

        this.getmarkupobjbyGUID = function(GUID){
            var i = 0;

            var markupobj = -1;

            for (i = 0; i < this.markuplist.length; i++) {
                if (this.markuplist[i].uniqueID == GUID) {
                    markupobj = this.markuplist[i];
                }
            }

            return markupobj;
        };

        this.getmarkupbyGUID = function(GUID){
            var i = 0;
            var markupobj = -1;
            for (i = 0; i < this.markuplist.length; i++) {
                if (this.markuplist[i].uniqueID == GUID) {
                    markupobj = i;
                }
            }
            return markupobj;
        };

        this.getmarkupbynumber = function (markupnumber) {
            var i = 0;
            var markupobj = -1;
            for (i = 0; i < this.markuplist.length; i++) {
                if (this.markuplist[i].markupnumber == markupnumber) {
                    markupobj = i;
                }
            }
            return markupobj;
        };


        /*this.selectedmarkuprect = function(){
            var i = 0;
            var combinedrect = undefined;

            for (i = 0; i < this.markuplist.length; i++) {
                if (this.markuplist[i].selected && this.markuplist[i].pagenumber == this.currentpage) {
                    var combinedrect = this.markuplist[i].getrect(combinedrect);
                }
            }
        };*/

        this.setGroupSelectedMarkup = function(add){
            var i = 0;

            if (!add){
                for (i = 0; i < this.markuplist.length; i++) {
                    this.markuplist[i].bispartofGroup = false;
                    this.markuplist[i].groupRect = {x:0,y:0,w:0,h:0};
                }
                //console.log(thisdocument.markuplist[i-1].groupRect);

            }else{
                for (i = 0; i < this.markuplist.length; i++) {
                    var btextarrow = (this.markuplist[i].bhasArrow && this.markuplist[i].type == 9);
                    var barrowtext = (this.markuplist[i].subtype == 6 && this.markuplist[i].type == 6);
                    var btexboxwarrow = (barrowtext || barrowtext);
                    var bseledit = (this.markuplist[i].selectedit && this.markuplist[i].type != 9);
                    var bselected = (this.markuplist[i].selected || bseledit);

                    if (btexboxwarrow && bselected && this.markuplist[i].pagenumber == thisdocument.getcurPage()) {
                        this.markuplist[i].bispartofGroup = true;
                        this.markuplist[i].groupRect = thisdocument.getmarkupGroupRect();
                    }
                }
                //console.log(thisdocument.markuplist[i-1].groupRect);
            }



        };

        this.getNumSelectedMarkup = function(){
            var i = 0;
            var numselected = 0;

            for (i = 0; i < this.markuplist.length; i++) {

                var bseledit = (this.markuplist[i].selectedit && this.markuplist[i].type != 9);
                var bselected = (this.markuplist[i].selected || bseledit);
                var btextArrow = (this.markuplist[i].type == 9 && this.markuplist[i].bhasArrow);


                if (!btextArrow && bselected && this.markuplist[i].pagenumber == thisdocument.getcurPage()) {
                    numselected ++;
                }
            }
            return numselected;
        };

        this.getMarkupMultiselected = function(){

            //console.log(bMultiMarkupselected);
            return bMultiMarkupselected;

        };

        this.setMarkupMultiselected = function(){

            //console.log(thisdocument.getNumSelectedMarkup());

            if (thisdocument.getNumSelectedMarkup() > 1){

                bMultiMarkupselected = true;

            }else{
                bMultiMarkupselected = false;
            }

            thisdocument.setGroupSelectedMarkup(bMultiMarkupselected);
        };

        this.getmarkupGroupRect = function(){
            var i = 0;
            var counter = 0;
            var points = [];

            var minx = 0;
            var miny = 0;
            var maxx = 0;
            var maxy = 0;

            var mgrouparray = thisdocument.getSelectedMarkup();
            if (mgrouparray.length > 1){

                var brelSize = (mgrouparray[0].type == 3 || mgrouparray[0].type == 4 || mgrouparray[0].type == 5 || mgrouparray[0].type == 9 || mgrouparray[0].type == 10 || mgrouparray[0].type == 11 || mgrouparray[0].type == 12);

                if(brelSize){

                    if (mgrouparray[0].rotation != 0){
                        var rrect = mgrouparray[0].rotrect(mgrouparray[0].xscaled, mgrouparray[0].yscaled,mgrouparray[0].xscaled + mgrouparray[0].wscaled, mgrouparray[0].yscaled + mgrouparray[0].hscaled);
                    }else{
                        rrect = {x: mgrouparray[0].xscaled, y : mgrouparray[0].yscaled,w : mgrouparray[0].wscaled, h : mgrouparray[0].hscaled};
                    }

                    minx = rrect.x;
                    miny = rrect.y;
                    maxx = rrect.x + rrect.w;
                    maxy = rrect.y + rrect.h;

                    if (mgrouparray[0].type == 4  && mgrouparray[0].subtype == 1){
                        var xdiff = Math.max(mgrouparray[0].xscaled, mgrouparray[0].wscaled) - Math.min(mgrouparray[0].xscaled, mgrouparray[0].wscaled);
                        var ydiff = Math.max(mgrouparray[0].yscaled, mgrouparray[0].hscaled) - Math.min(mgrouparray[0].yscaled, mgrouparray[0].hscaled);
                        var radius = mgrouparray[0].getdiag(xdiff, ydiff);
                        minx = mgrouparray[0].xscaled - radius;
                        miny = mgrouparray[0].yscaled - radius;
                        maxx = mgrouparray[0].xscaled + radius;
                        maxy = mgrouparray[0].yscaled + radius;
                    }

                }else{
                    minx = mgrouparray[0].xscaled;
                    miny = mgrouparray[0].yscaled;
                    maxx = mgrouparray[0].wscaled;
                    maxy = mgrouparray[0].hscaled;
                }

                for (i = 0; i < mgrouparray.length; i++) {
                    var brelSize = (mgrouparray[i].type == 3 || mgrouparray[i].type == 4 || mgrouparray[i].type == 5 || mgrouparray[i].type == 9 || mgrouparray[i].type == 10 || mgrouparray[i].type == 11 || mgrouparray[i].type == 12);
                    if(brelSize){
                        if (mgrouparray[i].rotation != 0){
                            var rrect = mgrouparray[i].rotrect(mgrouparray[i].xscaled, mgrouparray[i].yscaled,mgrouparray[i].xscaled + mgrouparray[i].wscaled, mgrouparray[i].yscaled + mgrouparray[i].hscaled);
                        }else{
                            rrect = {x: mgrouparray[i].xscaled, y : mgrouparray[i].yscaled,w : mgrouparray[i].wscaled, h : mgrouparray[i].hscaled};
                        }


                        if (mgrouparray[i].type == 4  && mgrouparray[i].subtype == 1){
                            var xdiff = Math.max(mgrouparray[i].xscaled, mgrouparray[i].wscaled) - Math.min(mgrouparray[i].xscaled, mgrouparray[i].wscaled);
                            var ydiff = Math.max(mgrouparray[i].yscaled, mgrouparray[i].hscaled) - Math.min(mgrouparray[i].yscaled, mgrouparray[i].hscaled);
                            var radius = mgrouparray[i].getdiag(xdiff, ydiff);

                            points.push({x: mgrouparray[i].xscaled - radius, y : mgrouparray[i].yscaled - radius});
                            points.push({x: mgrouparray[i].xscaled + radius, y : mgrouparray[i].yscaled + radius});

                        }else{
                            points.push({x: rrect.x, y : rrect.y});
                            points.push({x: rrect.x + rrect.w, y : rrect.y + rrect.h});

                        }


                    }else{
                        points.push({x: mgrouparray[i].xscaled, y : mgrouparray[i].yscaled});
                        points.push({x: mgrouparray[i].wscaled, y : mgrouparray[i].hscaled});
                    }

                }

                for (counter = 0; counter < points.length; counter++) {
                    if (points[counter].x < minx) {
                        minx = points[counter].x;
                    }
                    if (points[counter].y < miny) {
                        miny = points[counter].y;
                    }
                    if (points[counter].x > maxx) {
                        maxx = points[counter].x;
                    }
                    if (points[counter].y > maxy) {
                        maxy = points[counter].y;
                    }
                }

            }

            return {x : minx, y : miny, w : maxx, h : maxy};

        };

        this.getSelectedMarkup = function(){
            var i = 0;

            const allMarkupsSelected = [];

            for (i = 0; i < this.markuplist.length; i++) {

                var bseledit = (this.markuplist[i].selectedit && this.markuplist[i].type != 9);
                var bselected = (this.markuplist[i].selected || bseledit);

                if (bselected && this.markuplist[i].pagenumber == thisdocument.getcurPage()) {

                    if(this.markuplist[i].bhasArrow && this.markuplist[i].markupArrowConnected != null){
                        allMarkupsSelected.push(this.markuplist[i].markupArrowConnected);
                    }else{
                        allMarkupsSelected.push(this.markuplist[i]);
                    }

                }
            }
            return allMarkupsSelected;

        };

        this.moveselected = function(xdiff, ydiff){
            var i = 0;

            for (i = 0; i < this.markuplist.length; i++) {

                var bseledit = (this.markuplist[i].selectedit && this.markuplist[i].type != 9);
                var bselected = (this.markuplist[i].selected || bseledit);

                if (bselected && this.markuplist[i].pagenumber == thisdocument.getcurPage()) {

                    this.markuplist[i].move(xdiff, ydiff);
                }
            }

        };

        this.draw_mpage = function () {
            var ty = (canvasoheight / 2);

            switch (this.pages[this.currentpage].currentimage) {
                case 0:

                    if (this.pages[this.currentpage].dy > ty && this.currentpage > 0) {
                        this.currentpage -= 1;
                    } else if (this.pages[this.currentpage].endy < ty && this.currentpage < this.NumPages - 1) {
                        this.currentpage += 1;
                    }
                    this.pages[this.currentpage].draw_image(true);

                    if (this.pages[this.currentpage].endy < canvasoheight && this.currentpage < this.NumPages - 1) {

                        if (this.pages[this.currentpage + 1].largeimageloaded) {
                            this.pages[this.currentpage + 1].dy = this.pages[this.currentpage].endy + 10;
                            this.pages[this.currentpage + 1].dx = this.pages[this.currentpage].dx;
                            this.pages[this.currentpage + 1].dscale = this.pages[this.currentpage].dscale;


                            this.pages[this.currentpage + 1].draw_image(false);
                        } else {
                            this.loadpage(this.currentpage + 1);
                            this.currentpage += 1;
                        }

                    } else if (this.pages[this.currentpage].dy > 10 && this.currentpage > 0) {

                        if (this.pages[this.currentpage - 1].largeimageloaded) {
                            this.pages[this.currentpage - 1].dy = this.pages[this.currentpage].dy - (this.pages[this.currentpage].MainImageHeight * this.pages[this.currentpage].dscale) - 10;
                            this.pages[this.currentpage - 1].dx = this.pages[this.currentpage].dx;
                            this.pages[this.currentpage - 1].dscale = this.pages[this.currentpage].dscale;


                            this.pages[this.currentpage - 1].draw_image(false);
                        } else {
                            this.loadpage(this.currentpage - 1);
                            this.currentpage -= 1;
                        }

                    }
                    /*else if(thispage.dy > ty && thispage.pagenumber > 0){
                     DocObj.currentpage = thispage.pagenumber - 1;
                     }else if(thispage.dy < ty && thispage.pagenumber < DocObj.NumPages){
                     DocObj.currentpage = thispage.pagenumber + 1;
                     }*/

                    break;

                case 1:
                    //this.pages[this.currentpage].draw_image(true);

                    if (this.pages[this.currentpage].dyextent > ty && this.currentpage > 0) {
                        this.currentpage -= 1;
                    } else if (this.pages[this.currentpage].endy < ty && this.currentpage < this.NumPages - 1) {
                        this.currentpage += 1;
                    }

                    this.pages[this.currentpage].draw_image(true);

                    if (this.pages[this.currentpage].endy < canvasoheight && this.currentpage < this.NumPages - 1) {

                        if (this.pages[this.currentpage + 1].smallimageloaded) {

                            this.pages[this.currentpage + 1].dy = this.pages[this.currentpage].endy + 10;
                            this.pages[this.currentpage + 1].dx = this.pages[this.currentpage].dx;
                            this.pages[this.currentpage + 1].dscale = this.pages[this.currentpage].dscale;


                            this.pages[this.currentpage + 1].draw_image(false);
                        } else {
                            this.loadpage(this.currentpage + 1);
                            this.currentpage += 1;
                        }

                    } else if (this.pages[this.currentpage].dyextent > 10 && this.currentpage > 0) {

                        if (this.pages[this.currentpage - 1].smallimageloaded) {

                            this.pages[this.currentpage - 1].dy = this.pages[this.currentpage].dy - (this.pages[this.currentpage].MainImageHeight * this.pages[this.currentpage].dscale) - 10;
                            this.pages[this.currentpage - 1].dx = this.pages[this.currentpage].dx;
                            this.pages[this.currentpage - 1].dscale = this.pages[this.currentpage].dscale;


                            this.pages[this.currentpage - 1].draw_image(false);
                        } else {
                            this.loadpage(this.currentpage - 1);
                            this.currentpage -= 1;
                        }

                    }

                    break;
            }
            var stateobj = {
                iscompare:documentcompare,
                numOpenFiles:OpenFiles.length,
                isPDF:this.pages[this.currentpage].usepdfjs,
                is3D:this.pages[this.currentpage].usevector3Dxml,
                is2D:this.pages[this.currentpage].usevectorxml,
                numpages:this.pages.length,
                currentpage:this.currentpage,
                activefile : this.bActive
            };

            this.restorecurpage = this.currentpage;

            /*if (RxCore_GUI_State != undefined) {
                RxCore_GUI_State.setGUIState(stateobj);
            }*/

            var pagingobject = {
                numpages:this.pages.length,
                currentpage:this.currentpage
            };

            if(RxCore_GUI_Page != undefined){
                RxCore_GUI_Page.pageEvent(pagingobject);
            }

        };

        this.updateadjpages = function () {
            if (this.currentpage == 0) {
                if (!this.pages[this.currentpage + 1].pdfisrendered) {
                    this.pages[this.currentpage + 1].queRenderPageScaled();
                }

            }

            if (this.currentpage == this.NumPages - 1) {
                if (!this.pages[this.currentpage - 1].pdfisrendered) {
                    this.pages[this.currentpage - 1].queRenderPageScaled();
                }

            }

            if (this.currentpage > 0 && this.currentpage < this.NumPages - 1) {
                if (!this.pages[this.currentpage + 1].pdfisrendered) {
                    this.pages[this.currentpage + 1].queRenderPageScaled();
                }
                if (!this.pages[this.currentpage - 1].pdfisrendered) {
                    this.pages[this.currentpage - 1].queRenderPageScaled();
                }

            }

        };

        this.draw_mpagepdf = function () {
            var ty = (canvasoheight / 2);
            var curpage = this.currentpage;

            if(this.pages[this.currentpage] == undefined){
                return;
            }

            if (this.pages.length > 1 && !thisdocument.pagelocked) {
                if (this.pages[this.currentpage].dypdf - 10 > ty && this.currentpage > 0) {

                    this.currentpage -= 1;
                    if (this.pages[this.currentpage].pdfisrendered) {
                        //this.updateadjpages();
                    }

                } else if (this.pages[this.currentpage].endy + 10 < ty && this.currentpage < this.pages.length - 1) {

                    this.currentpage += 1;
                    if (this.pages[this.currentpage].pdfisrendered) {
                        //this.updateadjpages();
                    }


                }

                /*if(this.pages[this.currentpage].ispagevisible && this.pages[this.currentpage].dscalepdf != 1){
                 this.pages[this.currentpage].queRenderPageScaled();
                 }*/

                this.pages[this.currentpage].draw_canvas(true);

                if (this.pages[this.currentpage].endy < canvasoheight && this.currentpage < this.pages.length - 1) {

                    if (this.pages[this.currentpage + 1].pageloaded) {

                        this.pages[this.currentpage + 1].dypdf = this.pages[this.currentpage].endy + 10;
                        //this.pages[this.currentpage + 1].dxpdf = this.pages[this.currentpage].dxpdf;
                        //this.pages[this.currentpage + 1].dscalepdf = this.pages[this.currentpage].dscalepdf;
                        /*if(this.pages[this.currentpage + 1].ispagevisible && this.pages[this.currentpage + 1].dscalepdf != 1){
                         this.pages[this.currentpage + 1].queRenderPageScaled();
                         }*/
                        //this.pages[this.currentpage + 1].renderPDFpagescale();
                        //this.pages[this.currentpage + 1].pagecanvas.height = this.pages[this.currentpage].pagecanvas.height;
                        //this.pages[this.currentpage + 1].pagecanvas.width = this.pages[this.currentpage].pagecanvas.width;

                        this.pages[this.currentpage + 1].draw_canvas(false);


                    } else {
                        var dytemppdf = this.pages[this.currentpage].endy + 10;
                        contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                        contexto.fillRect(this.pages[0].dxpdf, dytemppdf, this.pages[0].offscreenwidth * this.pages[0].dscalepdf, this.pages[0].offscreenheight * this.pages[0].dscalepdf);

                        this.loadpage(this.currentpage + 1);
                        this.currentpage += 1;
                    }

                } else if (this.pages[this.currentpage].dypdf > 10 && this.currentpage > 0) {

                    if (this.pages[this.currentpage - 1].pageloaded) {
                        /*if (this.pages[this.currentpage - 1].dscalepdf != 1){
                         this.pages[this.currentpage - 1].queRenderPageScaled();
                         }*/

                        this.pages[this.currentpage - 1].dypdf = this.pages[this.currentpage].dypdf - (this.pages[this.currentpage - 1].offscreenheight * this.pages[this.currentpage - 1].dscalepdf) - 10;
                        //this.pages[this.currentpage - 1].dxpdf = this.pages[this.currentpage].dxpdf;
                        //this.pages[this.currentpage - 1].dscalepdf = this.pages[this.currentpage].dscalepdf;
                        //this.pages[this.currentpage - 1].renderPDFpagescale();
                        //this.pages[this.currentpage - 1].pagecanvas.height = this.pages[this.currentpage].pagecanvas.height;
                        //this.pages[this.currentpage - 1].pagecanvas.width = this.pages[this.currentpage].pagecanvas.width;
                        /*if(this.pages[this.currentpage - 1].ispagevisible && this.pages[this.currentpage - 1].dscalepdf != 1){
                         this.pages[this.currentpage - 1].queRenderPageScaled();
                         }*/

                        this.pages[this.currentpage - 1].draw_canvas(false);


                    } else {
                        dytemppdf = this.pages[this.currentpage].dypdf - (this.pages[this.currentpage - 1].offscreenheight * this.pages[this.currentpage - 1].dscalepdf) - 10;
                        contexto.fillStyle = "rgb(255,255,255)"; //contexto.fillStyle = "rgb(238,243,250)";
                        contexto.fillRect(this.pages[0].dxpdf, dytemppdf, this.pages[0].offscreenwidth * this.pages[0].dscalepdf, this.pages[0].offscreenheight * this.pages[0].dscalepdf);

                        this.loadpage(this.currentpage - 1);
                        this.currentpage -= 1;
                    }

                }
                if(curpage != this.currentpage){
                    //this.pagechange();
                    //shortpgupdateloop();
                    pgupdateloop();
                }

            } else {

                this.pages[this.currentpage].draw_canvas(true);
            }

            if(this.textselect){
                this.pages[this.currentpage].PDFTextArea.style.display = szdispvalue;
            }


            var stateobj = {
                iscompare:documentcompare,
                numOpenFiles:OpenFiles.length,
                isPDF:this.pages[this.currentpage].usepdfjs,
                is3D:this.pages[this.currentpage].usevector3Dxml,
                is2D:this.pages[this.currentpage].usevectorxml,
                numpages:this.pages.length,
                currentpage:this.currentpage,
                activefile : this.bActive
            };

            this.restorecurpage = this.currentpage;

            /*if (RxCore_GUI_State != undefined) {
                RxCore_GUI_State.setGUIState(stateobj);
            }*/

            var pagingobject = {
                numpages:this.pages.length,
                currentpage:this.currentpage
            };

            if(RxCore_GUI_Page != undefined){
                if(curpage != this.currentpage){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }

            }

        };

        this.Suspend = function () {
            if (thisdocument.pages[thisdocument.currentpage].usevector3Dxml) {
                thisdocument.pages[thisdocument.currentpage].clock.stop();
                renderer.clippingPlanes = Empty;

                renderer.domElement.style.visibility = 'hidden';
                bAnimateready = false;

                if (RxCore_GUI_3DParts != undefined) {
                    RxCore_GUI_3DParts.isupdate = false;
                    RxCore_GUI_3DParts.set3DParts([]);
                }

            }

        };

        this.SetActive = function (ref) {

            if(thisdocument.bSopenSilent){
                return;
            }

            var compare = false;
            thisdocument.currentpage = thisdocument.restorecurpage;


            if (thisdocument.pages.length == 0) {
                return false;
            }

            if(ref){
                if (ref.Type == 'Compare'){
                    compare = true;
                    this.disableMenu = true;
                    this.Drawmarkup = false;
                    thisdocument.restorecurpage = thisdocument.currentpage;
                    thisdocument.currentpage = ref.currentpage;
                }
            }


            //backgroundColor = this.backgroundColor;
            this.bActive = true;

            renderer.clippingPlanes = Empty;

            renderer.domElement.style.visibility = 'hidden';
            bAnimateready = false;

            documentcompare = compare;


            if (thisdocument.pages[thisdocument.currentpage].usevectorxml) {
                setSmoothingEnabled(false);

                if(!compare && thisdocument.pages[thisdocument.currentpage].VectorPageObj){
                    thisdocument.pages[thisdocument.currentpage].restoreScaleAndOffset();

                    thisdocument.pages[thisdocument.currentpage].VectorPageObj.setActive();

                    /*if (RxCore_GUI_VectorLayers != undefined) {
                        RxCore_GUI_VectorLayers.setVectorLayers(thisdocument.pages[thisdocument.currentpage].VectorPageObj.layerlist);
                    }
                    if (RxCore_GUI_VectorBlocks != undefined) {
                        RxCore_GUI_VectorBlocks.setVectorBlocks(thisdocument.pages[thisdocument.currentpage].VectorPageObj.blocklist);
                    }*/

                    for(var p=0;p<thisdocument.pages.length;p++ ){
                        thisdocument.pages[p].usedincomposite = false;
                        if(thisdocument.pages[p].VectorPageObj){
                            thisdocument.pages[p].VectorPageObj.docompare = false;
                        }

                    }
                    this.disableMenu = false;
                    this.setactive = false;
                    this.Drawmarkup = true;

                    thisdocument.pages[thisdocument.currentpage].draw_vector(true);


                }
                // contexto.imageSmoothingEnabled = false;
                // contexto.mozImageSmoothingEnabled = false;
                // //contexto.webkitImageSmoothingEnabled = false;
                // contexto.msImageSmoothingEnabled = false;


                drawmarkupAll(cntximg);

                RxCore_default();

            } else if (thisdocument.pages[thisdocument.currentpage].usevector3Dxml) {
                thisdocument.pages[thisdocument.currentpage].clock.start();
                renderer.domElement.style.visibility = 'visible';
                //check if this is needed.
                documentcompare = false;

                if(thisdocument.pages[thisdocument.currentpage].Vector3DPageObj.clippingOn){
                    renderer.clippingPlanes = thisdocument.pages[thisdocument.currentpage].Vector3DPageObj.globalPlanes;
                }else{
                    renderer.clippingPlanes = Empty;
                }

                bAnimateready = true;

                if (RxCore_GUI_3DParts != undefined) {
                    RxCore_GUI_3DParts.isupdate = false;
                    RxCore_GUI_3DParts.set3DParts(thisdocument.pages[thisdocument.currentpage].Vector3DPageObj.blocklist);
                }

                switch(thisdocument.curcontrol3D){
                    case 'orbitControl' :
                        //RxCore_3DOrbit();
                        if (tool == undefined) {
                            set_tool('orbitControl', {});
                            //tool = new tools['orbitControl']();
                            thisdocument.curcontrol3D = 'orbitControl';
                        }else{
                            set_tool('orbitControl', {});
                            //tool = new tools['orbitControl']();
                            thisdocument.curcontrol3D = 'orbitControl';

                        }
                        if (RxCore_GUI_3DWalkthrough != undefined) {
                            RxCore_GUI_3DWalkthrough.setWalkthroughGUI(false);
                        }


                        break;
                    case 'Walkthrough3D' :
                        if (tool == undefined) {

                        }
                        set_tool('Walkthrough3D', {});
                        //tool = new tools['Walkthrough3D']();

                        thisdocument.curcontrol3D = 'Walkthrough3D';

                        if (RxCore_GUI_3DWalkthrough != undefined) {
                            RxCore_GUI_3DWalkthrough.setWalkthroughGUI(true);
                        }

                        //RxCore_3DWalkThrough(true);

                        break;
                }

                //var toolType = thisdocument.curcontrol3D;
                //tool = new tools[toolType]();

            } else if (thisdocument.pages[thisdocument.currentpage].usepdfjs) {

                setSmoothingEnabled(false);
                // contexto.imageSmoothingEnabled = false;
                // contexto.mozImageSmoothingEnabled = false;
                // //contexto.webkitImageSmoothingEnabled = false;
                // contexto.msImageSmoothingEnabled = false;
                if(!compare){
                    thisdocument.pages[thisdocument.currentpage].restoreScaleAndOffset();
                    thisdocument.pages[thisdocument.currentpage].draw_canvas(true);
                    this.disableMenu = false;
                    this.Drawmarkup = true;
                    drawmarkupAll(cntximg);

                }

                //thisdocument.pages[thisdocument.currentpage].draw_canvas(true);
                //drawmarkupAll(cntximg);

                RxCore_default();

            } else {
                setSmoothingEnabled(true);

                if(!compare){
                    thisdocument.pages[thisdocument.currentpage].restoreScaleAndOffset();
                    thisdocument.pages[thisdocument.currentpage].resetimage();
                    this.disableMenu = false;
                    this.Drawmarkup = true;
                    drawmarkupAll(cntximg);

                }
                thisdocument.pages[thisdocument.currentpage].draw_image(true);

                RxCore_default();
            }

            if (RxCore_GUI_Markuplist != undefined) {
                RxCore_GUI_Markuplist.setMarkupList(thisdocument.markuplist, thisdocument.bActive);
            }

            if (RxCore_GUI_pagethumbs != undefined) {
                RxCore_GUI_pagethumbs.setThumbnails(thisdocument.thumbnails);
            }


            var stateobj = {
                iscompare:documentcompare,
                numOpenFiles:OpenFiles.length,
                isPDF:this.pages[this.currentpage].usepdfjs,
                is3D:this.pages[this.currentpage].usevector3Dxml,
                is2D:this.pages[this.currentpage].usevectorxml,
                numpages:this.pages.length,
                currentpage:this.currentpage,
                activefile : this.bActive,
                disableMenu: this.disableMenu || false
            };

            if (RxCore_GUI_State != undefined) {
                RxCore_GUI_State.setGUIState(stateobj);
            }

            if (RxCore_GUI_HasText != undefined){
                RxCore_GUI_HasText.hastext = thisdocument.hastext;
                RxCore_GUI_HasText.hasText(thisdocument.hastext, thisdocument.bActive);
            }
            var pagingobject = {
                numpages:this.pages.length,
                currentpage:this.currentpage
            };

            if(RxCore_GUI_Page != undefined){
                RxCore_GUI_Page.pageEvent(pagingobject);
            }


            return true;

        };

        this.enableTextSelect = function(onoff){
            thisdocument.textselect = onoff;
            var curpage = 0;
            while (curpage < thisdocument.pages.length) {
                if (thisdocument.pages[curpage].usepdfjs) {
                    if(!onoff){
                        //turn visibilty off for all page text divs.

                        thisdocument.pages[curpage].PDFTextArea.style.display = "none";

                    }


                }
                if(thisdocument.pages[curpage].usevectorxml){
                    if(!onoff){

                        thisdocument.pages[curpage].TextSelectArea.style.display = "none";

                    }
                }
                curpage++;
            }
            if(onoff){
                if (thisdocument.pages[thisdocument.currentpage].usepdfjs) {
                    thisdocument.pages[thisdocument.currentpage].PDFTextArea.style.display = szdispvalue;
                }
                if(thisdocument.pages[thisdocument.currentpage].usevectorxml){
                    thisdocument.pages[thisdocument.currentpage].cleartextdivs();
                    thisdocument.pages[thisdocument.currentpage].settextdivs();
                    thisdocument.pages[thisdocument.currentpage].TextSelectArea.style.display = szdispvalue;
                }
            }

        };

        this.closePages = function(bClearMarkup){
            while (thisdocument.pages.length != 0) {
                if (thisdocument.pages[thisdocument.pages.length - 1].usepdfjs) {
                    thisdocument.pages[thisdocument.pages.length - 1].PDFPointArray = [];

                    if(thisdocument.pages[thisdocument.pages.length - 1].pdfisfirstrendered){
                        clearInterval(thisdocument.pages[thisdocument.pages.length - 1].pdftimervar);

                        //this.pages[this.currentpage].PDFTextArea.style.display = "initial";

                        thisdocument.pages[thisdocument.pages.length - 1].PDFTextArea.removeEventListener('wheel', ev_canvas, true);
                        rxcontainer.removeChild(thisdocument.pages[thisdocument.pages.length - 1].PDFTextArea);


                    }
                }
                if (thisdocument.pages[thisdocument.pages.length - 1].usevectorxml) {
                    clearInterval(thisdocument.pages[thisdocument.pages.length - 1].vectortimervar);
                    thisdocument.textselect = false;
                    //thisdocument.pages[thisdocument.pages.length - 1].selecttext();

                    rxcontainer.appendChild(thisdocument.pages[thisdocument.pages.length - 1].TextSelectArea);
                    rxcontainer.removeChild(thisdocument.pages[thisdocument.pages.length - 1].TextSelectArea);
                    //thisdocument.pages[thisdocument.pages.length - 1].removetext();


                    if (thisdocument.pages[thisdocument.pages.length - 1].VectorPageObj != undefined) {
                        thisdocument.pages[thisdocument.pages.length - 1].VectorPageObj.Close();
                    }

                    var emptylist = [];
                    if (RxCore_GUI_VectorLayers != undefined) {
                        RxCore_GUI_VectorLayers.setVectorLayers(emptylist);
                    }
                    if (RxCore_GUI_VectorBlocks != undefined) {
                        RxCore_GUI_VectorBlocks.setVectorBlocks(emptylist);
                    }


                }
                if (thisdocument.pages[thisdocument.pages.length - 1].usevector3Dxml) {


                    //renderer.clear();
                    renderer.domElement.style.visibility = 'hidden';

                    if (RxCore_GUI_3DWalkthrough != undefined) {
                        RxCore_GUI_3DWalkthrough.setWalkthroughGUI(false);

                    }
                    bAnimateready = false;
                    if (thisdocument.pages[thisdocument.pages.length - 1].Vector3DPageObj != undefined) {
                        thisdocument.pages[thisdocument.pages.length - 1].Vector3DPageObj.Close();
                        thisdocument.pages[thisdocument.pages.length - 1].Vector3DPageObj = null;
                    }

                    var empty3dpartlist = [];
                    if (RxCore_GUI_3DParts != undefined) {
                        RxCore_GUI_3DParts.isupdate = false;
                        RxCore_GUI_3DParts.set3DParts(empty3dpartlist);
                    }


                }

                thisdocument.pages.pop();
            }

            if(bClearMarkup){
                while (thisdocument.markupundolist.length != 0) {
                    thisdocument.markupundolist.pop();
                }

                while (thisdocument.markuplist.length != 0) {
                    thisdocument.markuplist.pop();

                }
                while(thisdocument.markupdraworder.length != 0){
                    thisdocument.markupdraworder.pop();
                }

            }

            if (RxCore_GUI_Markuplist != undefined) {
                RxCore_GUI_Markuplist.setMarkupList(thisdocument.markuplist, thisdocument.bActive);
                // RxCore_GUI_Markuplist.notify();
            }

            if (RxCore_GUI_pagethumbs != undefined) {
                RxCore_GUI_pagethumbs.setThumbnails(thisdocument.thumbnails);
            }


        };

        this.Close = function () {

            //console.log('Close');
            thisdocument.bActive = false;

            while (thisdocument.pages.length != 0) {
                if (thisdocument.pages[thisdocument.pages.length - 1].usepdfjs) {
                    thisdocument.pages[thisdocument.pages.length - 1].PDFPointArray = [];
                    if(thisdocument.pages[thisdocument.pages.length - 1].pdfisfirstrendered){
                        clearInterval(thisdocument.pages[thisdocument.pages.length - 1].pdftimervar);
                        //this.pages[this.currentpage].PDFTextArea.style.display = "initial";

                        thisdocument.pages[thisdocument.pages.length - 1].PDFTextArea.removeEventListener('wheel', ev_canvas, true);
                        rxcontainer.removeChild(thisdocument.pages[thisdocument.pages.length - 1].PDFTextArea);

                    }
                }
                if (thisdocument.pages[thisdocument.pages.length - 1].usevectorxml) {
                    clearInterval(thisdocument.pages[thisdocument.pages.length - 1].vectortimervar);
                    thisdocument.textselect = false;
                    //thisdocument.pages[thisdocument.pages.length - 1].selecttext();

                    rxcontainer.appendChild(thisdocument.pages[thisdocument.pages.length - 1].TextSelectArea);
                    rxcontainer.removeChild(thisdocument.pages[thisdocument.pages.length - 1].TextSelectArea);
                    //thisdocument.pages[thisdocument.pages.length - 1].removetext();


                    if (thisdocument.pages[thisdocument.pages.length - 1].VectorPageObj != undefined) {
                        thisdocument.pages[thisdocument.pages.length - 1].VectorPageObj.Close();
                    }

                    var emptylist = [];
                    if (RxCore_GUI_VectorLayers != undefined) {
                        RxCore_GUI_VectorLayers.setVectorLayers(emptylist);
                    }
                    if (RxCore_GUI_VectorBlocks != undefined) {
                        RxCore_GUI_VectorBlocks.setVectorBlocks(emptylist);
                    }


                }
                if (thisdocument.pages[thisdocument.pages.length - 1].usevector3Dxml) {


                    //renderer.clear();
                    renderer.domElement.style.visibility = 'hidden';

                    if (RxCore_GUI_3DWalkthrough != undefined) {
                        RxCore_GUI_3DWalkthrough.setWalkthroughGUI(false);

                    }
                    bAnimateready = false;
                    if (thisdocument.pages[thisdocument.pages.length - 1].Vector3DPageObj != undefined) {
                        thisdocument.pages[thisdocument.pages.length - 1].Vector3DPageObj.Close();
                        thisdocument.pages[thisdocument.pages.length - 1].Vector3DPageObj = null;
                    }

                    var empty3dpartlist = [];
                    if (RxCore_GUI_3DParts != undefined) {
                        RxCore_GUI_3DParts.isupdate = false;
                        RxCore_GUI_3DParts.set3DParts(empty3dpartlist);
                    }


                }

                thisdocument.pages.pop();
            }

            if(thisdocument.bdestroyPDFonClose){

                if(thisdocument.pdfDoc != null){
                    thisdocument.pdfDoc.destroy();
                }

                thisdocument.pdfDoc = null;
            }


            while (this.markupundolist.length != 0) {
                this.markupundolist.pop();
            }

            while (this.markuplist.length != 0) {
                this.markuplist.pop();
            }

            while(this.markupdraworder.length != 0){
                this.markupdraworder.pop();
            }

            while (this.layouts.length != 0) {
                this.layouts.pop();
            }
            while (this.thumbnails.length != 0) {
                this.thumbnails.pop();
            }


            if (RxCore_GUI_Markuplist != undefined) {
                RxCore_GUI_Markuplist.setMarkupList(thisdocument.markuplist, thisdocument.bActive);
                // RxCore_GUI_Markuplist.notify();
            }

            if (RxCore_GUI_pagethumbs != undefined) {
                RxCore_GUI_pagethumbs.setThumbnails(thisdocument.thumbnails);
            }


        };

        function yieldingLoop(state, chunksize, callback, finished) {


            (function chunk() {
                var i = 0;
                var endloop = false;

                if (thisdocument.pagelocked){
                    var pagelength = thisdocument.pages.length;
                }else{
                    pagelength = thisdocument.pages.length - 1;
                }

                //var end = Math.min(i + chunksize, count);
                var end = (i < chunksize );
                for (; i < chunksize; ++i) {
                    callback.call(null, state);
                    if (state.bpageshort){
                        if (state.pagearray.length == 0){
                            endloop = true;
                            break;
                        }
                    }else{
                        if(state.pagenum == pagelength){
                            endloop = true;
                            break;
                        }

                    }

                }
                if (state.pagenum != (pagelength) || !endloop) {

                    setTimeout(chunk, 10);
                } else {

                    finished.call(null);
                }
            })();
        }

    };


    var ComparePrintObject = function(compareobj){
        var scope = this;
        var bovinverted = false;
        var bbginverted = false;

        compareobj.printing = true;
        this.pages = [];
        this.bispdf = compareobj.bispdf;
        this.oispdf = compareobj.oispdf;
        this.bisimage = compareobj.bisimage;
        this.oisimage = compareobj.oisimage;
        this.bisdvector = compareobj.bisdvector;
        this.oisvector = compareobj.oisvector;
        this.scaleratio = compareobj.scaleratio;
        this.overlayScale = compareobj.overlayScale;
        this.nudgeScalefactor = compareobj.nudgeScalefactor;
        this.overlayCScale = compareobj.overlayCScale;
        this.OffsetX = compareobj.OffsetX;
        this.OffsetY = compareobj.OffsetY;
        this.backgroundScale = compareobj.backgroundScale;
        this.overlayOffsetX = 0;
        this.overlayOffsetY = 0;
        this.pages[0] = compareobj.pages[0];
        this.pages[1] = compareobj.pages[1];

        this.pages[0].compositePrintreference = this;
        this.pages[1].compositePrintreference = this;

        this.backgroundColor = 'blue';
        this.overlayColor = '#ff8000';


        this.backgroundready = false;
        this.overlayready = false;

        this.pageURL = "";


        //this.combinedSize =

        if(this.oispdf){
            this.ovpagecanvas = document.createElement('canvas');
            this.ovpagecanvas.width = this.pages[1].pagecanvas.width;
            this.ovpagecanvas.height = this.pages[1].pagecanvas.height;
            this.ovpagectx = this.ovpagecanvas.getContext('2d');

        }
        if(this.bispdf){
            this.bgpagecanvas = document.createElement('canvas');
            this.bgpagecanvas.width = this.pages[0].pagecanvas.width;
            this.bgpagecanvas.height = this.pages[0].pagecanvas.height;
            this.bgpagectx = this.bgpagecanvas.getContext('2d');

        }


        this.printcanvas = document.createElement('canvas');
        this.printctx = this.printcanvas.getContext('2d');

        this.printobj = {
            paperimage : scope.printcanvas,
            paperwidth : 297,
            paperheight : 210,
            docwidth : 1,
            docheight : 1,
            inchtomm : 25.4,
            DPI : 300,
            scrDPI : 96,
            scaleSet : false,
            pdx : 0,
            pdy : 0,
            pscale : 1,
            printctx : scope.printctx,
            setRes : function(dpi){
                this.DPI = dpi;
            },
            setPaperSize : function(width,height){
                this.paperwidth = width;
                this.paperheight = height;
                PaperWidth = width;
                PaperHeight = height;
                this.paperimage.width = (width / this.inchtomm)* this.DPI;
                this.paperimage.height = (height / this.inchtomm)* this.DPI;
            },
            setDocSize : function(width, height){
                this.docwidth = width;
                this.docheight = height;
            },
            setScale : function(){
                var xscale = this.paperimage.width / this.docwidth; //thispage.MainImageWidth;
                var yscale = this.paperimage.height / this.docheight; // thispage.MainImageHeight;

                this.pscale = Math.min(xscale, yscale);
                this.pdx = (this.paperimage.width - (this.docwidth * this.pscale)) / 2;
                this.pdy = (this.paperimage.height - (this.docheight * this.pscale)) / 2;
                this.scaleSet = true;
            },
            print : function(pageURL){
                if(!this.scaleSet){
                    return;
                }
                scope.pageURL = pageURL;
                scope.scaleToBackground(true);
                /*if(thispage.usepdfjs){
                 //thispage.renderPDFpagePrint();
                 }else if (thispage.usevectorxml){
                 thispage.draw_vectorPrint();
                 }else if(thispage.usevector3Dxml){
                 //get imageurl.
                 thispage.print3Dimage.addEventListener('load', thispage.load3Dimage, false);
                 thispage.print3Dimage.src = renderer.domElement.toDataURL();

                 }else{
                 thispage.draw_imagePrint();
                 }*/

            }

        };

        this.getpaperscale = function(){

            var compositedim = scope.getwidthheight();
            if(compositedim.x2-compositedim.x1 > compositedim.y2-compositedim.y1){
                var pwidtdh = scope.printobj.paperwidth;
                var pheight = scope.printobj.paperheight;
            }else{
                pwidtdh = scope.printobj.paperheight;
                pheight = scope.printobj.paperwidth;

            }
            scope.printobj.setPaperSize(pwidtdh,pheight);
            scope.printobj.setDocSize(compositedim.x2-compositedim.x1,compositedim.y2-compositedim.y1);

        };

        this.getwidthheight = function(){


            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

            var compositestartx = Math.min(ovrlOffsetX, scope.overlayOffsetX);
            var compositestarty = Math.min(ovrlOffsetY, scope.overlayOffsetY);
            var compositeend = compareobj.getwidthheight();

            var compositeendx = Math.max(compositeend.x - scope.OffsetX, compositeend.x + scope.OffsetX);
            var compositeendy = Math.max(compositeend.y - scope.OffsetY, compositeend.y + scope.OffsetY);

            return {x1 : compositestartx,y1 : compositestarty,x2 : compositeendx, y2 : compositeendy};




        };

        //scope.getpaperscale();

        this.scaleToBackground = function(scalechanged){


            scope.OffsetX /= scope.overlayScale;
            scope.OffsetY /= scope.overlayScale;


            if(scope.bispdf){
                scope.backgroundready = false;

                if(scope.oispdf){
                    scope.backgroundScale = (scope.ovpagecanvas.width * scope.pages[1].dscalepdf) / scope.bgpagecanvas.width;
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscalepdf;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayCScale = scope.backgroundScale;// * scope.scaleratio;

                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;

                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.overlayready = false;
                    scope.pages[0].pdfisrendered = !scalechanged;
                    scope.pages[1].pdfisrendered = !scalechanged;


                    //scope.draw_compare(scalechanged);


                }else if (scope.oisimage){
                    scope.backgroundScale = (scope.pages[1].dscale * scope.pages[1].MainImageWidth) / scope.bgpagecanvas.width;
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscale;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;

                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.overlayCScale = scope.backgroundScale;


                    scope.pages[0].pdfisrendered = !scalechanged;
                    //scope.draw_compare(scalechanged);
                    scope.overlayready = false;

                    if (!scalechanged){

                    }



                }else if (scope.oisvector){

                    scope.backgroundScale = (scope.pages[1].VectorPageObj.width * scope.pages[1].dscalevector) / scope.bgpagecanvas.width;
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscalevector;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;

                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;


                    scope.overlayCScale = scope.backgroundScale;// * scope.scaleratio;


                    scope.pages[0].pdfisrendered = !scalechanged;


                    scope.overlayready = false;
                    scope.draw_compare_print(scalechanged);



                    if (!scalechanged){

                    }



                }
            }

            if(scope.bisimage){
                scope.backgroundready = false;
                scope.pages[0].checkimageswitch();

                if(scope.oispdf){
                    scope.backgroundScale = (scope.ovpagecanvas.width * scope.pages[1].dscalepdf) / scope.pages[0].MainImageWidth;
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;


                    scope.overlayCScale = scope.backgroundScale;

                    scope.overlayScale = scope.pages[1].dscalepdf;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;

                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.pages[1].pdfisrendered = !scalechanged;

                    if (!scalechanged){
                        scope.overlayready = false;
                        scope.draw_compare_print(scalechanged);
                    }


                }else if (scope.oisimage){

                    //scope.pages[0].currentimage = 0;
                    //scope.pages[1].currentimage = 0;
                    scope.backgroundScale = (scope.pages[1].dscale * scope.pages[1].MainImageWidth) / scope.pages[0].MainImageWidth;
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscale;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayCScale = scope.backgroundScale;
                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;
                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.overlayready = false;
                    scope.draw_compare_print(scalechanged);


                }else if (scope.oisvector){
                    scope.backgroundScale = (scope.pages[1].VectorPageObj.width * scope.pages[1].dscalevector) / scope.pages[0].MainImageWidth;
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscalevector;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayCScale = scope.backgroundScale;
                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;

                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.overlayready = false;
                    scope.draw_compare_print(scalechanged);

                }

            }

            if(scope.bisdvector){
                scope.backgroundready = false;

                if(scope.oispdf){
                    scope.backgroundScale = (scope.ovpagecanvas.width * scope.pages[1].dscalepdf) / (scope.pages[0].VectorPageObj.width);
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscalepdf;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayCScale = scope.backgroundScale;

                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;

                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.pages[1].pdfisrendered = !scalechanged;


                    if (!scalechanged){
                        scope.overlayready = false;
                        scope.draw_compare_print(scalechanged);
                    }


                }else if (scope.oisimage){

                    scope.backgroundScale = (scope.pages[1].dscale * scope.pages[1].MainImageWidth) / (scope.pages[0].VectorPageObj.width);
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscale;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;
                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.overlayCScale = scope.backgroundScale;

                    scope.overlayready = false;
                    scope.draw_compare_print(scalechanged);



                }else if (scope.oisvector){
                    scope.backgroundScale = (scope.pages[1].VectorPageObj.width * scope.pages[1].dscalevector) / (scope.pages[0].VectorPageObj.width);
                    scope.backgroundScale *= scope.scaleratio;
                    scope.backgroundScale *= scope.printobj.pscale;

                    scope.overlayScale = scope.pages[1].dscalevector;
                    scope.overlayScale *= scope.printobj.pscale;

                    scope.overlayCScale = scope.backgroundScale;
                    scope.overlayOffsetX = 0;
                    scope.overlayOffsetY = 0;

                    scope.OffsetX *= scope.overlayScale;
                    scope.OffsetY *= scope.overlayScale;

                    scope.overlayready = false;
                    scope.draw_compare_print(scalechanged);

                }

            }


        };

        this.invertpdf = function(){


            if(scope.bispdf){
                scope.pages[0].invertpdfprint(1);
                bbginverted = true;

            }

            if(scope.oispdf){
                scope.pages[1].invertpdfprint(2);
                bovinverted = true;
            }

            if(scope.bispdf && scope.oispdf){
                if(bbginverted && bovinverted){
                    scope.backgroundready = true;
                    scope.overlayready = true;
                    scope.draw_compare_print(true);
                    bbginverted = false;
                    bovinverted = false;


                }

            }else if(scope.bispdf && !scope.oispdf){
                if(bbginverted){
                    scope.backgroundready = true;
                    scope.draw_compare_print(true);
                    bbginverted = false;

                }
            }else if(!scope.bispdf && scope.oispdf){
                if(bovinverted){
                    scope.overlayready = true;
                    scope.draw_compare_print(true);
                    bovinverted = false;

                }


            }

            //scope.usepdf = true;
            //scope.pdfrendered = true;

            //scope.scaleToBackground(true);

        };
        this.renderPDFscale = function(){

            if(scope.bispdf){
                scope.backgroundready = false;
                scope.pages[0].queRenderCompareScale(0);
            }

            if(scope.oispdf){
                scope.overlayready = false;
                scope.pages[1].queRenderCompareScale(1);
            }


        };

        this.draw_image = function (clear) {

            if (!scope.bisimage && !scope.oisimage) {
                return;
            }

            /*if(scope.bisimage){
                var curimage = scope.pages[0].currentimage;
            }else if(scope.oisimage){
                curimage = scope.pages[1].currentimage;
            }*/

            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;
            /*if (clear) {
             contexto.fillStyle = "rgb(62,62,62)";
             contexto.fillRect(0, 0, canvasowidth, canvasoheight);
             }*/



            //var tx = (canvasowidth / 2);
            //var ty = (canvasoheight / 2);

            //var drawscale = this.pages[1].dscale / scope.overlayScale;
            //var drawscaleext = this.pages[1].dscaleextent / scope.overlayScale;
            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

            scope.printobj.printctx.save();

            if (scope.bisimage){
                scope.printobj.printctx.globalCompositeOperation = 'source-over';
                scope.printobj.printctx.drawImage(scope.pages[0].largeimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].MainImageWidth * scope.overlayCScale, scope.pages[0].MainImageHeight * scope.overlayCScale);
                scope.backgroundready = true;
            }
            if (scope.oisimage){

                if(bShowDiffonly){
                    scope.printobj.printctx.globalCompositeOperation = szdrawmode;
                }else{
                    scope.printobj.printctx.globalCompositeOperation = 'darken';

                }


                scope.printobj.printctx.drawImage(scope.pages[1].largeimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].MainImageWidth * overlayscalenudge, scope.pages[1].MainImageHeight * overlayscalenudge);
                scope.overlayready = true;
            }
            scope.printobj.printctx.restore();


            /*switch (curimage) {
                case 0:

                    if (this.pages[1].drotation == 0) {

                    } else {
                        contexto.save();
                        contexto.translate(tx, ty);
                        contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                        contexto.translate(-tx, -ty);
                        if (scope.bisimage){
                            contexto.globalCompositeOperation = 'source-over';
                            contexto.drawImage(scope.pages[0].largeimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].MainImageWidth * scope.overlayCScale, scope.pages[0].MainImageHeight * scope.overlayCScale);
                        }
                        if (scope.oisimage){
                            contexto.globalCompositeOperation = 'darken';
                            contexto.drawImage(scope.pages[1].largeimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].MainImageWidth * scope.overlayScale, scope.pages[1].MainImageHeight * scope.overlayScale);

                        }


                        contexto.restore();

                    }
                    break;
                case 1:
                    var bgscale = scope.overlayCScale / scope.pages[0].bitmapratio;
                    var ovscale = scope.overlayScale / scope.pages[1].bitmapratio;

                    scope.printobj.printctx.save();
                    //contexto.drawImage(this.smallimagecnv, this.dxextent, this.dyextent, this.SmallImageWidth * this.dscaleextent, this.SmallImageHeight * this.dscaleextent);
                    if (scope.bisimage){
                        scope.printobj.printctx.globalCompositeOperation = 'source-over';
                        scope.printobj.printctx.drawImage(scope.pages[0].smallimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].SmallImageWidth * bgscale, scope.pages[0].SmallImageHeight * bgscale);


                    }
                    if (scope.oisimage){
                        scope.printobj.printctx.globalCompositeOperation = 'darken';
                        scope.printobj.printctx.drawImage(scope.pages[1].smallimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].SmallImageWidth * ovscale, scope.pages[1].SmallImageHeight * ovscale);

                    }

                    scope.printobj.printctx.restore();


                    if (this.pages[1].drotation == 0) {
                    } else {
                        contexto.save();
                        contexto.translate(tx, ty);
                        contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                        contexto.translate(-tx, -ty);
                        //contexto.drawImage(this.smallimagecnv, this.dxextent, this.dyextent, this.SmallImageWidth * this.dscaleextent, this.SmallImageHeight * this.dscaleextent);
                        if (scope.bisimage){
                            contexto.globalCompositeOperation = 'source-over';
                            contexto.drawImage(scope.pages[0].smallimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].SmallImageWidth * bgscale, scope.pages[0].SmallImageHeight * bgscale);


                        }
                        if (scope.oisimage){
                            contexto.globalCompositeOperation = 'darken';
                            contexto.drawImage(scope.pages[1].smallimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].SmallImageWidth * ovscale, scope.pages[1].SmallImageHeight * ovscale);


                        }


                        contexto.restore();

                    }

                    break;
            }*/

        };

        this.draw_vector = function(refresh){

            this.bisdvector = (scope.pages[0].VectorPageObj != undefined);
            this.oisvector = (scope.pages[1].VectorPageObj != undefined);


            if (!scope.bisdvector && !scope.oisvector) {
                return;
            }

            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;

            scope.printobj.printctx.save();
            if (scope.bisdvector){
                scope.pages[0].VectorPageObj.drawallcmpre(scope.printobj.printctx, scope.overlayCScale, scope.overlayOffsetX, scope.overlayOffsetY, refresh, this.backgroundColor, true, scope.compareMode);
                scope.backgroundready = true;
            }

            if (scope.oisvector){
                scope.pages[1].VectorPageObj.drawallcmpre(scope.printobj.printctx, overlayscalenudge, scope.overlayOffsetX + scope.OffsetX, scope.overlayOffsetY + scope.OffsetY, refresh, this.overlayColor, false, scope.compareMode);
                scope.overlayready = true;

            }

            scope.printobj.printctx.restore();

            //var tx = (canvasowidth / 2);
            //var ty = (canvasoheight / 2);




            /*if (this.pages[1].drotation == 0) {

            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);
                if (scope.bisdvector){
                    this.pages[0].VectorPageObj.drawallcmpre(contexto, scope.overlayCScale, scope.overlayOffsetX, scope.overlayOffsetY, refresh, this.backgroundColor, true);

                }

                if (scope.oisvector){
                    //this.pages[1].VectorPageObj.drawallcmpre(contexto, this.pages[1].dscalevector, this.pages[1].dxvector, this.pages[1].dyvector, refresh, this.overlayColor, false);
                    this.pages[1].VectorPageObj.drawallcmpre(contexto, scope.overlayScale, scope.overlayOffsetX + scope.OffsetX, scope.overlayOffsetY + scope.OffsetY, refresh, this.overlayColor, false);

                }

                contexto.restore();

            }*/

            //contexto.restore();
        };

        this.draw_canvas = function (clear) {

            if (!scope.bispdf && !scope.oispdf) {
                return;
            }
            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;
            //var tx = (canvasowidth / 2);
            //var ty = (canvasoheight / 2);

            //documentopen = true;
            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

            scope.printobj.printctx.save();

            if (scope.bispdf){
                scope.printobj.printctx.globalCompositeOperation = 'source-over';
                scope.printobj.printctx.drawImage(scope.bgpagecanvas, scope.overlayOffsetX, scope.overlayOffsetY, scope.bgpagecanvas.width * scope.overlayCScale, scope.bgpagecanvas.height * scope.overlayCScale);
            }
            if (scope.oispdf){
                if(bShowDiffonly){
                    scope.printobj.printctx.globalCompositeOperation = szdrawmode;
                }else{
                    scope.printobj.printctx.globalCompositeOperation = 'darken';
                }


                scope.printobj.printctx.drawImage(scope.ovpagecanvas, ovrlOffsetX, ovrlOffsetY, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);
            }
            scope.printobj.printctx.restore();


            /*if (this.pages[1].drotation == 0) {



            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);
                if (scope.bispdf){
                    contexto.globalCompositeOperation = 'source-over';
                    contexto.drawImage(scope.bgpagecanvas, scope.overlayOffsetX, scope.overlayOffsetY, scope.bgpagecanvas.width * scope.overlayCScale, scope.bgpagecanvas.height * scope.overlayCScale);
                }
                if (scope.oispdf){
                    contexto.globalCompositeOperation = 'darken';
                    contexto.drawImage(scope.ovpagecanvas, ovrlOffsetX, ovrlOffsetY, scope.ovpagecanvas.width * scope.overlayScale, scope.ovpagecanvas.height * scope.overlayScale);
                }

                contexto.restore();

            }*/


        };
        this.draw_compare_print = function(refresh){

            scope.printobj.printctx.save();
            scope.printobj.printctx.fillStyle = "rgb(255,255,255)";
            scope.printobj.printctx.fillRect(0, 0, scope.printobj.paperimage.width, scope.printobj.paperimage.height);

            if (scope.bisdvector){

                scope.draw_vector(refresh);
                scope.draw_image(refresh);
                scope.draw_canvas(refresh);

            }else if(scope.bisimage){
                scope.draw_image(refresh);
                scope.draw_vector(refresh);
                scope.draw_canvas(refresh);
            }else if(scope.bispdf){

                scope.draw_canvas(refresh);
                scope.draw_vector(refresh);
                scope.draw_image(refresh);
            }

            if(scope.overlayready && scope.backgroundready){
                ///console.log('only once I hope');
                printCanvas(scope.pageURL);

            }
            //


        };

    };

    var CompareObject = function (pageobjectb, pageobjecto) {

        var scope = this;
        var bovinverted = false;
        var bbginverted = false;

        this.printing = false;
        this.printref = {};
        this.pages = [];
        this.fileindex = 0;
        this.scaleindex = 0;
        this.bActive = true;
        this.Type = 'Compare';


        this.compareMode = 0;
        //this.overlayPage = pageobjecto;
        //this.backgroundPage = pageobjectb;

        this.pages[0] = pageobjectb;
        this.pages[1] = pageobjecto;

        this.pages[0].backupScaleAndOffset();
        this.pages[1].backupScaleAndOffset();

        this.pages[1].DocRef.Drawmarkup = false;
        this.pages[0].DocRef.Drawmarkup = false;


        this.pages[0].usedincomposite = true;
        this.pages[0].compositereference = this;
        this.pages[0].isbackground = true;
        this.pages[0].isoverlay = false;


        this.pages[1].usedincomposite = true;
        this.pages[1].compositereference = this;
        this.pages[1].isbackground = false;
        this.pages[1].isoverlay = true;


        this.bisdvector = pageobjectb.usevectorxml;
        this.oisvector = pageobjecto.usevectorxml;

        this.bisimage = !pageobjectb.usevectorxml && !pageobjectb.usepdfjs;
        this.oisimage = !pageobjecto.usevectorxml && !pageobjecto.usepdfjs;


        this.bisdvector = (pageobjectb.VectorPageObj != undefined);
        this.oisvector = (pageobjecto.VectorPageObj != undefined);

        this.bispdf = pageobjectb.usepdfjs;
        this.oispdf = pageobjecto.usepdfjs;


        this.currentpage = pageobjecto.pagenumber;
        this.currentDocPage = pageobjecto.DocRef.currentpage;


        this.backgroundColor = overlayBGColor;
        this.overlayColor = overlayFGColor;

        //future

        this.scaleratio = 1;
        this.scaleratioextent = 1;
        this.backgroundMScale = 1;
        this.backgroundMScaleext = 1;
        this.backgroundCScale = 1;
        this.backgroundScale = 1;
        this.fgdrawangle = 0;
        this.bnudgeangleused = false;

        this.originalpdfpagescale = 1;
        this.originalpdfscale = 1;


        this.bgpageheight = pageobjectb.endy - pageobjectb.starty;
        this.bgpagewidth = pageobjectb.endx - pageobjectb.startx;

        this.backgroundWidth = this.bgpagewidth;
        this.backgroundHeigth = this.bgpageheight;


        this.backgroundOffsetX = 0;
        this.backgroundOffsetY = 0;
        this.backgroundAlOffsetX = 0;
        this.backgroundAlOffsetY = 0;

        this.backgroundAlOffsetXext = 0;
        this.backgroundAlOffsetYext = 0;

        this.backgroundOffset = 0;

        this.overlayMScale = 1;
        this.overlayMScaleext = 1;
        this.overlayCScale = 1;
        this.overlayScale = 1;
        this.nudgeScalefactor = 0;

        this.ovpageheight = pageobjecto.endy - pageobjecto.starty;
        this.ovpagewidth = pageobjecto.endx - pageobjecto.startx;

        this.overlayWidth = this.bgpagewidth;
        this.overlayHeigth = this.bgpageheight;

        this.overlayOffsetX = 0;
        this.overlayOffsetY = 0;

        this.overlayAlOffsetX = 0;
        this.overlayAlOffsetY = 0;

        this.overlayAlOffsetXunscaled = 0;
        this.overlayAlOffsetYunscaled = 0;

        this.OffsetX = 0;
        this.OffsetY = 0;
        this.AlignOffsetBackup = {x : 0, y: 0, bgcanvwidth : this.bgpagewidth};


        this.overlayOffset = 0;



        this.resetCompare = function(){
            this.scaleratio = 1;
            this.scaleratioextent = 1;
            this.backgroundMScale = 1;
            this.backgroundMScaleext = 1;
            this.backgroundCScale = 1;
            this.backgroundScale = 1;
            this.fgdrawangle = 0;

            this.originalpdfpagescale = 1;
            this.originalpdfscale = 1;


            this.bgpageheight = pageobjectb.endy - pageobjectb.starty;
            this.bgpagewidth = pageobjectb.endx - pageobjectb.startx;

            this.backgroundWidth = this.bgpagewidth;
            this.backgroundHeigth = this.bgpageheight;


            this.backgroundOffsetX = 0;
            this.backgroundOffsetY = 0;
            this.backgroundAlOffsetX = 0;
            this.backgroundAlOffsetY = 0;

            this.backgroundAlOffsetXext = 0;
            this.backgroundAlOffsetYext = 0;

            this.backgroundOffset = 0;

            this.overlayMScale = 1;
            this.overlayMScaleext = 1;
            this.overlayCScale = 1;
            this.overlayScale = 1;
            this.nudgeScalefactor = 0;

            this.ovpageheight = pageobjecto.endy - pageobjecto.starty;
            this.ovpagewidth = pageobjecto.endx - pageobjecto.startx;

            this.overlayWidth = this.bgpagewidth;
            this.overlayHeigth = this.bgpageheight;

            this.overlayOffsetX = 0;
            this.overlayOffsetY = 0;

            this.overlayAlOffsetX = 0;
            this.overlayAlOffsetY = 0;

            this.overlayAlOffsetXunscaled = 0;
            this.overlayAlOffsetYunscaled = 0;

            this.backgroundAlOffsetXunscaled = 0;
            this.backgroundAlOffsetYunscaled = 0;


            this.OffsetX = 0;
            this.OffsetY = 0;


            this.overlayOffset = 0;

            scope.initialScale();

            scope.renderPDFscale();
            scope.scaleToBackground(true);


        };


        this.initialScale = function(){
            //calculate initial scaleratio. I.E difference between background and overlay.
            if(scope.bisimage){

                this.originalpdfpagescale = this.pages[0].curpagescale;
                this.originalpdfscale = this.pages[0].dscalepdf;

                if(scope.oispdf){

                    this.ovpagecanvas = document.createElement('canvas');
                    this.ovpagecanvas.width = this.pages[1].pagecanvas.width;
                    this.ovpagecanvas.height = this.pages[1].pagecanvas.height;
                    this.ovpagectx = this.ovpagecanvas.getContext('2d');


                    this.ovpageheight = this.pages[1].pdfpageheight;
                    this.ovpagewidth = this.pages[1].pdfpagewidth;

                    this.overlayScale = this.pages[1].getdscale();
                    this.overlayOffsetX = this.pages[1].getdx();
                    this.overlayOffsetY = this.pages[1].getdy();

                }else if (scope.oisimage){

                    this.overlayScale = this.pages[1].dscale;
                    this.overlayOffsetX = this.pages[1].dx;
                    this.overlayOffsetY = this.pages[1].dy;
                    this.overlayCScale = this.overlayScale * this.scaleratio;



                }else if (scope.oisvector){

                    this.overlayScale = this.pages[1].dscalevector;
                    this.overlayOffsetX = this.pages[1].dxvector;
                    this.overlayOffsetY = this.pages[1].dyvector;
                    this.overlayCScale = this.overlayScale * this.scaleratio;

                }
                this.backgroundScale = this.pages[0].dscale;
                this.backgroundOffsetX = this.pages[0].dx;
                this.backgroundOffsetY = this.pages[0].dy;

            }
            if(scope.bispdf){
                this.bgpagecanvas = document.createElement('canvas');
                this.bgpagecanvas.width = this.pages[0].pagecanvas.width;
                //console.log(this.bgpagecanvas.width);
                this.bgpagecanvas.height = this.pages[0].pagecanvas.height;
                this.bgpagectx = this.bgpagecanvas.getContext('2d');


                this.bgpagewidth = this.pages[0].pdfpagewidth;
                this.bgpageheight = this.pages[0].pdfpageheight;

                this.backgroundScale = this.pages[0].dscalepdf;


                this.backgroundOffsetX = this.pages[0].getdx();
                this.backgroundOffsetY = this.pages[0].getdy();


                if(scope.oispdf){
                    this.ovpagecanvas = document.createElement('canvas');
                    this.ovpagecanvas.width = this.pages[1].pagecanvas.width;
                    this.ovpagecanvas.height = this.pages[1].pagecanvas.height;
                    this.ovpagectx = this.ovpagecanvas.getContext('2d');


                    this.ovpageheight = this.pages[1].pdfpageheight;
                    this.ovpagewidth = this.pages[1].pdfpagewidth;

                    this.overlayScale = this.pages[1].getdscale();
                    this.overlayOffsetX = this.pages[1].getdx();
                    this.overlayOffsetY = this.pages[1].getdy();

                }else if (scope.oisimage){

                    this.overlayScale = this.pages[1].dscale;
                    this.overlayOffsetX = this.pages[1].dx;
                    this.overlayOffsetY = this.pages[1].dy;


                    this.overlayCScale = this.overlayScale * this.scaleratio;

                }else if (scope.oisvector){
                    this.overlayOffsetX = this.backgroundOffsetX;
                    this.overlayOffsetY = this.backgroundOffsetY;
                    this.overlayCScale = 1;

                }
            }
            if(scope.bisdvector){

                if(scope.oispdf){
                    this.ovpagecanvas = document.createElement('canvas');
                    this.ovpagecanvas.width = this.pages[1].pagecanvas.width;
                    this.ovpagecanvas.height = this.pages[1].pagecanvas.height;
                    this.ovpagectx = this.ovpagecanvas.getContext('2d');

                    this.ovpageheight = this.pages[1].pdfpageheight;
                    this.ovpagewidth = this.pages[1].pdfpagewidth;

                    this.overlayScale = this.pages[1].getdscale();
                    this.overlayOffsetX = this.pages[1].getdx();
                    this.overlayOffsetY = this.pages[1].getdy();


                }else if (scope.oisimage){


                    this.overlayScale = this.pages[1].dscale;
                    this.overlayOffsetX = this.pages[1].dx;
                    this.overlayOffsetY = this.pages[1].dy;
                    this.overlayCScale = (scope.pages[1].dscale * scope.pages[1].MainImageWidth) / (scope.pages[0].VectorPageObj.width);

                }else if (scope.oisvector){

                    this.overlayScale = this.pages[1].dscalevector;
                    this.overlayOffsetX = this.pages[1].dxvector;
                    this.overlayOffsetY = this.pages[1].dyvector;
                    this.overlayCScale = this.overlayScale * this.scaleratio;

                }

                this.backgroundScale = this.pages[0].dscalevector;
                this.backgroundOffsetX = this.pages[0].dxvector;
                this.backgroundOffsetY = this.pages[0].dyvector;


            }
        };

        scope.initialScale();

        this.isActiveDoc = true;

        this.print = function (PrintpgURL){
            scope.printref = new ComparePrintObject(scope);
            scope.printref.printobj.setRes(300);
             //scope.printref.printobj.setPaperSize(paper.width,paper.height);
            scope.printref.getpaperscale();

            scope.printref.printobj.setScale();
            scope.printref.printobj.print(PrintpgURL);
        };

        this.printClose = function(){
            if (scope.printing){
                scope.printref.printobj.paperwidth = 1;
                scope.printref.printobj.paperheight = 1;
                scope.printref = {};
                scope.printing = false;
            }


        };

        this.getoverlayOffsets = function(zoomtype){
            var compositeend = scope.getwidthheight();

            //var compwidthHalf = compositeend.x / 2;
            //var compheighthHalf = compositeend.y / 2;

            var totaloffsetx = scope.pages[1].dxpdf;
            var totaloffsety = scope.pages[1].dypdf;


            if (zoomtype == 0 ){



                totaloffsetx = (canvasowidth - (compositeend.x * scope.pages[1].dscalepdf)) / 2;
                totaloffsety = (canvasoheight - (compositeend.y * scope.pages[1].dscalepdf)) / 2;

                //scope.overlayOffsetX = totaloffsetx - scope.OffsetX;
                //scope.overlayOffsetY = totaloffsety - scope.OffsetY;
            }else if (zoomtype == 1){



               totaloffsetx = (canvasowidth - (compositeend.x * scope.pages[1].dscalepdf)) / 2;
               totaloffsety = (canvasoheight - (compositeend.y * scope.pages[1].dscalepdf)) / 2;

            }

            return {
                x : totaloffsetx,
                y : totaloffsety
            }
        };

        this.getoverlayScaleFactor = function(zoomtype){

            var bgScalefactor = scope.pages[1].dscalepdf;
             //added calculation of total composite extent.
             var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
             var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

             var compositestartx = Math.min(ovrlOffsetX, scope.overlayOffsetX);
             var compositestarty = Math.min(ovrlOffsetY, scope.overlayOffsetY);
             var compositeend = scope.getwidthheight();

             var zoomwidth = scope.ovpagecanvas.width * scope.pages[1].dscalepdf;
             var zoomheight = scope.ovpagecanvas.height * scope.pages[1].dscalepdf;

             //console.log(zoomtype);

            if (zoomtype == 3 || zoomtype == 4 || zoomtype == 5 || zoomtype == 6){
                //var totaloffsetx = ((canvasowidth - compositeend.x) / 2);
                //var totaloffsety = ((canvasoheight - compositeend.y) / 2);

                //scope.overlayOffsetX = totaloffsetx - scope.OffsetX;
                //scope.overlayOffsetY = totaloffsety - scope.OffsetY;

                var zoomscale = compositeend.x/zoomwidth;
                if(zoomscale != 0){
                    bgScalefactor = 1 / zoomscale;
                }
                //scope.backgroundScale = (scope.ovpagecanvas.width * scope.pages[1].dscalepdf) / scope.bgpagecanvas.width;
                //scope.overlayScale = scope.pages[1].dscalepdf;
                //scope.overlayCScale = scope.backgroundScale;// * scope.scaleratio;

                /*if(scope.OffsetX != 0){
                    scope.OffsetX /= zoomscale;
                }
                if(scope.OffsetY != 0){
                    scope.OffsetY /= zoomscale;
                }*/
                //scope.renderPDFscale();
                //scope.pages[0].pdfisrendered = false;
                //scope.pages[1].pdfisrendered = false;

            }


            return bgScalefactor;
        };

        this.offsetScaling = function(bgwidth, ovwidth){
            var pdfbackgroundscale = bgwidth / scope.pages[0].pdfpagewidth;
            pdfbackgroundscale *= scope.overlayCScale;

            var backgroundAlOffsetX = scope.backgroundAlOffsetXunscaled * pdfbackgroundscale;
            var backgroundAlOffsetY = scope.backgroundAlOffsetYunscaled * pdfbackgroundscale;

            var pdfoverlayscale = ovwidth / scope.pages[1].pdfpagewidth;

            var overlayAlOffsetX = (scope.overlayAlOffsetXunscaled * pdfoverlayscale);
            var overlayAlOffsetY = (scope.overlayAlOffsetYunscaled * pdfoverlayscale);

            //x : -((overlayAlOffsetX) - (backgroundAlOffsetX*scope.scaleratio)),
            //y : -((overlayAlOffsetY) - (backgroundAlOffsetY*scope.scaleratio))

            return {
                x : -((overlayAlOffsetX) - (backgroundAlOffsetX)),
                y : -((overlayAlOffsetY) - (backgroundAlOffsetY))
            }

        };

        this.scaleToBackground = function(scalechanged){


            if(scope.OffsetX != 0){
                scope.OffsetX /= scope.overlayScale;
            }
            if(scope.OffsetY != 0){
                scope.OffsetY /= scope.overlayScale;
            }

            /*var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;


            var compositestartx = Math.min(ovrlOffsetX, scope.overlayOffsetX);
            var compositestarty = Math.min(ovrlOffsetY, scope.overlayOffsetY);
            var compositeend = scope.getwidthheight();*/


            if(scope.bispdf){


                if(scope.oispdf){


                    scope.backgroundScale = (scope.ovpagecanvas.width * scope.pages[1].dscalepdf) / scope.bgpagecanvas.width;

                    scope.backgroundScale *= scope.scaleratio;

                    scope.overlayScale = scope.pages[1].dscalepdf;

                    scope.overlayCScale = scope.backgroundScale;// * scope.scaleratio;


                    scope.overlayOffsetX = scope.pages[1].dxpdf;
                    scope.overlayOffsetY = scope.pages[1].dypdf;

                    //scope.AlignOffsetBackup.x = scope.OffsetX;
                    //scope.AlignOffsetBackup.y = scope.OffsetY;
                    //scope.AlignOffsetBackup.scale = scope.scaleratio;

                    //var bgratio = scope.bgpagecanvas.width / scope.AlignOffsetBackup.bgcanvwidth;
                    //bgratio /= scope.scaleratio;

                    var scaledoffsets = scope.offsetScaling(scope.bgpagecanvas.width, scope.ovpagecanvas.width);
                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                        var diffx = scope.OffsetX - scaledoffsets.x;
                        var tenpercent = 0.2 * scope.OffsetX;
                        if (Math.abs(diffx) < Math.abs(tenpercent)){
                            scope.OffsetX = scaledoffsets.x;
                        }

                        //console.log('newcalcX',scaledoffsets.x);
                        //console.log('OffsetX',scope.OffsetX);


                    }

                    if(scope.OffsetY != 0){

                        scope.OffsetY *= scope.overlayScale;
                        var diffy = scope.OffsetY - scaledoffsets.y;
                        tenpercent = 0.2 * scope.OffsetY;

                        if (Math.abs(diffy) < Math.abs(tenpercent)){
                            scope.OffsetY = scaledoffsets.y;
                        }
                        //bgratio /= scope.scaleratio;
                        //scope.OffsetY = scaledoffsets.y;
                        //console.log('newcalcY',scaledoffsets.y);
                        //console.log('OffsetY',scope.OffsetY);
                        //scope.OffsetY = scaledoffsets.y;
                    }

                    if (scope.OffsetX < 0){
                        scope.overlayOffsetX += Math.abs(scope.OffsetX);

                    }

                    if (scope.OffsetY < 0){
                        scope.overlayOffsetY += Math.abs(scope.OffsetY);

                    }

                    scope.pages[0].pdfisrendered = !scalechanged;
                    scope.pages[1].pdfisrendered = !scalechanged;

                    scope.draw_compare(scalechanged);


                }else if (scope.oisimage){
                    scope.backgroundScale = (scope.pages[1].dscale * scope.pages[1].MainImageWidth) / scope.bgpagecanvas.width;
                    scope.backgroundScale *= scope.scaleratio;
                    scope.overlayScale = scope.pages[1].dscale;
                    scope.overlayOffsetX = scope.pages[1].dx;
                    scope.overlayOffsetY = scope.pages[1].dy;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }



                    scope.overlayCScale = scope.backgroundScale;


                    scope.pages[0].pdfisrendered = !scalechanged;
                    scope.draw_compare(scalechanged);

                    if (!scalechanged){

                    }



                }else if (scope.oisvector){

                    scope.backgroundScale = (scope.pages[1].VectorPageObj.width * scope.pages[1].dscalevector) / scope.bgpagecanvas.width;
                    scope.backgroundScale *= scope.scaleratio;

                    scope.overlayScale = scope.pages[1].dscalevector;
                    scope.overlayOffsetX = scope.pages[1].dxvector;
                    scope.overlayOffsetY = scope.pages[1].dyvector;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }


                    scope.overlayCScale = scope.backgroundScale;// * scope.scaleratio;


                    scope.pages[0].pdfisrendered = !scalechanged;

                    scope.draw_compare(scalechanged);

                    if (!scalechanged){

                    }

                }
            }

            if(scope.bisimage){

                scope.pages[0].checkimageswitch();

                if(scope.oispdf){
                    scope.backgroundScale = (scope.ovpagecanvas.width * scope.pages[1].dscalepdf) / scope.pages[0].MainImageWidth;
                    scope.backgroundScale *= scope.scaleratio;



                    scope.overlayCScale = scope.backgroundScale;

                    scope.overlayScale = scope.pages[1].dscalepdf;
                    scope.overlayOffsetX = scope.pages[1].dxpdf;
                    scope.overlayOffsetY = scope.pages[1].dypdf;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }



                    scope.pages[1].pdfisrendered = !scalechanged;

                    if (!scalechanged){
                        scope.draw_compare(scalechanged);
                    }


                }else if (scope.oisimage){

                    scope.pages[0].currentimage = scope.pages[1].currentimage;
                    scope.backgroundScale = (scope.pages[1].dscale * scope.pages[1].MainImageWidth) / scope.pages[0].MainImageWidth;
                    scope.backgroundScale *= scope.scaleratio;

                    scope.backgroundWidth = scope.pages[0].MainImageWidth * scope.backgroundScale;
                    scope.backgroundHeigth = scope.pages[0].MainImageHeight * scope.backgroundScale;


                    scope.overlayScale = scope.pages[1].dscale;

                    scope.overlayCScale = scope.backgroundScale;
                    scope.overlayOffsetX = scope.pages[1].dx;
                    scope.overlayOffsetY = scope.pages[1].dy;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }


                    scope.draw_compare(scalechanged);

                }else if (scope.oisvector){
                    scope.backgroundScale = (scope.pages[1].VectorPageObj.width * scope.pages[1].dscalevector) / scope.pages[0].MainImageWidth;
                    scope.backgroundScale *= scope.scaleratio;

                    scope.overlayScale = scope.pages[1].dscalevector;
                    scope.overlayCScale = scope.backgroundScale;
                    scope.overlayOffsetX = scope.pages[1].dxvector;
                    scope.overlayOffsetY = scope.pages[1].dyvector;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }


                    scope.draw_compare(scalechanged);
                }

            }

            if(scope.bisdvector){


                if(scope.oispdf){
                    scope.backgroundScale = (scope.ovpagecanvas.width * scope.pages[1].dscalepdf) / (scope.pages[0].VectorPageObj.width);
                    scope.backgroundScale *= scope.scaleratio;


                    scope.overlayScale = scope.pages[1].dscalepdf;
                    scope.overlayCScale = scope.backgroundScale;

                    scope.overlayOffsetX = scope.pages[1].dxpdf;
                    scope.overlayOffsetY = scope.pages[1].dypdf;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }


                    scope.pages[1].pdfisrendered = !scalechanged;


                    if (!scalechanged){
                        scope.draw_compare(scalechanged);
                    }


                }else if (scope.oisimage){

                    scope.backgroundScale = (scope.pages[1].dscale * scope.pages[1].MainImageWidth) / (scope.pages[0].VectorPageObj.width);
                    scope.backgroundScale *= scope.scaleratio;
                    scope.overlayScale = scope.pages[1].dscale;
                    scope.overlayOffsetX = scope.pages[1].dx;
                    scope.overlayOffsetY = scope.pages[1].dy;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }


                    scope.overlayCScale = scope.backgroundScale;

                    scope.draw_compare(scalechanged);


                }else if (scope.oisvector){
                    scope.backgroundScale = (scope.pages[1].VectorPageObj.width * scope.pages[1].dscalevector) / (scope.pages[0].VectorPageObj.width);
                    scope.backgroundScale *= scope.scaleratio;
                    scope.overlayScale = scope.pages[1].dscalevector;

                    scope.backgroundWidth = scope.pages[0].VectorPageObj.width * scope.backgroundScale;
                    scope.backgroundHeigth = scope.pages[0].VectorPageObj.height * scope.backgroundScale;


                    scope.overlayCScale = scope.backgroundScale;
                    scope.overlayOffsetX = scope.pages[1].dxvector;
                    scope.overlayOffsetY = scope.pages[1].dyvector;

                    if(scope.OffsetX != 0){
                        scope.OffsetX *= scope.overlayScale;
                    }

                    if(scope.OffsetY != 0){
                        scope.OffsetY *= scope.overlayScale;
                    }


                    scope.draw_compare(scalechanged);
                }

            }


        };

        //OpenFiles[OpenFiles.length-2].Drawmarkup = false;
        //OpenFiles[OpenFiles.length-1].Drawmarkup = false;

        this.invertpdf = function(){
            if(scope.compareMode == 0){
                if(scope.bispdf){
                    scope.pages[0].invertpdf(1);
                    bbginverted = true;

                }

                if(scope.oispdf){
                    scope.pages[1].invertpdf(2);
                    bovinverted = true;
                }

            }else{
                if(scope.bispdf){
                    scope.pages[0].transparentpdf(1);
                    bbginverted = true;
                }

                if(scope.oispdf){
                    scope.pages[1].transparentpdf(2);
                    bovinverted = true;
                }

            }

            if(scope.bispdf && scope.oispdf){
                if(bbginverted && bovinverted){
                    scope.draw_compare(true);
                    bbginverted = false;
                    bovinverted = false;
                }

            }else{
                scope.draw_compare(true);
            }

            scope.scaleToBackground(false);

        };

        this.invertimages = function(){

            if(scope.compareMode == 0){
                if(scope.bisimage){
                    scope.pages[0].invert(1);
                }
                if(scope.oisimage){
                    scope.pages[1].invert(2);
                }

            }else{
                if(scope.bisimage){
                    scope.pages[0].transparentimage(1);
                }
                if(scope.oisimage){
                    scope.pages[1].transparentimage(2);
                }

            }

        };


        this.SetActive = function () {

            //setSmoothingEnabled(false);
            documentcompare = true;
            scope.isActiveDoc = true;
            scope.bActive = true;

            this.pages[0].backupScaleAndOffset();
            this.pages[1].backupScaleAndOffset();

            scope.pages[1].DocRef.Drawmarkup = false;
            scope.pages[0].DocRef.Drawmarkup = false;

            scope.pages[0].usedincomposite = true;
            scope.pages[1].usedincomposite = true;

            scope.pages[0].isbackground = true;
            scope.pages[0].isoverlay = false;

            scope.pages[1].isbackground = false;
            scope.pages[1].isoverlay = true;

            if (scope.pages[0].VectorPageObj != undefined){
                scope.pages[0].VectorPageObj.docompare = true;
            }

            if (scope.pages[1].VectorPageObj != undefined){
                scope.pages[1].VectorPageObj.docompare = true;
            }
            //this.disableMenu = true;

            scope.invertimages();
            scope.invertpdf();
            /*if(scope.bisimage){
                scope.pages[0].invert(1);
            }
            if(scope.oisimage){
                scope.pages[1].invert(2);
            }*/


            DocObj = OpenFiles[scope.pages[1].DocRef.fileindex];
            DocObj.SetActive(scope);

            scope.draw_compare(true);
            //console.log('setactive');

            var stateobj = {
                iscompare:documentcompare,
                numOpenFiles:OpenFiles.length,
                isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                numpages:DocObj.pages.length,
                currentpage:DocObj.getcurPage(),
                activefile : DocObj.bActive,
                disableMenu: true
            };

            if (RxCore_GUI_State != undefined) {
                RxCore_GUI_State.setGUIState(stateobj);
            }

            var pagingobject = {
                numpages:DocObj.pages.length,
                currentpage:DocObj.getcurPage()
            };

            if(RxCore_GUI_Page != undefined){
                RxCore_GUI_Page.pageEvent(pagingobject);
            }


        };

        this.Suspend = function () {
            scope.isActiveDoc = false;
            if (scope.pages[0].VectorPageObj == undefined){
                scope.pages[0].VectorPageObj.docompare = false;
            }

            if (scope.pages[1].VectorPageObj == undefined){
                scope.pages[1].VectorPageObj.docompare = false;
            }

            if(scope.bisimage){
                scope.pages[0].resetimage();
            }
            if(scope.oisimage){
                scope.pages[1].resetimage();
            }


        };

        this.Close = function () {
            scope.pages[1].DocRef.Drawmarkup = true;
            scope.pages[0].DocRef.Drawmarkup = true;

            scope.pages[0].usedincomposite = false;
            scope.pages[0].compositereference = undefined;
            scope.pages[0].isbackground = false;
            scope.pages[0].isoverlay = false;

            if (scope.pages[0].VectorPageObj != undefined){
                scope.pages[0].VectorPageObj.docompare = false;
            }

            scope.pages[1].usedincomposite = false;
            scope.pages[1].compositereference = undefined;
            scope.pages[1].isbackground = false;
            scope.pages[1].isoverlay = false;
            if (scope.pages[1].VectorPageObj != undefined){
                scope.pages[1].VectorPageObj.docompare = false;
            }

            if(scope.bisimage){
                scope.pages[0].resetimage();
            }
            if(scope.oisimage){
                scope.pages[1].resetimage();
            }

            scope.isActiveDoc = false;

        };

        this.setdistance = function(dist,offset,pwidth){
            scope.nudgeScale(2);

            if (scope.scaleindex == 0){

                scope.backgroundMScale = dist / pwidth;
                scope.overlayAlOffsetXunscaled = offset.x;
                scope.overlayAlOffsetYunscaled = offset.y;


                if (scope.bispdf){
                    var pdfscale = scope.bgpagecanvas.width / scope.pages[0].pdfpagewidth;
                    scope.backgroundAlOffsetX = offset.x * pdfscale;
                    scope.backgroundAlOffsetY = offset.y * pdfscale;

                }else{
                    scope.backgroundAlOffsetX = offset.x * scope.backgroundScale;
                    scope.backgroundAlOffsetY = offset.y * scope.backgroundScale;

                }


                if(RxCore_GUI_CompareAlign != undefined){
                    RxCore_GUI_CompareAlign.AlignComplete(1);
                }

                scope.scaleindex = 1;

                scope.pages[scope.scaleindex].usedincomposite = false;
                RxCore_setActiveFile(scope.pages[scope.scaleindex].DocRef.fileindex);
                scope.pages[scope.scaleindex].enableSnap(true);
                set_tool('overlayscale', {p1 : scope});
                //tool = new tools['overlayscale'](scope);


            }else{
                if(scope.oispdf){
                    pdfscale = scope.ovpagecanvas.width / scope.pages[1].pdfpagewidth;
                    scope.overlayAlOffsetX = offset.x * pdfscale;
                    scope.overlayAlOffsetY = offset.y * pdfscale;

                }else{
                    scope.overlayAlOffsetX = offset.x * scope.overlayScale;
                    scope.overlayAlOffsetY = offset.y * scope.overlayScale;

                }

                scope.overlayMScale = (dist / pwidth) / scope.backgroundMScale;

                if(scope.oisimage){

                    scope.scaleratio = scope.overlayMScale;

                }else{
                    scope.scaleratio = scope.overlayMScale;
                }

                if(RxCore_GUI_CompareAlign != undefined){
                    RxCore_GUI_CompareAlign.AlignComplete(2);
                }


                scope.OffsetX = -((scope.overlayAlOffsetX) - (scope.backgroundAlOffsetX*scope.scaleratio));
                scope.OffsetY = -((scope.overlayAlOffsetY) - (scope.backgroundAlOffsetY*scope.scaleratio));


                scope.pages[0].usedincomposite = true;
                scope.pages[1].usedincomposite = true;
                DeactivateAll();
                scope.SetActive();
                scope.scaleindex = 0;
                set_tool('markupedit', {p1 : false});

                scope.scaleToBackground(true);


            }


        };



        this.setColors = function(bgColor,fgColor){
            scope.backgroundColor = bgColor;
            scope.overlayColor = fgColor;
            scope.invertimages();
            scope.draw_compare(true);

            if (RxCore_GUI_CompareDiag != undefined) {
                RxCore_GUI_CompareDiag.CompareDialog();
            }


        };

        this.getColors = function(){

            return {
                bg:scope.backgroundColor,
                fg:scope.overlayColor
            };


        };



        this.setcomparescale = function(scalearray){

            scope.nudgeScale(2);
            scope.resetCompare();
            //scope.OffsetX = 0;
            //scope.OffsetY = 0;

            //scope.initialScale();
            //scope.renderPDFscale();

            //scope.scaleToBackground(true);

            //var curScopeoffsetX = scope.OffsetX;
            //var curScopeoffsetY = scope.OffsetY;


            for (var i = 0;i<scalearray.length;i++){

                if(i == 0){
                    var bgangle = scalearray[i].angle;

                    scope.backgroundMScale = scalearray[i].dist / scalearray[i].pwidth;

                    if (scope.bispdf){
                        var pdfscale = scope.bgpagecanvas.width / scope.pages[0].pdfpagewidth;
                        //var pdfscale = scope.bgpagecanvas.width / scalearray[i].pwidth;

                        pdfscale *= scope.overlayCScale;
                        scope.backgroundAlOffsetX = scalearray[i].offset.x * pdfscale;
                        scope.backgroundAlOffsetY = scalearray[i].offset.y * pdfscale;

                        scope.backgroundAlOffsetXunscaled = scalearray[i].offset.x;
                        scope.backgroundAlOffsetYunscaled = scalearray[i].offset.y;


                        //scope.backgroundAlOffsetX /= scope.scaleratio;
                        //scope.backgroundAlOffsetY /= scope.scaleratio;


                        /*context.lineWidth = 3;
                        context.strokeStyle = 'red';
                        context.strokeRect(scalearray[i].offset.x - 10, scalearray[i].offset.y - 10, 20, 20);*/

                        var bovroffsetx = scope.backgroundAlOffsetX + scope.overlayOffsetX;
                        var bovroffsety = scope.backgroundAlOffsetY + scope.overlayOffsetY;

                        var snsbovroffsetx = scope.backgroundAlOffsetX;
                        var snsbovroffsety = scope.backgroundAlOffsetY;


                        //var centerx = (scope.bgpagecanvas.width * 0.5) + scope.overlayOffsetX;
                        //var centery = (scope.bgpagecanvas.height * 0.5) + scope.overlayOffsetY;

                        /*context.lineWidth = 3;
                        context.strokeStyle = 'blue';
                        context.strokeRect(bovroffsetx - 10, bovroffsety - 10, 20, 20);

                        context.lineWidth = 3;
                        context.strokeStyle = 'yellow';
                        context.strokeRect(scope.overlayOffsetX - 10, scope.overlayOffsetY - 10, 20, 20);*/




                    }else{
                        scope.backgroundAlOffsetX = scalearray[i].offset.x * scope.backgroundScale;
                        scope.backgroundAlOffsetY = scalearray[i].offset.y * scope.backgroundScale;

                    }

                }else{
                    var fgangle = scalearray[i].angle;

                    scope.overlayAlOffsetXunscaled = scalearray[i].offset.x;
                    scope.overlayAlOffsetYunscaled = scalearray[i].offset.y;

                    scope.overlayMScale = (scalearray[i].dist / scalearray[i].pwidth) / scope.backgroundMScale;

                    var boffsetnewscalex = scope.backgroundAlOffsetX * scope.overlayMScale;
                    var boffsetnewscaley = scope.backgroundAlOffsetY * scope.overlayMScale;
                    boffsetnewscalex += scope.overlayOffsetX;
                    boffsetnewscaley += scope.overlayOffsetY;



                    if(scope.oispdf){

                        /*context.lineWidth = 3;
                        context.strokeStyle = 'black';
                        context.strokeRect(boffsetnewscalex - 10, boffsetnewscaley - 10, 20, 20);*/

                        pdfscale = scope.ovpagecanvas.width / scope.pages[1].pdfpagewidth;



                        /*context.lineWidth = 3;
                        context.strokeStyle = 'red';
                        context.strokeRect(scalearray[i].offset.x - 10, scalearray[i].offset.y - 10, 20, 20);*/

                        scope.overlayAlOffsetX = (scalearray[i].offset.x * pdfscale);
                        scope.overlayAlOffsetY = (scalearray[i].offset.y * pdfscale);

                        //scope.overlayAlOffsetX += scope.OffsetX;
                        //scope.overlayAlOffsetY += scope.OffsetY;

                        var ovroffsetx = scope.overlayAlOffsetX + scope.overlayOffsetX + scope.OffsetX;
                        var ovroffsety = scope.overlayAlOffsetY + scope.overlayOffsetY + scope.OffsetY;

                        var snsovroffsetx = scope.overlayAlOffsetX + scope.OffsetX;
                        var snsovroffsety = scope.overlayAlOffsetY + scope.OffsetY;

                        //scope.overlayAlOffsetX = scalearray[i].offset.x * scope.overlayMScale;
                        //scope.overlayAlOffsetY = scalearray[i].offset.y * scope.overlayMScale;

                        /*context.lineWidth = 3;
                        context.strokeStyle = 'red';
                        context.strokeRect(ovroffsetx - 10, ovroffsety - 10, 20, 20);*/


                        /*context.lineWidth = 3;
                        context.strokeStyle = 'blue';
                        context.strokeRect(scope.overlayAlOffsetX - 10, scope.overlayAlOffsetY - 10, 20, 20);*/


                    }else{
                        scope.overlayAlOffsetX = scalearray[i].offset.x * scope.overlayScale;
                        scope.overlayAlOffsetY = scalearray[i].offset.y * scope.overlayScale;

                    }



                    if(scope.oisimage){

                        scope.scaleratio = scope.overlayMScale;

                    }else{
                        scope.scaleratio = scope.overlayMScale;
                    }

                    scope.OffsetX = -((scope.overlayAlOffsetX) - (scope.backgroundAlOffsetX*scope.scaleratio));
                    scope.OffsetY = -((scope.overlayAlOffsetY) - (scope.backgroundAlOffsetY*scope.scaleratio));

                    scope.AlignOffsetBackup.x = scope.OffsetX;
                    scope.AlignOffsetBackup.y = scope.OffsetY;
                    scope.AlignOffsetBackup.bgcanvwidth = scope.bgpagecanvas.width;
                    //var pdfscale = scope.bgpagecanvas.width / scope.pages[0].pdfpagewidth;

                    //console.log('Offsets :', scope.OffsetX, scope.OffsetY);
                    //var diffx = snsbovroffsetx - snsovroffsetx;
                    //var diffy = snsbovroffsety - snsovroffsety;
                    //console.log('Diffscurscale :', diffx, diffy);



                    /*if (scope.OffsetX == 0 && scope.OffsetY == 0){
                    }else{
                        var diffx = snsbovroffsetx - snsovroffsetx;
                        var diffy = snsbovroffsety - snsovroffsety;
                        scope.OffsetX += diffx;
                        scope.OffsetY += diffy;
                    }*/



                }//end else


            }//end for

            scope.fgdrawangle = bgangle - fgangle;

            scope.scaleToBackground(true);
        };


        this.nudgeRotate = function(clockwise){
            //0.01745329252
            if(clockwise){
                scope.fgdrawangle -= 0.001;
            }else{
                scope.fgdrawangle += 0.001;
            }
            scope.bnudgeangleused = true;
            scope.draw_compare(true);

        };

        this.nudgeScale = function(updown){

            var onepermillescale = scope.overlayScale / 5000;

            /*0 - up
            1 - down
            2 - reset*/

            switch(updown){
                case  0 :
                    scope.nudgeScalefactor += onepermillescale;
                    break;
                case 1 :
                    scope.nudgeScalefactor -= onepermillescale;
                    break;
                case 2 :
                    scope.nudgeScalefactor = 0;

            }

            scope.draw_compare(true);


        };
        this.nudgeoffset = function(direction){

            /*0 - left
            1 - right
            2 - up
            3 - down*/

            switch(direction){
              case 0 :
                  scope.OffsetX += 0.1;
                  break;
              case 1 :
                  scope.OffsetX -= 0.1;
                  break;
              case 2 :
                  scope.OffsetY -= 0.1;
                  break;
              case 3 :
                  scope.OffsetY += 0.1;
                  break;
          }

            scope.draw_compare(true);

        };

        this.scalecompare = function(){
            scope.pages[scope.scaleindex].usedincomposite = false;

            RxCore_setActiveFile(scope.pages[scope.scaleindex].DocRef.fileindex);
            scope.pages[scope.scaleindex].enableSnap(true);

            if(RxCore_GUI_CompareAlign != undefined){
                RxCore_GUI_CompareAlign.AlignComplete(0);
            }
            set_tool('overlayscale', {p1 : scope});
            //tool = new tools['overlayscale'](scope);

            //RxCore_setActiveFile(indx);


        };

        this.getwidthheight = function(){
            var endx = 0;
            var endy = 0;
            var endxo = 0;
            var endyo = 0;
            var endxb = 0;
            var endyb = 0;
            var ovcover = false;


            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;


            if(scope.bispdf){
                endxb = scope.bgpagecanvas.width * scope.overlayCScale;
                endyb = scope.bgpagecanvas.height * scope.overlayCScale;


            }else if(scope.bisimage){
                var curimage = scope.pages[0].currentimage;
                var bgscale = scope.overlayCScale / scope.pages[0].bitmapratio;

                switch (curimage) {
                    case 0:
                        endxb = scope.pages[0].MainImageWidth * scope.overlayCScale;
                        endyb = scope.pages[0].MainImageHeight * scope.overlayCScale;

                        break;
                    case 1:
                        endxb = scope.pages[0].SmallImageWidth * bgscale;
                        endyb = scope.pages[0].SmallImageHeight * bgscale;

                        //
                        break;

                }
            }else if(scope.bisdvector){
                endxb = scope.pages[0].VectorPageObj.width * scope.overlayCScale;
                endyb = scope.pages[0].VectorPageObj.height * scope.overlayCScale;


            }

            if(scope.oispdf){
                endxo = scope.ovpagecanvas.width * overlayscalenudge;
                endyo = scope.ovpagecanvas.height * overlayscalenudge;


            }else if (scope.oisimage){
                curimage = scope.pages[1].currentimage;

                var ovscale = overlayscalenudge / scope.pages[1].bitmapratio;
                switch (curimage) {
                    case 0:
                        endxo = scope.pages[1].MainImageWidth * overlayscalenudge;
                        endyo = scope.pages[1].MainImageHeight * overlayscalenudge;
                        break;
                    case 1:
                        //
                        endxo = scope.pages[1].SmallImageWidth * ovscale;
                        endyo = scope.pages[1].SmallImageHeight * ovscale;

                        break;
                }



            }else if (scope.oisvector){
                endxo = scope.pages[1].VectorPageObj.width * overlayscalenudge;
                endyo = scope.pages[1].VectorPageObj.height * overlayscalenudge;

            }
            endx = Math.max(endxo,endxb);
            endy = Math.max(endyo,endyb);

            if (endx == endxo && endy == endyo){
                ovcover = true;
            }

            return {x : endx,y : endy, ovcover : ovcover};

        };

        this.draw_image = function (clear) {

            if (!scope.bisimage && !scope.oisimage) {
                return;
            }

            if(scope.bisimage){
                var curimage = scope.pages[0].currentimage;
            }else if(scope.oisimage){
                curimage = scope.pages[1].currentimage;
            }

            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;
            /*if (clear) {
                contexto.fillStyle = "rgb(62,62,62)";
                contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            }*/

            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);

            //var drawscale = this.pages[1].dscale / scope.overlayScale;
            //var drawscaleext = this.pages[1].dscaleextent / scope.overlayScale;
            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

            switch (curimage) {
                case 0:
                    var bgalignX = scope.overlayOffsetX + (scope.overlayAlOffsetXunscaled * overlayscalenudge);
                    var bgalignY = scope.overlayOffsetY + (scope.overlayAlOffsetYunscaled * overlayscalenudge);


                    var otx = scope.overlayOffsetX + (scope.backgroundWidth / 2);
                    var oty = scope.overlayOffsetY + (scope.backgroundHeigth / 2);


                    var rotpoint = rotate_pointrad({x:bgalignX,y : bgalignY},otx,oty,-scope.fgdrawangle);
                    var rotoffsetX = rotpoint.x - bgalignX;
                    var rotoffsetY = rotpoint.y - bgalignY;

                    if (this.pages[1].drotation == 0) {
                        contexto.save();

                        if (scope.bisimage){
                            contexto.globalCompositeOperation = 'source-over';
                            contexto.drawImage(scope.pages[0].largeimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].MainImageWidth * scope.overlayCScale, scope.pages[0].MainImageHeight * scope.overlayCScale);
                        }
                        if (scope.oisimage){
                            if(bShowDiffonly){

                                contexto.globalCompositeOperation = szdrawmode;
                            }else{
                                contexto.globalCompositeOperation = 'darken';
                            }

                            if (Math.abs(scope.fgdrawangle) > 0.02 || scope.bnudgeangleused){
                                contexto.save();
                                contexto.translate(otx, oty);
                                contexto.rotate(-scope.fgdrawangle);
                                contexto.translate(-otx, -oty);

                                var offsetX = (scope.overlayOffsetX + scope.OffsetX) - rotoffsetX;
                                var offsetY = (scope.overlayOffsetY + scope.OffsetY) - rotoffsetY;

                                contexto.drawImage(scope.pages[1].largeimagecnv, offsetX, offsetY, scope.pages[1].MainImageWidth * overlayscalenudge, scope.pages[1].MainImageHeight * overlayscalenudge);

                                contexto.restore();
                                scope.bnudgeangleused = false;

                            }else{
                                contexto.drawImage(scope.pages[1].largeimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].MainImageWidth * overlayscalenudge, scope.pages[1].MainImageHeight * overlayscalenudge);

                            }

                        }
                        contexto.restore();

                    } else {
                        contexto.save();
                        contexto.translate(tx, ty);
                        contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                        contexto.translate(-tx, -ty);
                        if (scope.bisimage){
                            contexto.globalCompositeOperation = 'source-over';
                            contexto.drawImage(scope.pages[0].largeimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].MainImageWidth * scope.overlayCScale, scope.pages[0].MainImageHeight * scope.overlayCScale);
                        }
                        if (scope.oisimage){

                            if(bShowDiffonly){
                                contexto.globalCompositeOperation = szdrawmode;
                            }else{
                                contexto.globalCompositeOperation = 'darken';

                            }


                            contexto.drawImage(scope.pages[1].largeimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].MainImageWidth * overlayscalenudge, scope.pages[1].MainImageHeight * overlayscalenudge);

                        }


                        contexto.restore();

                    }
                    break;
                case 1:
                    var bgscale = scope.overlayCScale / scope.pages[0].bitmapratio;
                    var ovscale = overlayscalenudge / scope.pages[1].bitmapratio;
                    bgalignX = scope.overlayOffsetX + (scope.overlayAlOffsetXunscaled * overlayscalenudge);
                    bgalignY = scope.overlayOffsetY + (scope.overlayAlOffsetYunscaled * overlayscalenudge);

                    otx = scope.overlayOffsetX + (scope.backgroundWidth / 2);
                    oty = scope.overlayOffsetY + (scope.backgroundHeigth / 2);


                    rotpoint = rotate_pointrad({x:bgalignX,y : bgalignY},otx,oty,-scope.fgdrawangle);
                    rotoffsetX = rotpoint.x - bgalignX;
                    rotoffsetY = rotpoint.y - bgalignY;


                    if (this.pages[1].drotation == 0) {
                        contexto.save();
                        //contexto.drawImage(this.smallimagecnv, this.dxextent, this.dyextent, this.SmallImageWidth * this.dscaleextent, this.SmallImageHeight * this.dscaleextent);
                        if (scope.bisimage){
                            contexto.globalCompositeOperation = 'source-over';
                            contexto.drawImage(scope.pages[0].smallimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].SmallImageWidth * bgscale, scope.pages[0].SmallImageHeight * bgscale);


                        }
                        if (scope.oisimage){
                            if(bShowDiffonly){
                                contexto.globalCompositeOperation = szdrawmode;
                            }else{
                                contexto.globalCompositeOperation = 'darken';
                            }


                            if (Math.abs(scope.fgdrawangle) > 0.02 || scope.bnudgeangleused){
                                contexto.save();
                                contexto.translate(otx, oty);
                                contexto.rotate(-scope.fgdrawangle);
                                contexto.translate(-otx, -oty);
                                offsetX = (scope.overlayOffsetX + scope.OffsetX) - rotoffsetX;
                                offsetY = (scope.overlayOffsetY + scope.OffsetY) - rotoffsetY;
                                contexto.drawImage(scope.pages[1].smallimagecnv, offsetX, offsetY, scope.pages[1].SmallImageWidth * ovscale, scope.pages[1].SmallImageHeight * ovscale);
                                contexto.restore();
                                scope.bnudgeangleused = false;
                            }else{
                                contexto.drawImage(scope.pages[1].smallimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].SmallImageWidth * ovscale, scope.pages[1].SmallImageHeight * ovscale);
                            }


                        }

                        contexto.restore();
                    } else {
                        contexto.save();
                        contexto.translate(tx, ty);
                        contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                        contexto.translate(-tx, -ty);
                        //contexto.drawImage(this.smallimagecnv, this.dxextent, this.dyextent, this.SmallImageWidth * this.dscaleextent, this.SmallImageHeight * this.dscaleextent);
                        if (scope.bisimage){
                            contexto.globalCompositeOperation = 'source-over';
                            contexto.drawImage(scope.pages[0].smallimagecnv, scope.overlayOffsetX, scope.overlayOffsetY, scope.pages[0].SmallImageWidth * bgscale, scope.pages[0].SmallImageHeight * bgscale);


                        }
                        if (scope.oisimage){
                            if(bShowDiffonly){
                                contexto.globalCompositeOperation = szdrawmode;
                            }else{
                                contexto.globalCompositeOperation = 'darken';
                            }



                            contexto.drawImage(scope.pages[1].smallimagecnv, ovrlOffsetX, ovrlOffsetY, scope.pages[1].SmallImageWidth * ovscale, scope.pages[1].SmallImageHeight * ovscale);


                        }


                        contexto.restore();

                    }

                    break;
            }

        };

        this.draw_vector = function(refresh){



            this.bisdvector = (scope.pages[0].VectorPageObj != undefined);
            this.oisvector = (scope.pages[1].VectorPageObj != undefined);


            if (!scope.bisdvector && !scope.oisvector) {
                return;
            }

            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;

            //contexto.save();
            //contexto.fillStyle = "rgb(62,62,62)";
            //contexto.fillStyle = "rgb(160,160,160)";
            //contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);
            //documentopen = true;

            var bgalignX = scope.overlayOffsetX + (scope.overlayAlOffsetXunscaled * overlayscalenudge);
            var bgalignY = scope.overlayOffsetY + (scope.overlayAlOffsetYunscaled * overlayscalenudge);


            var otx = scope.overlayOffsetX + (scope.backgroundWidth / 2);
            var oty = scope.overlayOffsetY + (scope.backgroundHeigth / 2);

            //var drawscale = this.pages[1].dscalevector / scope.overlayScale;
            //context,scalefactor,offsetx,offsety
            //this.dxvector = dx;
            //this.dyvector = dy;
            //this.dscalevector = dscale;

            var rotpoint = rotate_pointrad({x:bgalignX,y : bgalignY},otx,oty,-scope.fgdrawangle);
            var rotoffsetX = rotpoint.x - bgalignX;
            var rotoffsetY = rotpoint.y - bgalignY;


            if (this.pages[1].drotation == 0) {
                if (scope.bisdvector){

                    scope.pages[0].VectorPageObj.drawallcmpre(contexto, scope.overlayCScale, scope.overlayOffsetX, scope.overlayOffsetY, refresh, this.backgroundColor, true, scope.compareMode);
                }

                if (scope.oisvector){
                    if (Math.abs(scope.fgdrawangle) > 0.02 || scope.bnudgeangleused){
                        contexto.save();
                        contexto.translate(otx, oty);
                        contexto.rotate(-scope.fgdrawangle);
                        contexto.translate(-otx, -oty);

                        var offsetX = (scope.overlayOffsetX + scope.OffsetX) - rotoffsetX;
                        var offsetY = (scope.overlayOffsetY + scope.OffsetY) - rotoffsetY;

                        scope.pages[1].VectorPageObj.drawallcmpre(contexto, overlayscalenudge, offsetX, offsetY, refresh, this.overlayColor, false, scope.compareMode);

                        contexto.restore();
                        scope.bnudgeangleused = false;

                    }else{

                        scope.pages[1].VectorPageObj.drawallcmpre(contexto, overlayscalenudge, scope.overlayOffsetX + scope.OffsetX, scope.overlayOffsetY + scope.OffsetY, refresh, this.overlayColor, false, scope.compareMode);
                    }


                }

            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);
                if (scope.bisdvector){
                    this.pages[0].VectorPageObj.drawallcmpre(contexto, scope.overlayCScale, scope.overlayOffsetX, scope.overlayOffsetY, refresh, this.backgroundColor, true,scope.compareMode );


                }

                if (scope.oisvector){
                    //this.pages[1].VectorPageObj.drawallcmpre(contexto, this.pages[1].dscalevector, this.pages[1].dxvector, this.pages[1].dyvector, refresh, this.overlayColor, false);
                    if (Math.abs(scope.fgdrawangle) > 0.02 || scope.bnudgeangleused){
                        contexto.save();
                        contexto.translate(otx, oty);
                        contexto.rotate(-scope.fgdrawangle);
                        contexto.translate(-otx, -oty);

                        offsetX = (scope.overlayOffsetX + scope.OffsetX) - rotoffsetX;
                        offsetY = (scope.overlayOffsetY + scope.OffsetY) - rotoffsetY;

                        scope.pages[1].VectorPageObj.drawallcmpre(contexto, overlayscalenudge, offsetX, offsetY, refresh, this.overlayColor, false, scope.compareMode);

                        contexto.restore();
                        scope.bnudgeangleused = false;


                    }else{
                        this.pages[1].VectorPageObj.drawallcmpre(contexto, overlayscalenudge, scope.overlayOffsetX + scope.OffsetX, scope.overlayOffsetY + scope.OffsetY, refresh, this.overlayColor, false, scope.compareMode);
                    }


                }

                contexto.restore();

            }

            //contexto.restore();
        };

        this.draw_canvas = function (clear) {

            if (!scope.bispdf && !scope.oispdf) {
                return;
            }

            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);

            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;
            //documentopen = true;
            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

            if(scope.oispdf){
                var pdfscale = scope.ovpagecanvas.width / scope.pages[1].pdfpagewidth;
            }else{
                pdfscale = scope.overlayScale;
            }


            var bgalignX = scope.overlayOffsetX + (scope.overlayAlOffsetXunscaled * pdfscale);
            var bgalignY = scope.overlayOffsetY + (scope.overlayAlOffsetYunscaled * pdfscale);

            if (scope.bispdf){
                var otx = scope.overlayOffsetX + (scope.bgpagecanvas.width / 2);
                var oty = scope.overlayOffsetY + (scope.bgpagecanvas.height / 2);
            }else{
                otx = scope.overlayOffsetX + (scope.backgroundWidth / 2);
                oty = scope.overlayOffsetY + (scope.backgroundHeigth / 2);

            }



            var otxpnt = ovrlOffsetX + (scope.overlayAlOffsetXunscaled * pdfscale);
            var otypnt = ovrlOffsetY + (scope.overlayAlOffsetYunscaled * pdfscale);

            /*context.lineWidth = 3;
              context.strokeStyle = 'blue';
              context.strokeRect(bovroffsetx - 10, bovroffsety - 10, 20, 20);*/

            var rotpoint = rotate_pointrad({x:bgalignX,y : bgalignY},otx,oty,-scope.fgdrawangle);
            //console.log(scope.fgdrawangle*(180/Math.PI));
            var rotoffsetX = rotpoint.x - bgalignX;
            var rotoffsetY = rotpoint.y - bgalignY;

            if (this.pages[1].drotation == 0) {

                contexto.save();

                if (scope.bispdf){
                    contexto.globalCompositeOperation = 'source-over';
                    contexto.drawImage(scope.bgpagecanvas, scope.overlayOffsetX, scope.overlayOffsetY, scope.bgpagecanvas.width * scope.overlayCScale, scope.bgpagecanvas.height * scope.overlayCScale);
                }
                if (scope.oispdf){
                    if(bShowDiffonly){
                        contexto.globalCompositeOperation = szdrawmode;
                    }else{
                        contexto.globalCompositeOperation = 'darken';
                    }


                    if (Math.abs(scope.fgdrawangle) > 0.02 || scope.bnudgeangleused){
                        contexto.save();
                        contexto.translate(otxpnt, otypnt);
                        contexto.rotate(scope.fgdrawangle);
                        contexto.translate(-otxpnt, -otypnt);
                        //var offsetX = (scope.overlayOffsetX + scope.OffsetX) - rotoffsetX;
                        //var offsetY = (scope.overlayOffsetY + scope.OffsetY) - rotoffsetY;
                        //contexto.drawImage(scope.ovpagecanvas, offsetX, offsetY, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);
                        //contexto.drawImage(scope.ovpagecanvas, 0, 0, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);
                        contexto.drawImage(scope.ovpagecanvas, ovrlOffsetX, ovrlOffsetY, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);

                        /*context.lineWidth = 3;
                        context.strokeStyle = 'red';
                        context.strokeRect(ovrlOffsetX - 10, ovrlOffsetY - 10, 20, 20);

                        context.lineWidth = 3;
                        context.strokeStyle = 'blue';
                        context.strokeRect(otxpnt - 10, otypnt - 10, 20, 20);*/
                        contexto.restore();
                        scope.bnudgeangleused = false;


                    }else{
                        contexto.drawImage(scope.ovpagecanvas, ovrlOffsetX, ovrlOffsetY, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);
                    }

                }
                contexto.restore();


            } else {
                contexto.save();
                contexto.translate(tx, ty);
                contexto.rotate(this.pages[1].drotation * (Math.PI / 180));
                contexto.translate(-tx, -ty);
                if (scope.bispdf){
                    contexto.globalCompositeOperation = 'source-over';
                    contexto.drawImage(scope.bgpagecanvas, scope.overlayOffsetX, scope.overlayOffsetY, scope.bgpagecanvas.width * scope.overlayCScale, scope.bgpagecanvas.height * scope.overlayCScale);
                }
                if (scope.oispdf){
                    if(bShowDiffonly){
                        contexto.globalCompositeOperation = szdrawmode;
                    }else{
                        contexto.globalCompositeOperation = 'darken';
                    }


                    if (Math.abs(scope.fgdrawangle) > 0.02 || scope.bnudgeangleused){
                        /*contexto.translate(otx, oty);
                        contexto.rotate(-scope.fgdrawangle);
                        contexto.translate(-otx, -oty);*/
                        contexto.save();
                        contexto.translate(otxpnt, otypnt);
                        contexto.rotate(scope.fgdrawangle);
                        contexto.translate(-otxpnt, -otypnt);

                        //offsetX = (scope.overlayOffsetX + scope.OffsetX) - rotoffsetX;
                        //offsetY = (scope.overlayOffsetY + scope.OffsetY) - rotoffsetY;
                        //contexto.drawImage(scope.ovpagecanvas, offsetX, offsetY, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);
                        contexto.drawImage(scope.ovpagecanvas, ovrlOffsetX, ovrlOffsetY, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);
                        contexto.restore();
                        scope.bnudgeangleused = false;

                    }else{
                        contexto.drawImage(scope.ovpagecanvas, ovrlOffsetX, ovrlOffsetY, scope.ovpagecanvas.width * overlayscalenudge, scope.ovpagecanvas.height * overlayscalenudge);
                    }

                }

                contexto.restore();

            }


        };



        this.draw_compare = function (refresh) {
            if (!this.bActive) {
                return;

            }
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);

            contexto.save();
            contexto.fillStyle = displayBGColor;
            //contexto.fillStyle = "rgb(160,160,160)";
            contexto.fillRect(0, 0, canvasowidth, canvasoheight);
            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

            var compositestartx = Math.min(ovrlOffsetX, scope.overlayOffsetX);
            var compositestarty = Math.min(ovrlOffsetY, scope.overlayOffsetY);

            var compositeend = scope.getwidthheight();

            var compositeendx = Math.max(compositeend.x - scope.OffsetX, compositeend.x + scope.OffsetX);
            var compositeendy = Math.max(compositeend.y - scope.OffsetY, compositeend.y + scope.OffsetY);

            var centerx = compositestartx + (compositeend.x / 2);
            var centery = compositestarty + (compositeend.y / 2);

            /*if (Math.abs(scope.fgdrawangle) < 0.02){
                //we have rotation

                var rotpointul = rotate_pointrad({x:bgalignX,y : bgalignY},otx,oty,-scope.fgdrawangle);

            }*/


            if (scope.pages[1].drotation != 0){
                contexto.save();
                contexto.translate(centerx, centery);
                contexto.rotate(scope.pages[1].drotation * (Math.PI / 180));
                contexto.translate(-centerx, -centery);
                contexto.fillStyle = "rgb(255,255,255)";
                contexto.fillRect(compositestartx, compositestarty, compositeend.x, compositeend.y);
                contexto.restore();
            }else{
                if ((Math.abs(scope.fgdrawangle) > 0.02) && compositeend.ovcover) {
                    contexto.save();
                    contexto.translate(centerx, centery);
                    contexto.rotate(scope.fgdrawangle);
                    contexto.translate(-centerx, -centery);
                    contexto.fillStyle = "rgb(255,255,255)";
                    contexto.fillRect(compositestartx, compositestarty, compositeend.x, compositeend.y);
                    contexto.restore();
                }else{
                    contexto.fillStyle = "rgb(255,255,255)";
                    contexto.fillRect(compositestartx, compositestarty, compositeend.x, compositeend.y);

                }
                /*contexto.fillStyle = "rgb(255,255,255)";
                contexto.fillRect(compositestartx, compositestarty, compositeend.x, compositeend.y);
                contexto.strokeStyle = 'red';
                contexto.fillRect(centerx - 10, centery - 10, 20, 20);*/


            }



            if (scope.bisdvector){

                scope.draw_vector(refresh);
                scope.draw_image(refresh);
                scope.draw_canvas(refresh);

            }else if(scope.bisimage){
                scope.draw_image(refresh);
                scope.draw_vector(refresh);
                scope.draw_canvas(refresh);
            }else if(scope.bispdf){

                scope.draw_canvas(refresh);
                scope.draw_vector(refresh);
                scope.draw_image(refresh);
            }

            contexto.restore();


        };

        this.renderPDFscale = function(){

            if(scope.bispdf){
                scope.pages[0].queRenderCompareScale(0);
            }

            if(scope.oispdf){
                scope.pages[1].queRenderCompareScale(1);
            }


        };

        this.checkPDFmagnify = function(scale){

            if(scope.bispdf){
                scope.pages[0].renderPDFMagnify(scale);
            }

            if(scope.oispdf){
                scope.pages[1].renderPDFMagnify(scale);
            }


        };


        this.drawmagnify = function (mousepos,ctx,magnificationScale){
            if (!this.bActive) {
                return;
            }

            ctx.save();
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, magcanvas.width, magcanvas.height);

            if (scope.bisdvector){
                scope.draw_maginfyvector(mousepos,ctx,magnificationScale);
                scope.draw_maginfyimage(mousepos,ctx,magnificationScale);
                scope.draw_magnifycanvas(mousepos,ctx,magnificationScale);

            }else if(scope.bisimage){
                scope.draw_maginfyimage(mousepos,ctx,magnificationScale);
                scope.draw_maginfyvector(mousepos,ctx,magnificationScale);
                scope.draw_magnifycanvas(mousepos,ctx,magnificationScale);
            }else if (scope.bispdf){
                scope.draw_magnifycanvas(mousepos,ctx,magnificationScale);
                scope.draw_maginfyvector(mousepos,ctx,magnificationScale);
                scope.draw_maginfyimage(mousepos,ctx,magnificationScale);
            }

            ctx.restore();

        };

        this.draw_maginfyvector = function(mousepos,ctx,magnificationScale){

            this.bisdvector = (scope.pages[0].VectorPageObj != undefined);
            this.oisvector = (scope.pages[1].VectorPageObj != undefined);

            if (!scope.bisdvector && !scope.oisvector) {
                return;
            }
            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;

            if (scope.pages[1].drotation == 0) {
                var rectCenterX = (mousepos.x - ((magcanvas.width / 2)/magnificationScale));
                var rectCenterY = (mousepos.y - ((magcanvas.height / 2)/magnificationScale));

            }else{
                var rotpos = rotate_point(mousepos,(canvasowidth / 2),(canvasoheight / 2),(360 - scope.pages[1].drotation));
                rectCenterX = (rotpos.x - ((magcanvas.width / 2)/magnificationScale));
                rectCenterY = (rotpos.y - ((magcanvas.height / 2)/magnificationScale));

            }

            var tx = (magcanvas.width / 2);
            var ty = (magcanvas.height / 2);

            if (scope.bisdvector){
                //scope.overlayCScale, scope.overlayOffsetX, scope.overlayOffsetY

                var drawscale = scope.overlayCScale * magnificationScale;
                var xoffset =  -(rectCenterX) + (scope.overlayOffsetX); // - (thispage.dxvector + wscale);
                var yoffset =  -(rectCenterY) + (scope.overlayOffsetY);// - (thispage.dyvector + hscale);
                xoffset *= magnificationScale;
                yoffset *= magnificationScale;

                var pagenum = 0;
                var ovrlbackground = true;
                var drawcolor = scope.backgroundColor;

                if (scope.pages[1].drotation == 0) {
                    scope.pages[pagenum].VectorPageObj.drawallmagnifycmpre(ctx, drawscale, xoffset, yoffset,drawcolor,ovrlbackground);
                }else{
                    ctx.save();
                    ctx.translate(tx, ty);
                    ctx.rotate(scope.pages[1].drotation * (Math.PI / 180));
                    ctx.translate(-tx, -ty);
                    scope.pages[pagenum].VectorPageObj.drawallmagnifycmpre(ctx, drawscale, xoffset, yoffset,drawcolor,ovrlbackground);
                    ctx.restore();

                }

            }
            if (scope.oisvector){
                //scope.overlayScale, scope.overlayOffsetX + scope.OffsetX, scope.overlayOffsetY + scope.OffsetY
                drawscale = overlayscalenudge * magnificationScale;
                xoffset =  -(rectCenterX) + (scope.overlayOffsetX + scope.OffsetX); // - (thispage.dxvector + wscale);
                yoffset =  -(rectCenterY) + (scope.overlayOffsetY + scope.OffsetY);// - (thispage.dyvector + hscale);
                xoffset *= magnificationScale;
                yoffset *= magnificationScale;

                pagenum = 1;

                ovrlbackground = false;
                drawcolor = scope.overlayColor;

                if (scope.pages[1].drotation == 0) {
                    scope.pages[pagenum].VectorPageObj.drawallmagnifycmpre(ctx, drawscale, xoffset, yoffset,drawcolor,ovrlbackground);
                }else{
                    ctx.save();
                    ctx.translate(tx, ty);
                    ctx.rotate(scope.pages[1].drotation * (Math.PI / 180));
                    ctx.translate(-tx, -ty);
                    scope.pages[pagenum].VectorPageObj.drawallmagnifycmpre(ctx, drawscale, xoffset, yoffset,drawcolor,ovrlbackground);
                    ctx.restore();

                }

            }

        };

        this.draw_magnifycanvas = function(mousepos,ctx,magnificationScale){

            if (!scope.bispdf && !scope.oispdf) {
                return;
            }

            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;
            if (scope.pages[1].drotation == 0) {
                var rectCenterX = (mousepos.x - ((magcanvas.width / 2)/magnificationScale));
                var rectCenterY = (mousepos.y - ((magcanvas.height / 2)/magnificationScale));

            }else{
                var rotpos = rotate_point(mousepos,(canvasowidth / 2),(canvasoheight / 2),(360 - scope.pages[1].drotation.drotation));
                rectCenterX = (rotpos.x - ((magcanvas.width / 2)/magnificationScale));
                rectCenterY = (rotpos.y - ((magcanvas.height / 2)/magnificationScale));

            }

            var tx = (magcanvas.width / 2);
            var ty = (magcanvas.height / 2);

            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;


            if (scope.pages[1].drotation != 0) {


                ctx.save();
                ctx.translate(tx, ty);
                ctx.rotate(scope.pages[1].drotation * (Math.PI / 180));
                ctx.translate(-tx, -ty);


            }

            ctx.save();
            if (scope.bispdf){
                var drawscale = scope.overlayCScale * magnificationScale;
                var xoffset =  -(rectCenterX) + (scope.overlayOffsetX);
                var yoffset =  -(rectCenterY) + (scope.overlayOffsetY);
                xoffset *= magnificationScale;
                yoffset *= magnificationScale;

                ctx.globalCompositeOperation = 'source-over';
                ctx.drawImage(scope.pages[0].magnifycanvas, xoffset, yoffset);

            }
            if (scope.oispdf){
                drawscale = overlayscalenudge * magnificationScale;
                xoffset =  -(rectCenterX) + (ovrlOffsetX);
                yoffset =  -(rectCenterY) + (ovrlOffsetY);
                xoffset *= magnificationScale;
                yoffset *= magnificationScale;

                if(bShowDiffonly){
                    ctx.globalCompositeOperation = szdrawmode;
                }else{
                    ctx.globalCompositeOperation = 'darken';
                }






                ctx.drawImage(scope.pages[1].magnifycanvas, xoffset, yoffset);
            }
            ctx.restore();

            if (this.pages[1].drotation != 0) {
                ctx.restore();
            }

        };

        this.draw_maginfyimage = function(mousepos,ctx,magnificationScale){
            if (!scope.bisimage && !scope.oisimage) {
                return;
            }
            var overlayscalenudge = scope.overlayScale + scope.nudgeScalefactor;

            if (scope.pages[1].drotation == 0) {
                var rectCenterX = (mousepos.x - ((magcanvas.width / 2)/magnificationScale));
                var rectCenterY = (mousepos.y - ((magcanvas.height / 2)/magnificationScale));

            }else{
                var rotpos = rotate_point(mousepos,(canvasowidth / 2),(canvasoheight / 2),(360 - scope.pages[1].drotation.drotation));
                rectCenterX = (rotpos.x - ((magcanvas.width / 2)/magnificationScale));
                rectCenterY = (rotpos.y - ((magcanvas.height / 2)/magnificationScale));

            }

            var tx = (magcanvas.width / 2);
            var ty = (magcanvas.height / 2);

            //var drawscale = this.pages[1].dscale / scope.overlayScale;
            //var drawscaleext = this.pages[1].dscaleextent / scope.overlayScale;
            var ovrlOffsetX = scope.overlayOffsetX + scope.OffsetX;
            var ovrlOffsetY = scope.overlayOffsetY + scope.OffsetY;

            switch (scope.pages[1].currentimage) {

                case 0:

                    if (scope.pages[1].drotation != 0) {


                        ctx.save();
                        ctx.translate(tx, ty);
                        ctx.rotate(scope.pages[1].drotation * (Math.PI / 180));
                        ctx.translate(-tx, -ty);


                    }
                    ctx.save();
                    if (scope.bisimage){
                        var drawscale = scope.overlayCScale * magnificationScale;
                        var xoffset =  -(rectCenterX) + (scope.overlayOffsetX);
                        var yoffset =  -(rectCenterY) + (scope.overlayOffsetY);
                        xoffset *= magnificationScale;
                        yoffset *= magnificationScale;

                        ctx.globalCompositeOperation = 'source-over';
                        ctx.drawImage(scope.pages[0].largeimagecnv, xoffset, yoffset, scope.pages[0].MainImageWidth * drawscale, scope.pages[0].MainImageHeight * drawscale);

                    }
                    if (scope.oisimage){
                        drawscale = overlayscalenudge * magnificationScale;
                        xoffset =  -(rectCenterX) + (ovrlOffsetX);
                        yoffset =  -(rectCenterY) + (ovrlOffsetY);
                        xoffset *= magnificationScale;
                        yoffset *= magnificationScale;
                        if(bShowDiffonly){
                            ctx.globalCompositeOperation = szdrawmode;
                        }else{
                            ctx.globalCompositeOperation = 'darken';
                        }

                        ctx.drawImage(scope.pages[1].largeimagecnv, xoffset, yoffset, scope.pages[1].MainImageWidth * drawscale, scope.pages[1].MainImageHeight * drawscale);
                    }
                    ctx.restore();

                    if (this.pages[1].drotation != 0) {
                        ctx.restore();
                    }

                    break;
                case 1:
                    var bgscale = scope.overlayCScale / scope.pages[0].bitmapratio;
                    var ovscale = overlayscalenudge / scope.pages[1].bitmapratio;

                    if (scope.pages[1].drotation != 0) {

                        ctx.save();
                        ctx.translate(tx, ty);
                        ctx.rotate(scope.pages[1].drotation * (Math.PI / 180));
                        ctx.translate(-tx, -ty);

                    }

                    ctx.save();
                    if (scope.bisimage){
                        drawscale = bgscale * magnificationScale;
                        xoffset =  -(rectCenterX) + (scope.overlayOffsetX);
                        yoffset =  -(rectCenterY) + (scope.overlayOffsetY);
                        xoffset *= magnificationScale;
                        yoffset *= magnificationScale;

                        ctx.globalCompositeOperation = 'source-over';
                        ctx.drawImage(scope.pages[0].smallimagecnv, xoffset, yoffset, scope.pages[0].SmallImageWidth * drawscale, scope.pages[0].SmallImageHeight * drawscale);


                    }
                    if (scope.oisimage){
                        drawscale = ovscale * magnificationScale;
                        xoffset =  -(rectCenterX) + (ovrlOffsetX);
                        yoffset =  -(rectCenterY) + (ovrlOffsetY);
                        xoffset *= magnificationScale;
                        yoffset *= magnificationScale;

                        if(bShowDiffonly){
                            ctx.globalCompositeOperation = szdrawmode;
                        }else{
                            ctx.globalCompositeOperation = 'darken';
                        }


                        ctx.drawImage(scope.pages[1].smallimagecnv, xoffset, yoffset, scope.pages[1].SmallImageWidth * drawscale, scope.pages[1].SmallImageHeight * drawscale);


                    }

                    ctx.restore();

                    if (this.pages[1].drotation != 0) {
                        ctx.restore();
                    }

                    break;
            }


        };

    };



    function xhrProgress(evt) {
        if (evt.lengthComputable) {
            //var percentComplete = Math.round(evt.loaded * 100 / evt.total);
            //showDownloadDialog();
            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("show");
            }

            //document.getElementById('progressbar').value = Math.round(evt.loaded * 100 / evt.total);//percentComplete;//.toString() + '%';
            //if (document.getElementById('progressbar').value == 100){
            //document.getElementById('progressbar').value = 0;
            //hideDownloadDialog();

            //}
        } else {
            //document.getElementById('progressNumber').innerHTML = 'unable to compute';
        }
    }

    function PDFuploadProgress(ev) {

    }

    function ImageUploadComplete(ev) {
        //hideUploadDialog();
        if (RxCore_GUI_Upload != undefined) {
            RxCore_GUI_Upload.setUpload("hide");
        }

        if (ev.currentTarget.status == 200) {
            var xmlDoc = ev.currentTarget.responseXML;
            if (xmlDoc == null || xmlDoc.documentElement == null) {
                xmlDoc = $.parseXML(ev.currentTarget.responseText).documentElement;
            }
            var PDFFileUrl = xmlDoc.getElementsByTagName('File')[0].firstChild.nodeValue;
            var cachfolder = getURLPath(DocObj.FileNameSRC);
            PDFFileUrl = cachfolder + PDFFileUrl;

            if (Rxcore_GUI_exportComplete != undefined){
                Rxcore_GUI_exportComplete.loadComplete(PDFFileUrl);
            }


            //get pdf url here.
        } else if (this.status == 404) {
            alert("XML could not be found");
        } else if (this.status == 503) {
            alert("Server is down");
        }

    }

    function ImageUploadProgress(ev) {
        if (ev.lengthComputable) {
            //var percentComplete = Math.round(evt.loaded * 100 / evt.total);
            //showUploadDialog();
            if (RxCore_GUI_Upload != undefined) {
                RxCore_GUI_Upload.setUpload(Math.round(ev.loaded * 100 / ev.total));
            }

            /*document.getElementById('progressbar').value = Math.round(ev.loaded * 100 / ev.total); //percentComplete;//.toString() + '%';
            if (document.getElementById('progressbar').value == 100) {
                document.getElementById('progressbar').value = 0;
                //hideUploadDialog();

            }*/
        } else {
            //document.getElementById('progressNumber').innerHTML = 'unable to compute';
        }

    }

    function post3DImageData() {
        //CanvasSaveUrl

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        xhr.addEventListener("progress", ImageUploadProgress, false);
        xhr.addEventListener("load", ImageUploadComplete, false);
        //xhr.addEventListener("error", ImageuploadFailed, false);
        //xhr.addEventListener("abort", ImageuploadCanceled, false);

        xhr.upload.addEventListener("progress", ImageUploadProgress, false);

        var path = getPath(DocObj.OriginalURL);
        var file = getFileName(DocObj.OriginalURL);


        //var InageCreateURL = CanvasSaveUrl + "?" + path + "&" + file + "&" + "PDF&200";

        if(bUseCustomrelpath){
            var InageCreateURL = CanvasSaveUrl + "&" + path + "&" + file + "&" + "PDF&200";
        }else{
            InageCreateURL = CanvasSaveUrl + "?" + path + "&" + file + "&" + "PDF&200";
        }


        //var dataURL = canvas.toDataURL();
        //var canvas = document.getElementById("canvas");
        var dataURL = renderer.domElement.toDataURL();

        try {
            xhr.open('POST', InageCreateURL, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.send(dataURL);

    }

    function getUserInfo(){

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        try {
            xhr.open('GET', userInfoURL, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {
            if (this.status == 200) {
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }

                if (xmlDoc.getElementsByTagName('ID')[0] != undefined) {
                    signature = xmlDoc.getElementsByTagName('ID')[0].firstChild.nodeValue;
                }
                if (xmlDoc.getElementsByTagName('name')[0] != undefined) {
                    DisplayName = xmlDoc.getElementsByTagName('name')[0].firstChild.nodeValue;
                }
                if (xmlDoc.getElementsByTagName('color')[0] != undefined) {
                    markupcolor = xmlDoc.getElementsByTagName('color')[0].firstChild.nodeValue;
                }
                if (xmlDoc.getElementsByTagName('layer')[0] != undefined) {
                    markuplayer = xmlDoc.getElementsByTagName('layer')[0].firstChild.nodeValue;
                }

                if (xmlDoc.getElementsByTagName('canChangeLayer')[0] != undefined) {
                    bCanChangeLayer = (xmlDoc.getElementsByTagName('canChangeLayer')[0].firstChild.nodeValue == '1');
                }

                Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);

                if (RxCore_GUI_Users != undefined) {
                    RxCore_GUI_Users.setUserlist(Userlist, true);
                }

                /*
                 <ID>Demo</ID>
                 <name>Demo User</name>
                 <color>#ff0000</color>
                 <layer>5</layer>
                */

            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            }
        };

        xhr.send();
    }


    function exportFile(consolidateonly,format,UPI,paperSize,markupFlag){
        var params = {
            consolidateonly : consolidateonly,
            format : format,
            UPI : UPI,
            paperSize : paperSize,
            markupFlag : markupFlag,
            useRaster : false
        }

        exportFileSend(params);
    }

    function exportFileRaster(consolidateonly,format,UPI,paperSize,markupFlag){

        var params = {
            consolidateonly : consolidateonly,
            format : format,
            UPI : UPI,
            paperSize : paperSize,
            markupFlag : markupFlag,
            useRaster : true
        }

        exportFileSend(params);
    }

    function exportFileSend(params){
        var consolidateonly = params.consolidateonly;
        var format = params.format
        var UPI = params.UPI;
        var paperSize = params.paperSize;
        var markupFlag = params.markupFlag;
        //var bUseRaster = params.useRaster;
        var nUseRaster = params.useRaster ? "1" : "0";

        var curmarkup = 0;
        var savetime = new Date().getTime();
        var internalscale = 1;
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            post3DImageData();
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            internalscale = DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf;
        }


        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        xhr.upload.addEventListener("progress", PDFuploadProgress, false);


        var markupxml = createxmlmarkup(false, consolidateonly,true,signature, signature);
        //var markupxml = parseXML(markupxmltxt);


        var path = getPath(DocObj.OriginalURL);
        var file = getFileName(DocObj.OriginalURL);
        //WebClientSaveAs?filepath&filename&PDF&UPI

        if(bUseCustomrelpath){
            var PDFCreateURL = PDFExportURL + "&" + path + "&" + file + "&" + format + "&" + UPI + "&" + paperSize + "&" + markupFlag + "&" + nUseRaster;
        }else{
            PDFCreateURL = PDFExportURL + "?" + path + "&" + file + "&" + format + "&" + UPI + "&" + paperSize + "&" + markupFlag + "&" + nUseRaster;
        }


        /*if(bUseCustomrelpath){
            var PDFCreateURL = xmlurlrelcustom + "?" + path + "&" + file + "&" + format + "&" + UPI + "&" + paperSize + "&" + markupFlag;
        }else{

        }*/
        //xmlurlrelcustom = fileurl;



        //PDFExportURL?path&file&PDF&200

        try {
            xhr.open('POST', PDFCreateURL, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {

            if (this.status == 200) {
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }

                var bIsPDF = true;
                var PDFFileUrl = xmlDoc.getElementsByTagName('File')[0].firstChild.nodeValue;
                if (xmlDoc.getElementsByTagName('isPDF')[0] != undefined) {
                    bIsPDF = (xmlDoc.getElementsByTagName('isPDF')[0].firstChild.nodeValue == '1');
                }

                var cachfolder = getURLPath(DocObj.FileNameSRC);

                if(bUseCustomrelpath){
                    cachfolder = xmlurlrelcustom;
                }


                if(!bPDFExportfullPath){
                    if(bIsPDF){
                        PDFFileUrl = cachfolder + PDFFileUrl;
                    }else{
                        PDFFileUrl = cachfolder + PDFFileUrl;
                        //PDFFileUrl;
                    }
                }

                if (Rxcore_GUI_exportComplete != undefined){
                    Rxcore_GUI_exportComplete.loadComplete(PDFFileUrl);
                }


                //get pdf url here.
            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            }

        };
        xhr.send(markupxml);
    }


    function PDExportnew() {
        var curmarkup = 0;
        var savetime = new Date().getTime();
        var internalscale = 1;
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            post3DImageData();
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            internalscale = DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf;
        }


        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        xhr.upload.addEventListener("progress", PDFuploadProgress, false);

        var markupxml = createxmlmarkup(false,false,true,signature, signature);
        //var markupxml = parseXML(markupxmltxt);



        var path = getPath(DocObj.OriginalURL);
        var file = getFileName(DocObj.OriginalURL);
        //WebClientSaveAs?filepath&filename&PDF&UPI
        var PDFCreateURL = PDFExportURL + "?" + path + "&" + file + "&" + "PDF&200";

        //PDFExportURL?path&file&PDF&200

        try {
            xhr.open('POST', PDFCreateURL, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {

            if (this.status == 200) {
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var PDFFileUrl = xmlDoc.getElementsByTagName('File')[0].firstChild.nodeValue;
                var cachfolder = getURLPath(DocObj.FileNameSRC);
                PDFFileUrl = cachfolder + PDFFileUrl;

                if (Rxcore_GUI_exportComplete != undefined){
                    Rxcore_GUI_exportComplete.loadComplete(PDFFileUrl, true);
                }


                //get pdf url here.
            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            }

        };
        xhr.send(markupxml);

    }


    function getxmlurlEx(filepath){
        bAbortPageload = false;
        //showDownloadDialog();
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        try {
            xhr.open('GET', filepath, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {


            if (this.status == 200) {
                //hideDownloadDialog();
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var imageinfo = xmlDoc.getElementsByTagName('IMAGE_INFO');
                var fileurl = xmlDoc.getElementsByTagName("URL")[0].firstChild.nodeValue;
                var markupurls = xmlDoc.getElementsByTagName('MARKUP_URL');
                var saveurl = xmlDoc.getElementsByTagName('USER_MARKUPPOSTURL');
                //var xcmfiles = [];


                for (var i = 0; i < markupurls.length; i++) {

                    byrefmarkupfiles[i] = markupurls[i].firstChild.nodeValue;

                }
                bUsemarkupbyrefEx = true;
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("show");
                }

                var openfileobj = {filename: fileurl, displayname : null};
                getFile(openfileobj);


            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            }

        };


        xhr.send();
    }

    function getxmlurl(filepath) {
        bAbortPageload = false;
        //showDownloadDialog();
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        try {
            xhr.open('GET', filepath, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {


            if (this.status == 200) {
                //hideDownloadDialog();
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var imageinfo = xmlDoc.getElementsByTagName('IMAGE_INFO');
                var fileurl = xmlDoc.getElementsByTagName("URL")[0].firstChild.nodeValue;
                var markupurls = xmlDoc.getElementsByTagName('MARKUP_URL');
                var saveurl = xmlDoc.getElementsByTagName('USER_MARKUPPOSTURL');
                //var xcmfiles = [];


                for (var i = 0; i < markupurls.length; i++) {

                    byrefmarkupfiles[i] = markupurls[i].firstChild.nodeValue;

                }

                bUsemarkupbyref = true;

                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("show");
                }

                var openfileobj = {filename: fileurl, displayname : null};

                getFile(openfileobj);


            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            }

        };


        xhr.send();

    }

    function getFileCustom(Filepath){
        bAbortPageload = false;
        if(bIsmobile){
            GetLicense();
        }

        if (!bLicenseAquired) {
            return;
        }

        if (RxCore_GUI_HasText != undefined){
            RxCore_GUI_HasText.hastext = false;
            RxCore_GUI_HasText.hasText(RxCore_GUI_HasText.hastext, true);
        }

        cntximg.clearRect(0, 0, canvas.width, canvas.height);
        context.clearRect(0, 0, canvas.width, canvas.height);
        contexto.clearRect(0, 0, canvas.width, canvas.height);
        numUsers = 0;
        Userlist = [];
        Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
        numUsers++;

        var dataxml = Filepath + "data.xml";
        var PageObj;

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        try {
            xhr.open('GET', dataxml, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {

            if (this.status == 200) {
                //hideDownloadDialog();
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var i, j = 0;

                if (documentopen && bSingleDocmode) {
                    RxCore_Closedocument();
                }

                /*if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }*/


                //save for use with print.
                DocXMLPrint = xmlDoc;
                var totalpages = 0;
                if (DocObj == null || DocObj == undefined) {
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;
                    DocObj.relativepath = Filepath;

                } else {
                    //DocObj.Suspend();
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;
                    DocObj.relativepath = Filepath;
                }

                var path = addSlash(DocObj.OriginalURL);
                var layoutxmlobj = xmlDoc.getElementsByTagName('Layout');
                for (i = 0; i < layoutxmlobj.length; i++) {
                    var layoutname = layoutxmlobj[i].getElementsByTagName("LayoutName")[0].firstChild.nodeValue;
                    DocObj.addlayout(layoutname);
                    var pagexmlobj = layoutxmlobj[i].getElementsByTagName('Page');
                    for (j = 0; j < pagexmlobj.length; j++) {

                        if (j == 0 && i == 0) {
                            PageObj = new PageObject(pagexmlobj[j], layoutname, true, path, j, DocObj);
                            DocObj.addpage(PageObj, true);
                        } else {
                            PageObj = new PageObject(pagexmlobj[j], layoutname, false, '', j + totalpages, DocObj);
                            DocObj.addpage(PageObj, false);
                        }

                    }
                    totalpages += j;


                }

                //DocObj.FileName = szFileName;


                OpenFiles[nCurdocindex - 1] = DocObj;
                if (RxCore_GUI_pagethumbs != undefined) {
                    RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
                }

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                    is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                    is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage(),
                    activefile : DocObj.bActive
                };

                if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }

                var pagingobject = {
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage()
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }
                if(bIsmobile){
                    FreeLicense();
                }


            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                alert("Server is not responding refresh the page");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }
                if(!bIsmobile){
                    GetLicense();
                }

            }

        };

        xhr.send();
    }


    function getfilePagesPDFdoc(Filepath,pdfdoc, pages, callback){
        bAbortPageload = false;
        if(bIsmobile){
            GetLicense();
        }

        //var TDocObj;
        if (!bLicenseAquired) {
            return;
        }

        if (RxCore_GUI_HasText != undefined){
            RxCore_GUI_HasText.hastext = false;
            RxCore_GUI_HasText.hasText(RxCore_GUI_HasText.hastext, true);

        }

        var szFileName = getFileName(Filepath);


        cntximg.clearRect(0, 0, canvas.width, canvas.height);
        context.clearRect(0, 0, canvas.width, canvas.height);
        contexto.clearRect(0, 0, canvas.width, canvas.height);
        numUsers = 0;
        Userlist = [];
        Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
        numUsers++;

        var PageObj;

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var XMLGetFile = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetFile += "<RxViewServer>";
        XMLGetFile += "<Command>GetFile</Command>";
        XMLGetFile += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetFile += "<FileURL>" + Filepath + "</FileURL>";
        XMLGetFile += "</RxViewServer>";

        try {
            xhr.open('POST', xmlurl, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {
            if (this.status == 200) {


                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var i, j = 0;


                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

                var totalpages = 0;
                var pagesadded = 0;
                if (DocObj == null || DocObj == undefined) {
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;
                    DocObj.usepagesload = true;

                } else {

                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;
                    DocObj.usepagesload = true;
                }

                DocObj.setPDFdocument(pdfdoc, false);

                var path = addSlash(DocObj.OriginalURL);
                var layoutxmlobj = xmlDoc.getElementsByTagName('Layout');

                for (i = 0; i < layoutxmlobj.length; i++) {
                    var layoutname = layoutxmlobj[i].getElementsByTagName("LayoutName")[0].firstChild.nodeValue;
                    DocObj.addlayout(layoutname);
                    var pagexmlobj = layoutxmlobj[i].getElementsByTagName('Page');

                    //pages

                    for (j = 0; j < pagexmlobj.length; j++) {

                        if (j == 0 && i == 0) {

                            if (pages.indexOf(j) >= 0){
                                PageObj = new PageObject(pagexmlobj[j], layoutname, true, path, j, DocObj);
                                DocObj.addpage(PageObj, true);
                                pagesadded ++;
                            }
                        } else {
                            if (pages.indexOf(j) >= 0){
                                if(pagesadded == 0){
                                    PageObj = new PageObject(pagexmlobj[j], layoutname, true, path, j + totalpages, DocObj);
                                    DocObj.addpage(PageObj, true);
                                    pagesadded ++;

                                }else{
                                    PageObj = new PageObject(pagexmlobj[j], layoutname, false, '', j + totalpages, DocObj);
                                    DocObj.addpage(PageObj, false);
                                    pagesadded ++;
                                }
                            }
                        }

                    }
                    totalpages += j;

                }

                DocObj.FileName = szFileName;

                OpenFiles[nCurdocindex - 1] = DocObj;
                if (RxCore_GUI_pagethumbs != undefined) {
                    RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
                }

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                    is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                    is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage(),
                    activefile : DocObj.bActive
                };

                if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }

                var pagingobject = {
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage()
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }

                if(bIsmobile){
                    FreeLicense();
                }


            }else if (this.status == 404) {
                alert("XML could not be found");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

            } else if (this.status == 503) {
                alert("Server is down");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

            } else if (this.status == 501) {
                alert("Server is not responding refresh the page");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }
                if(!bIsmobile){
                    GetLicense();
                }
            }

            if (callback && typeof callback === "function") {
                callback(this);
            }

        };

        xhr.send(XMLGetFile);

    }

    function switchDocPages(Filepath, pages, callback){

        if (RxCore_GUI_HasText != undefined){
            RxCore_GUI_HasText.hastext = false;
            RxCore_GUI_HasText.hasText(RxCore_GUI_HasText.hastext, true);

        }

        var szFileName = getFileName(Filepath);

        cntximg.clearRect(0, 0, canvas.width, canvas.height);
        context.clearRect(0, 0, canvas.width, canvas.height);
        contexto.clearRect(0, 0, canvas.width, canvas.height);

        var PageObj;

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var XMLGetFile = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetFile += "<RxViewServer>";
        XMLGetFile += "<Command>GetFile</Command>";
        XMLGetFile += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetFile += "<FileURL>" + Filepath + "</FileURL>";
        XMLGetFile += "</RxViewServer>";

        try {
            xhr.open('POST', xmlurl, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {
            if (this.status == 200) {


                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var i, j = 0;


                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

                var totalpages = 0;
                var pagesadded = 0;
                if (DocObj == null || DocObj == undefined) {
                    return;
                }else{
                    DocObj.closePages(false);
                    //close existing page(s)
                }

                var path = addSlash(DocObj.OriginalURL);
                var layoutxmlobj = xmlDoc.getElementsByTagName('Layout');

                for (i = 0; i < layoutxmlobj.length; i++) {
                    var layoutname = layoutxmlobj[i].getElementsByTagName("LayoutName")[0].firstChild.nodeValue;
                    //DocObj.addlayout(layoutname);
                    var pagexmlobj = layoutxmlobj[i].getElementsByTagName('Page');

                    //pages

                    for (j = 0; j < pagexmlobj.length; j++) {

                        if (j == 0 && i == 0) {

                            if (pages.indexOf(j) >= 0){
                                PageObj = new PageObject(pagexmlobj[j], layoutname, false, path, j, DocObj);
                                DocObj.addpage(PageObj, true);
                                pagesadded ++;
                            }
                        } else {
                            if (pages.indexOf(j) >= 0){
                                if(pagesadded == 0){
                                    PageObj = new PageObject(pagexmlobj[j], layoutname, false, path, j + totalpages, DocObj);
                                    DocObj.addpage(PageObj, true);
                                    pagesadded ++;

                                }else{
                                    PageObj = new PageObject(pagexmlobj[j], layoutname, false, '', j + totalpages, DocObj);
                                    DocObj.addpage(PageObj, false);
                                    pagesadded ++;
                                }
                            }
                        }

                    }
                    totalpages += j;

                }

                if(PageObj.usepdfjs){

                    DocObj.loadPDFpages();

                }


                if (RxCore_GUI_pagethumbs != undefined) {
                    RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
                }

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                    is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                    is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage(),
                    activefile : DocObj.bActive
                };

                if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }

                var pagingobject = {
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage()
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }



            }else if (this.status == 404) {
                alert("XML could not be found");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

            } else if (this.status == 503) {
                alert("Server is down");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

            } else if (this.status == 501) {
                alert("Server is not responding refresh the page");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }
            }

            if (callback && typeof callback === "function") {
                callback(this);
            }

        };

        xhr.send(XMLGetFile);

    }

    function getFilePages(Filepath,pages, callback){
        bAbortPageload = false;
        if(bIsmobile){
            GetLicense();
        }

        //var TDocObj;
        if (!bLicenseAquired) {
            return;
        }

        if (RxCore_GUI_HasText != undefined){
            RxCore_GUI_HasText.hastext = false;
            RxCore_GUI_HasText.hasText(RxCore_GUI_HasText.hastext, true);

        }

        var szFileName = getFileName(Filepath);


        cntximg.clearRect(0, 0, canvas.width, canvas.height);
        context.clearRect(0, 0, canvas.width, canvas.height);
        contexto.clearRect(0, 0, canvas.width, canvas.height);
        numUsers = 0;
        Userlist = [];
        Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
        numUsers++;

        var PageObj;

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var XMLGetFile = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetFile += "<RxViewServer>";
        XMLGetFile += "<Command>GetFile</Command>";
        XMLGetFile += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetFile += "<FileURL>" + Filepath + "</FileURL>";
        XMLGetFile += "</RxViewServer>";

        try {
            xhr.open('POST', xmlurl, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {
            if (this.status == 200) {


                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var i, j = 0;


                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

                var totalpages = 0;
                var pagesadded = 0;
                if (DocObj == null || DocObj == undefined) {
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;
                    DocObj.usepagesload = true;

                } else {

                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;
                    DocObj.usepagesload = true;
                }

                var path = addSlash(DocObj.OriginalURL);
                var layoutxmlobj = xmlDoc.getElementsByTagName('Layout');

                for (i = 0; i < layoutxmlobj.length; i++) {
                    var layoutname = layoutxmlobj[i].getElementsByTagName("LayoutName")[0].firstChild.nodeValue;
                    DocObj.addlayout(layoutname);
                    var pagexmlobj = layoutxmlobj[i].getElementsByTagName('Page');

                    //pages

                    for (j = 0; j < pagexmlobj.length; j++) {

                        if (j == 0 && i == 0) {

                            if (pages.indexOf(j) >= 0){
                                PageObj = new PageObject(pagexmlobj[j], layoutname, true, path, j, DocObj);
                                DocObj.addpage(PageObj, true);
                                pagesadded ++;
                            }
                        } else {
                            if (pages.indexOf(j) >= 0){
                                if(pagesadded == 0){
                                    PageObj = new PageObject(pagexmlobj[j], layoutname, true, path, j + totalpages, DocObj);
                                    DocObj.addpage(PageObj, true);
                                    pagesadded ++;

                                }else{
                                    PageObj = new PageObject(pagexmlobj[j], layoutname, false, '', j + totalpages, DocObj);
                                    DocObj.addpage(PageObj, false);
                                    pagesadded ++;
                                }
                            }
                        }

                    }
                    totalpages += j;

                }

                DocObj.FileName = szFileName;

                OpenFiles[nCurdocindex - 1] = DocObj;
                if (RxCore_GUI_pagethumbs != undefined) {
                    RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
                }

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                    is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                    is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage(),
                    activefile : DocObj.bActive
                };

                if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }

                var pagingobject = {
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage()
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }

                if(bIsmobile){
                    FreeLicense();
                }


            }else if (this.status == 404) {
                alert("XML could not be found");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

            } else if (this.status == 503) {
                alert("Server is down");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

            } else if (this.status == 501) {
                alert("Server is not responding refresh the page");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }
                if(!bIsmobile){
                    GetLicense();
                }
            }

            if (callback && typeof callback === "function") {
                callback(this);
            }

        };

        xhr.send(XMLGetFile);

    }

    /* Andriy added callback to getFile */



    function getFile(Filepath, callback, progressCallBack) {
        bAbortPageload = false;

        if(bIsmobile){
            GetLicense();
        }

        //var TDocObj;
        if (!bLicenseAquired) {
            return;
        }
        //showDownloadDialog();
       /*if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
       }*/

        if (RxCore_GUI_HasText != undefined){
            RxCore_GUI_HasText.hastext = false;
            RxCore_GUI_HasText.hasText(RxCore_GUI_HasText.hastext, true);

        }

        if(Filepath.displayname != null){
            var szFileName = Filepath.displayname;
        }else{
            szFileName = getFileName(Filepath.filename);
        }


        cntximg.clearRect(0, 0, canvas.width, canvas.height);
        context.clearRect(0, 0, canvas.width, canvas.height);
        contexto.clearRect(0, 0, canvas.width, canvas.height);
        numUsers = 0;
        Userlist = [];
        Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
        numUsers++;

        var PageObj;


        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;

        var XMLGetFile = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetFile += "<RxViewServer>";
        XMLGetFile += "<Command>GetFile</Command>";
        XMLGetFile += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetFile += "<FileURL>" + Filepath.filename + "</FileURL>";
        XMLGetFile += "</RxViewServer>";

        try {
            xhr.open('POST', xmlurl, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {

            if (this.status == 200) {
                //hideDownloadDialog();
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }

                szLatestresponseHeaders = this.getAllResponseHeaders();

                if(RxCore_GUI_getResponsHeaders != undefined){
                    RxCore_GUI_getResponsHeaders.setRespHeaders(szLatestresponseHeaders);
                }

                var i, j = 0;

                if (documentopen && bSingleDocmode) {
                    RxCore_Closedocument();
                }

                /*if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }*/

                //ThumbnailpagesContainer.setEmpty();
                //save for use with print.
                DocXMLPrint = xmlDoc;
                var totalpages = 0;
                if (DocObj == null || DocObj == undefined) {
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;

                } else {
                    //DocObj.Suspend();
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;
                }

                var path = addSlash(DocObj.OriginalURL);
                var layoutxmlobj = xmlDoc.getElementsByTagName('Layout');
                for (i = 0; i < layoutxmlobj.length; i++) {
                    var layoutname = layoutxmlobj[i].getElementsByTagName("LayoutName")[0].firstChild.nodeValue;
                    DocObj.addlayout(layoutname);
                    var pagexmlobj = layoutxmlobj[i].getElementsByTagName('Page');
                    for (j = 0; j < pagexmlobj.length; j++) {

                        if (j == 0 && i == 0) {
                            PageObj = new PageObject(pagexmlobj[j], layoutname, true, path, j, DocObj);
                            DocObj.addpage(PageObj, true);
                        } else {
                            PageObj = new PageObject(pagexmlobj[j], layoutname, false, '', j + totalpages, DocObj);
                            DocObj.addpage(PageObj, false);
                        }

                    }
                    totalpages += j;

                }

                DocObj.FileName = szFileName;

                //var szstyle = "width: 200px; height: " + canvasoheight + "px; position:relative; top:-100px; left:15px"

                //Thumbnailpopup = DocObj.thumbnailhtmlsource;
                //layerhtmlsource
                //setContentThumb(Thumbnailpopup);

                //ThumbnailpagesContainer.innerHTML = Thumbnailpopup;
                //ThumbnailpagesContainer.Setheight(canvasoheight);
                //ThumbnailpagesContainer.setContent();

                OpenFiles[nCurdocindex - 1] = DocObj;
                if (RxCore_GUI_pagethumbs != undefined) {
                    RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
                }

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                    is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                    is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage(),
                    activefile : DocObj.bActive
                };

                if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }

                var pagingobject = {
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage()
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }

                //ThumbnailpagesContainer.parentNode.parentNode.style.height = canvasoheight + "px";
                //DocObj.pages[DocObj.currentpage].loadimages();
                //documentopen = true;
                //hideDownloadDialog();
                //var path = addSlash(DocObj.OriginalURL);
                //var path = getPath(DocObj.OriginalURL);
                //getMarkupFilelist(path);

                //moved to attempt to secure that file is loaded.
                //var path = addSlash(DocObj.OriginalURL);
                //getMarkupFilelist(path);

                if(bIsmobile){
                    FreeLicense();
                }

            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                alert("Server is not responding refresh the page");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }
                if(!bIsmobile){
                    GetLicense();
                }
            }

            if (callback && typeof callback === "function") {
                callback(this);
            }

        };

        //Download progress
        xhr.addEventListener("progress", function (evt) {
            if (evt.lengthComputable) {
                var percentComplete = evt.loaded / evt.total;
                if (progressCallBack) {
                    progressCallBack(percentComplete)
                }
            }
        }, false);

        xhr.send(XMLGetFile);


    }

    function getFileNotActive(Filepath, callback, progressCallBack) {
        bAbortPageload = false;

        if(bIsmobile){
            GetLicense();
        }

        //var TDocObj;
        if (!bLicenseAquired) {
            return;
        }
        //showDownloadDialog();
       /*if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
       }*/

        if (RxCore_GUI_HasText != undefined){
            RxCore_GUI_HasText.hastext = false;
            RxCore_GUI_HasText.hasText(RxCore_GUI_HasText.hastext, false);

        }


        var szFileName = getFileName(Filepath);

        //cntximg.clearRect(0, 0, canvas.width, canvas.height);
        //context.clearRect(0, 0, canvas.width, canvas.height);
        //contexto.clearRect(0, 0, canvas.width, canvas.height);
        numUsers = 0;
        Userlist = [];
        Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
        numUsers++;

        var PageObj;


        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;

        var XMLGetFile = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetFile += "<RxViewServer>";
        XMLGetFile += "<Command>GetFile</Command>";
        XMLGetFile += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetFile += "<FileURL>" + Filepath + "</FileURL>";
        XMLGetFile += "</RxViewServer>";

        try {
            xhr.open('POST', xmlurl, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {

            if (this.status == 200) {
                //hideDownloadDialog();
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }
                var i, j = 0;

                if (documentopen && bSingleDocmode) {
                    RxCore_Closedocument();
                }

                /*if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }*/

                //ThumbnailpagesContainer.setEmpty();
                //save for use with print.
                DocXMLPrint = xmlDoc;
                var totalpages = 0;
                if (DocObj == null || DocObj == undefined) {
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    DocObj = OpenFiles[nCurdocindex - 1];
                    DocObj.fileindex = nCurdocindex - 1;

                } else {
                    //DocObj.Suspend();
                    nCurdocindex = OpenFiles.push(new DocumentObject(xmlDoc));
                    //DocObj = OpenFiles[nCurdocindex - 1];
                    OpenFiles[nCurdocindex - 1].fileindex = nCurdocindex - 1;
                    OpenFiles[nCurdocindex - 1].bSopenSilent = true;
                    //DocObj.fileindex = nCurdocindex - 1;
                }

                var path = addSlash(OpenFiles[nCurdocindex - 1].OriginalURL);
                var layoutxmlobj = xmlDoc.getElementsByTagName('Layout');
                for (i = 0; i < layoutxmlobj.length; i++) {
                    var layoutname = layoutxmlobj[i].getElementsByTagName("LayoutName")[0].firstChild.nodeValue;
                    OpenFiles[nCurdocindex - 1].addlayout(layoutname);
                    var pagexmlobj = layoutxmlobj[i].getElementsByTagName('Page');
                    for (j = 0; j < pagexmlobj.length; j++) {

                        if (j == 0 && i == 0) {
                            PageObj = new PageObject(pagexmlobj[j], layoutname, true, path, j, OpenFiles[nCurdocindex - 1]);
                            OpenFiles[nCurdocindex - 1].addpage(PageObj, true);
                        } else {
                            PageObj = new PageObject(pagexmlobj[j], layoutname, false, '', j + totalpages, OpenFiles[nCurdocindex - 1]);
                            OpenFiles[nCurdocindex - 1].addpage(PageObj, false);
                        }

                    }
                    totalpages += j;

                }

                OpenFiles[nCurdocindex - 1].FileName = szFileName;

                //var szstyle = "width: 200px; height: " + canvasoheight + "px; position:relative; top:-100px; left:15px"

                //Thumbnailpopup = DocObj.thumbnailhtmlsource;
                //layerhtmlsource
                //setContentThumb(Thumbnailpopup);

                //ThumbnailpagesContainer.innerHTML = Thumbnailpopup;
                //ThumbnailpagesContainer.Setheight(canvasoheight);
                //ThumbnailpagesContainer.setContent();

                //OpenFiles[nCurdocindex - 1] = DocObj;
                if (RxCore_GUI_pagethumbs != undefined) {
                    RxCore_GUI_pagethumbs.setThumbnails(OpenFiles[nCurdocindex - 1].thumbnails);
                }

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:OpenFiles[nCurdocindex - 1].pages[OpenFiles[nCurdocindex - 1].currentpage].usepdfjs,
                    is3D:OpenFiles[nCurdocindex - 1].pages[OpenFiles[nCurdocindex - 1].currentpage].usevector3Dxml,
                    is2D:OpenFiles[nCurdocindex - 1].pages[OpenFiles[nCurdocindex - 1].currentpage].usevectorxml,
                    numpages:OpenFiles[nCurdocindex - 1].pages.length,
                    currentpage:OpenFiles[nCurdocindex - 1].getcurPage(),
                    activefile : false
                };

                if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }

                var pagingobject = {
                    numpages:OpenFiles[nCurdocindex - 1].pages.length,
                    currentpage:OpenFiles[nCurdocindex - 1].getcurPage()
                };

                if(RxCore_GUI_Page != undefined){
                    RxCore_GUI_Page.pageEvent(pagingobject);
                }

                //ThumbnailpagesContainer.parentNode.parentNode.style.height = canvasoheight + "px";
                //DocObj.pages[DocObj.currentpage].loadimages();
                //documentopen = true;
                //hideDownloadDialog();
                //var path = addSlash(DocObj.OriginalURL);
                //var path = getPath(DocObj.OriginalURL);
                //getMarkupFilelist(path);

                //moved to attempt to secure that file is loaded.
                //var path = addSlash(DocObj.OriginalURL);
                //getMarkupFilelist(path);

                if(bIsmobile){
                    FreeLicense();
                }

            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                alert("Server is not responding refresh the page");
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }
                if(!bIsmobile){
                    GetLicense();
                }
            }

            if (callback && typeof callback === "function") {
                callback(this);
            }

        };

        //Download progress
        xhr.addEventListener("progress", function (evt) {
            if (evt.lengthComputable) {
                var percentComplete = evt.loaded / evt.total;
                if (progressCallBack) {
                    progressCallBack(percentComplete)
                }
            }
        }, false);

        xhr.send(XMLGetFile);


    }

    function getMarkupxmlurl(DocRef){

        DocRef.setnummarkupfiles(byrefmarkupfiles.length);

        for (var i = 0; i < byrefmarkupfiles.length; i++) {
            var last = (i == byrefmarkupfiles.length - 1);
            getMarkup(byrefmarkupfiles[i],DocRef);
        }

        drawmarkupAll(cntximg);
        DocRef.markuploaded = true;
        if (markupfilepathobj.length == 0) {
            if (RxCore_GUI_Markuplist != undefined) {
                RxCore_GUI_Markuplist.setMarkupList(DocRef.markuplist, DocRef.bActive);
                /* Andriy */
                // RxCore_GUI_Markuplist.notify();
            }

        }
        bUsemarkupbyrefEx = false;


    }


    function getMarkupbyReference(Filepath, DocRef) {

        var relpath = xmlurlrel;
        if(bUseCustomrelpath){
            relpath = xmlurlrelcustom;
        }


        var file = getFileName(DocRef.CacheFileName);
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var XMLGetFile = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetFile += "<RxViewServer>";
        XMLGetFile += "<Command>GetMarkupByRef</Command>";
        XMLGetFile += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetFile += "<FileURL>" + Filepath + file + "</FileURL>";
        //XMLGetFile += "<FileURL>" + Filepath + "</FileURL>";
        XMLGetFile += "<MARKUP_INFO>";
        for (var i = 0; i < byrefmarkupfiles.length; i++) {
            XMLGetFile += "<MARKUP_URL>" + byrefmarkupfiles[i] + "</MARKUP_URL>";
        }
        XMLGetFile += "</MARKUP_INFO>";
        XMLGetFile += "</RxViewServer>";

        try {
            xhr.open('POST', xmlurl, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            //xhr.responseType = 'text/xml';
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {


            if (this.status == 200) {
                //console.log(this.responseText);
                var MarkupFilePath = 0;
                var i = 0;
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }

                var markupfilepathobj = xmlDoc.getElementsByTagName('File');

                DocRef.setnummarkupfiles(markupfilepathobj.length);

                for (i = 0; i < markupfilepathobj.length; i++) {
                    MarkupFilePath = markupfilepathobj[i].firstChild.nodeValue;
                    MarkupFilePath = relpath + MarkupFilePath;
                    var last = (i == markupfilepathobj.length - 1);
                    getMarkup(MarkupFilePath, DocRef);
                    //markupfiles.push(MarkupFilePath);
                }
                drawmarkupAll(cntximg);
                DocRef.markuploaded = true;
                if (markupfilepathobj.length == 0) {
                    if (RxCore_GUI_Markuplist != undefined) {
                        RxCore_GUI_Markuplist.setMarkupList(DocRef.markuplist, DocRef.bActive);
                        /* Andriy */
                        // RxCore_GUI_Markuplist.notify();
                    }
                }
                bUsemarkupbyref = false;

            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }


        };

        xhr.send(XMLGetFile);

    }

    function getMarkupFilelist(Filepath, DocRef) {
        //var TDocObj;
        var PageObj;
        //var pages = new Array();

        var file = getFileName(DocRef.FileName);
        var xhr = new XMLHttpRequest();

        xhr.withCredentials = bUseCredentials;

        //alert("XMLHttpRequest created");

        var XMLGetFile = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetFile += "<RxViewServer>";
        XMLGetFile += "<Command>GetMarkup</Command>";
        XMLGetFile += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetFile += "<FileURL>" + Filepath + "</FileURL>";
        XMLGetFile += "</RxViewServer>";

        try {
            xhr.open('POST', xmlurlmarkup, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            //xhr.responseType = 'text/xml';
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {

            if (this.status == 200) {
                //console.log(this.responseText);
                var MarkupFilePath = 0;
                var i = 0;
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    if (this.responseText != ""){
                        xmlDoc = $.parseXML(this.responseText).documentElement;
                    }

                }

                if(xmlDoc == null || xmlDoc.documentElement == null){
                    return;
                }

                try {
                    var SzReadonlymarkup = xmlDoc.getElementsByTagName("readonlymarkup")[0].firstChild.nodeValue;
                } catch (e) {
                    //ignore and continue
                    SzReadonlymarkup = "";
                }

                if (!readonlymode){
                    readonlymode = (SzReadonlymarkup != "" && SzReadonlymarkup == "True");
                }


                var markupfilepathobj = xmlDoc.getElementsByTagName('File');

                DocRef.setnummarkupfiles(markupfilepathobj.length);

                for (i = 0; i < markupfilepathobj.length; i++) {
                    MarkupFilePath = markupfilepathobj[i].firstChild.nodeValue;
                    if(bUseCustomrelpath){

                        MarkupFilePath = xmlurlrelcustom + MarkupFilePath;
                    }else{
                        MarkupFilePath = xmlurlrelmarkup + MarkupFilePath;
                    }

                    getMarkup(MarkupFilePath, DocRef);
                    //markupfiles.push(MarkupFilePath);
                }
                drawmarkupAll(cntximg);
                DocRef.markuploaded = true;


                if (markupfilepathobj.length == 0) {

                    if (RxCore_GUI_Markuplist != undefined) {
                        RxCore_GUI_Markuplist.setMarkupList(DocRef.markuplist, DocRef.bActive);
                        /* Andriy */
                        // RxCore_GUI_Markuplist.notify();
                    }

                    if (Rxcore_GUI_markupLoadComplete != undefined) {
                        Rxcore_GUI_markupLoadComplete.loadComplete(DocRef.markuplist, DocRef.fileindex, DocRef.bActive);
                    }


                }




            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }


        };
        //alert(XMLGetFile);
        xhr.send(XMLGetFile);

    }

    function singleMarkupToLocalStorage(MarkupObj){
        localStorage.clear();
        MarkupToLocalStorage(MarkupObj, false);

    }
    function multiMarkupToLocalStorage(MarkupObj){
        MarkupToLocalStorage(MarkupObj, true);

    }

    function MarkupToLocalStorage(MarkupObj, multi) {
        if (typeof(Storage) !== "undefined") {
            if (multi){
                var postfix = MarkupObj.markupnumber;
                if (localStorage.getItem("MarkupPostfixlist") != null) {
                    var postfixes = localStorage.MarkupPostfixlist;
                    localStorage.setItem("MarkupPostfixlist", postfixes + "," + postfix);
                }else{
                    localStorage.setItem("MarkupPostfixlist", postfix);
                }

            }else{
                var postfix = '';
            }

            //localStorage.Type = MarkupObj.type;
            localStorage.setItem("Type" + postfix , MarkupObj.type);
            //localStorage.Subtype = MarkupObj.subtype;
            localStorage.setItem("Subtype" + postfix , MarkupObj.subtype);
            localStorage.setItem("Alternative" + postfix , MarkupObj.alternative);
            localStorage.setItem("Redaction" + postfix , MarkupObj.bRedact ? 1:0);
            //createAndAppendElement(entityNode, "Redaction", DocObj.markuplist[curmarkup].bRedact ? 1:0);
            localStorage.setItem("Rotation" + postfix , MarkupObj.rotation);
            localStorage.setItem("fillcolor" + postfix , MarkupObj.fillcolor);
            localStorage.setItem("strokecolor" + postfix , MarkupObj.strokecolor);
            localStorage.setItem("textcolor" + postfix , MarkupObj.textcolor);
            localStorage.setItem("markercolor" + postfix , MarkupObj.markercolor);
            localStorage.setItem("Color" + postfix , MarkupObj.color);
            localStorage.setItem("FontName" + postfix , MarkupObj.font.fontName);
            localStorage.setItem("FontHeight" + postfix , MarkupObj.font.height);

            if(MarkupObj.leaderoffset != undefined){
                localStorage.setItem("LeaderOffset" + postfix , MarkupObj.leaderoffset);
            }

            if(MarkupObj.labeloffsetx != undefined){
                localStorage.setItem("LabelOffsetX" + postfix , MarkupObj.labeloffsetx);
            }

            if(MarkupObj.labeloffsety != undefined){
                localStorage.setItem("LabelOffsetY" + postfix , MarkupObj.labeloffsety);
            }


            if(MarkupObj.arrowlength != undefined){
                localStorage.setItem("Arrowlength" + postfix , MarkupObj.arrowlength);
            }

            //localStorage.Alternative = MarkupObj.alternative;
            //localStorage.Rotation = MarkupObj.rotation;
            //localStorage.fillcolor = MarkupObj.fillcolor;
            //localStorage.strokecolor = MarkupObj.strokecolor;
            //localStorage.textcolor = MarkupObj.textcolor;
            //localStorage.markercolor = MarkupObj.markercolor;
            //localStorage.Color = MarkupObj.color;
            //localStorage.FontName = MarkupObj.font.fontName;
            //localStorage.FontHeight = MarkupObj.font.height;
            if (MarkupObj.text == "") {
                //localStorage.Text = ".";
                localStorage.setItem("Text" + postfix , "");
            } else {
                //localStorage.Text = MarkupObj.text;
                localStorage.setItem("Text" + postfix , MarkupObj.text);
            }
            if (localStorage.DimText == "") {
                //localStorage.DimText = ".";
                localStorage.setItem("DimText" + postfix , "");
            } else {
                //localStorage.DimText = MarkupObj.dimtext;
                localStorage.setItem("DimText" + postfix , MarkupObj.dimtext);
            }

            //localStorage.TextWidth = MarkupObj.textwidth;
            localStorage.setItem("TextWidth" + postfix , MarkupObj.textwidth);

            if (MarkupObj.type == 12) {
                //localStorage.Stampsmalltheight = MarkupObj.stampsmalltheight;
                localStorage.setItem("Stampsmalltheight" + postfix , MarkupObj.stampsmalltheight);
            }

            if (MarkupObj.type == 11) {
                localStorage.setItem("image" + postfix , MarkupObj.image.src);
                //localStorage.image = MarkupObj.image.src;

            }

            localStorage.setItem("Scaling" + postfix , MarkupObj.scaling);
            //localStorage.Scaling = MarkupObj.scaling;

            //localStorage.Xoffset = MarkupObj.xoffset;
            localStorage.setItem("Xoffset" + postfix , MarkupObj.xoffset);

            //localStorage.Yoffset = MarkupObj.yoffset;
            localStorage.setItem("Yoffset" + postfix , MarkupObj.yoffset);

            localStorage.setItem("LineWidth" + postfix , MarkupObj.linewidth);
            //localStorage.LineWidth = MarkupObj.linewidth;

            if (MarkupObj.points.length > 0) {
                //localStorage.Points = JSON.stringify(MarkupObj.points);
                localStorage.setItem("Points" + postfix , JSON.stringify(MarkupObj.points));

            }
            if (MarkupObj.pointlist.length > 0) {
                localStorage.setItem("Pointlist" + postfix , JSON.stringify(MarkupObj.pointlist));
                //localStorage.Pointlist = JSON.stringify(MarkupObj.pointlist);

            }

            localStorage.setItem("Rect" + postfix , "x=" + MarkupObj.x + " y=" + MarkupObj.y + " w=" + MarkupObj.w + " h=" + MarkupObj.h);

            //localStorage.Rect = "x=" + MarkupObj.x + " y=" + MarkupObj.y + " w=" + MarkupObj.w + " h=" + MarkupObj.h;
        } else {
            // Sorry! No web storage support..
        }

    }

    function MarkupFromLocalStorage() {
        if (typeof(Storage) !== "undefined") {
            if (localStorage.getItem("MarkupPostfixlist") != null) {
                var Postfixlist = localStorage.MarkupPostfixlist;
                var Postfixarray = Postfixlist.split(",");

            }else{
                Postfixarray = [''];
            }

            for(var pfixc = 0;pfixc < Postfixarray.length; pfixc++){
                var postfix = Postfixarray[pfixc];

                if (localStorage.getItem("Type" + postfix) != null) {
                    var type = parseInt(localStorage.getItem("Type" + postfix));
                    if (localStorage.getItem("Subtype" + postfix) != null) {
                        var subtype = parseInt(localStorage.getItem("Subtype" + postfix));

                        if (localStorage.getItem("Alternative" + postfix) != null) {
                            if (localStorage.getItem("Rect" + postfix) != null) {

                                var alternative = parseInt(localStorage.getItem("Alternative" + postfix));
                                var NewMarkupobj = new MarkupObject(type, subtype, alternative);

                                NewMarkupobj.bRedact = (parseInt(localStorage.getItem("Alternative" + postfix)) == 1);
                                //parseInt(localStorage.getItem("Alternative" + postfix));
                                NewMarkupobj.pagenumber = DocObj.getcurPage();

                                NewMarkupobj.fillcolor = localStorage.getItem("fillcolor" + postfix);

                                NewMarkupobj.strokecolor = localStorage.getItem("strokecolor" + postfix);
                                NewMarkupobj.textcolor = localStorage.getItem("textcolor" + postfix);
                                NewMarkupobj.markercolor = localStorage.getItem("markercolor" + postfix);

                                NewMarkupobj.color = localStorage.getItem("Color" + postfix);

                                NewMarkupobj.dimtext = localStorage.getItem("DimText" + postfix);


                                NewMarkupobj.font.setFontname(localStorage.getItem("FontName" + postfix));
                                NewMarkupobj.font.setHeight(localStorage.getItem("FontHeight" + postfix));

                                //NewMarkupobj.textheight = localStorage.FontHeight;
                                if (type == 12) {
                                    NewMarkupobj.stampsmalltheight = localStorage.getItem("Stampsmalltheight" + postfix);
                                }

                                if (type == 11) {
                                    var createimage = new Image();
                                    NewMarkupobj.markupcdataload(createimage, localStorage.getItem("image" + postfix));


                                }

                                if(localStorage.getItem("LeaderOffset" + postfix) != null){
                                    NewMarkupobj.leaderoffset = parseFloat(localStorage.getItem("LeaderOffset" + postfix));
                                }

                                if(localStorage.getItem("LabelOffsetX" + postfix) != null){
                                    NewMarkupobj.labeloffsetx = parseFloat(localStorage.getItem("LabelOffsetX" + postfix));
                                }

                                if(localStorage.getItem("LabelOffsetY" + postfix) != null){
                                    NewMarkupobj.labeloffsety = parseFloat(localStorage.getItem("LabelOffsetY" + postfix));
                                }

                                if(localStorage.getItem("LabelColor" + postfix) != null){
                                    NewMarkupobj.labelfillcolor = localStorage.getItem("LabelColor" + postfix);
                                }


                                if(localStorage.getItem("Arrowlength" + postfix) != null){
                                    NewMarkupobj.arrowlength = parseFloat(localStorage.getItem("Arrowlength" + postfix));
                                }


                                NewMarkupobj.text = localStorage.getItem("Text" + postfix);


                                NewMarkupobj.dimtext = localStorage.getItem("DimText" + postfix);

                                NewMarkupobj.textwidth = parseFloat(localStorage.getItem("TextWidth" + postfix));

                                NewMarkupobj.scaling = parseFloat(localStorage.getItem("Scaling" + postfix));

                                NewMarkupobj.xoffset = parseFloat(localStorage.getItem("Xoffset" + postfix));

                                NewMarkupobj.yoffset = parseFloat(localStorage.getItem("Yoffset" + postfix));

                                NewMarkupobj.linewidth = parseInt(localStorage.getItem("LineWidth" + postfix));


                                var Rectlist = localStorage.getItem("Rect" + postfix);

                                var Rectarray = Rectlist.split(" ");
                                var xval = Rectarray[0].split("=");
                                var yval = Rectarray[1].split("=");
                                var wval = Rectarray[2].split("=");
                                var hval = Rectarray[3].split("=");
                                NewMarkupobj.x = parseInt(xval[1]);
                                NewMarkupobj.y = parseInt(yval[1]);
                                NewMarkupobj.w = parseInt(wval[1]);
                                NewMarkupobj.h = parseInt(hval[1]);
                                var bOval = (NewMarkupobj.type == 4 && NewMarkupobj.subtype == 0);
                                if (NewMarkupobj.type == 3 || bOval || NewMarkupobj.type == 5 || NewMarkupobj.type == 9 || NewMarkupobj.type == 10 || NewMarkupobj.type == 11 || NewMarkupobj.type == 12) {
                                    NewMarkupobj.x += 10;
                                    NewMarkupobj.y += 10;

                                } else {
                                    NewMarkupobj.x += 10;
                                    NewMarkupobj.y += 10;
                                    NewMarkupobj.w += 10;
                                    NewMarkupobj.h += 10;
                                }

                                if (localStorage.getItem("Points" + postfix) != null) {

                                    var Pointlist = localStorage.getItem("Points" + postfix);
                                    NewMarkupobj.points = JSON.parse(Pointlist);
                                    //var content_array = JSON.parse(str);
                                    //var pointarray = Pointlist.split(",");
                                    for (var i = 0; i < NewMarkupobj.points.length - 1; i++) {
                                        NewMarkupobj.points[i].x += 10;
                                        NewMarkupobj.points[i].y += 10;
                                        //var point = pointarray[i];
                                        //var pointpair = point.split(" ");
                                        //var xp = pointpair[0].split("=");
                                        //var yp = pointpair[1].split("=");
                                        //NewMarkupobj.addpoint(parseInt(xp[1]),parseInt(yp[1]));
                                        //NewMarkupobj.addpoint(parseInt(xp[1]) + 10, parseInt(yp[1]) + 10);
                                        //+= "x=" + MarkupObj.points[i].x + " y=" + MarkupObj.points[i].y + ",";
                                    }

                                }
                                if (localStorage.getItem("Pointlist" + postfix) != null) {
                                    Pointlist = localStorage.getItem("Pointlist" + postfix);
                                    NewMarkupobj.pointlist = JSON.parse(Pointlist);
                                }


                                NewMarkupobj.savemetolistLoad(DocObj);
                            }

                        }

                    }

                }
            }


        } else {
            // Sorry! No web storage support..
        }

    }

    function createCustomStamp(image, sname){


            var stampinfo = { type : 5, data : image.image, index : sname, width : image.width, height: image.height};

            if (RxCore_GUI_CustomStamps != undefined){
                RxCore_GUI_CustomStamps.onStampReceived(stampinfo);
            }

    }

    function createCustomStamps(stampsobject){

        /*var stampinfo = { type : 1, data : "1"};

        if (RxCore_GUI_CustomStamps != undefined){
            RxCore_GUI_CustomStamps.onStampReceived(stampinfo);
        }*/

        var stampinfo = {type : 2, data : "Custom Stamps" };

        if (RxCore_GUI_CustomStamps != undefined){
            RxCore_GUI_CustomStamps.onStampReceived(stampinfo);
        }

        stampinfo = {type : 3, data : stampsobject.numstamps};
        if (RxCore_GUI_CustomStamps != undefined){
            RxCore_GUI_CustomStamps.onStampReceived(stampinfo);
        }


        for (var i = 0; i < stampsobject.numstamps; i++){
            createCustomStamp(stampsobject.stamps[i],i);
        }

    }

    function getSymbolPNGData(num,sname){
        //Command=symbolpngdata&Libnumber=n&Symbolnumber=s;

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var urlEncodedData = "";
        var urlEncodedDataPairs = [];

        urlEncodedDataPairs.push(encodeURIComponent("MfcISAPICommand") + '=' + encodeURIComponent("FormRequest"));
        urlEncodedDataPairs.push(encodeURIComponent("Command") + '=' + encodeURIComponent("symbolpng"));
        urlEncodedDataPairs.push(encodeURIComponent("Libnumber") + '=' + encodeURIComponent(num));
        urlEncodedDataPairs.push(encodeURIComponent("Symbolnumber") + '=' + encodeURIComponent(sname));

        urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');

        try {
            xhr.open('POST', xmlurldirect + "?FormRequest", true);
            xhr.responseType = "arraybuffer";
        } catch (e) {
            alert("Error 1 - " + e);
        }


        xhr.onload = function (e) {
            if (this.status == 200) {

                //parse symbol xml here.
                //create callback to push symbol library to GUI
                var symbolPNGData = new Blob([xhr.response], {type: "image/png"});
                //var symbolPNGData = this.responseText;

                var symbolinfo = { type : 5, data : symbolPNGData, index : sname};

                if (RxCore_GUI_Symbols != undefined){
                    RxCore_GUI_Symbols.onSymbolReceived(symbolinfo);
                }


            }else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }
        };

        xhr.send(urlEncodedData);



    }
    function getSymbolName(num, sname){
        //Command=Symbolname&Libnumber=nSymbolnumber=
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var urlEncodedData = "";
        var urlEncodedDataPairs = [];

        urlEncodedDataPairs.push(encodeURIComponent("MfcISAPICommand") + '=' + encodeURIComponent("FormRequest"));
        urlEncodedDataPairs.push(encodeURIComponent("Command") + '=' + encodeURIComponent("Symbolname"));
        urlEncodedDataPairs.push(encodeURIComponent("Libnumber") + '=' + encodeURIComponent(num));
        urlEncodedDataPairs.push(encodeURIComponent("Symbolnumber") + '=' + encodeURIComponent(sname));

        urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');

        try {
            xhr.open('POST', xmlurldirect + "?FormRequest", true);
        } catch (e) {
            alert("Error 1 - " + e);
        }


        xhr.onload = function (e) {
            if (this.status == 200) {

                //parse symbol xml here.
                //create callback to push symbol library to GUI
                var symbolName = this.responseText;

                var symbolinfo = { type : 4, data : symbolName};


                if (RxCore_GUI_Symbols != undefined){
                    RxCore_GUI_Symbols.onSymbolReceived(symbolinfo);
                }


            }else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }
        };

        xhr.send(urlEncodedData);


    }

    function getnumSymbols(num){
        //Command=Numsymbols&Libnumber=n
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var urlEncodedData = "";
        var urlEncodedDataPairs = [];

        urlEncodedDataPairs.push(encodeURIComponent("MfcISAPICommand") + '=' + encodeURIComponent("FormRequest"));
        urlEncodedDataPairs.push(encodeURIComponent("Command") + '=' + encodeURIComponent("Numsymbols"));
        urlEncodedDataPairs.push(encodeURIComponent("Libnumber") + '=' + encodeURIComponent(num));

        urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');

        try {
            xhr.open('POST', xmlurldirect + "?FormRequest", true);
        } catch (e) {
            alert("Error 1 - " + e);
        }


        xhr.onload = function (e) {
            if (this.status == 200) {

                //parse symbol xml here.
                //create callback to push symbol library to GUI
                var numsymbols = this.responseText;

                var symbolinfo = { type : 3, data : numsymbols};

                if (RxCore_GUI_Symbols != undefined){
                    RxCore_GUI_Symbols.onSymbolReceived(symbolinfo);
                }


            }else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }
        };

        xhr.send(urlEncodedData);

    }

    function selectSymbname(num){
        //Command=Libname&Libnumber=n

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var urlEncodedData = "";
        var urlEncodedDataPairs = [];

        urlEncodedDataPairs.push(encodeURIComponent("MfcISAPICommand") + '=' + encodeURIComponent("FormRequest"));
        urlEncodedDataPairs.push(encodeURIComponent("Command") + '=' + encodeURIComponent("Libname"));
        urlEncodedDataPairs.push(encodeURIComponent("Libnumber") + '=' + encodeURIComponent(num));

        urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');

        try {
            xhr.open('POST', xmlurldirect + "?FormRequest", true);
        } catch (e) {
            alert("Error 1 - " + e);
        }


        xhr.onload = function (e) {
            if (this.status == 200) {

                //parse symbol xml here.
                //create callback to push symbol library to GUI
                var libname = this.responseText;
                var symbolinfo = { type : 2, data : libname};

                if (RxCore_GUI_Symbols != undefined){
                    RxCore_GUI_Symbols.onSymbolReceived(symbolinfo);
                }



            }else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }
        };

        xhr.send(urlEncodedData);

    }


    function selectSymblib(num){
        //Command=Selectlib&Libnumber=n
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var urlEncodedData = "";
        var urlEncodedDataPairs = [];

        urlEncodedDataPairs.push(encodeURIComponent("MfcISAPICommand") + '=' + encodeURIComponent("FormRequest"));
        urlEncodedDataPairs.push(encodeURIComponent("Command") + '=' + encodeURIComponent("Selectlib"));
        urlEncodedDataPairs.push(encodeURIComponent("Libnumber") + '=' + encodeURIComponent(num));

        urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');

        try {
            xhr.open('POST', xmlurldirect + "?FormRequest", true);
        } catch (e) {
            alert("Error 1 - " + e);
        }

        xhr.onload = function (e) {
            if (this.status == 200) {

                //parse symbol xml here.
                //create callback to push symbol library to GUI
                //var Numlibs = this.responseText;
                var symbolinfo = { type : 6, data : num};

                if (RxCore_GUI_Symbols != undefined){
                    RxCore_GUI_Symbols.onSymbolReceived(symbolinfo);
                }

            }else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }
        };

        xhr.send(urlEncodedData);
    }

    function getNumSymblibs(){
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        var urlEncodedData = "";
        var urlEncodedDataPairs = [];

        urlEncodedDataPairs.push(encodeURIComponent("MfcISAPICommand") + '=' + encodeURIComponent("FormRequest"));
        urlEncodedDataPairs.push(encodeURIComponent("Command") + '=' + encodeURIComponent("Numlibs"));

        urlEncodedData = urlEncodedDataPairs.join('&').replace(/%20/g, '+');

        try {
            xhr.open('POST', xmlurldirect + "?FormRequest", true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        xhr.onload = function (e) {
            if (this.status == 200) {

                //parse symbol xml here.
                //create callback to push symbol library to GUI
                var Numlibs = this.responseText;

                var symbolinfo = { type : 1, data : Numlibs};

                if (RxCore_GUI_Symbols != undefined){
                    RxCore_GUI_Symbols.onSymbolReceived(symbolinfo);
                }

            }else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }
        };

        xhr.send(urlEncodedData);
    }



    function getGUID(markupobject){
        //GetGUID
        var XMLGetGUID = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetGUID += "<RxViewServer>";
        XMLGetGUID += "<Command>GetGUID</Command>";
        XMLGetGUID += "<LicenseID>" + LicenseID + "</LicenseID>";
        XMLGetGUID += "</RxViewServer>";

        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        try {
            xhr.open('POST', xmlurl, false);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        xhr.onload = function (e) {
            if (this.status == 200) {
                var GUID = this.responseText;
                markupobject.setUniqueID(GUID);

            }
        };

        xhr.send(XMLGetGUID);

    }

    function modifyMarkup(GUID,markupxml){


        var xmlmarkupobj = findUniqueMarkup(GUID);
        if(xmlmarkupobj.isempty){
            return;
        }

        MarkupSaveStateByref(xmlmarkupobj);
        //MarkupSaveStateGUID(GUID);

        var xmldoc = parseXML(markupxml);

        if (xmldoc.getElementsByTagName('FileVersion') != null && xmldoc.getElementsByTagName('FileVersion').length != 0) {
            var fileVersion = xmldoc.getElementsByTagName('FileVersion')[0].firstChild.nodeValue;
        }

        if (xmldoc.getElementsByTagName('Entity') != null) {
            var markupentityobj = xmldoc.getElementsByTagName('Entity');
            for (var i = 0; i < markupentityobj.length; i++) {
                //var markupType = markupentityobj[i].getElementsByTagName("Type")[0].firstChild.nodeValue;
                //var markupSubtype = markupentityobj[i].getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                //if (markupentityobj[i].getElementsByTagName("Alternative")[0].firstChild.nodeValue != undefined)

                if ( markupentityobj[i].getElementsByTagName('HaveLeader')[0] != undefined) {
                    var bhasArrow = (parseInt(markupentityobj[i].getElementsByTagName('HaveLeader')[0].firstChild.nodeValue) == 1);
                }

                if(bhasArrow){
                    if (markupentityobj[i].getElementsByTagName('Entity')[0] != undefined){
                        var arrowleader = markupentityobj[i].getElementsByTagName("Entity")[0];
                        //var leadermarkupType = arrowleader.getElementsByTagName("Type")[0].firstChild.nodeValue;
                        //var leadermarkupSubtype = arrowleader.getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                        var leadermarkupAlternative = arrowleader.getElementsByTagName("Alternative")[0].firstChild.nodeValue;
                        //var leadermarkupID = !arrowleader.getAttribute('ID') ? null : arrowleader.getAttribute('ID');
                        //leadermarkupType = parseInt(leadermarkupType);
                        //leadermarkupSubtype = parseInt(leadermarkupSubtype);
                        //leadermarkupAlternative = parseInt(leadermarkupAlternative);
                        //var leaderxmlmarkupobj = new MarkupObject(leadermarkupType, leadermarkupSubtype, leadermarkupAlternative);
                        //var blOK = leaderxmlmarkupobj.SetfromXML(DocObj,arrowleader, fileVersion);
                        var blOK = xmlmarkupobj.SetfromXML(DocObj,arrowleader, fileVersion);


                        if(blOK){
                            markupentityobj[i].removeChild(arrowleader);
                            xmlmarkupobj.alternative = leadermarkupAlternative;

                            if(xmlmarkupobj.textBoxConnected != null){
                                xmlmarkupobj = xmlmarkupobj.textBoxConnected;
                            }
                            //var markupfiles = DocRef.getnummarkupfiles();
                            //var received = DocRef.getmarkupfilesreceived();
                            //var lastmarkup = (i == markupentityobj.length - 1 && (markupfiles == received));

                            //leaderxmlmarkupobj.savemetolistLoad(DocObj,false);

                        }

                    }

                }

                var markupAlternative = markupentityobj[i].getElementsByTagName("Alternative")[0].firstChild.nodeValue;
                markupAlternative = parseInt(markupAlternative);
                //var markupID = !markupentityobj[i].getAttribute('ID') ? null : markupentityobj[i].getAttribute('ID');
                //markupType = parseInt(markupType);
                //markupSubtype = parseInt(markupSubtype);
                //markupAlternative = parseInt(markupAlternative);
                //var xmlmarkupobj = new MarkupObject(markupType, markupSubtype, markupAlternative);
                //xmlmarkupobj.markupID = markupID;

                var bOK = xmlmarkupobj.SetfromXML(DocObj, markupentityobj[i], fileVersion);
                if (bOK) {

                    xmlmarkupobj.alternative = markupAlternative;

                    //xmlmarkupobj.savemetolist(true);
                }

            }

            /* Andriy call callback only once */

            if (xmlmarkupobj) xmlmarkupobj.notify();

            if (markupentityobj.length == 0) {
                if (RxCore_GUI_Markuplist != undefined) {
                    RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
                    /* Andriy */
                    // RxCore_GUI_Markuplist.notify();
                }

            }

            drawmarkupAll(cntximg);

        }
    }

    function addMarkup(markupxml){

        var xmldoc = parseXML(markupxml);


        if (xmldoc.getElementsByTagName('FileVersion') != null && xmldoc.getElementsByTagName('FileVersion').length != 0) {
            var fileVersion = xmldoc.getElementsByTagName('FileVersion')[0].firstChild.nodeValue;

        }

        if (xmldoc.getElementsByTagName('Entity') != null) {
            var markupentityobj = xmldoc.getElementsByTagName('Entity');
            for (var i = 0; i < markupentityobj.length; i++) {
                var markupType = markupentityobj[i].getElementsByTagName("Type")[0].firstChild.nodeValue;
                var markupSubtype = markupentityobj[i].getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                var markupAlternative = markupentityobj[i].getElementsByTagName("Alternative")[0].firstChild.nodeValue;

                var markupID = !markupentityobj[i].getAttribute('ID') ? null : markupentityobj[i].getAttribute('ID');

                if ( markupentityobj[i].getElementsByTagName('HaveLeader')[0] != undefined) {
                    var bhasArrow = (parseInt(markupentityobj[i].getElementsByTagName('HaveLeader')[0].firstChild.nodeValue) == 1);
                }

                if(bhasArrow){
                    if (markupentityobj[i].getElementsByTagName('Entity')[0] != undefined){
                        var arrowleader = markupentityobj[i].getElementsByTagName("Entity")[0];
                        var leadermarkupType = arrowleader.getElementsByTagName("Type")[0].firstChild.nodeValue;
                        var leadermarkupSubtype = arrowleader.getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                        var leadermarkupAlternative = arrowleader.getElementsByTagName("Alternative")[0].firstChild.nodeValue;
                        var leadermarkupID = !arrowleader.getAttribute('ID') ? null : arrowleader.getAttribute('ID');
                        leadermarkupType = parseInt(leadermarkupType);
                        leadermarkupSubtype = parseInt(leadermarkupSubtype);
                        leadermarkupAlternative = parseInt(leadermarkupAlternative);
                        var leaderxmlmarkupobj = new MarkupObject(leadermarkupType, leadermarkupSubtype, leadermarkupAlternative);
                        var blOK = leaderxmlmarkupobj.SetfromXML(DocObj,arrowleader, fileVersion);

                        if(blOK){
                            markupentityobj[i].removeChild(arrowleader);
                            //var markupfiles = DocRef.getnummarkupfiles();
                            //var received = DocRef.getmarkupfilesreceived();
                            //var lastmarkup = (i == markupentityobj.length - 1 && (markupfiles == received));

                            leaderxmlmarkupobj.savemetolistLoad(DocObj,false);

                        }

                    }

                }

                markupType = parseInt(markupType);
                markupSubtype = parseInt(markupSubtype);
                markupAlternative = parseInt(markupAlternative);



                var xmlmarkupobj = new MarkupObject(markupType, markupSubtype, markupAlternative);
                xmlmarkupobj.markupID = markupID;


                var bOK = xmlmarkupobj.SetfromXML(DocObj,markupentityobj[i], fileVersion);
                if (bOK) {

                    if(blOK && bhasArrow && leaderxmlmarkupobj != null){
                        xmlmarkupobj.bhasArrow = bhasArrow;
                        xmlmarkupobj.markupArrowConnected = leaderxmlmarkupobj;
                        leaderxmlmarkupobj.bisTextArrow = true;
                        leaderxmlmarkupobj.textBoxConnected = xmlmarkupobj;
                        blOK = false;
                        bhasArrow = false;
                    }


                    xmlmarkupobj.savemetolistLoad(DocObj);
                }

                //xmlmarkupobj.markupnumber = parseInt(markupID);

                if (markupentityobj[i].getElementsByTagName("Signature")[0].firstChild.nodeValue != undefined){
                    var sign = markupentityobj[i].getElementsByTagName("Signature")[0].firstChild.nodeValue;

                    if (markupentityobj[i].getElementsByTagName("Name")[0].firstChild.nodeValue != undefined){
                        var dispname = markupentityobj[i].getElementsByTagName("Name")[0].firstChild.nodeValue;
                    }

                    if (sign && dispname){
                        if (GetDisplayName(sign) == 'default user'){
                            numUsers = Userlist.length;
                            var layerColor = getMarkupLayerColor(xmlmarkupobj.layer)
                            Userlist[numUsers] = new Users(sign, dispname, xmlmarkupobj.layer, layerColor);
                            numUsers = Userlist.length;
                        }

                    }

                }


            }

            /* Andriy call callback only once */
            /*for(var mc = 0; mc < DocObj.markuplist.length; mc++){
                if(DocObj.markuplist[mc].bhasArrow && !isNaN(DocObj.markuplist[mc].markupArrowConnected)){
                    var markupnum = DocObj.markuplist[mc].markupArrowConnected;
                    for(var ac = 0; ac < DocObj.markuplist.length; ac++){
                        if (DocObj.markuplist[ac].markupnumber == markupnum){
                            DocObj.markuplist[mc].markupArrowConnected = DocObj.markuplist[ac];
                        }
                    }
                }

            }*/

            //connect markup text box with leader arrow



            if (xmlmarkupobj) xmlmarkupobj.notify();

            if (markupentityobj.length == 0) {
                if (RxCore_GUI_Markuplist != undefined) {
                    RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist,DocObj.bActive);
                    /* Andriy */
                    // RxCore_GUI_Markuplist.notify();
                }

            }

            /*if (RxCore_GUI_Users != undefined) {
                RxCore_GUI_Users.setUserlist(Userlist);
            }*/

            /*if (Rxcore_GUI_fileLoadComplete != undefined) {
                Rxcore_GUI_fileLoadComplete.loadComplete(MarkupFile);
            }*/

            drawmarkupAll(cntximg);

        }

    }

    function getMarkup(MarkupFile, DocRef) {

        var PageObj;
        var xhr = new XMLHttpRequest();

        xhr.withCredentials = bUseCredentials;

        try {
            xhr.open('GET', MarkupFile, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            //xhr.responseType = 'text/xml';
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }


        xhr.onload = function (e) {


            if (this.status == 200) {
                //console.log(this.responseText);

                var MarkupFilePath = 0;
                var i = 0;
                var xmlDoc = this.responseXML;
                if (xmlDoc == null || xmlDoc.documentElement == null) {
                    xmlDoc = $.parseXML(this.responseText).documentElement;
                }

                //var markupType = markupentityobj[i].getElementsByTagName("Type")[0].firstChild.nodeValue;
                DocRef.setmarkupfilesreceived();

                //DocObj = new DocumentObject(xmlDoc);
                if (xmlDoc.getElementsByTagName('FileVersion') != null && xmlDoc.getElementsByTagName('FileVersion').length != 0) {
                    var fileVersion = xmlDoc.getElementsByTagName('FileVersion')[0].firstChild.nodeValue;

                }

                if (xmlDoc.getElementsByTagName('User') != null && xmlDoc.getElementsByTagName('User').length != 0) {
                    var UserID = xmlDoc.getElementsByTagName('User');
                    for (i = 0; i < UserID.length; i++) {

                        var MarkupUserDispName = UserID[i].getElementsByTagName("Name")[0].firstChild.nodeValue;
                        var MarkupUserID = UserID[i].getElementsByTagName("ID")[0].firstChild.nodeValue;
                        if (UserID[i].getElementsByTagName("Layer")[0] != undefined) {
                            var MarkupUserLayer = UserID[i].getElementsByTagName("Layer")[0].firstChild.nodeValue;
                        } else {
                            MarkupUserLayer = markuplayer;
                        }
                        if (UserID[i].getElementsByTagName("Color")[0] != undefined) {
                            var MarkupUserColor = UserID[i].getElementsByTagName("Color")[0].firstChild.nodeValue;
                        } else {
                            MarkupUserColor = markupcolor;
                        }


                        //var MarkupUserLayer = UserID[i].getElementsByTagName("Layer")[0].firstChild.nodeValue;
                        //var MarkupUserColor = UserID[i].getElementsByTagName("Color")[0].firstChild.nodeValue;


                        if (Userlist[0].Signature == MarkupUserID) {
                            //Userlist[0] = new Users(MarkupUserID,MarkupUserDispName,MarkupUserLayer,MarkupUserColor);
                            //numUsers++;
                        } else {
                            Userlist[numUsers] = new Users(MarkupUserID, MarkupUserDispName, MarkupUserLayer, MarkupUserColor);
                            numUsers++;
                        }
                    }
                } else {
                    if (xmlDoc.getElementsByTagName('Name') != null) {
                        var sign = xmlDoc.getElementsByTagName('Name');
                        if (Userlist[0].Signature != sign[0].firstChild.nodeValue) {

                            Userlist[numUsers] = new Users(sign[0].firstChild.nodeValue, sign[0].firstChild.nodeValue, markuplayer, markupcolor);
                            numUsers++;

                        }
                    }
                }
                if (xmlDoc.getElementsByTagName('Entity') != null) {
                    var markupentityobj = xmlDoc.getElementsByTagName('Entity');
                    for (i = 0; i < markupentityobj.length; i++) {
                        var markupType = markupentityobj[i].getElementsByTagName("Type")[0].firstChild.nodeValue;
                        var markupSubtype = markupentityobj[i].getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                        var markupAlternative = markupentityobj[i].getElementsByTagName("Alternative")[0].firstChild.nodeValue;
                        var markupID = !markupentityobj[i].getAttribute('ID') ? null : markupentityobj[i].getAttribute('ID');

                        if ( markupentityobj[i].getElementsByTagName('HaveLeader')[0] != undefined) {
                            var bhasArrow = (parseInt(markupentityobj[i].getElementsByTagName('HaveLeader')[0].firstChild.nodeValue) == 1);
                        }

                        if(bhasArrow){
                            if (markupentityobj[i].getElementsByTagName('Entity')[0] != undefined){
                                var arrowleader = markupentityobj[i].getElementsByTagName("Entity")[0];
                                var leadermarkupType = arrowleader.getElementsByTagName("Type")[0].firstChild.nodeValue;
                                var leadermarkupSubtype = arrowleader.getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                                var leadermarkupAlternative = arrowleader.getElementsByTagName("Alternative")[0].firstChild.nodeValue;
                                var leadermarkupID = !arrowleader.getAttribute('ID') ? null : arrowleader.getAttribute('ID');
                                leadermarkupType = parseInt(leadermarkupType);
                                leadermarkupSubtype = parseInt(leadermarkupSubtype);
                                leadermarkupAlternative = parseInt(leadermarkupAlternative);
                                var leaderxmlmarkupobj = new MarkupObject(leadermarkupType, leadermarkupSubtype, leadermarkupAlternative);
                                var blOK = leaderxmlmarkupobj.SetfromXML(DocRef,arrowleader, fileVersion);

                                if(blOK){
                                    markupentityobj[i].removeChild(arrowleader);
                                    //var markupfiles = DocRef.getnummarkupfiles();
                                    //var received = DocRef.getmarkupfilesreceived();
                                    //var lastmarkup = (i == markupentityobj.length - 1 && (markupfiles == received));
                                    leaderxmlmarkupobj.savemetolistLoad(DocRef,false);

                                }

                            }

                        }

                        markupType = parseInt(markupType);
                        markupSubtype = parseInt(markupSubtype);
                        markupAlternative = parseInt(markupAlternative);
                        var xmlmarkupobj = new MarkupObject(markupType, markupSubtype, markupAlternative);
                        xmlmarkupobj.markupID = markupID;


                        var bOK = xmlmarkupobj.SetfromXML(DocRef,markupentityobj[i], fileVersion);
                        if (bOK) {
                            if(blOK && bhasArrow && leaderxmlmarkupobj != null){
                                xmlmarkupobj.bhasArrow = bhasArrow;
                                xmlmarkupobj.markupArrowConnected = leaderxmlmarkupobj;

                                leaderxmlmarkupobj.bisTextArrow = true;
                                leaderxmlmarkupobj.textBoxConnected = xmlmarkupobj;

                                blOK = false;
                                bhasArrow = false;
                            }
                            var markupfiles = DocRef.getnummarkupfiles();
                            var received = DocRef.getmarkupfilesreceived();
                            var lastmarkup = (i == markupentityobj.length - 1 && (markupfiles == received));
                            xmlmarkupobj.savemetolistLoad(DocRef,lastmarkup);
                        }
                        //xmlmarkupobj.markupnumber = parseInt(markupID);
                    }

                    /* Andriy call callback only once */
                    /*if(lastmarkup){
                        for(var mc = 0; mc < DocObj.markuplist.length; mc++){
                            if(DocObj.markuplist[mc].bhasArrow && !isNaN(DocObj.markuplist[mc].markupArrowConnected)){
                                var markupnum = DocObj.markuplist[mc].markupArrowConnected;
                                for(var ac = 0; ac < DocObj.markuplist.length; ac++){
                                    if (DocObj.markuplist[ac].markupnumber == markupnum){
                                        DocObj.markuplist[mc].markupArrowConnected = DocObj.markuplist[ac];
                                    }
                                }
                            }

                        }

                    }*/


                    if (xmlmarkupobj) xmlmarkupobj.notify();

                    if (markupentityobj.length == 0) {
                        if (RxCore_GUI_Markuplist != undefined) {
                            RxCore_GUI_Markuplist.setMarkupList(DocRef.markuplist,DocRef.bActive);
                            /* Andriy */
                            // RxCore_GUI_Markuplist.notify();
                        }

                    }

                    if (RxCore_GUI_Users != undefined) {
                        RxCore_GUI_Users.setUserlist(Userlist, DocRef.bActive);
                    }

                    if (Rxcore_GUI_fileLoadComplete != undefined) {
                        //Rxcore_GUI_fileLoadComplete.loadComplete(MarkupFile);
                    }

                    drawmarkupAll(cntximg);
                    /*if(last){
                        if (Rxcore_GUI_markupLoadComplete != undefined) {
                            Rxcore_GUI_markupLoadComplete.loadComplete(DocObj.markuplist, DocObj.fileindex);
                        }
                    }*/

                }

            } else if (this.status == 404) {
                alert("XML could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            } else if (this.status == 501) {
                //alert("Markup could not be loaded");
            }


        };

        xhr.send();


    }

    function parseXML(text) {

        var doc;

        if (window.ActiveXObject) {
            doc = new ActiveXObject("Microsoft.XMLDOM");
            doc.async = "false";
            doc.loadXML(text);
        } else if (window.DOMParser) {
            var parser = new DOMParser();
            doc = parser.parseFromString(text, "text/xml");
        } else {
            throw new Error("Cannot parse XML");
        }
        return doc;
    }

    /* Andriy: According to ECMAScript standard,function statement not in the top level prohibited */
    /* function f() {
     function g() {
     // IT IS OK!
     }
     }

     function f() {
     if () {
     function g() {
     // NOT OK! As it is inside if statement, as it was with createAndAppendElement below.
     }
     }
     }
     It does not change logic, just lift up function declaration to ensure it works correctly in modern browsers.
     Update: Lift it up to the top level as it was declared twice inside sendMarkup and
     */

    function createAppendElementret(source, name, value){
        var node = source.ownerDocument.createElement(name);
        node.appendChild(source.ownerDocument.createTextNode(value));
        source.appendChild(node);
        return node;
    }

    function createAndAppendElement(source, name, value) {
        var node = source.ownerDocument.createElement(name);
        node.appendChild(source.ownerDocument.createTextNode(value));
        source.appendChild(node);
    }

    function createxmlmarkup(markupsave,consolidate,includeall,signature, dispname){
        var curmarkup = 0;
        var savetime = new Date().getTime();
        var internalscale = 1;
        var fixedscale = 1;
        var imagescale = 1;
        var leaders = [];
        var leaderobj = {};

        var markupxmltxt = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";

        markupxmltxt += "<RasterexMarkup>\n";
        markupxmltxt += "<Header>\n";
        markupxmltxt += "<FileVersion>C366</FileVersion>\n";
        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            markupxmltxt += "<Format>pdfjs</Format>\n";
        } else if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            markupxmltxt += "<Format>vector</Format>\n";
        } else {
            markupxmltxt += "<Format>image</Format>\n";
        }
        markupxmltxt += "<Scale>1.0000</Scale>\n";
        markupxmltxt += "<OrigoX>0.0000</OrigoX>\n";
        markupxmltxt += "<OrigoY>0.0000</OrigoY>\n";
        markupxmltxt += "<DirectionY>1</DirectionY>\n";
        markupxmltxt += "<DirectionX>1</DirectionX>\n";
        markupxmltxt += "</Header>\n";
        markupxmltxt += "<Users>\n";
        markupxmltxt += "<User>\n";
        markupxmltxt += "<ID>" + signature + "</ID>\n";
        markupxmltxt += "<Name>" + dispname + "</Name>\n";
        markupxmltxt += "<Color>" + markupcolor + "</Color>\n";
        markupxmltxt += "<Layer>" + markuplayer + "</Layer>\n";
        markupxmltxt += "</User>\n";
        markupxmltxt += "</Users>\n";
        markupxmltxt += "<Entities/></RasterexMarkup>\n";
        //jquery function
        //var markupxml = $.parseXML(markupxmltxt);
        var markupxml = parseXML(markupxmltxt);

        //var found = false;
        var id = -1;


        if (DocObj.markuplist.length > 0) {


            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
                if (DocObj.markuplist[curmarkup] != null) {

                    var pagenumber = DocObj.markuplist[curmarkup].pagenumber;

                    var pageobject = DocObj.getPageObject(pagenumber);
                    var bpageExist = (pageobject != undefined);


                    if ((DocObj.markuplist[curmarkup].signature == signature || includeall) && (DocObj.markuplist[curmarkup].display || markupsave) && (DocObj.markuplist[curmarkup].consolidated || !consolidate) && bpageExist) {
                        if (pageobject.usepdfjs || pageobject.usevectorxml) {
                            internalscale = DocObj.markuplist[curmarkup].scaling;
                        }else{
                            imagescale = DocObj.markuplist[curmarkup].scaling;
                        }

                        fixedscale = pageobject.fixedScale;
                        //var fixedscalefactor = DocObj.pages[DocObj.currentpage].fixedscaleFactor;

                        var bRedact = (DocObj.markuplist[curmarkup].type == 3 && DocObj.markuplist[curmarkup].subtype == 4);

                        var entityNode = markupxml.createElement("Entity");

                        entityNode.setAttribute("ID", DocObj.markuplist[curmarkup].markupnumber);
                        if(DocObj.markuplist[curmarkup].type == 11){

                            var imagenode = createAppendElementret(entityNode, "Image", getBase64Image(DocObj.markuplist[curmarkup].image));
                            //type="png" encoding="base64"
                            imagenode.setAttribute("type", "png");
                            imagenode.setAttribute("encoding", "base64");

                            /*if(DocObj.markuplist[curmarkup].subtype == 1){
                             entityNode.setAttribute("abspath", 1);
                             }else{
                             entityNode.setAttribute("abspath", 0);
                             }*/
                        }

                        createAndAppendElement(entityNode, "UniqueID", DocObj.markuplist[curmarkup].uniqueID);
                        if(DocObj.markuplist[curmarkup].type == 11 && DocObj.markuplist[curmarkup].imagehref != ""){
                            createAndAppendElement(entityNode, "Imagehref", DocObj.markuplist[curmarkup].imagehref);
                        }
                        createAndAppendElement(entityNode, "Type", DocObj.markuplist[curmarkup].type);
                        createAndAppendElement(entityNode, "Subtype", DocObj.markuplist[curmarkup].subtype);
                        createAndAppendElement(entityNode, "Alternative", DocObj.markuplist[curmarkup].alternative);
                        createAndAppendElement(entityNode, "Redaction", DocObj.markuplist[curmarkup].bRedact ? 1:0);
                        createAndAppendElement(entityNode, "Layer", DocObj.markuplist[curmarkup].layer);
                        createAndAppendElement(entityNode, "Rotation", DocObj.markuplist[curmarkup].rotation);
                        createAndAppendElement(entityNode, "TextRotation", DocObj.markuplist[curmarkup].textrotate);
                        createAndAppendElement(entityNode, "PageRotation", DocObj.markuplist[curmarkup].pagerotation);
                        createAndAppendElement(entityNode, "FileName", DocObj.markuplist[curmarkup].documentName);
                        createAndAppendElement(entityNode, "Layout", pageobject.LayoutName);
                        createAndAppendElement(entityNode, "View", pagenumber);
                        createAndAppendElement(entityNode, "ViewName", pageobject.PageName);
                        createAndAppendElement(entityNode, "Handle", DocObj.markuplist[curmarkup].markupnumber);
                        //createAndAppendElement(entityNode, "Color", DocObj.markuplist[curmarkup].color);
                        createAndAppendElement(entityNode, "FillColor", DocObj.markuplist[curmarkup].fillcolor);

                        if(bRedact){
                            createAndAppendElement(entityNode, "LineColor", DocObj.markuplist[curmarkup].fillcolor);
                        }else{
                            createAndAppendElement(entityNode, "LineColor", DocObj.markuplist[curmarkup].strokecolor);
                        }

                        createAndAppendElement(entityNode, "TextColor", DocObj.markuplist[curmarkup].textcolor);
                        createAndAppendElement(entityNode, "Transparency", DocObj.markuplist[curmarkup].transparency);
                        createAndAppendElement(entityNode, "Consolidated", DocObj.markuplist[curmarkup].consolidated ? 1:0);
                        createAndAppendElement(entityNode, "HaveLink", DocObj.markuplist[curmarkup].bhaveLink ? 1:0);

                        createAndAppendElement(entityNode, "HaveLeader", DocObj.markuplist[curmarkup].bhasArrow ? 1:0);
                        if (DocObj.markuplist[curmarkup].bhasArrow && DocObj.markuplist[curmarkup].markupArrowConnected != null){

                            createAndAppendElement(entityNode, "LeaderReference", DocObj.markuplist[curmarkup].markupArrowConnected.markupnumber);
                            //leaders.push({entity : entityNode, mnumber : DocObj.markuplist[curmarkup].markupnumber});
                            for(var lcount = 0; lcount < leaders.length; lcount++){
                                if(leaders[lcount].mnumber == DocObj.markuplist[curmarkup].markupArrowConnected.markupnumber){
                                    entityNode.appendChild(leaders[lcount].entity);
                                }
                            }

                        }

                        createAndAppendElement(entityNode, "FixedScale", bUseFixedScale ? 1:0);
                        createAndAppendElement(entityNode, "LineStyleScale", fixedscale);
                        createAndAppendElement(entityNode, "LinkURL", DocObj.markuplist[curmarkup].linkURL);


                        var fontNode = markupxml.createElement("Font");
                        fontNode.setAttribute("facename", DocObj.markuplist[curmarkup].font.fontName);
                        //fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height);
                        if (pageobject.usepdfjs || pageobject.usevectorxml) {
                            if(DocObj.markuplist[curmarkup].type != 12){
                                if(bUseFixedScale){
                                    fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height / fixedscale);
                                }else{
                                    fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height / internalscale);
                                }
                            }else{
                                fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height / internalscale);
                            }



                            /*if (DocObj.markuplist[curmarkup].type != 12){
                                var fontscale = DocObj.markuplist[curmarkup].font.height / internalscale;
                            }else{
                                fontscale = DocObj.markuplist[curmarkup].font.height;
                            }*/

                            /*if(bUseFixedScale){
                                fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height / fixedscale);
                            }else{

                            }*/

                        } else {
                            if(DocObj.markuplist[curmarkup].type != 12){
                                if(bUseFixedScale){
                                    fontNode.setAttribute("height", (DocObj.markuplist[curmarkup].font.height / fixedscale) * imagescale);
                                }else{
                                    fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height);
                                }

                            }else{
                                fontNode.setAttribute("height", DocObj.markuplist[curmarkup].font.height);

                            }



                            /*if(bUseFixedScale &&  DocObj.markuplist[curmarkup].type != 12){
                                var fontscale = (DocObj.markuplist[curmarkup].font.height / fixedscale) * imagescale;

                            }else{
                                var fontscale = DocObj.markuplist[curmarkup].font.height;

                            }*/

                        }

                        //fontNode.setAttribute("height", fontscale);
                        fontNode.setAttribute("bold", DocObj.markuplist[curmarkup].font.bold ? 1 : 0);
                        fontNode.setAttribute("italic", DocObj.markuplist[curmarkup].font.italic ? 1 : 0);
                        entityNode.appendChild(fontNode);


                        /*createAndAppendElement(entityNode, "FontName", DocObj.markuplist[curmarkup].fontname);
                         if (DocObj.pages[DocObj.currentpage].usepdfjs || DocObj.pages[DocObj.currentpage].usevectorxml) {
                         createAndAppendElement(entityNode, "FontHeight", DocObj.markuplist[curmarkup].textheight / internalscale);
                         } else {
                         createAndAppendElement(entityNode, "FontHeight", DocObj.markuplist[curmarkup].textheight);
                         }*/

                        createAndAppendElement(entityNode, "Text", DocObj.markuplist[curmarkup].text == "" ? "." : DocObj.markuplist[curmarkup].text);
                        createAndAppendElement(entityNode, "SmallText", DocObj.markuplist[curmarkup].smalltext == "" ? "." : DocObj.markuplist[curmarkup].smalltext);
                        createAndAppendElement(entityNode, "DimText", DocObj.markuplist[curmarkup].dimtext == "" ? "." : DocObj.markuplist[curmarkup].dimtext);


                        createAndAppendElement(entityNode, "CustomLabelOn", DocObj.markuplist[curmarkup].busecustomlabel ? 1:0);
                        createAndAppendElement(entityNode, "CustomLabelText", DocObj.markuplist[curmarkup].customlabeltext == "" ? "." : DocObj.markuplist[curmarkup].customlabeltext);

                        createAndAppendElement(entityNode, "TextWidth", DocObj.markuplist[curmarkup].textwidth);
                        createAndAppendElement(entityNode, "Signature", DocObj.markuplist[curmarkup].signature);
                        var displayname = GetDisplayName(DocObj.markuplist[curmarkup].signature);
                        createAndAppendElement(entityNode, "Name", displayname);


                        createAndAppendElement(entityNode, "TimeStamp", DocObj.markuplist[curmarkup].timestamp);
                        createAndAppendElement(entityNode, "Scaling", DocObj.markuplist[curmarkup].scaling);

                        if (pageobject.usepdfjs || pageobject.usevectorxml) {
                            createAndAppendElement(entityNode, "Xoffset", DocObj.markuplist[curmarkup].xoffset / internalscale);
                            createAndAppendElement(entityNode, "Yoffset", DocObj.markuplist[curmarkup].yoffset / internalscale);

                        } else {
                            createAndAppendElement(entityNode, "Xoffset", DocObj.markuplist[curmarkup].xoffset);
                            createAndAppendElement(entityNode, "Yoffset", DocObj.markuplist[curmarkup].yoffset);
                        }

                        var localLinewidth = DocObj.markuplist[curmarkup].linewidth;


                        if (pageobject.usepdfjs || pageobject.usevectorxml) {
                            if(bRedact){
                                createAndAppendElement(entityNode, "LineWidth", 1);
                            }else{
                                if(bUseFixedScale){

                                    //var linescale = ( localLinewidth / fixedscale) / internalscale;
                                    var linescale = ( localLinewidth / fixedscale);

                                    //console.log(fixedscale);
                                    //console.log(linescale);

                                    createAndAppendElement(entityNode, "LineWidth", linescale);



                                }else{
                                    createAndAppendElement(entityNode, "LineWidth", localLinewidth / internalscale);
                                }

                            }

                        } else {
                            //createAndAppendElement(entityNode, "LineWidth", DocObj.markuplist[curmarkup].linewidth);
                            if(bRedact){
                                createAndAppendElement(entityNode, "LineWidth", 1);
                            }else{
                                if(bUseFixedScale){
                                    var linescale = (localLinewidth / fixedscale) * imagescale;
                                    createAndAppendElement(entityNode, "LineWidth", linescale);

                                }else{
                                    createAndAppendElement(entityNode, "LineWidth", localLinewidth);
                                }

                            }

                        }

                        var localArrowSize = DocObj.markuplist[curmarkup].arrowlength - DocObj.markuplist[curmarkup].linewidth;
                        createAndAppendElement(entityNode, "ArrowSize", localArrowSize);

                        createAndAppendElement(entityNode, "LineStyle", DocObj.markuplist[curmarkup].linestyle);

                        createAndAppendElement(entityNode, "MainImageScaling", pageobject.MainImageScaling);
                        createAndAppendElement(entityNode, "MainImageOffsetX", pageobject.MainImageOffsetX);
                        createAndAppendElement(entityNode, "MainImageOffsetY", pageobject.MainImageOffsetY);

                        createAndAppendElement(entityNode, "DocScale", DocObj.markuplist[curmarkup].docdscale);
                        createAndAppendElement(entityNode, "DocOffsetX", DocObj.markuplist[curmarkup].docdx);
                        createAndAppendElement(entityNode, "DocOffsetY", DocObj.markuplist[curmarkup].docdy);

                        if(DocObj.markuplist[curmarkup].type != 0 ){
                            if (DocObj.markuplist[curmarkup].points.length != -1) {
                                var pointsNode = markupxml.createElement("Points");
                                for (var i = 0; i < DocObj.markuplist[curmarkup].points.length; i++) {
                                    var pointNode = markupxml.createElement("Point");

                                    if (pageobject.usepdfjs || pageobject.usevectorxml) {
                                        var xpoint = (DocObj.markuplist[curmarkup].points[i].x - DocObj.markuplist[curmarkup].xoffset) / internalscale;
                                        var ypoint = (DocObj.markuplist[curmarkup].points[i].y - DocObj.markuplist[curmarkup].yoffset) / internalscale;

                                        pointNode.setAttribute("x", xpoint);
                                        pointNode.setAttribute("y", ypoint);

                                    } else {
                                        pointNode.setAttribute("x", DocObj.markuplist[curmarkup].points[i].x);
                                        pointNode.setAttribute("y", DocObj.markuplist[curmarkup].points[i].y);

                                    }
                                    pointsNode.appendChild(pointNode);
                                }
                                entityNode.appendChild(pointsNode);
                            }
                        }else{
                            if (DocObj.markuplist[curmarkup].pointlist.length != 0) {
                                for(var j = 0; j < DocObj.markuplist[curmarkup].pointlist.length;j++){
                                    var linesNode = markupxml.createElement("Line");
                                    for (i = 0; i < DocObj.markuplist[curmarkup].pointlist[j].length; i++) {
                                        pointNode = markupxml.createElement("Point");
                                        if (pageobject.usepdfjs || pageobject.usevectorxml) {
                                            xpoint = (DocObj.markuplist[curmarkup].pointlist[j][i].x - DocObj.markuplist[curmarkup].xoffset) / internalscale;
                                            ypoint = (DocObj.markuplist[curmarkup].pointlist[j][i].y - DocObj.markuplist[curmarkup].yoffset) / internalscale;

                                            pointNode.setAttribute("x", xpoint);
                                            pointNode.setAttribute("y", ypoint);

                                        } else {
                                            pointNode.setAttribute("x", DocObj.markuplist[curmarkup].pointlist[j][i].x);
                                            pointNode.setAttribute("y", DocObj.markuplist[curmarkup].pointlist[j][i].y);

                                        }
                                        linesNode.appendChild(pointNode);
                                    }
                                    entityNode.appendChild(linesNode);
                                }


                            }

                        }

                        if(DocObj.markuplist[curmarkup].type == 7){

                            if (pageobject.usepdfjs || pageobject.usevectorxml) {
                                createAndAppendElement(entityNode, "LeaderLineOffset", DocObj.markuplist[curmarkup].leaderoffset / internalscale);
                            }else{
                                createAndAppendElement(entityNode, "LeaderLineOffset", DocObj.markuplist[curmarkup].leaderoffset);
                            }

                        }

                        if(DocObj.markuplist[curmarkup].type == 8){
                            if (pageobject.usepdfjs || pageobject.usevectorxml) {
                                createAndAppendElement(entityNode, "LabelOffsetX", DocObj.markuplist[curmarkup].labeloffsetx / internalscale);
                                createAndAppendElement(entityNode, "LabelOffsetY", DocObj.markuplist[curmarkup].labeloffsety / internalscale);

                            }else{
                                createAndAppendElement(entityNode, "LabelOffsetX", DocObj.markuplist[curmarkup].labeloffsetx);
                                createAndAppendElement(entityNode, "LabelOffsetY", DocObj.markuplist[curmarkup].labeloffsety);
                            }

                            createAndAppendElement(entityNode, "LabelColor", DocObj.markuplist[curmarkup].labelfillcolor);

                        }


                        var rectangleNode = markupxml.createElement("Rect");
                        if (pageobject.usepdfjs || pageobject.usevectorxml) {


                            var xorig = (DocObj.markuplist[curmarkup].x - DocObj.markuplist[curmarkup].xoffset) / internalscale;
                            var yorig = (DocObj.markuplist[curmarkup].y - DocObj.markuplist[curmarkup].yoffset) / internalscale;

                            var bCircle = (DocObj.markuplist[curmarkup].type == 4 && DocObj.markuplist[curmarkup].subtype);
                            if (DocObj.markuplist[curmarkup].type == 0 || DocObj.markuplist[curmarkup].type == 1 || DocObj.markuplist[curmarkup].type == 2 || DocObj.markuplist[curmarkup].type == 6 || DocObj.markuplist[curmarkup].type == 7 || DocObj.markuplist[curmarkup].type == 8 || bCircle) {
                                var worig = (DocObj.markuplist[curmarkup].w - DocObj.markuplist[curmarkup].xoffset) / internalscale;
                                var horig = (DocObj.markuplist[curmarkup].h - DocObj.markuplist[curmarkup].yoffset) / internalscale;

                            } else {
                                if (DocObj.markuplist[curmarkup].type == 9 && DocObj.markuplist[curmarkup].subtype == 0) {
                                    worig = (DocObj.markuplist[curmarkup].w / internalscale);
                                    horig = (DocObj.markuplist[curmarkup].textheight / internalscale);
                                } else if(DocObj.markuplist[curmarkup].type == 10 && bUseFixedScale) {
                                    worig = (DocObj.markuplist[curmarkup].w / fixedscale);
                                    horig = (DocObj.markuplist[curmarkup].h / fixedscale);
                                }else{
                                    worig = (DocObj.markuplist[curmarkup].w / internalscale);
                                    horig = (DocObj.markuplist[curmarkup].h / internalscale);
                                }
                            }


                            rectangleNode.setAttribute("x", xorig);
                            rectangleNode.setAttribute("y", yorig);
                            rectangleNode.setAttribute("w", worig);
                            rectangleNode.setAttribute("h", horig);

                        } else {
                            rectangleNode.setAttribute("x", DocObj.markuplist[curmarkup].x);
                            rectangleNode.setAttribute("y", DocObj.markuplist[curmarkup].y);
                            rectangleNode.setAttribute("w", DocObj.markuplist[curmarkup].w);
                            rectangleNode.setAttribute("h", DocObj.markuplist[curmarkup].h);

                        }


                        entityNode.appendChild(rectangleNode);

                        if(DocObj.markuplist[curmarkup].customattributes.length > 0){
                            var extendedNode = markupxml.createElement("Extended");
                            for (var cacnt = 0;cacnt < DocObj.markuplist[curmarkup].customattributes.length; cacnt++){
                                var sztagname  = DocObj.markuplist[curmarkup].customattributes[cacnt].name;
                                var sztagvalue  = DocObj.markuplist[curmarkup].customattributes[cacnt].value;
                                createAndAppendElement(extendedNode, sztagname, sztagvalue);
                            }
                            entityNode.appendChild(extendedNode);

                        }

                        if(DocObj.markuplist[curmarkup].type == 6 && DocObj.markuplist[curmarkup].subtype == 6){

                            //var leaders = [];
                            //var leaderobj = {};
                            leaders.push({entity : entityNode, mnumber : DocObj.markuplist[curmarkup].markupnumber});
                            //var leaderNode = entityNode;
                        }else{
                            markupxml.getElementsByTagName("Entities")[0].appendChild(entityNode);
                        }



                    }
                }
            } //end for
            //SendData(markupxml,"http://viewserver.rasterex.com/demo/markupserver.dll?webmarkupsave");
        } //end if

        return markupxml;
    }

    function createxmlmarkupentity(markupobj,Docref,bgetArrow){

        var arrowleader = null;

        if(!bgetArrow){
            if(markupobj.bisTextArrow && markupobj.textBoxConnected != null){
                arrowleader = createxmlmarkupentity(markupobj, Docref, true);
                markupobj = markupobj.textBoxConnected;
            }
        }

        var savetime = new Date().getTime();
        var internalscale = 1;
        var fixedscale = 1;
        var imagescale = 1;


        var markupxmltxt = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";
        markupxmltxt += "<RasterexMarkup>\n";
        markupxmltxt += "<FileVersion>C366</FileVersion>\n";
        markupxmltxt += "<Entities/></RasterexMarkup>\n";
        var markupxml = parseXML(markupxmltxt);

        if (markupobj != null) {
            var pagenumber = markupobj.pagenumber;

            var pageobject = Docref.getPageObject(pagenumber);

            if(pageobject == undefined){
                return;
            }

            if (pageobject.usepdfjs || pageobject.usevectorxml) {
                internalscale = markupobj.scaling;
            }else{
                imagescale = markupobj.scaling;
            }

            var bRedact = (markupobj.type == 3 && markupobj.subtype == 4);
            //fixedscale = markupobj.fixedScale;

            fixedscale = pageobject.fixedScale;


            var bpagenotloaded = (Docref.getPageObject(pagenumber) == undefined);
            var entityNode = markupxml.createElement("Entity");
            entityNode.setAttribute("ID", markupobj.markupnumber);
            if(markupobj.type == 11){

                var imagenode = createAppendElementret(entityNode, "Image", getBase64Image(markupobj.image));
                //type="png" encoding="base64"
                imagenode.setAttribute("type", "png");
                imagenode.setAttribute("encoding", "base64");

                /*if(markupobj.subtype == 1){
                 entityNode.setAttribute("abspath", 1);
                 }else{
                 entityNode.setAttribute("abspath", 0);
                 }*/
            }

            createAndAppendElement(entityNode, "UniqueID", markupobj.uniqueID);
            if(markupobj.type == 11 && markupobj.imagehref != ""){
                createAndAppendElement(entityNode, "Imagehref", markupobj.imagehref);
            }
            createAndAppendElement(entityNode, "Type", markupobj.type);
            createAndAppendElement(entityNode, "Subtype", markupobj.subtype);
            createAndAppendElement(entityNode, "Alternative", markupobj.alternative);
            createAndAppendElement(entityNode, "Redaction", markupobj.bRedact ? 1:0);
            createAndAppendElement(entityNode, "Layer", markupobj.layer);
            createAndAppendElement(entityNode, "Rotation", markupobj.rotation);
            createAndAppendElement(entityNode, "TextRotation", markupobj.textrotate);
            createAndAppendElement(entityNode, "PageRotation", markupobj.pagerotation);
            createAndAppendElement(entityNode, "FileName", markupobj.documentName);
            if (bpagenotloaded){
                createAndAppendElement(entityNode, "Layout", markupobj.layout);
            }else{
                createAndAppendElement(entityNode, "Layout", Docref.getPageObject(pagenumber).LayoutName);
            }
            createAndAppendElement(entityNode, "View", pagenumber);
            if (bpagenotloaded){
                createAndAppendElement(entityNode, "ViewName", pagenumber);
            }else{
                createAndAppendElement(entityNode, "ViewName", Docref.getPageObject(pagenumber).PageName);
            }
            createAndAppendElement(entityNode, "Handle", markupobj.markupnumber);
            //createAndAppendElement(entityNode, "Color", markupobj.color);
            createAndAppendElement(entityNode, "FillColor", markupobj.fillcolor);
            if(bRedact){
                createAndAppendElement(entityNode, "LineColor", markupobj.fillcolor);
            }else{
                createAndAppendElement(entityNode, "LineColor", markupobj.strokecolor);
            }



            createAndAppendElement(entityNode, "TextColor", markupobj.textcolor);
            createAndAppendElement(entityNode, "Transparency", markupobj.transparency);
            createAndAppendElement(entityNode, "Consolidated", markupobj.consolidated ? 1:0);
            createAndAppendElement(entityNode, "HaveLink", markupobj.bhaveLink ? 1:0);

            createAndAppendElement(entityNode, "HaveLeader", markupobj.bhasArrow ? 1:0);
            if (markupobj.bhasArrow && markupobj.markupArrowConnected != null){
                createAndAppendElement(entityNode, "LeaderReference", markupobj.markupArrowConnected.markupnumber);
                if(arrowleader != null){
                    entityNode.appendChild(arrowleader);
                }
            }

            createAndAppendElement(entityNode, "FixedScale", bUseFixedScale ? 1:0);
            createAndAppendElement(entityNode, "LineStyleScale", fixedscale);
            createAndAppendElement(entityNode, "LinkURL", markupobj.linkURL);

            /*var fontNode = markupxml.createElement("Font");
            fontNode.setAttribute("facename", markupobj.font.fontName);
            //fontNode.setAttribute("height", markupobj.font.height);
            if (Docref.pages[Docref.currentpage].usepdfjs || Docref.pages[Docref.currentpage].usevectorxml) {

                fontNode.setAttribute("height", markupobj.font.height / internalscale);
            } else {
                fontNode.setAttribute("height", markupobj.font.height);
            }*/
            //pagenumber
            var fontNode = markupxml.createElement("Font");
            fontNode.setAttribute("facename", markupobj.font.fontName);

            if (pageobject.usepdfjs || pageobject.usevectorxml) {
                if(markupobj.type != 12){
                    if(bUseFixedScale){
                        fontNode.setAttribute("height", markupobj.font.height / fixedscale);
                    }else{
                        fontNode.setAttribute("height", markupobj.font.height / internalscale);
                    }
                }else{
                    fontNode.setAttribute("height", markupobj.font.height / internalscale);
                }


            } else {
                if(markupobj.type != 12){
                    if(bUseFixedScale){
                        fontNode.setAttribute("height", (markupobj.font.height / fixedscale) * imagescale);
                    }else{
                        fontNode.setAttribute("height", markupobj.font.height);
                    }

                }else{
                    fontNode.setAttribute("height", markupobj.font.height);

                }

            }

            fontNode.setAttribute("bold", markupobj.font.bold ? 1 : 0);
            fontNode.setAttribute("italic", markupobj.font.italic ? 1 : 0);
            entityNode.appendChild(fontNode);


            /*createAndAppendElement(entityNode, "FontName", markupobj.fontname);
             if (Docref.pages[Docref.currentpage].usepdfjs || Docref.pages[Docref.currentpage].usevectorxml) {
             createAndAppendElement(entityNode, "FontHeight", markupobj.textheight / internalscale);
             } else {
             createAndAppendElement(entityNode, "FontHeight", markupobj.textheight);
             }*/
            createAndAppendElement(entityNode, "Text", markupobj.text == "" ? "." : markupobj.text);
            createAndAppendElement(entityNode, "SmallText", markupobj.smalltext == "" ? "." : markupobj.smalltext);
            createAndAppendElement(entityNode, "DimText", markupobj.dimtext == "" ? "." : markupobj.dimtext);

            createAndAppendElement(entityNode, "TextWidth", markupobj.textwidth);
            createAndAppendElement(entityNode, "Signature", markupobj.signature);
            var displayname = GetDisplayName(markupobj.signature);

            createAndAppendElement(entityNode, "Name", displayname);
            createAndAppendElement(entityNode, "TimeStamp", markupobj.timestamp);
            createAndAppendElement(entityNode, "Scaling", markupobj.scaling);

            if (pageobject.usepdfjs || pageobject.usevectorxml) {
                createAndAppendElement(entityNode, "Xoffset", markupobj.xoffset / internalscale);
                createAndAppendElement(entityNode, "Yoffset", markupobj.yoffset / internalscale);

            } else {
                createAndAppendElement(entityNode, "Xoffset", markupobj.xoffset);
                createAndAppendElement(entityNode, "Yoffset", markupobj.yoffset);

            }
            var localLinewidth = markupobj.linewidth;

            if (pageobject.usepdfjs || pageobject.usevectorxml) {

                if(bRedact){
                    createAndAppendElement(entityNode, "LineWidth", 1);
                }else{
                    if(bUseFixedScale){
                        var linescale = ( localLinewidth / fixedscale);
                        createAndAppendElement(entityNode, "LineWidth", linescale);
                    }else{
                        createAndAppendElement(entityNode, "LineWidth", localLinewidth / internalscale);
                    }

                }



            } else {
                createAndAppendElement(entityNode, "LineWidth", markupobj.linewidth);
                if(bRedact){
                    createAndAppendElement(entityNode, "LineWidth", 1);
                }else{
                    if(bUseFixedScale){
                        var linescale = (localLinewidth / fixedscale) * imagescale;
                        createAndAppendElement(entityNode, "LineWidth", linescale);

                    }else{
                        createAndAppendElement(entityNode, "LineWidth", localLinewidth);
                    }
                }

            }

           var localArrowSize = markupobj.arrowlength - markupobj.linewidth;
           createAndAppendElement(entityNode, "ArrowSize", localArrowSize);

            /*if (Docref.pages[Docref.currentpage].usepdfjs || Docref.pages[Docref.currentpage].usevectorxml) {
                if(bUseFixedScale){
                    createAndAppendElement(entityNode, "LineWidth", markupobj.linewidth / internalscale);
                }else{
                    createAndAppendElement(entityNode, "LineWidth", markupobj.linewidth / internalscale);
                }


            } else {
                createAndAppendElement(entityNode, "LineWidth", markupobj.linewidth);
            }*/

            createAndAppendElement(entityNode, "LineStyle", markupobj.linestyle);
            if (bpagenotloaded){
                createAndAppendElement(entityNode, "MainImageScaling", markupobj.docdscale);
                createAndAppendElement(entityNode, "MainImageOffsetX", markupobj.docdx);
                createAndAppendElement(entityNode, "MainImageOffsetY", markupobj.docdy);
            }else{
                createAndAppendElement(entityNode, "MainImageScaling", Docref.getPageObject(pagenumber).MainImageScaling);
                createAndAppendElement(entityNode, "MainImageOffsetX", Docref.getPageObject(pagenumber).MainImageOffsetX);
                createAndAppendElement(entityNode, "MainImageOffsetY", Docref.getPageObject(pagenumber).MainImageOffsetY);
            }

            createAndAppendElement(entityNode, "DocScale", markupobj.docdscale);
            createAndAppendElement(entityNode, "DocOffsetX", markupobj.docdx);
            createAndAppendElement(entityNode, "DocOffsetY", markupobj.docdy);

            if(markupobj.type != 0 ){
                if (markupobj.points.length != -1) {
                    var pointsNode = markupxml.createElement("Points");
                    for (var i = 0; i < markupobj.points.length; i++) {
                        var pointNode = markupxml.createElement("Point");

                        if (pageobject.usepdfjs || pageobject.usevectorxml) {
                            var xpoint = (markupobj.points[i].x - markupobj.xoffset) / internalscale;
                            var ypoint = (markupobj.points[i].y - markupobj.yoffset) / internalscale;

                            pointNode.setAttribute("x", xpoint);
                            pointNode.setAttribute("y", ypoint);

                        } else {
                            pointNode.setAttribute("x", markupobj.points[i].x);
                            pointNode.setAttribute("y", markupobj.points[i].y);

                        }
                        pointsNode.appendChild(pointNode);
                    }
                    entityNode.appendChild(pointsNode);
                }
            }else{
                if (markupobj.pointlist.length != 0) {
                    for(var j = 0; j < markupobj.pointlist.length;j++){
                        var linesNode = markupxml.createElement("Line");
                        for (i = 0; i < markupobj.pointlist[j].length; i++) {
                            pointNode = markupxml.createElement("Point");
                            if (pageobject.usepdfjs || pageobject.usevectorxml) {
                                xpoint = (markupobj.pointlist[j][i].x - markupobj.xoffset) / internalscale;
                                ypoint = (markupobj.pointlist[j][i].y - markupobj.yoffset) / internalscale;

                                pointNode.setAttribute("x", xpoint);
                                pointNode.setAttribute("y", ypoint);

                            } else {
                                pointNode.setAttribute("x", markupobj.pointlist[j][i].x);
                                pointNode.setAttribute("y", markupobj.pointlist[j][i].y);

                            }
                            linesNode.appendChild(pointNode);
                        }
                        entityNode.appendChild(linesNode);
                    }


                }

            }

            if(markupobj.type == 7){

                if (pageobject.usepdfjs || pageobject.usevectorxml) {
                    createAndAppendElement(entityNode, "LeaderLineOffset", markupobj.leaderoffset / internalscale);
                }else{
                    createAndAppendElement(entityNode, "LeaderLineOffset", markupobj.leaderoffset);
                }

            }

            if(markupobj.type == 8){
                if (pageobject.usepdfjs || pageobject.usevectorxml) {
                    createAndAppendElement(entityNode, "LabelOffsetX", markupobj.labeloffsetx / internalscale);
                    createAndAppendElement(entityNode, "LabelOffsetY", markupobj.labeloffsety / internalscale);

                }else{
                    createAndAppendElement(entityNode, "LabelOffsetX", markupobj.labeloffsetx);
                    createAndAppendElement(entityNode, "LabelOffsetY", markupobj.labeloffsety);
                }
                createAndAppendElement(entityNode, "LabelColor", markupobj.labelfillcolor);
            }


            var rectangleNode = markupxml.createElement("Rect");
            if (pageobject.usepdfjs || pageobject.usevectorxml) {


                var xorig = (markupobj.x - markupobj.xoffset) / internalscale;
                var yorig = (markupobj.y - markupobj.yoffset) / internalscale;

                var bCircle = (markupobj.type == 4 && markupobj.subtype == 1);
                if (markupobj.type == 0 || markupobj.type == 1 || markupobj.type == 2 || markupobj.type == 6 || markupobj.type == 7 || markupobj.type == 8 || bCircle) {
                    var worig = (markupobj.w - markupobj.xoffset) / internalscale;
                    var horig = (markupobj.h - markupobj.yoffset) / internalscale;

                } else {
                    if (markupobj.type == 9 && markupobj.subtype == 0) {
                        worig = (markupobj.w / internalscale);
                        horig = (markupobj.textheight / internalscale);
                    } else if(markupobj.type == 10 && bUseFixedScale) {
                        worig = (markupobj.w / fixedscale);
                        horig = (markupobj.h / fixedscale);
                    } else {
                        worig = (markupobj.w / internalscale);
                        horig = (markupobj.h / internalscale);

                    }
                }


                rectangleNode.setAttribute("x", xorig);
                rectangleNode.setAttribute("y", yorig);
                rectangleNode.setAttribute("w", worig);
                rectangleNode.setAttribute("h", horig);

            } else {
                rectangleNode.setAttribute("x", markupobj.x);
                rectangleNode.setAttribute("y", markupobj.y);
                rectangleNode.setAttribute("w", markupobj.w);
                rectangleNode.setAttribute("h", markupobj.h);

            }


            entityNode.appendChild(rectangleNode);



            if(markupobj.customattributes.length > 0){
                var extendedNode = markupxml.createElement("Extended");
                for (var cacnt = 0;cacnt < markupobj.customattributes.length; cacnt++){
                    var sztagname  = markupobj.customattributes[cacnt].name;
                    var sztagvalue  = markupobj.customattributes[cacnt].value;
                    createAndAppendElement(extendedNode, sztagname, sztagvalue);
                }
                entityNode.appendChild(extendedNode);

            }


            markupxml.getElementsByTagName("Entities")[0].appendChild(entityNode);


        }

        if(bgetArrow){
            return entityNode;
        }else{
            return markupxml;
        }



    }

    function sendMarkup(xmlurlsave, signature, dispname) {
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        /*if(DocObj.pages[DocObj.currentpage].usepdfjs){
         internalscale = DocObj.pages[DocObj.currentpage].curpagescale*DocObj.pages[DocObj.currentpage].dscalepdf;
         }*/


        var markupxml = createxmlmarkup(true, false,false,signature, dispname);

            var path = getPath(DocObj.OriginalURL);

            if (bMarkupPostOnly){
                var markupsendurl = xmlurlsave;// + "&" + path + "&" + signature;
            }else{
                markupsendurl = xmlurlsave + "&" + path + "&" + signature;
            }


        try {
            xhr.open('POST', markupsendurl, true);
        } catch (e) {
            alert("Error 1 - " + e);
        }
        try {
            xhr.responseType = '';
        } catch (e) {
            //alert("Error 2 - " + e);
        }

        xhr.onload = function (e) {
            if (this.status == 200) {

                if (bRefreshmarkup) {
                    DocObj.markuplist = [];
                    numUsers = 0;
                    Userlist = [];
                    Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
                    numUsers++;
                    DocObj.nummarkups = 0;
                    getMarkupFilelist('');

                }
                if(DocObj){
                    DocObj.bMarkupchanged = false;
                }


                if (RxCore_GUI_MarkupSave != undefined){
                    RxCore_GUI_MarkupSave.markupSaved();
                }
                //alert("Markup Saved!");
            } else if (this.status == 404) {
                alert("server could not be found");
            } else if (this.status == 503) {
                alert("Server is down");
            }

        };
        xhr.send(markupxml);


    } // end sendmarkup

    function getConfigJSON(configurationLocation){
        var XMLGetConfig = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetConfig += "<RxViewServer>";
        XMLGetConfig += "<Command>GetConfiguration</Command>";
        XMLGetConfig += "<LicenseID>" + LicenseID + "</LicenseID>";
        if (locationSearchSet) {
            XMLGetConfig += "<CallingPageUrl>" + htmlviewerurl + szLocationSearch + "</CallingPageUrl>";
        } else {
            XMLGetConfig += "<CallingPageUrl>" + htmlviewerurl + "</CallingPageUrl>";
        }

        XMLGetConfig += "</RxViewServer>";


        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        if(bUsecustomConfig){
            try {
                xhr.open('GET', configurationLocation, false);
            } catch (e) {
                alert("Error 1 - " + e);
            }
            xhr.send();

        }else{
            try {
                xhr.open('POST', configurationLocation, false);
            } catch (e) {
                alert("Error 1 - " + e);
            }
            xhr.send(XMLGetConfig);

        }

        configJSON = Object.freeze(JSON.parse(xhr.responseText));
        //Object.freeze(configJSON);

        try {
            //var xmllayers = configxml.getElementsByTagName('layer');
            if (configJSON.layers.layer.length > 0) {
                for (var l = 0; l < configJSON.layers.layer.length; l++) {
                    //get layer attributes and create layer list.
                    var LayerName = configJSON.layers.layer[l].name;
                    var LayerColor = configJSON.layers.layer[l].color;
                    var LayerNumber = configJSON.layers.layer[l].number;
                    var LayerState = configJSON.layers.layer[l].state;
                    if (LayerState == 'on') {
                        var bState = true;
                    } else {
                        bState = false;
                    }
                    Layerlist[l] = new Layers(LayerNumber, LayerColor, LayerName, bState);
                }
            }
        } catch (e) {
            //ignore and continue
            createLayers();
        }
        readonlymode = configJSON.Readonlymarkup;
    }

    function getConfiguration(configurationLocation) {
        var XMLGetConfig = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
        XMLGetConfig += "<RxViewServer>";
        XMLGetConfig += "<Command>GetConfiguration</Command>";
        XMLGetConfig += "<LicenseID>" + LicenseID + "</LicenseID>";
        if (locationSearchSet) {
            XMLGetConfig += "<CallingPageUrl>" + htmlviewerurl + szLocationSearch + "</CallingPageUrl>";
        } else {
            XMLGetConfig += "<CallingPageUrl>" + htmlviewerurl + "</CallingPageUrl>";
        }

        XMLGetConfig += "</RxViewServer>";


        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        if(bUsecustomConfig){
            try {
                xhr.open('GET', configurationLocation, false);
            } catch (e) {
                alert("Error 1 - " + e);
            }
            xhr.send();

        }else{
            try {
                xhr.open('POST', configurationLocation, false);
            } catch (e) {
                alert("Error 1 - " + e);
            }
            xhr.send(XMLGetConfig);

        }
        var xmlDoc = xhr.responseText;
        var configxml = $.parseXML(xmlDoc);

        try {
            var SzContext = configxml.getElementsByTagName("Context")[0].firstChild.nodeValue;
        } catch (e) {
            //alert("Error getting Context - " + e);
            //getting context failed ignore and proceed
            //added try cactch for safari compliance
            SzContext = "";
        }
        try {
            var szLicMode = configxml.getElementsByTagName("Licensemode")[0].firstChild.nodeValue;

        } catch (e) {
            szLicMode = "";
        }

        try {
            var szLicCompany = configxml.getElementsByTagName("CompanyFeature")[0].firstChild.nodeValue;

        } catch (e) {
            szLicCompany = "";
        }

        bUseCompanyFeature = (szLicCompany != "");
        szLicenCompanyFeature = szLicCompany;
        //<CompanyFeature>

        try {
            var szImgSwitchFactor = configxml.getElementsByTagName("ImgSwitchFactor")[0].firstChild.nodeValue;

        } catch (e) {
            imageswitchfactor = 1.5;
        }

        try {
            var SzCurrentUser = configxml.getElementsByTagName("CurrentUserName")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzCurrentUser = "";
        }
        try {
            var SzDisplayName = configxml.getElementsByTagName("DisplayName")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzDisplayName = "";
        }


        try {
            var SzMarkupLayer = configxml.getElementsByTagName("MarkupLayer")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzMarkupLayer = "";
        }

        try {
            var SzMarkupColor = configxml.getElementsByTagName("MarkupColor")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzMarkupColor = "";
        }


        try {
            var SzXmlUrl = configxml.getElementsByTagName("XmlUrl")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzXmlUrl = "";
        }

        try {
            var SzXmlUrlmarkup = configxml.getElementsByTagName("XmlUrlmarkup")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzXmlUrlmarkup = "";
        }

        try {
            var szMarkupPostonly = configxml.getElementsByTagName("MarkupSavePOSTOnly")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            szMarkupPostonly = "";
        }

        bMarkupPostOnly = (szMarkupPostonly != "" && szMarkupPostonly == "True");

        try {
            var SzXMLURLRel = configxml.getElementsByTagName("XmlUrlRel")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzXMLURLRel = "";
        }

        try {
            var SzMarkupSaveUrl = configxml.getElementsByTagName("MarkupSaveUrl")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzMarkupSaveUrl = "";
        }

        try {
            var SzFileExport = configxml.getElementsByTagName("ExportFile")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzFileExport = "";
        }

        try {
            var Sz3DImage = configxml.getElementsByTagName("Image3DSave")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            Sz3DImage = "";
        }



        try {
            var SzPrintPageURL = configxml.getElementsByTagName("PrintPageURL")[0].firstChild.nodeValue;
        } catch (e) {
            SzPrintPageURL = "printcanvas.htm";
        }

        try {
            var SzEnableMarkupEdit = configxml.getElementsByTagName("EnableMarkupEdit")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzEnableMarkupEdit = "";
        }
        try {
            var SzCanChangeSign = configxml.getElementsByTagName("CanChangeSignature")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzCanChangeSign = "";
        }
        try {
            var SzCanConsolidate = configxml.getElementsByTagName("CanConsolidate")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzCanConsolidate = "";
        }
        try {
            var SzCanChangeLayer = configxml.getElementsByTagName("CanChangeLayer")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzCanChangeLayer = "";
        }
        try {
            var SzReadonlymarkup = configxml.getElementsByTagName("Readonlymarkup")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzReadonlymarkup = "";
        }
        try {
            var SzEnableFileIOpen = configxml.getElementsByTagName("EnableFileOpen")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzEnableFileIOpen = "";
        }

        try {
            var SzReverseScale = configxml.getElementsByTagName("ReverseScale")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzReverseScale = "";
        }

        try {
            var SzIntitialDocument = configxml.getElementsByTagName("InitialDocument")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzIntitialDocument = "";
        }

        try {
            var SzUseCustom = configxml.getElementsByTagName("UseCustom")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzUseCustom = "";
        }

        try {
            var SzPaperWidth = configxml.getElementsByTagName("Paperwidth")[0].firstChild.nodeValue;
        } catch (e) {
            SzPaperWidth = "794";
        }
        try {
            var SzPaperHeight = configxml.getElementsByTagName("Paperheight")[0].firstChild.nodeValue;
        } catch (e) {
            SzPaperHeight = "1122";
        }


        try {
            var SzArrowSize = configxml.getElementsByTagName("ArrowSize")[0].firstChild.nodeValue;
        } catch (e) {
            SzArrowSize = "20";
        }

        nArrowSize = parseInt(SzArrowSize);

        try {
            var SzLabelSize = configxml.getElementsByTagName("LabelSize")[0].firstChild.nodeValue;
        } catch (e) {
            SzLabelSize = "12";
        }

        nLabelTextsize = parseInt(SzLabelSize);

        try {
            var SzrefreshMarkup = configxml.getElementsByTagName("RefreshMarkup")[0].firstChild.nodeValue;
        } catch (e) {
            //ignore and continue
            SzrefreshMarkup = "";
        }

        try {
            var szPDFZoomAll = configxml.getElementsByTagName("PDFZoomAll")[0].firstChild.nodeValue;
        } catch (e) {
            szPDFZoomAll = "";
        }
        bPDFZoomAllinit = (szPDFZoomAll != "" && szPDFZoomAll == "True");

        try {
            var szPDFanimateRender = configxml.getElementsByTagName("PDFAnimateRender")[0].firstChild.nodeValue;
        } catch (e) {
            szPDFanimateRender = "";
        }
        bAnimatePDFrender = (szPDFanimateRender != "" && szPDFanimateRender == "True");


        try {
            var xmllayers = configxml.getElementsByTagName('layer');
            if (xmllayers.length > 0) {
                for (var l = 0; l < xmllayers.length; l++) {
                    //get layer attributes and create layer list.
                    var LayerName = xmllayers[l].getElementsByTagName("name")[0].firstChild.nodeValue;
                    var LayerColor = xmllayers[l].getElementsByTagName("color")[0].firstChild.nodeValue;
                    var LayerNumber = xmllayers[l].getElementsByTagName("number")[0].firstChild.nodeValue;
                    var LayerState = xmllayers[l].getElementsByTagName("state")[0].firstChild.nodeValue;
                    if (LayerState == 'on') {
                        var bState = true;
                    } else {
                        bState = false;
                    }
                    Layerlist[l] = new Layers(LayerNumber, LayerColor, LayerName, bState);
                }
            }
        } catch (e) {
            //ignore and continue
            createLayers();
        }

        try {
            var stamptags = configxml.getElementsByTagName('stamp');
            if (stamptags.length > 0) {
                for (var i = 0; i < stamptags.length; i++) {
                    Stamplist[i] = stamptags[i].firstChild.nodeValue;
                }
                Stamplist[i] = "Date";
                Stamplist[i + 1] = "User Name";
            } else {
                Stamplist = ["Approved", "Draft", "Received", "Rejected", "Reviewed", "Revised", "Date", "User Name"];
            }
        } catch (e) {
            //ignore error and add default values
            Stamplist = ["Approved", "Draft", "Received", "Rejected", "Reviewed", "Revised", "Date", "User Name"];

        }


        if (Stamplist.length > 0) {

            if (RxCore_GUI_Stamps != undefined) {
                RxCore_GUI_Stamps.setMarkupStamps(Stamplist);
            }

        }

        //set global variables from xml
        if (SzContext != "") {
            //
        }
        if (szLicMode != "") {
            OEMFlag = szLicMode;
        }
        if (szImgSwitchFactor != "") {
            imageswitchfactor = parseFloat(szImgSwitchFactor);
        }
        if (SzCurrentUser != "") {
            signature = SzCurrentUser;
        }
        if (SzDisplayName != "") {
            DisplayName = SzDisplayName;
        }

        if (SzMarkupLayer != "") {
            markuplayer = parseInt(SzMarkupLayer);
        }

        if (SzMarkupColor != "") {
            markupcolor = SzMarkupColor;
            markuplinecolor = SzMarkupColor;
            markuptextcolor = SzMarkupColor;
        }

        Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
        numUsers++;

        if (SzXmlUrl != "") {
            xmlurl = SzXmlUrl;
        }

        if (SzXmlUrlmarkup != "") {
            xmlurlmarkup = SzXmlUrlmarkup;
        }


        if (SzXMLURLRel != "") {
            xmlurlrel = SzXMLURLRel;
        }
        if (SzMarkupSaveUrl != "") {
            xmlurlmarkupsave = SzMarkupSaveUrl;
        }

        if(SzFileExport != ""){
            PDFExportURL = SzFileExport;
        }

        if(Sz3DImage != ""){
            CanvasSaveUrl = Sz3DImage;
        }
        //

        if (SzPrintPageURL != "") {
            PrintPageURL = SzPrintPageURL;
        }

        readonlymode = (SzReadonlymarkup != "" && SzReadonlymarkup == "True");

        /*if (SzReadonlymarkup != "" && SzReadonlymarkup == "True") {
            readonlymode = true;
            //$('.editOnly').remove();
            //$('#View').css('display', '');
            //$('li[ref="View"]').addClass('selected');

        } else {
            readonlymode = false;
        }*/
        bCanChangeSignature = (SzCanChangeSign != "" && SzCanChangeSign == "True");

        bCanConsolidate = (SzCanConsolidate != "" && SzCanConsolidate == "True");

        bCanChangeLayer = (SzCanChangeLayer != "" && SzCanChangeLayer == "True");

        if (SzEnableFileIOpen != "" && SzEnableFileIOpen == "False") {
            $('.disableOpenClose').remove();
        } else {
            //bCanChangeLayer = false;
        }
        bReverseScale = (SzReverseScale != "" && SzReverseScale == "True");
        bRefreshmarkup = (SzrefreshMarkup != "" && SzrefreshMarkup == "True");

        if (SzIntitialDocument != "") {
            //getFile(SzIntitialDocument);
            bOpeninitialdoc = true;
            OpeninitialdocURL = SzIntitialDocument;

            initialDoc.open = bOpeninitialdoc;
            initialDoc.url = OpeninitialdocURL;
        }

        if(SzUseCustom != "" && SzUseCustom == "True"){
            initialDoc.custom = true;
        }else{
            initialDoc.custom = false;
        }


        Paper = new PaperSize(SzPaperWidth, SzPaperHeight);

        /*try{
         xhr.responseType = 'document';
         }
         catch(e){
         //alert("Error 2 - " + e);
         }*/

        /*xhr.onreadystatechange = function(){
         if (this.readyState === 4 && this.status === 200) {
         //console.log(this.responseText);
         var xmlDoc = this.responseText;

         //var xmlDoc = this.responseXML;
         try{
         var SzContext = xmlDoc.getElementsByTagName("Context")[0].firstChild.nodeValue;
         }
         catch(e){
         //alert("Error getting Context - " + e);
         //getting context failed ignore and proceed
         //added try cactch for safari compliance
         }
         try{
         var SzCurrentUser = xmlDoc.getElementsByTagName("CurrentUserName")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }
         try{
         var SzXmlUrl = xmlDoc.getElementsByTagName("XmlUrl")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }

         try{
         var SzXMLURLRel = xmlDoc.getElementsByTagName("XmlUrlRel")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }

         try{
         var SzMarkupSaveUrl = xmlDoc.getElementsByTagName("MarkupSaveUrl")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }

         try{
         var SzEnableMarkupEdit = xmlDoc.getElementsByTagName("EnableMarkupEdit")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }
         try{
         var SzCanChangeSign = xmlDoc.getElementsByTagName("CanChangeSignature")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }
         try{
         var SzCanChangeLayer = xmlDoc.getElementsByTagName("CanChangeLayer")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }
         try{
         var SzReadonlymarkup = xmlDoc.getElementsByTagName("Readonlymarkup")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }
         try{
         var SzEnableFileIOpen = xmlDoc.getElementsByTagName("EnableFileOpen")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }

         try{
         var SzIntitialDocument = xmlDoc.getElementsByTagName("InitialDocument")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }

         try{
         var SzrefreshMarkup = xmlDoc.getElementsByTagName("RefreshMarkup")[0].firstChild.nodeValue;
         }
         catch(e){
         //ignore and continue
         }





         //set global variables from xml
         if(SzContext != ""){
         //
         }

         if(SzCurrentUser != ""){
         signature = SzCurrentUser;
         }
         if(SzXmlUrl != ""){
         xmlurl = SzXmlUrl;
         }
         if(SzXMLURLRel != ""){
         xmlurlrel = SzXMLURLRel;
         }
         if(SzMarkupSaveUrl != ""){
         xmlurlmarkupsave = SzMarkupSaveUrl;
         }
         if(SzReadonlymarkup != "" && SzReadonlymarkup == "True"){
         readonlymode = true;
         $('.editOnly').remove();
         $('#View').css('display', '');
         $('li[ref="View"]').addClass('selected');

         }else{
         readonlymode = false;
         }
         if(SzCanChangeSign != "" && SzCanChangeSign == "True"){
         bCanChangeSignature = true;
         }else{
         bCanChangeSignature = false;
         }
         if(SzCanChangeLayer != "" && SzCanChangeLayer == "True"){
         bCanChangeLayer = true;
         }else{
         bCanChangeLayer = false;
         }
         if(SzEnableFileIOpen != "" && SzEnableFileIOpen == "False"){
         $('.disableOpenClose').remove();
         }else{
         //bCanChangeLayer = false;
         }
         if(SzrefreshMarkup != "" && SzrefreshMarkup == "True"){
         bRefreshmarkup = true;
         }else{
         bRefreshmarkup = false;
         }
         if(SzIntitialDocument != ""){
         getFile(SzIntitialDocument);
         }


         }
         else if (this.status == 404){
         alert("XML configuration could not be found");
         }
         };*/

        /*xhr.onload = function(ev) {





         };*/

        //xhr.send(XMLGetConfig);


    }


    function GetLicense() {

        /* Andriy TODO: REMOVE, prevent checking licenses */

        //LicenseID = 50942768;
        //bLicenseAquired = true;

        //return;
        /*var formData = new FormData();

         //text/plain
         formData.append("MfcISAPICommand", "FormRequest");
         formData.append("Command", "OpenSession");
         formData.append("LicenseType", "Normal");
         formData.enctype = "text/plain";*/
        var licmode = 'LicenseMode' + 'RxView360' + OEMFlag;

        if(bUseCompanyFeature){
            var geturl = openUsessionurl + '&' + 'RxView360' + szLicenCompanyFeature + '&2.0' + '&' + signature;

        }else{
            geturl = openUsessionurl + '&' + 'RxView360' + OEMFlag + '&2.0' + '&' + signature;

        }


        if(OEMFlag == 'bypass'){
            LicenseID = 50942768;
            bLicenseAquired = true;
            return;
        }


        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        try {
            xhr.open('GET', geturl, false);
        } catch (e) {
            alert("Error 1 - " + e);
        }

        xhr.send();

        var xmlDoc = xhr.responseText;
        var responsArray = xmlDoc.split(':');
        if (responsArray[0] == 'OK') {
            var licensearr = responsArray[1].split(',');
            LicenseID = licensearr[0];
            bLicenseAquired = true;
            if (OEMFlag == 'OEM') {
                //$('.disableOpenClose').remove();
            }
        } else {
            alert(xmlDoc);
        }


    }

    function FreeLicense() {
        if(!bLicenseAquired){
            return;
        }
        var geturl = closesessionurl + '&' + LicenseID;
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        try {
            xhr.open('GET', geturl, false);
        } catch (e) {
            alert("Error 1 - " + e);
        }

        xhr.send();

        var xmlDoc = xhr.responseText;
        bLicenseAquired = false;
        /*var responsArray = xmlDoc.split(':');
         if(responsArray[0] == 'OK'){
         var licensearr = responsArray[1].split(',');
         LicenseID = licensearr[0];
         }*/


    }


    function printfile(prwin) {
        prwin.print();

    }


    function checkprintload() {
        if (printWin.document.readyState == 'complete' && bPrintpageloaded) {
            var printbtn = printWin.document.getElementById('printbtn');
            printbtn.click();
        } else {
            window.setTimeout(checkprintload, 1000);
        }
    }


    function printloadcomplete(ev) {
        //ev.url
        //alert('try to print');
        bPrintpageloaded = true;
        //var printbtn = printWin.document.getElementById('printbtn');
        //printbtn.click();
        //checkprintload();
    }

    function GetPaperWidth() {
        return PaperWidth;
    }

    function ClosePrint() {
        printWin.close();
    }

    function GetPaperHeight() {
        return PaperHeight;
    }

    function GetPrintObject() {
        return DocObj;
    }

    function GetPageObject() {
        return DocXMLPrint;
    }

    function printCanvas(imagedataurl) {



        printWin = window.open(imagedataurl, "Print");

        /*if(DocObj.pages[DocObj.currentpage].usevectorxml){
         printWin = window.open('printsvg.htm',"Print");
         }else{
         printWin = window.open(imagedataurl,"Print");
         }*/

        //    printWin.focus();

    }

    function printfocus() {
        //printWin = window.open(imagedataurl,"Print");
        if(CompareObj != undefined){
            if(CompareObj.printref != undefined){
                CompareObj.printClose();
            }
        }
        printWin.focus();
        printWin.close();


    }



    /*function PDFIframeLoad(printwindow){
     var iframe = printwindow.document.getElementById('iframe_a');
     if(iframe.src) {
     var frm = iframe.contentWindow;

     frm.focus();// focus on contentWindow is needed on some ie versions
     frm.print();
     return false;
     }
     }*/


    /*function printPDF(printwindow){
     if (navigator.appName == 'Microsoft Internet Explorer') {

     //Wait until PDF is ready to print
     if (typeof printwindow.document.getElementById("pdfDocument").print == 'undefined') {

     setTimeout(function(){printPDF("pdfDocument");}, 1000);

     } else {

     var x = printwindow.document.getElementById("pdfDocument");
     x.print();
     }

     } else{

     PDFIframeLoad(printwindow);  // for chrome
     }
     }*/


    /*function sendMarkup(xmlurl,signature) {
     var curmarkup = 0;
     var savetime = new Date().getTime();
     var xhr = new XMLHttpRequest();


     var markupxml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n";

     markupxml += "<RasterexMarkup>\n";
     markupxml += "<Header>\n";
     markupxml += "<FileVersion>C350</FileVersion>\n";
     markupxml += "<Scale>1.0000</Scale>\n";
     markupxml += "<OrigoX>0.0000</OrigoX>\n";
     markupxml += "<OrigoY>0.0000</OrigoY>\n";
     markupxml += "<DirectionY>1</DirectionY>\n";
     markupxml += "<DirectionX>1</DirectionX>\n";
     markupxml += "</Header>\n";

     markupxml += "<Users>\n";
     markupxml += "<Name>"+ signature +"</Name>\n";
     markupxml += "</Users>\n";
     markupxml += "<Entities>\n";

     //var found = false;
     var id = -1;
     if (DocObj.markuplist.length > 0){
     for (curmarkup=0;curmarkup<DocObj.markuplist.length;curmarkup++){
     if (DocObj.markuplist[curmarkup] != null){
     if(DocObj.markuplist[curmarkup].signature == signature){
     var pagenumber = DocObj.markuplist[curmarkup].pagenumber;
     markupxml += "<Entity>\n";
     markupxml += "<Type>" + DocObj.markuplist[curmarkup].type + "</Type>\n";
     markupxml += "<Subtype>" + DocObj.markuplist[curmarkup].subtype + "</Subtype>\n";
     markupxml += "<Alternative>" + DocObj.markuplist[curmarkup].alternative + "</Alternative>\n";
     markupxml += "<Layer>" + DocObj.markuplist[curmarkup].layer + "</Layer>\n";
     markupxml += "<Rotation>" + DocObj.markuplist[curmarkup].rotation + "</Rotation>\n";
     markupxml += "<FileName>" + DocObj.markuplist[curmarkup].documentName + "</FileName>\n";
     markupxml += "<Layout>" + pageobject.LayoutName + "</Layout>\n";
     markupxml += "<View>" + pagenumber + "</View>\n";
     markupxml += "<Handle>" + curmarkup + "</Handle>\n";
     markupxml += "<Color>" + DocObj.markuplist[curmarkup].color + "</Color>\n";
     markupxml += "<FontName>"+ DocObj.markuplist[curmarkup].fontname +"</FontName>\n";
     markupxml += "<FontHeight>"+ DocObj.markuplist[curmarkup].textheight +"</FontHeight>\n";
     if (DocObj.markuplist[curmarkup].text == ""){DocObj.markuplist[curmarkup].text = ".";}
     markupxml += "<Text>"+ DocObj.markuplist[curmarkup].text +"</Text>\n";
     if (DocObj.markuplist[curmarkup].dimtext == ""){DocObj.markuplist[curmarkup].dimtext = ".";}
     markupxml += "<DimText>"+ DocObj.markuplist[curmarkup].dimtext +"</DimText>\n";
     //<Font height='-16' width='0' escapement='0' orientation='0' weight='400' italic='0' underline='0' 		strikeout='0' charset='1' outprecision='3' clipprecision='2' quality='1' pitch='34' 		facename='Arial'/>
     markupxml += "<TextWidth>" + DocObj.markuplist[curmarkup].textwidth + "</TextWidth>\n";
     markupxml += "<Signature>" + DocObj.markuplist[curmarkup].signature + "</Signature>\n";
     markupxml += "<TimeStamp>" + DocObj.markuplist[curmarkup].timestamp + "</TimeStamp>\n";
     markupxml += "<Scaling>" + DocObj.markuplist[curmarkup].scaling + "</Scaling>\n";
     markupxml += "<Xoffset>" + DocObj.markuplist[curmarkup].xoffset + "</Xoffset>\n";
     markupxml += "<Yoffset>" + DocObj.markuplist[curmarkup].yoffset + "</Yoffset>\n";
     markupxml += "<LineWidth>" + DocObj.markuplist[curmarkup].linewidth + "</LineWidth>\n";

     if (DocObj.markuplist[curmarkup].numpoints != -1){
     markupxml += "<Points>\n";
     for (i =0; i<DocObj.markuplist[curmarkup].points.length;i++){
     markupxml += "<Point x='"+DocObj.markuplist[curmarkup].points[i].x + "' y='" +DocObj.markuplist[curmarkup].points[i].y + "'/>\n";
     }
     markupxml += "</Points>\n";
     }

     markupxml += "<Rect x='"+ DocObj.markuplist[curmarkup].x + "' y='" + DocObj.markuplist[curmarkup].y + "' w='" + DocObj.markuplist[curmarkup].w + "' h='" + DocObj.markuplist[curmarkup].h + "' />\n";
     markupxml += "</Entity>\n";

     }
     }
     }//end for
     //SendData(markupxml,"http://viewserver.rasterex.com/demo/markupserver.dll?webmarkupsave");
     }else{
     markupxml += "<Entity/>"
     }//end if

     markupxml += "</Entities>\n";
     markupxml += "</RasterexMarkup>\n";

     var path = getPath(DocObj.OriginalURL);
     var markupsendurl = xmlurl + "&" + path + "&" + signature;
     try{
     xhr.open('POST', markupsendurl, true);
     }
     catch(e){
     alert("Error 1 - " + e);
     }
     try{
     xhr.responseType = 'text/xml';
     }
     catch(e){
     //alert("Error 2 - " + e);
     }

     xhr.onload = function(e) {
     if (this.status == 200) {
     alert("Markup Saved");
     }
     else if (this.status == 404){
     alert("server could not be found");
     }
     else if (this.status == 503){
     alert("Server is down");
     }

     };
     xhr.send(markupxml);


     }// end sendmarkup*/


    function img_update() {
        cntximg.drawImage(canvas, 0, 0);
        context.clearRect(0, 0, canvas.width, canvas.height);
    }

    function draw_image(image, dx, dy, dscale) {

        /*var dxextent=0.0, dyextent=0.0;
         var imagewidth = 0, imageheight = 0;
         var dscale=1;
         var dscaleextent=1;*/


        var localdx = 0.0;
        var localdy = 0.0;
        var localdscale = 0.0;

        contexto.fillStyle = "rgb(238,243,250)";
        contexto.fillRect(0, 0, canvasowidth, canvasoheight);
        switch (imagesize) {
            case 0:
                localdx = dx;
                localdy = dy;
                localdscale = dscale;
                break;
            case 1:
                localdx = dx;
                localdy = dy;
                localdscale = dscale;

                break;
        }


        if (drotation == 0) {
            contexto.drawImage(image, localdx, localdy, imagewidth * localdscale, imageheight * localdscale);

        } else {
            contexto.save();
            var tx = (canvasowidth / 2);
            var ty = (canvasoheight / 2);
            contexto.translate(tx, ty);
            contexto.rotate(drotation * (Math.PI / 180));
            contexto.translate(-tx, -ty);
            contexto.drawImage(image, localdx, localdy, imagewidth * localdscale, imageheight * localdscale);
            contexto.restore();

        }
    }

    /*function rotateCanvas(){
     var localdx = 0.0;
     var localdy = 0.0;
     var localdscale = 0.0;



     contexto.save();
     var tx = (canvasowidth/2);
     var ty = (canvasoheight/2);
     contexto.translate(tx,ty);
     contexto.rotate(drotation*(Math.PI/180));
     contexto.translate(-tx,-ty);
     contexto.fillStyle = "rgb(238,243,250)";
     contexto.fillRect(0, 0, canvasowidth, canvasoheight);
     switch(imagesize){
     case 0:
     localdx = dx;
     localdy = dy;
     localdscale = dscale;
     contexto.drawImage(myimage, localdx, localdy,imagewidth*dscale, imageheight*dscaleextent);
     break;
     case 1:
     localdx = dxextent;
     localdy = dyextent;
     localdscale = dscaleextent;
     contexto.drawImage(myimagesmall, localdx, localdy,imagewidth*dscale, imageheight*dscaleextent);
     break;
     }




     contexto.restore();

     }*/

    /*function rotateimage(degree){
     var i = 0;
     switch(drotation){
     case 0:
     if (degree == 90){
     for(i=0;i<=90;i=i+10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 180){
     for(i=0;i<=180;i=i+10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 270){
     for(i=0;i<=270;i=i+10){
     drotation = i;
     rotateCanvas();
     }
     }
     break;
     case 90:
     if (degree == 0){
     for(i=90;i>=0;i=i-10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 180){
     for(i=90;i<=180;i=i+10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 270){
     for(i=90;i<=270;i=i+10){
     drotation = i;
     rotateCanvas();
     }
     }

     break;
     case 180:
     if (degree == 0){
     for(i=180;i>=0;i=i-10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 270){
     for(i=180;i<=270;i=i+10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 90){
     for(i=180;i>=90;i=i-10){
     drotation = i;
     rotateCanvas();
     }
     }

     break;
     case 270:
     if (degree == 0){
     for(i=270;i>=0;i=i-10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 180){
     for(i=270;i>=180;i=i-10){
     drotation = i;
     rotateCanvas();
     }
     }
     if (degree == 90){
     for(i=270;i>=90;i=i-10){
     drotation = i;
     rotateCanvas();
     }
     }

     break;
     }

     DocObj.pages[DocObj.currentpage].draw_image();



     //draw_image(myimage);

     }*/

    function GetImageWidth(image) {

        var nimagewidth = image.width;
        nimagewidth = image.naturalWidth;

        return imagewidth;
    }

    function GetImageHeight(image) {

        var nimageheight = image.width;
        nimageheight = image.naturalWidth;

        return imageheight;
    }

    function SetImageDim(image) {
        imagewidth = image.width;
        imageheight = image.height;

        imagewidth = image.naturalWidth;
        imageheight = image.naturalHeight;

    }

    function splashload() {


        imageloaded = true;
    }

    function imageloadprogress(ev) {
        if (ev.lengthComputable) {
            //var percentComplete = Math.round(evt.loaded * 100 / evt.total);


            /*document.getElementById('progressbar').value = Math.round(ev.loaded * 100 / ev.total);//percentComplete;//.toString() + '%';
             if (document.getElementById('progressbar').value == 100){
             document.getElementById('progressbar').value = 0;
             //hideUploadDialog();

             }*/
        } else {
            //document.getElementById('progressNumber').innerHTML = 'unable to compute';
        }

    }

    function imageload(ev) {
        var yscale = 0.0;
        var xscale = 0.0;
        var dxlocal = 0.0;
        var dylocal = 0.0;
        var dscalelocal = 0.0;
        var imagewidth = 0;
        var imageheight = 0;

        var target = ev.target || ev.srcElement;

        //if (ev.srcElement.src.toLowerCase() == DocObj.pages[DocObj.currentpage].MainImageSRC.toLowerCase()){
        if (target.src.toLowerCase() == DocObj.pages[DocObj.currentpage].MainImageSRC.toLowerCase()) {
            //largeimageloaded = true;
            //SetImageDim(ev.srcElement); //use width and height from xml instead of calculating
            imagewidth = DocObj.pages[DocObj.currentpage].MainImageWidth;
            imageheight = DocObj.pages[DocObj.currentpage].MainImageHeight;

            //set image fixed scale for markup
            yscale = fixedScaleSize.height / DocObj.pages[DocObj.currentpage].MainImageHeight; //thispage.MainImageHeight;
            xscale = fixedScaleSize.width / DocObj.pages[DocObj.currentpage].MainImageWidth; // thispage.MainImageWidth;
            DocObj.pages[DocObj.currentpage].fixedScale = Math.min(xscale, yscale);


            yscale = canvasoheight / imageheight;
            xscale = canvasowidth / imagewidth;
            dscalelocal = Math.min(xscale, yscale);
            //DocObj.pages[DocObj.currentpage].dscale = dscalelocal;

            dxlocal = (canvasowidth - (imagewidth * dscalelocal)) / 2;
            dylocal = (canvasoheight - (imageheight * dscalelocal)) / 2;

            //DocObj.pages[DocObj.currentpage].dx = dxlocal;
            //DocObj.pages[DocObj.currentpage].dy = dylocal;

            DocObj.pages[DocObj.currentpage].setimagedimlarge(dxlocal, dylocal, dscalelocal);
            //hideDownloadDialog();
            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("hide");
            }


        }

        //if (ev.srcElement.src.toLowerCase() == DocObj.pages[DocObj.currentpage].SmallImageSRC.toLowerCase()){
        if (target.src.toLowerCase() == DocObj.pages[DocObj.currentpage].SmallImageSRC.toLowerCase()) {
            //smallimageloaded = true;
            //SetImageDim(ev.srcElement); //use width and height from xml instead of calculating
            imagewidth = DocObj.pages[DocObj.currentpage].SmallImageWidth;
            imageheight = DocObj.pages[DocObj.currentpage].SmallImageHeight;

            yscale = canvasoheight / imageheight;
            xscale = canvasowidth / imagewidth;
            dscalelocal = Math.min(xscale, yscale);

            dxlocal = (canvasowidth - (imagewidth * dscalelocal)) / 2;
            dylocal = (canvasoheight - (imageheight * dscalelocal)) / 2;


            DocObj.pages[DocObj.currentpage].setimagedimsmall(dxlocal, dylocal, dscalelocal);
            //hideDownloadDialog();
            if (RxCore_GUI_Download != undefined) {
                RxCore_GUI_Download.setDownload("hide");
            }

            //draw_image(ev.srcElement);
            //DocObj.pages[DocObj.currentpage].draw_image();

        }

        //imageloaded = true;
        //drawmarkupAll(cntximg);


    }

    function get_splash(url, image) {
        image.addEventListener('load', splashload, false);
        image.src = url;
    }


    function get_image(url, image) {

        //showDownloadDialog();

        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        image.addEventListener('load', imageload, false);
        image.addEventListener('progress', imageloadprogress, false);
        image.src = url;


    }

    /*function toolswitchstate(btool,toolname){

     if (toolname == 'zoomwindow' && !btool){
     bZoomWindow = true;
     }else{
     bZoomWindow = false;
     }

     if (toolname == 'pan' && !btool){
     bPan = true;
     }else{
     bPan = false;
     }

     if (toolname == 'markupedit' && !btool){
     bMarkupEdit = true;
     }else{
     bMarkupEdit = false;
     }


     if (toolname == 'calibrate' && !btool){
     bCalibrate = true;
     }else{
     bCalibrate = false;
     }

     //bMarkupHide = false;

     if (toolname == 'erase' && !btool){
     bMarkuperase = true;
     }else{
     bMarkuperase = false;
     }


     if (toolname == 'text' && !btool){
     bMarkupText = true;
     }else{
     bMarkupText = false;
     }


     if (toolname == 'note' && !btool){
     bMarkupNote = true;
     }else{
     bMarkupNote = false;
     }

     //bMarkupStamp = false;

     if (toolname == 'line' && !btool){
     bMarkupLine = true;
     }else{
     bMarkupLine = false;
     }


     if (toolname == 'arrow' && !btool){
     bMarkupArrow = true;
     }else{
     bMarkupArrow = false;
     }

     if (toolname == 'shape' && !btool){
     bMarkupShape = true;
     }else{
     bMarkupShape = false;
     }


     if (toolname == 'measure' && !btool){
     bMarkupDimension = true;
     }else{
     bMarkupDimension = false;
     }


     if (toolname == 'area' && !btool){
     bMarkupArea = true;
     }else{
     bMarkupArea = false;
     }

     if (toolname == 'marker' && !btool){
     bMarkupMarker = true;
     }else{
     bMarkupMarker = false;
     }

     //bMarkupOutline = true;
     //bMarkupEdged = false;
     //bMarkupFilled = false;
     //bMarkupHatched = false;
     if (toolname == 'measuretool' && !btool){
     bMeasure = true;
     }else{
     bMeasure = false;
     }

     }*/

    function uploadFiledragdrop(dragdropfile) {
        //var fd = new FormData();
        var file = dragdropfile;
        dragdropfilename = file.name;
        //fd.append("fileToUpload", file);
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        xhr.upload.addEventListener("progress", uploadProgress, false);
        xhr.addEventListener("load", uploaddragComplete, false);
        xhr.addEventListener("error", uploadFailed, false);
        xhr.addEventListener("abort", uploadCanceled, false);
        var urifilename = encodeURI(file.name);
        //xhr.open("POST", FileuploadURL + "?" + UploadServerfolder + "&" + file.name,true);
        xhr.open("POST", FileuploadURL + "?" + UploadServerfolder + "&" + file.name + "&" + file.lastModified + "&" + file.size, true);
        xhr.send(file);
    }


    function uploadFile() {
        //var fd = new FormData();
        var file = document.getElementById('fileToUpload').files[0];
        //fd.append("fileToUpload", file);
        var xhr = new XMLHttpRequest();
        xhr.withCredentials = bUseCredentials;
        if (RxCore_GUI_Upload != undefined) {
            RxCore_GUI_Upload.setUpload("show");
        }


        xhr.upload.addEventListener("progress", uploadProgress, false);
        xhr.addEventListener("load", uploadComplete, false);
        xhr.addEventListener("error", uploadFailed, false);
        xhr.addEventListener("abort", uploadCanceled, false);
        var urifilename = encodeURI(file.name);
        //xhr.open("POST", FileuploadURL + "?" + UploadServerfolder + "&" + file.name,true);
        xhr.open("POST", FileuploadURL + "?" + UploadServerfolder + "&" + file.name + "&" + file.lastModified + "&" + file.size, true);
        xhr.send(file);
    }

    function uploadProgress(evt) {
        if (evt.lengthComputable) {
            //var percentComplete = Math.round(evt.loaded * 100 / evt.total);
            //showUploadDialog();
            if (RxCore_GUI_Upload != undefined) {
                RxCore_GUI_Upload.setUpload(Math.round(evt.loaded * 100 / evt.total));
            }

            /*document.getElementById('progressbar').value = Math.round(evt.loaded * 100 / evt.total); //percentComplete;//.toString() + '%';
            if (document.getElementById('progressbar').value == 100) {
                document.getElementById('progressbar').value = 0;
                //hideUploadDialog();

            }*/
        } else {
            //document.getElementById('progressNumber').innerHTML = 'unable to compute';
        }
    }

    function uploadComplete(evt) {
        /* This event is raised when the server send back a response */
        var file = document.getElementById('fileToUpload').files[0];
        var urifilename = encodeURI(file.name);
        var openfile = UploadServerfolderd + file.name;
        //hideUploadDialog();
        if (RxCore_GUI_Upload != undefined) {
            RxCore_GUI_Upload.setUpload("hide");
        }
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        //var urifilename = encodeURI(openfile);
        var openfileobj = {filename: openfile, displayname : null};

        getFile(openfileobj);

        set_tool('markupedit', {p1 : false});

        //alert(evt.target.responseText);
    }

    function uploaddragComplete(evt) {
        /* This event is raised when the server send back a response */
        //var file = evt.dataTransfer.files[0];
        if (dragdropfilename == "") {
            return;
        }
        var urifilename = encodeURI(dragdropfilename);
        var openfile = UploadServerfolderd + dragdropfilename;
        //hideUploadDialog();

        if (RxCore_GUI_Upload != undefined) {
            RxCore_GUI_Upload.setUpload("hide");
        }

        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        //var urifilename = encodeURI(openfile);
        var openfileobj = {filename: openfile, displayname : null};
        getFile(openfileobj);

        set_tool('markupedit', {p1 : false});

        dragdropfilename = "";
        //alert(evt.target.responseText);
    }


    function uploadFailed(evt) {
        //hideUploadDialog();
        if (RxCore_GUI_Upload != undefined) {
            RxCore_GUI_Upload.setUpload("hide");
        }

        alert("There was an error attempting to upload the file.");

    }

    function uploadCanceled(evt) {
        //hideUploadDialog();
        if (RxCore_GUI_Upload != undefined) {
            RxCore_GUI_Upload.setUpload("hide");
        }

        alert("The upload has been canceled by the user or the browser dropped the connection.");

    }

    function fileSelected() {
        uploadFile();
    }

    function touchEvents(ev) {

        ev.preventDefault();

        var posX = 0;
        var posY = 0;
        var moveint = 0;

        if (RxCore_GUI_3DWalkthrough != undefined) {
            var _wheelImg = RxCore_GUI_3DWalkthrough._wheelImg;
            if (_wheelImg != undefined) {
                if (_wheelImg.x == undefined) {
                    var elemRect = _wheelImg.getBoundingClientRect();
                    var _wheelImgX = elemRect.left + 100;
                    var _wheelImgY = elemRect.top + 100;
                } else {
                    _wheelImgX = _wheelImg.x + 100;
                    _wheelImgY = _wheelImg.y + 100;

                }
            }

        } else {
            _wheelImgX = 0;
            _wheelImgY = 0;
        }


        switch (ev.type) {
            case 'mousedown':
                ev.preventDefault();
                posX = ev.pageX;
                posY = ev.pageY;
                moveint = 1;

                getAngleWithXAxis(100, posX - _wheelImgX, -posY + _wheelImgY, moveint);

                break;
            case 'MSPointerDown':
                ev.preventDefault();
                posX = ev.pageX;
                posY = ev.pageY;
                moveint = 1;
                getAngleWithXAxis(100, posX - _wheelImgX, -posY + _wheelImgY, moveint);

                break;
            case 'pointerdown':
                ev.preventDefault();
                posX = ev.pageX;
                posY = ev.pageY;
                moveint = 1;
                getAngleWithXAxis(100, posX - _wheelImgX, -posY + _wheelImgY, moveint);

                break;
            case 'mousemove':
                break;
            case 'touchstart':
                ev.preventDefault();
                posX = ev.targetTouches[0].pageX;
                posY = ev.targetTouches[0].pageY;
                moveint = 1;
                getAngleWithXAxis(100, posX - _wheelImgX, -posY + _wheelImgY, moveint);
                break;
            case 'touchmove':
                break;
            case 'mouseup':
                posX = ev.pageX;
                posY = ev.pageY;
                moveint = 0;
                getAngleWithXAxis(100, posX - _wheelImgX, -posY + _wheelImgY, moveint);
                break;
            case 'MSPointerUp':
                posX = ev.pageX;
                posY = ev.pageY;
                moveint = 0;
                getAngleWithXAxis(100, posX - _wheelImgX, -posY + _wheelImgY, moveint);
                break;
            case 'pointerup':
                posX = ev.pageX;
                posY = ev.pageY;
                moveint = 0;
                getAngleWithXAxis(100, posX - _wheelImgX, -posY + _wheelImgY, moveint);

                break;
            case 'mouseout':
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;

                moveint = 0;
                break;
            case 'MSPointerOut':

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;

                moveint = 0;
                break;
            case 'pointerout':
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;

                moveint = 0;
                break;

            case 'touchcancel':
                ev.preventDefault();
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;
                moveint = 0;
                break;
            case 'touchend':
                //alert('touchend');
                ev.preventDefault();
                //posX = ev.targetTouches[0].pageX;
                //posY = ev.targetTouches[0].pageY;
                //posX = ev.changedTouches[0].pageX;
                //posY = ev.changedTouches[0].pageY;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;




                moveint = 0;
                //getAngleWithXAxis(100, posX - _wheelImgX, - posY + _wheelImgY, moveint);

                break;
        }
        //DocObj.pages[DocObj.currentpage].walkthroughcontrol.updateMovementVector();
        //DocObj.pages[DocObj.currentpage].walkthroughcontrol.updateRotationVector();


    }

    function regEvents(element) {

        element.addEventListener('touchstart', touchEvents);
        element.addEventListener('touchmove', touchEvents);
        element.addEventListener('touchcancel', touchEvents);
        element.addEventListener('touchend', touchEvents);

        if(bDisableMSIE11Eventcheck){
            element.addEventListener('mousemove', touchEvents);
            element.addEventListener('mousedown', touchEvents);
            element.addEventListener('mouseup', touchEvents);
            element.addEventListener('mouseout', touchEvents);

        }else{
            if (window.navigator.msPointerEnabled) {
                element.addEventListener('MSPointerMove', touchEvents);
                element.addEventListener('MSPointerDown', touchEvents);
                element.addEventListener('MSPointerUp', touchEvents);
                element.addEventListener('MSPointerOut', touchEvents);

            }else{
                element.addEventListener('mousemove', touchEvents);
                element.addEventListener('mousedown', touchEvents);
                element.addEventListener('mouseup', touchEvents);
                element.addEventListener('mouseout', touchEvents);

            }
        }



    }

    var Rx_CustStampGUI = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.onStampReceived = function (stampinfo) {
            if (typeof scope.callback === "function") {
                scope.callback(stampinfo);
            }

        };

    };

    var Rx_SymbolGUI = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.onSymbolReceived = function (symbolinfo) {
            if (typeof scope.callback === "function") {
                scope.callback(symbolinfo);
            }

        };

    };


    var Rx_CanvasResize = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.onResize = function (canvassize) {
            if (typeof scope.callback === "function") {
                scope.callback(canvassize);
            }

        };

    };

    var Rx_TextInputConn = function (callback){
        var scope = this;
        this.callback = callback;

        this.operation = {
          start : false,
          create : false,
          edit : false,
          save : false
        };

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.getText = function (text) {
            if (DocObj.markuplist[GetTempID().id] != undefined) {
                 return DocObj.markuplist[GetTempID().id];
            }else{
                return null;
            }

        };

        this.setText = function (text) {
            if (DocObj.markuplist[GetTempID().id] != undefined) {

                scope.operation.edit = false;
                scope.operation.start = false;
                scope.operation.create = false;
                scope.operation.save = false;

                DocObj.markuplist[GetTempID().id].text = text;

                //DocObj.markuplist[GetTempID().id].AdjustForRotation();
                //drawmarkupAll(cntximg);
                //DrawMarkupSelected(context);
            }
        };
        this.setSize = function(size){
            if (DocObj.markuplist[GetTempID().id] != undefined) {

                scope.operation.edit = false;
                scope.operation.start = false;
                scope.operation.create = false;
                scope.operation.save = false;

                DocObj.markuplist[GetTempID().id].setSize(size);

                //DocObj.markuplist[GetTempID().id].AdjustForRotation();
                //drawmarkupAll(cntximg);
                //DrawMarkupSelected(context);
            }

        };

        this.setTextInput = function (textrect) {
            if (typeof scope.callback === "function") {
                scope.callback(textrect, scope.operation);
            }

        };
    };

    var Rx_TextdiagConn = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setText = function (text) {
            if (DocObj.markuplist[GetTempID().id] != undefined) {
                DocObj.markuplist[GetTempID().id].text = text;

                DocObj.markuplist[GetTempID().id].AdjustForRotation(false);
                drawmarkupAll(cntximg);
                DrawMarkupSelected(context);
            }


        };


        this.setTextdiag = function (textdata) {
            if (typeof scope.callback === "function") {
                if (textdata == "" || textdata == ".") {
                    DocObj.markuplist[GetTempID().id].text = scope.callback("");

                    DocObj.markuplist[GetTempID().id].AdjustForRotation(false);
                    drawmarkupAll(cntximg);
                    DrawMarkupSelected(context);
                } else {
                    scope.callback(textdata);
                }

            }

        };

    };

    var Rx_NotediagConn = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.isAvailable = function() {
            if (GetTempID() == undefined || GetTempID().id == -1){
                return false;
            }
            return (DocObj.markuplist[GetTempID().id].type == 10);

        };

        this.getText = function () {

            if (scope.isAvailable) {
                return DocObj.markuplist[GetTempID().id];
            }else{
                return null;
            }

        };

        this.setText = function (text) {

            if (scope.isAvailable) {
                DocObj.markuplist[GetTempID().id].text = text;
                drawmarkupAll(cntximg);
                DrawMarkupSelected(context);

            }


        };


        this.setNotediag = function (notedata, readonly) {
            if (typeof scope.callback === "function") {
                if (notedata == "" || notedata == ".") {
                    if (GetTempID() == undefined){
                        return;
                    }
                    DocObj.markuplist[GetTempID().id].text = scope.callback("");

                } else {
                    scope.callback(notedata, readonly);
                }

            }

        };

    };


    /*Rx_GUITextdialog = function(callback){

     var scope = this;
     this.callback = callback;



     this.getText = function(text){
     if (typeof scope.callback === "function") {
     callback(text);
     }

     };

     };*/

    var Rx_ZoomUpdate = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.zoomUpdate = function (factor, center, type) {
            if (typeof scope.callback === "function") {
                scope.callback(factor, center, type);
            }

        };

    };



    var Rx_PanUpdate = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.panUpdate = function (x,y,pagerect) {
            if (typeof scope.callback === "function") {
                scope.callback(x,y, pagerect);
            }
        };
    };


    var Rx_MarkupSave = function (callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.markupSaved = function () {
            if (typeof scope.callback === "function") {
                scope.callback();
            }

        };


    };

    var Rx_Ready = function(callback){
        var scope = this;
        this.callback = callback;


        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setupComplete = function (openInitDoc) {

            if (typeof scope.callback === "function") {
                scope.callback(openInitDoc);
            }

        };

    };

    var Rx_RotateEvent = function(callback){
        var scope = this;
        this.callback = callback;


        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.onRotate = function (angle, pagenum) {

            if (typeof scope.callback === "function") {
                scope.callback(angle, pagenum);
            }

        };


    };

    var Rx_GUIUpload = function (callback) {
        var scope = this;
        this.callback = callback;
        this.progress = 0;

        this.connect = function (callback) {
            scope.callback = callback;
        };



        this.setUpload = function (upload) {
            if (typeof scope.callback === "function") {
                scope.callback(upload);
            }

        };
    };

    var Rx_GUIhasText = function (callback) {

        var scope = this;
        //Set to true if a page in document has text. Do not set back to false
        this.hastext = false;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.hasText = function (hastext, activefile) {
            /*if(hastext && DocObj){
                DocObj.hastext = true;
            }*/

            if (typeof scope.callback === "function") {
                scope.callback(hastext, activefile);

            }

        };

    };

    var Rx_GUITextFound = function (callback) {

        var scope = this;
        //Set to true if a page in document has text. Do not set back to false
        this.hastext = false;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.numTextFound = function (nummatches) {
            if (typeof scope.callback === "function") {
                scope.callback(nummatches);

            }

        };

    };


    var Rx_GUIResponseHeaders = function(callback){

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setRespHeaders = function (szheaders) {
            if (typeof scope.callback === "function") {

                scope.callback(szheaders);


            }

        };


    };
    var Rx_GUIDownload = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setDownload = function (download) {
            if (typeof scope.callback === "function") {
                scope.callback(download);

                //file load complete event to use for doing stuff when loaded.
                if (download == 'hide') {
                    //nothing
                }

            }

        };

    };

    var Rx_GUIMarkupUnselectConn = function (callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.setMarkupunSelected = function (markup) {
            if (typeof scope.callback === "function") {
                scope.callback(markup);
            }

        };


    };

    var Rx_GUIMarkupLinkConn = function(callback){
        var scope = this;
        this.callback = callback;
        this.showContext = false;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.markupLink = function(markup){
            if (typeof scope.callback === "function") {
                scope.callback(markup);
            }

        };

    };


    var Rx_GUIMarkupConn = function (callback) {

        var scope = this;
        this.callback = callback;
        this.showContext = false;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setMarkupSelected = function (markup, operation) {
            if (typeof scope.callback === "function") {
                scope.callback(markup, operation);
            }

        };

    };

    var Rx_GUIPDFBookmarsConn = function (callback) {

        var scope = this;
        this._pagesRefCache = Object.create(null);
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        /*this.createPageRefCache = function(outline){

         for(var i= 0;i<outline.length;i++){
         if(outline[i].count > 0){
         var destRef = outline[i].dest[0];

         if(DocObj.pages[DocObj.currentpage].usepdfjs){
         DocObj.getPDF_PageRef(scope._pagesRefCache,destRef);
         }
         //RxCore_GUI_PDFBookmarks.getPageRef(scope._pagesRefCache,destRef);

         /*for (var j=0;j<outline[i].count;j++){
         //ulstring += '<li>' + outline[i].items[j].title + '</li>\n';
         }
         }

         }

         };*/
        this.getPageRef = function (destRef) {
            var pagenum = -1;
            if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                var cacheKey = destRef.num + ' ' + destRef.gen + ' R';
                if (scope._pagesRefCache[cacheKey] != undefined) {
                    pagenum = scope._pagesRefCache[cacheKey];
                }
            }
            return pagenum;
        };

        this.setPageRef = function (object) {
            scope._pagesRefCache = object;
        };


        this.setPDFBookmarks = function (outline) {
            if (typeof scope.callback === "function") {
                scope.callback(outline);
            }

        };

    };

    var RxPrintCompareConn = function(){
        var scope = this;
        this.callback = undefined;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.printCompareComplete = function(printobj){
            if (typeof scope.callback === "function" && scope.callback !== undefined) {
                scope.callback(printobj);
            }

        }

    };

    var Rx_PrintPageConn = function(){
        var scope = this;
        this.callback = undefined;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.printpageComplete = function(printobj){
            if (typeof scope.callback === "function" && scope.callback !== undefined) {
                scope.callback(printobj);
            }

        }

    };

    var Rx_GUIPageConn = function (callback){

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.pageEvent = function(pageobject){

            if (typeof scope.callback === "function" && scope.callback !== undefined) {
                scope.callback(pageobject);
            }


        };

    };

    var Rx_GUIStateConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setGUIState = function (stateojb) {
            this.state = stateojb;
            if (typeof scope.callback === "function" && scope.callback !== undefined) {
                scope.callback(stateojb);
            }
        };

    };


    var Rx_UserlistConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.getSignature = function () {
            return signature;
        };

        this.setSignature = function (sign) {
            signature = sign;
        };

        this.getCanChangeSign = function () {
            return bCanChangeSignature;
        };

        this.SetUserMarkupdisplay = function (numuser, state) {
            var curmarkup = 0;
            Userlist[numuser].display = state;

            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {

                var layerdisplay = getMarkupLayerState(DocObj.markuplist[curmarkup].layer);

                if (DocObj.markuplist[curmarkup].signature == Userlist[numuser].Signature && layerdisplay) {
                    DocObj.markuplist[curmarkup].display = Userlist[numuser].display;
                }

            }
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);

        };


        this.setUserlist = function (userlist, activefile) {
            if (typeof scope.callback === "function") {
                scope.callback(userlist, activefile);
            }

        };

    };

    var Rx_MarkupLayerConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.getCurMarkupLayer = function () {
            return markuplayer;
        };

        this.getCanChangelayer = function () {
            return bCanChangeLayer;
        };

        this.SetLayerMarkupdisplay = function (numlayer, state) {

            var curmarkup = 0;
            Layerlist[numlayer].display = state;

            for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {

                var signdisplay = getSignState(DocObj.markuplist[curmarkup].signature);

                if (DocObj.markuplist[curmarkup].layer == Layerlist[numlayer].Layer && signdisplay) {
                    DocObj.markuplist[curmarkup].display = Layerlist[numlayer].display;
                }
            }
            drawmarkupAll(cntximg);
            DrawMarkupSelected(context);
        };

        this.setMarkupLayers = function (markuplayers) {
            if (typeof scope.callback === "function") {
                scope.callback(markuplayers);
            }

        };

    };

    var Rx_FileInfoConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.getUnitlabel = function () {
            return Unitlabel;
        };

        this.setFileInfo = function (fileinfo) {
            this.fileinfo = fileinfo;
            if (typeof scope.callback === "function") {
                scope.callback(fileinfo);
            }

        };

    };

    var Rx_PageThumbnailsConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.getHeight = function () {
            return canvasoheight;
        };

        this.getCurrentPage = function () {
            return DocObj.getcurPage();
        };

        this.hasmarkup = function (page) {
            var hasmarkup = false;
            for (var i = 0; i < DocObj.markuplist.length; i++) {
                if (DocObj.markuplist[i].pagenumber == page) {
                    hasmarkup = true;
                }
            }
            return hasmarkup;
        };

        this.notify = function () {
            if (typeof scope.callback === "function") {
                scope.callback(this.thumbnails);
            }
        };

        this.setThumbnails = function (thumbnails) {

            this.thumbnails = thumbnails;
            this.notify();

        };

    };

    var Rx_VectorLayersConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.getHeight = function () {
            return canvasoheight;
        };


        this.setVectorLayers = function (vectorlayers) {
            if (typeof scope.callback === "function") {
                scope.callback(vectorlayers);
            }

        };

    };

    var Rx_VectorBlocksConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.getHeight = function () {
            return canvasoheight;
        };


        this.setVectorBlocks = function (vectorblocks) {
            if (typeof scope.callback === "function") {
                scope.callback(vectorblocks);
            }

        };

    };

    var Rx_3DPartsReadComplete = function (callback) {
        var scope = this;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.readComplete = function () {

            if (typeof scope.callback === "function") {
                scope.callback();
            }

        };


    };


    var Rx_3DPartsConn = function (callback) {

        var scope = this;
        this.listheight = 0;
        this.isupdate = false;
        this.scrollto = 0;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.getHeight = function () {
            return canvasoheight;
        };

        this.setlistHeight = function (height) {
            scope.listheight = height;
        };

        this.set3DParts = function (Parts) {
            this.parts = Parts;
            if (typeof scope.callback === "function") {
                scope.callback(Parts);
            }

        };

    };

    var Rx_2DBlockConn = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.set2DBlockID = function (blockid) {

            if (typeof scope.callback === "function") {
                scope.callback(blockid);
            }

        };

    };


    var Rx_2DBlockAttributeConn = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.set2DBlockInfo = function (PartInfo) {
            this.info = PartInfo;
            if (typeof scope.callback === "function") {
                scope.callback(PartInfo);
            }

        };

    };
    var Rx_3DPartInfoConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.set3DPartInfo = function (PartInfo) {
            this.info = PartInfo;
            if (typeof scope.callback === "function") {
                scope.callback(PartInfo);
            }

        };
    };

    var Rx_PDFRenderComplete = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.RenderComplete = function (pagedata) {

            if (typeof scope.callback === "function") {
                scope.callback(pagedata);
            }

        };

    };

    var Rx_PageLoadComplete = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.loadComplete = function (pagenumber) {

            if (typeof scope.callback === "function") {
                scope.callback(pagenumber);
                DocObj.pages[DocObj.currentpage].redraw();
            }

        };

    };

    var Rx_MarkupLoadComplete = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.loadComplete = function (markups, fileindex, activefile) {

            if (typeof scope.callback === "function") {
                scope.callback(markups, fileindex, activefile);
            }

        };

    };

    var Rx_FileLoadComplete = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.loadComplete = function (fileurl, bActiveFile) {

            if (typeof scope.callback === "function") {
                scope.callback(fileurl, bActiveFile);
            }

        };

    };


    var Rx_MarkupDrawErrorEvt = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.onDrawError = function(error){

            if (typeof scope.callback === "function") {
                scope.callback(error);
            }

        };

    };

    var Rx_MarkupDrawEvent = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.onDrawEvent = function(distAngle){

            if (typeof scope.callback === "function") {
                scope.callback(distAngle);
            }

        };

    };

    var Rx_MarkupListConn = function(callback) {
        var scope = this;
        this.callback = callback;
        this.pageonly = false;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.getDisplayName = function (sign) {
            return GetDisplayName(sign);
        };

        this.getDisplayDate = function (date) {
            return GetDateTime(date);
        };

        /* Andriy notify listeners */
        this.notify = function (markupList, fileActive) {
            if (typeof scope.callback === "function") {
                scope.callback(markupList, fileActive);
            }
        };

        this.setMarkupList = function (markupList, fileActive, preventNotification) {
            /* Andriy */
            this.markupList = markupList;

            if (!preventNotification) {
                this.notify(markupList, fileActive);
            }

        };
    };

    var Rx_MarkupStampsConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.setMarkupStamps = function (stamps) {
            if (typeof scope.callback === "function") {
                scope.callback(stamps);
            }

        };

    };

    var Rx_MeasureConn = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.getLength = function (length) {
            // Andriy: moved to a separate function
            return RxCore_helper.getLength(length);
        };

        this.getUnitlabel = function () {
            return Unitlabel;
        };

        this.getAreaUnitlabel = function () {
            return AreaUnitlabel;
        };


        this.setMeasureresult = function (measureresult) {
            if (typeof scope.callback === "function") {
                scope.callback(measureresult);
            }

        };


    };


    var Rx_CalibrateComplete = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.onCalibrate = function (calibratedata) {
            if (typeof scope.callback === "function") {
                scope.callback(calibratedata);
            }
        };


    };
    var Rx_CalibrateConn = function (callback) {

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.getUnitlabel = function () {
            return Unitlabel;
        };

        this.setCalibration = function (val) {
            var pagenumber = -1;

            if(documentopen){
                nCalibrateScale = DocObj.pages[DocObj.currentpage].setCalibration(val);
                pagenumber = DocObj.pages[DocObj.currentpage].pagenumber;
            }else{
                if (val) {
                    if (nCalibrateSet != 0) {
                        nCalibrateScale = nCalibrateMeasured / nCalibrateSet;
                        nCalibrateScale = 1 / nCalibrateScale;
                        //setCalibratebtn();
                        MeasureScale = nCalibrateScale;
                    }

                } else {
                    nCalibrateScale = 1;
                }

            }

            var calibratedata = {
                calibratescale : nCalibrateScale,
                pagenumber : pagenumber
            };


            if(RxCore_GUI_CalibrateComplete != undefined){
                RxCore_GUI_CalibrateComplete.onCalibrate(calibratedata);
            }


        };


        this.SetTempCal = function (value) {
            nCalibrateSet = value;
        };

        this.setCalibrate = function (calibratedata) {
            if (typeof scope.callback === "function") {
                scope.callback(calibratedata);
            }
        };

    };


    var Rx_StateGUIConn = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setStateGUI = function (RxCorestate) {
            if (typeof scope.callback === "function") {
                scope.callback(RxCorestate);
            }

        };

    };

    var Rx_Walkthrough3DConn = function (callback) {

        var scope = this;
        this.callback = callback;
        this.elementSet = false;
        this._wheelImg = undefined;

        this.connect = function (callback) {
            scope.callback = callback;
        };


        this.setDivElement = function (HTMLElement) {
            regEvents(HTMLElement);
            this.elementSet = true;
        };

        this.setWalkthroughGUI = function (setvisible) {
            if (typeof scope.callback === "function") {
                scope.callback(setvisible);

            }

        };


    };

    var Rx_CompareMeasureConn = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.AlignMeasure = function (distance,angle, offset, pagewidth) {
            if (typeof scope.callback === "function") {
                scope.callback(distance,angle, offset, pagewidth);
            }
        };
    };

    var Rx_CompareAlignConn = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.AlignComplete = function (pageobject) {
            if (typeof scope.callback === "function") {
                scope.callback(pageobject);

            }

        };


    };

    var onRotateEvent = function(callback){
      var scope = this;

    };

    var Rx_ConsolidateConn = function(callback){
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.Consolidatevt = function () {
            if (typeof scope.callback === "function") {
                scope.callback(consolidateObj);
            }
        };

    };

    var Rx_PermissionsConn = function(callback){

        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.UserPermissions = function (permissions) {
            if (typeof scope.callback === "function") {
                scope.callback(permissions);
            }
        };

    };


    var Rx_CompareDialogConn = function (callback) {
        var scope = this;
        this.callback = callback;

        this.connect = function (callback) {
            scope.callback = callback;
        };

        this.CompareDialog = function () {
            if (typeof scope.callback === "function") {
                scope.callback(OpenfileNames);

            }

        };


    };

    function RxCore_getSymbolLibNum(){
        getNumSymblibs();
    }

    function RxCore_selectSymblib(num){
        selectSymblib(num);
    }

    function RxCore_selectSymbName(num){
        selectSymbname(num);
    }

    function RxCore_getnumSymbols(num){
        getnumSymbols(num);
    }

    function RxCore_getSymbolName(num,sname){
        getSymbolName(num,sname);

    }

    function RxCore_getSymbolLibPNGData(num,sname){
        getSymbolPNGData(num,sname);

    }


    function RxCore_UseCredentials(onOff){

        bUseCredentials = onOff;
    }



    function RxCore_ConsolidatedOnly(onOff){

        if (!documentopen) {
            return;
        }

        for (var curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {

            //var signdisplay = getSignState(DocObj.markuplist[curmarkup].signature);

            if (!DocObj.markuplist[curmarkup].consolidated) {
                DocObj.markuplist[curmarkup].display = onOff;
            }
        }
        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }

    function RxCore_SetThumbnailctx(ctx,index){
        if (!documentopen) {
            return;
        }
        DocObj.pages[index].thumbctx = ctx;

    }

    function RxCore_AbortPDFload(ok){
        bAbortPageload = ok;

        RxCore_Closedocument();

    }

    function RxCore_AppendCustomBlockAttribute(blockid, name, value){
        if (!documentopen) {
            return;
        }

        if (documentcompare) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].appendCustomBlockAttribute(blockid , name, value);
        }


    }

    function RxCore_setRxSpaceColor(blockid , Color, override){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        var exist = setMarkupSpaceColor(blockid, Color, override);

    }

    function RxCore_setBlockColor(blockid , Color, override){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        var exist = setMarkupSpaceColor(blockid, Color, override);

        if (!exist){
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                DocObj.pages[DocObj.currentpage].setBlockColor(blockid , Color, override);
            }
        }

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            DocObj.pages[DocObj.currentpage].set3DBlockColor(blockid , Color, override);
        }



    }

    function RxCore_changeSpaceCustomLabel(blockid, newText){
        if (!documentopen || documentcompare) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        var markupobj = findSpaceMarkup(blockid);

        if(markupobj){
            if(markupobj.busecustomlabel){
              markupobj.customlabeltext = newText;
            }

        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }

    function RxCore_setCustomLabelText(text, onoff){
        if (!documentopen) {
            return;
        }

        if(readonlymode){
            return;
        }

        var markupobject = getSelectedmarkup();

        if(!markupobject.isempty){
            markupobject.customlabeltext = text;
            markupobject.busecustomlabel = onoff;

        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }

    function RxCore_setCompareColors(bgcolor, fgcolor){

        overlayBGColor = bgcolor;
        overlayFGColor = fgcolor;

        if (!documentopen) {
            return;
        }

        var bhaveCompare = false;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                bhaveCompare = true;
            }
        }

        if(bhaveCompare){
            CompareObj.setColors(bgcolor, fgcolor);
        }




    }


    function RxCore_SetCompareFiles(index, state) {

        if(index == undefined){
            return;
        }
        //var filelist = RxCore_GetOpenFiles();

        if (OpenfileNames.length < index + 1 || OpenfileNames.length == 0) {
            var filelist = RxCore_GetOpenFiles();
            if(filelist.length > index){
                OpenfileNames[index].state = state;
            }

        }else{
            OpenfileNames[index].state = state;
            //var filelist = RxCore_GetOpenFiles();
        }

        //make sure only 1 background and 1 overlay
        for (var i = 0; i < OpenfileNames.length; i++) {
            if (OpenfileNames[i].state == state && i != index) {
                OpenfileNames[i].state = 0;
            }
        }

        if (RxCore_GUI_CompareDiag != undefined) {
            RxCore_GUI_CompareDiag.CompareDialog();
        }


    }

    function RxCore_GetOpenFiles() {

        /*
         state
         0 = unused;
         1 = background;  //
         2 = overlay;
         */
        var fileExist = false;

        for (var i = 0; i < OpenFiles.length; i++) {
            var isImage = (!OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usepdfjs
                && !OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usevector3Dxml
                && !OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usevectorxml);

            if (OpenFiles[i].Type == 'Compare') {
                var OpenFileObject = {
                    index:OpenFiles[i].pages[0].DocRef.fileindex,
                    Name:OpenFiles[i].pages[0].DocRef.FileName,
                    Type:OpenFiles[i].pages[0].DocRef.Type,
                    Is2D:OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usevectorxml,
                    isImage : isImage,
                    isPDF : OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usepdfjs,
                    state:1
                };
                OpenfileNames.push(OpenFileObject);
                isImage = (!OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usepdfjs
                    && !OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usevector3Dxml
                    && !OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usevectorxml);

                OpenFileObject = {
                    index:OpenFiles[i].pages[1].DocRef.fileindex,
                    Name:OpenFiles[i].pages[1].DocRef.FileName,
                    Type:OpenFiles[i].pages[1].DocRef.Type,
                    Is2D:OpenFiles[i].pages[1].DocRef.pages[OpenFiles[i].pages[1].DocRef.currentpage].usevectorxml,
                    isImage : isImage,
                    isPDF : OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usepdfjs,
                    state:2
                };
                OpenfileNames.push(OpenFileObject);
            } else {
                var statecmp = 0;
                for (var j = 0; j < CompareFiles.length; j++) {
                    if (OpenFiles[i].FileName == CompareFiles[j].Name) {
                        statecmp = CompareFiles[j].state;
                    }
                }
                isImage = (!OpenFiles[i].pages[OpenFiles[i].currentpage].usepdfjs
                    && !OpenFiles[i].pages[OpenFiles[i].currentpage].usevector3Dxml
                    && !OpenFiles[i].pages[OpenFiles[i].currentpage].usevectorxml);

                OpenFileObject = {
                    index:OpenFiles[i].fileindex,
                    Name:OpenFiles[i].FileName,
                    Type:OpenFiles[i].Type,
                    Is2D:OpenFiles[i].pages[OpenFiles[i].currentpage].usevectorxml,
                    isImage : isImage,
                    isPDF : OpenFiles[i].pages[0].DocRef.pages[OpenFiles[i].pages[0].DocRef.currentpage].usepdfjs,
                    state:statecmp
                };

                for (var k = 0; k < OpenfileNames.length; k++) {
                    if (OpenFileObject.index == OpenfileNames[k].index) {
                        fileExist = true;
                    }
                }

                if (!fileExist) {
                    OpenfileNames.push(OpenFileObject);
                    fileExist = false;
                }


            }

        }


        return OpenfileNames;

    }

    function RxCore_getOpenFilesList() {
        var openFilesList = [];

        for (var i = 0; i < OpenFiles.length; i++) {
            openFilesList.push({
                index: OpenFiles[i].fileindex,
                name: OpenFiles[i].FileName || OpenFiles[i].Type,
                isActive: OpenFiles[i].bActive,
            })
        }
        return openFilesList;
    }

    function RxCore_setActiveFile(indx){
        context.clearRect(0, 0, canvas.width, canvas.height);
        cntximg.clearRect(0, 0, canvas.width, canvas.height);

        if(DocObj){
            DocObj.enableTextSelect(false);
        }


        if (OpenFiles.length >= 1 && OpenFiles[indx] != undefined) {

            if (OpenFiles[indx].Type == 'Compare') {
                CompareObj = OpenFiles[indx];
                CompareObj.bSopenSilent = false;
                for (var i = 0; i < OpenFiles.length; i++) {
                    if (OpenFiles[i].Type !== 'Compare' && OpenFiles[i].pages.length) {
                        for (var j = 0; j < OpenFiles[i].pages.length; j++) {
                            OpenFiles[i].pages[j].usedincomposite = true;
                        }
                    }

                }
                DeactivateAll();
                CompareObj.SetActive();

            } else{
                bAnimateready = true;
                DocObj = OpenFiles[indx];

                DocObj.bSopenSilent = false;

                if (bPDFtemprender && !DocObj.pdfDoc) {
                    bPDFtemprender = false;
                }
                if (DocObj.pages && DocObj.pages.length) {
                    DocObj.pages[0].usedincomposite = false;
                }

                if (!DocObj.pages[DocObj.currentpage].usevector3Dxml){
                    if (RxCore_GUI_3DWalkthrough != undefined) {
                        RxCore_GUI_3DWalkthrough.setWalkthroughGUI(false);
                        //$('div.wheelPanel').css('visibility', 'hidden');
                    }
                }


                DeactivateAll();
                DocObj.SetActive();

            }

        }

    }

    function RxCore_setWalkthroughDiv(HTMLElement) {
        if (!documentopen) {
            return;
        }

        regEvents(HTMLElement);
        //regEvents($(this.touchCake)[0]);

    }

    function RxCore_3DOrbit() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            //only reset camera if current tool is walkthrough
            if (tool == undefined) {
                set_tool('orbitControl', {});
                //tool = new tools['orbitControl']();
                DocObj.curcontrol3D = 'orbitControl';
            }

            if (tool.name == 'Walkthrough3D') {

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.enabled = false;

                camerax = 0;
                cameray *= 2;
                cameraz = 0;
                var format = DocObj.Format.substring(0, 3);
                if (format == 'IFC') {
                    var camerax = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.w / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    var cameray = -(DocObj.pages[DocObj.currentpage].Vector3DPageObj.h) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    var cameraz = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.d / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;

                    camerax = 0;
                    cameray *= 2;
                    cameraz = 0;


                    DocObj.pages[DocObj.currentpage].camera.up.set(0, 0, 1);
                    //DocObj.pages[DocObj.currentpage].camera.rotation.set(90 * Math.PI / 180, 0, 0);

                } else {

                    camerax = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.w / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    cameray = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.h / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    cameraz = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.d) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;

                    camerax = 0;
                    cameray = 0;
                    cameraz *= 2;

                    DocObj.pages[DocObj.currentpage].camera.up.set(0, 1, 0);
                    //DocObj.pages[DocObj.currentpage].camera.rotation.set(0, 90 * Math.PI / 180, 0);


                }


                DocObj.pages[DocObj.currentpage].camera.position.set(camerax, cameray, cameraz);
                DocObj.pages[DocObj.currentpage].camera.lookAt(new THREE.Vector3(0,0,0));

            }
            if (RxCore_GUI_3DWalkthrough != undefined) {
                RxCore_GUI_3DWalkthrough.setWalkthroughGUI(false);
                //$('div.wheelPanel').css('visibility', 'hidden');
            }

            set_tool('orbitControl', {});
            //tool = new tools['orbitControl']();
            DocObj.curcontrol3D = 'orbitControl';
        }

    }

    function RxCore_3DWalkThrough(selected) {
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            if (selected) {
                if (RxCore_GUI_3DWalkthrough != undefined) {
                    RxCore_GUI_3DWalkthrough.setWalkthroughGUI(true);
                    //$('div.wheelPanel').css('visibility', 'visible');
                }

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.reset();
                set_tool('Walkthrough3D', {});
                //tool = new tools['Walkthrough3D']();



                var format = DocObj.Format.substring(0, 3);
                if (format == 'IFC') {
                    var camerax = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.w / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    var cameray = -(DocObj.pages[DocObj.currentpage].Vector3DPageObj.h) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    var cameraz = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.d / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;

                    camerax = 0;
                    //cameray *= 2;
                    cameraz = 0;


                    DocObj.pages[DocObj.currentpage].camera.up.set(0, 0, 1);
                    //DocObj.pages[DocObj.currentpage].camera.rotation.set(90 * Math.PI / 180, 0, 0);

                } else {
                    camerax = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.w / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    cameray = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.h / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                    cameraz = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.d) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;

                    camerax = 0;
                    cameray = 0;
                    //cameraz = 0;

                    DocObj.pages[DocObj.currentpage].camera.up.set(0, 1, 0);
                    //DocObj.pages[DocObj.currentpage].camera.rotation.set(0, 90 * Math.PI / 180, 0);


                }


                DocObj.pages[DocObj.currentpage].camera.position.set(camerax, cameray, cameraz);
                DocObj.pages[DocObj.currentpage].camera.lookAt(new THREE.Vector3(0,0,0));
                DocObj.curcontrol3D = 'Walkthrough3D';
            } else {
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.firstxyrecieved = false;
                RxCore_3DOrbit();
            }


        }
    }

    function RxCore_3DTransparency(value) {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.setTransparency(value);
        }

    }

    function RxCore_3DTransparentOn() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.setTransparency(0.5);
        }

    }


    function RxCore_3DExplodedistance(value) {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml && DocObj.pages[DocObj.currentpage].Vector3DPageObj.doexplode) {
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.explode(value);
        }

    }


    function RxCore_Save3DCamera(){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

            DocObj.pages[DocObj.currentpage].Vector3DPageObj.saveCamera();
            //tool = new tools['select3d']();
        }


    }

    function RxCore_restoreCamera(){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

            DocObj.pages[DocObj.currentpage].Vector3DPageObj.restoreCamera();
            //tool = new tools['select3d']();
        }


    }

    function RxCore_3DExplode(onoff) {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

            DocObj.pages[DocObj.currentpage].Vector3DPageObj.doexplode = onoff;
            //tool = new tools['select3d']();
        }


    }


    function RxCore_3dClipping(onoff,plane,value){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

            DocObj.pages[DocObj.currentpage].Vector3DPageObj.clipping(plane,value,onoff);
            //tool = new tools['select3d']();
        }

    }

    function RxCore_ChangeVectorLayer(index) {
        if (!documentopen) {
            return;
        }
        DocObj.pages[DocObj.currentpage].turnLayerOnOff(index);
    }

    function RxCore_resetLayers() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].resetLayers();
        }

    }

    function RxCore_LayersAll(OnOff){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].turnLayerAllOnOff(OnOff);
        }


    }

    function RxCore_BlocksAll(OnOff){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].turnBlockAllOnOff(OnOff);
        }


    }

    function RxCore_BlockLoadMask(szBlockLoadMask){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].filterBlocks(szBlockLoadMask);
        }

    }


    function RxCore_get2DVectorBlocks(){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            return DocObj.pages[DocObj.currentpage].getBlocks();
        }

    }

    function RxCore_getBlockAttributes(blockid){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            return DocObj.pages[DocObj.currentpage].blockAttributes(blockid);
        }

    }


    function RxCore_createSpacefromBlock(blockid){
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {


            var scalefactor = DocObj.pages[DocObj.currentpage].dscalevector;
            var xoffset = DocObj.pages[DocObj.currentpage].dxvector;
            var yoffset = DocObj.pages[DocObj.currentpage].dyvector;
            var mediax = DocObj.pages[DocObj.currentpage].VectorPageObj.x;
            var mediay = DocObj.pages[DocObj.currentpage].VectorPageObj.y;
            var mediah = DocObj.pages[DocObj.currentpage].VectorPageObj.h;

            var attribs = DocObj.pages[DocObj.currentpage].blockAttributes(blockid);

            //var polypoints = DocObj.pages[DocObj.currentpage].getpolygonPointsbyblockID(blockid);

            var polypath = DocObj.pages[DocObj.currentpage].getpolygonPathbyblockID(blockid);


            //attribs

            if(polypath != null){
                RxCore_createSpacemarkupAttribsPath(blockid, polypath, attribs, scalefactor, xoffset, yoffset, mediax, mediay, mediah);
            }

            //RxCore_createSpacemarkupAttribs(blockid, polypoints, attribs, scalefactor, xoffset, yoffset, mediax, mediay, mediah);


        }


    }

    function RxCore_getBookMarkPage(destref){
        if (!documentopen) {
            return;
        }
        return DocObj.get_bookmark_pageref(destref);
    }

    function RxCore_getCacheURL(){
        if (!documentopen) {
            return;
        }

        return DocObj.CacheURL;

    }

    function RxCore_getOriginalPath(){
        if (!documentopen) {
            return;
        }

        return DocObj.OriginalURL;

    }


    function RxCore_ChangeVectorBlock(index) {
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].turnBlockOnOff(index);
        }

    }

    function RxCore_RestoreBlockStates(){
        if (!documentopen) {
            return;
        }

        restoreSpacemarkupStates();

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].restoreBlockStates();
        }

    }

    function RxCore_resetBlocks() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].resetBlocks();
        }

    }

    function RxCore_Change3DVectorBlock(name) {
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            DocObj.pages[DocObj.currentpage].turn3DBlockOnOff(name);
        }

    }

    function RxCore_findMarkupByAttr(attrname, attrvalue){
        if (!documentopen) {
            return;
        }


    }

    function RxCore_FindBlockByAttr(attrname, attrvalue){
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            return DocObj.pages[DocObj.currentpage].FindBlockByAttr(attrname, attrvalue);
        }


    }

    function RxCore_Search3dAttribute(expr){
        if (!documentopen) {
            return -1;
        }

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return DocObj.pages[DocObj.currentpage].search3DAttribute(expr);
        }

    }

    function RxCore_Select3DVectorBlock(name) {
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            DocObj.pages[DocObj.currentpage].select3DBlock(name);
        }

    }

    function RxCore_SelectVectorBlock(blockid) {
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].selectBlock(blockid);
        }

    }


    function RxCore_MoveTo3DPart(){
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            var partid = DocObj.pages[DocObj.currentpage].Vector3DPageObj.getSelectedPart();
            if (partid !=-1){
                DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.updateMatrixWorld();

                var origox = DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.position.x;
                var origoy = DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.position.y;
                var origoz = DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.position.z;
                var modelscale = DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;

                //var partx = -(origox - DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].center.x) * modelscale;
                //var party = -(origoy - DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].center.y) * modelscale;
                //var partz = -(origoz - DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].center.z) * modelscale;

                //vcentroid
                //centroid

                var partx = -DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].vcentroid.x * modelscale;
                var party = -DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].vcentroid.y * modelscale;
                var partz = -DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].vcentroid.z * modelscale;
                var zdiff = DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].vcentroid.z - DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].minz;


                var camerax = origox - partx; //- (DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].radius * 2);
                var cameray = origoy - party; //- (DocObj.pages[DocObj.currentpage].Vector3DPageObj.partlist[partid].radius * 2);
                var cameraz = origoz - partz;
                var partPos = new THREE.Vector3(camerax, cameray, cameraz);



                var format = DocObj.Format.substring(0, 3);
                if (format == 'IFC') {
                    DocObj.pages[DocObj.currentpage].camera.up.set(0, 0, 1);
                    //DocObj.pages[DocObj.currentpage].camera.rotation.set(90 * Math.PI / 180, 0, 0);

                } else {
                    //DocObj.pages[DocObj.currentpage].camera.rotation.set(0, 90 * Math.PI / 180, 0);
                    DocObj.pages[DocObj.currentpage].camera.up.set(0, 1, 0);
                }

                if(DocObj.pages[DocObj.currentpage].Vector3DPageObj.unit == 1){
                    var offset = modelscale;
                    var zoffset = (1.8 - zdiff) * modelscale;
                }else{
                    offset = 1000 * modelscale;
                    zoffset = (1800 - zdiff) * modelscale;
                }

                DocObj.pages[DocObj.currentpage].camera.position.x = camerax;
                DocObj.pages[DocObj.currentpage].camera.position.y = cameray - offset;
                DocObj.pages[DocObj.currentpage].camera.position.z = cameraz + zoffset;
                DocObj.pages[DocObj.currentpage].camera.lookAt(partPos);

                var xrot = DocObj.pages[DocObj.currentpage].camera.rotation.x;
                var yrot = DocObj.pages[DocObj.currentpage].camera.rotation.y;
                var zrot = DocObj.pages[DocObj.currentpage].camera.rotation.z;


                DocObj.pages[DocObj.currentpage].walkthroughcontrol.setInitial(-(xrot * (180 / Math.PI)),90,0,0);


            }
        }

        if (RxCore_GUI_3DWalkthrough != undefined) {
            RxCore_GUI_3DWalkthrough.setWalkthroughGUI(true);
            //$('div.wheelPanel').css('visibility', 'visible');
        }
        set_tool('Walkthrough3D', {});
        //tool = new tools['Walkthrough3D']();
        DocObj.curcontrol3D = 'Walkthrough3D';
    }

    function RxCore_Reset3DModel() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            DocObj.pages[DocObj.currentpage].reset3DParts();
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.doexplode = true;
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.explode(0);
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.doexplode = false;
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.resetTransparency();
            DocObj.pages[DocObj.currentpage].Vector3DPageObj.clipping(-1,0,false);
            //RxCore.clipping3D(item.state,-1,0);

            var format = DocObj.Format.substring(0, 3);
            if (format == 'IFC') {

                var camerax = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.w / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                var cameray = -(DocObj.pages[DocObj.currentpage].Vector3DPageObj.h) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                var cameraz = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.d / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;

                camerax = 0;
                cameray *= 2;
                cameraz = 0;

                DocObj.pages[DocObj.currentpage].camera.up.set(0, 0, 1);
                //DocObj.pages[DocObj.currentpage].camera.rotation.set(90 * Math.PI / 180, 0, 0);
            } else {

                camerax = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.w / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                cameray = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.h / 2) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                cameraz = (DocObj.pages[DocObj.currentpage].Vector3DPageObj.d) * DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;

                camerax = 0;
                cameray = 0;
                cameraz *= 2;

                DocObj.pages[DocObj.currentpage].camera.up.set(0, 1, 0);
                //DocObj.pages[DocObj.currentpage].camera.rotation.set(0, 90 * Math.PI / 180, 0);

            }


            //camera.rotation.set(90 * Math.PI / 180,0,0);
            DocObj.pages[DocObj.currentpage].camera.position.set(camerax, cameray, cameraz);
            DocObj.pages[DocObj.currentpage].camera.lookAt(new THREE.Vector3(0,0,0));

            DocObj.curcontrol3D = 'orbitControl';
            RxCore_3DOrbit();
            //Viewer3D.resetScene();
            //Viewer3D.update();
        }

    }

    function RxCore_MarkupMultiselect(onOff){

        bMultiselect = onOff;

        //if more than 1 markup is currently selected keep multiselect on.

        //if()
    }

    function RxCore_changeSnapState(state) {
        if (!documentopen) {
            return;
        }
        DocObj.pages[DocObj.currentpage].enableSnap(state);
    }

    function RxCore_getSnapState(){
        if (!documentopen) {
            return;
        }else{
            return DocObj.pages[DocObj.currentpage].getSnapState();
        }

    }

    function RxCore_changeLabelTransp(val){
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }


        var temptransp = globaltransparency;
        globaltransparency = val;
        ChangeMarkupSelected(12);

        if (!bSetGlobal) {
            globaltransparency = temptransp;
        }

    }

    function RxCore_ChangeTransp(val) {
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }


        var temptransp = globaltransparency;
        globaltransparency = val;
        ChangeMarkupSelected(6);
        if (!bSetGlobal) {
            globaltransparency = temptransp;
        }

    }

    function RxCore_ChangeColorByIndex(indx,val,strokefill){
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }


        if (val.match(/rgb/gi) != null) {
            val = rgbToHex(val);
        }

        var tempcolor = markupcolor;

        switch (strokefill) {
            case 1:
                tempcolor = markuplinecolor;
                markuplinecolor = val;
                ChangeMarkupByindx(indx,1);
                if (!bSetGlobal) {
                    markuplinecolor = tempcolor;
                }

                break;
            case 0:
                tempcolor = markupfillcolor;
                markupfillcolor = val;
                ChangeMarkupByindx(indx,7);
                if (!bSetGlobal) {
                    markupfillcolor = tempcolor;
                }

                break;
            case 2:
                tempcolor = markuptextcolor;
                markuptextcolor = val;
                ChangeMarkupByindx(indx,8);
                if (!bSetGlobal) {
                    markuptextcolor = tempcolor;
                }

                break;
        }


    }

    function RxCore_ChangeColor(val, strokefill) {
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }

        if (val.match(/rgb/gi) != null) {
            val = rgbToHex(val);
        }

        var tempcolor = markupcolor;
        //markupcolor = val;

        switch (strokefill) {
            case 1:
                tempcolor = markuplinecolor;
                markuplinecolor = val;

                ChangeMarkupSelected(1);
                if (!bSetGlobal) {
                    markuplinecolor = tempcolor;
                }

                break;
            case 0:
                tempcolor = markupfillcolor;
                markupfillcolor = val;

                ChangeMarkupSelected(7);
                if (!bSetGlobal) {
                    markupfillcolor = tempcolor;
                }

                break;
            case 2:
                tempcolor = markuptextcolor;
                markuptextcolor = val;

                ChangeMarkupSelected(8);
                if (!bSetGlobal) {
                    markuptextcolor = tempcolor;
                }

                break;
        }

        /*if (!bSetGlobal) {
            markupcolor = tempcolor;
        }*/

    }

    function RxCore_MarkupSaveCheck(OnOff){
        bMarkupSavecheck = OnOff;
    }


    function RxCore_GetColor() {
        return markupcolor;
    }

    function RxCore_GetCompareColors() {

        var comparecolors = {
            bg:overlayBGColor,
            fg:overlayFGColor
        };

        var bhaveCompare = false;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                bhaveCompare = true;
            }
        }
        if(bhaveCompare){
            comparecolors = CompareObj.getColors();
        }

        return comparecolors;

    }


    function RxCore_GetlineColor() {
        return markuplinecolor;
    }

    function RxCore_GetfillColor() {
        return markupfillcolor;
    }

    function RxCore_GetTextColor() {
        return markuptextcolor;
    }


    function RxCore_GetCanvasSize(){
        return {
            w:canvasowidth,
            h:canvasoheight
        };

    }

    function RxCore_overlaymode(szblendmode){

        bShowDiffonly = !bShowDiffonly;
        szdrawmode = szblendmode;

        return bShowDiffonly;
    }

    function RxCore_hideLabels(onoff){

        bMarkupNoLabel = onoff;


    }

    function RxCore_showMarkupLabels(onoff){
        bmarkupLabels = onoff;
    }

    function RxCore_lockMarkup(onoff){
        DocObj.bMarkupLocked = onoff;
    }

    function RxCore_MarkupChanged(){
        var retvalue = false;
        if(DocObj){
            (DocObj.bMarkupchanged && !readonlymode) ? retvalue = true : retvalue = false;
        }

        return retvalue;

    }

    function RxCore_MarkupRedraw(){
        if (!documentopen) {
            return;
        }


        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);


    }
    function RxCore_MarkupRotate(degree) {
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }


        var markupobject = getSelectedmarkup();

        if(!markupobject.isempty){
            markupobject.rotation = degree * (Math.PI / 180);
        }


        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

        //ChangeMarkupSelected(degree);
    }

    function RxCore_MarkupSubtype(num) {
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }
        var markupobject = getSelectedmarkup();

        if(!markupobject.isempty){
            markupobject.subtype = num;
        }


        //getSelectedmarkup().rotation = degree*( Math.PI /180);

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }

    function RxCore_OpenRecent(fileurl) {
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        var openfileobj = {filename: fileurl, displayname : null};
        getFile(openfileobj);


    }

    function RxCore_OpenMarkup(fileurl){
        if (!documentopen) {
            return;
        }

        getMarkup(fileurl,DocObj);
    }

    function RxCore_ClearMarkup(){
        if (!documentopen) {
            return;
        }

        DocObj.markuplist = [];
        DocObj.markupdraworder = [];
        numUsers = 0;
        Userlist = [];
        Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
        numUsers++;
        DocObj.nummarkups = 0;

        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
        }

        if (RxCore_GUI_Users != undefined) {
            RxCore_GUI_Users.setUserlist(Userlist, DocObj.bActive);
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);


    }

    function RxCore_OpenFileCustom(fileurl) {

        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        bUseCustomrelpath = true;
        xmlurlrelcustom = fileurl;
        getFileCustom(fileurl);

    }

    function RxCore_OpenPages(fileurl,pages){
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        bUseCustomrelpath = false;

        getFilePages(fileurl,pages);

    }

    function RxCore_OpenFileSilent(fileurl, callback, progressCallBack) {
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }
        bUseCustomrelpath = false;

        getFileNotActive(fileurl, callback, progressCallBack);

    }


    function RxCore_OpenFile(fileurl, callback, progressCallBack) {
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }
        bUseCustomrelpath = false;

        if (typeof(fileurl) == 'object'){
            var szquery = "";
            var bopenfile = false;

            if(fileurl.filepath != undefined){
                if(fileurl.filepath != null){
                    szquery = fileurl.filepath;
                    bopenfile = true;
                }
            }

            if(fileurl.mime != undefined){
                if (fileurl.mime != null){
                    szquery = szquery + "?x-mimetype=" + fileurl.mime;
                    //"?x-mimetype=" + mime + "&amp;cacheid=" + cacheid
                }
            }

            if(fileurl.cacheid != undefined){
                if (fileurl.cacheid != null){
                    szquery = szquery + "&amp;cacheid=" + fileurl.cacheid;
                    //szquery += fileurl.cacheid;
                }
            }

            var openfileobj = {filename: szquery, displayname : null};

            if(fileurl.displayname != undefined){
                if (fileurl.displayname != null){
                    openfileobj.displayname = fileurl.displayname;
                }
            }

            if(bopenfile){
                getFile(openfileobj, callback, progressCallBack);
            }else{
                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

            }


        }else if (typeof(fileurl) == 'string'){
            openfileobj = {filename: fileurl, displayname : null};
            getFile(openfileobj, callback, progressCallBack);
        }



    }


    function RxCore_OpenFilePagesPDFdoc(fileurl, pdfdoc, pages, callback) {
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        bUseCustomrelpath = false;

        getfilePagesPDFdoc(fileurl, pdfdoc, pages, callback);

    }
    function RxCore_OpenFilePages(fileurl, pages, callback) {
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        bUseCustomrelpath = false;
        getFilePages(fileurl,pages, callback);

    }

    function RxCore_switchpages(fileurl, pages, callback){
        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        bUseCustomrelpath = false;
        switchDocPages(fileurl,pages, callback);

    }

    function comparedrawcheck(){

        if(CompareObj.pages[1].VectorPageObj.firstdrawcompare && CompareObj.pages[0].VectorPageObj.firstdrawcompare){
            CompareObj.pages[1].VectorPageObj.firstdrawcompare = false;
            CompareObj.pages[0].VectorPageObj.firstdrawcompare = false;

            CompareObj.draw_compare(true);
        }

    }

    function comparecheck(fileName) {
        var compareReady = true;

        for (var i = 0; i < CompareFiles.length; i++) {
            if (fileName == CompareFiles[i].Name) {
                CompareFiles[i].loaded = true;
            }
            if (compareReady) {
                compareReady = CompareFiles[i].loaded;
            }

        }


        if (compareReady) {
            RxCore_GetOpenFiles();
            doCompare = false;
            CompareFiles = [];
            RxCore_Compare(true);


        }

    }

    function RxCore_consolidate(select){

        //bConsolidate = true;
        if(bCanConsolidate){

            consolidateObj.isactive = select;

            if(RxCore_GUI_Consolidate != undefined){
                RxCore_GUI_Consolidate.Consolidatevt();
            }

        }


    }

    /*function RxCore_consolidateObj(){

        return consolidateObj;

    }*/


    function RxCore_compareScale(){
        if (!documentopen) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();

        var bhaveCompare = false;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                bhaveCompare = true;
            }
        }

        CompareObj.scalecompare();

        //find background file index
        //RxCore_setActiveFile(indx);
        //tool = new tools['overlayscale']();


    }

    function RxCore_getCompareScale(){
        if (!documentopen) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();

        //DocObj.pages[DocObj.currentpage].scalecompare();

    }

    function RxCore_CompareNudgeRotate(clockwise){
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();

        var bhaveCompare = false;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                bhaveCompare = true;
            }
        }
        CompareObj.nudgeRotate(clockwise);

    }

    function RxCore_CompareNudgeScale(updown){
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();

        var bhaveCompare = false;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                bhaveCompare = true;
            }
        }
        CompareObj.nudgeScale(updown);


    }
    function RxCore_CompareNudgeOffset(direction){
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();

        var bhaveCompare = false;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                bhaveCompare = true;
            }
        }
        CompareObj.nudgeoffset(direction);
    }

    function RxCore_setCompareScale(scalearray){
        if (!documentopen) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();

        var bhaveCompare = false;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                bhaveCompare = true;
            }
        }

        CompareObj.setcomparescale(scalearray);

    }

    function compareOverlay(fileurlbackground, fileurloverlay, mode){
        doCompare = true;
        compareMode = mode;
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                OpenFiles.splice(i, 1);
            }
        }

        var OpenFileObject = {
            Name:getFileName(fileurlbackground),
            loaded:false,
            disableMenu: true,
            state:1
        };

        CompareFiles.push(OpenFileObject);

        OpenFileObject = {
            Name:getFileName(fileurloverlay),
            loaded:false,
            disableMenu: true,
            state:2
        };

        CompareFiles.push(OpenFileObject);

        if (RxCore_GUI_Download != undefined) {
            RxCore_GUI_Download.setDownload("show");
        }

        var openfileobjbg = {filename: fileurlbackground, displayname : null};
        var openfileobjov = {filename: fileurloverlay, displayname : null};

        getFile(openfileobjbg);
        getFile(openfileobjov);
    }

    function RxCore_OverlayFiles(fileurlbackground, fileurloverlay) {

        compareOverlay(fileurlbackground, fileurloverlay,1);

    }

    function RxCore_CompareFiles(fileurlbackground, fileurloverlay) {

        compareOverlay(fileurlbackground, fileurloverlay,0);

    }


    function RxCore_Comparediag() {

        if (RxCore_GUI_CompareDiag != undefined) {
            if (OpenfileNames.length == 0) {
                RxCore_GetOpenFiles();
            }
            RxCore_GUI_CompareDiag.CompareDialog();
        }

    }

    function DeactivateAll() {
        for (var i = 0; i < OpenFiles.length; i++) {
            OpenFiles[i].bActive = false;
        }

    }

    function RxCore_CompareEx(filelist,okcancel){
        var bindx = -1;
        var oindx = -1;

        if (OpenfileNames.length > 1 && okcancel){

        }


    }

    function RxCore_exicompareMeasure(){
        if (!documentopen) {
            return;
        }
        if(documentcompare){
            return;
        }

        DocObj.pages[DocObj.currentpage].enableSnap(false);

        set_tool('markupedit', {p1 : false});

    }
    function RxCore_CompareMesure(index){
        if (!documentopen) {
            return;
        }
        if(documentcompare){
            return;
        }

        DocObj.pages[DocObj.currentpage].enableSnap(true);
        set_tool('getoverlayscale', {p1 : DocObj.pages[DocObj.currentpage], p2 : index});
        //tool = new tools['getoverlayscale'](DocObj.pages[DocObj.currentpage], index);

    }


    function CreateCompareOverlay(okcancel,mode) {

        var bindx = -1;
        var oindx = -1;

        if(documentcompare){
            return;
        }

        if (OpenfileNames.length > 1 && okcancel) {
            for (var i = 0; i < OpenfileNames.length; i++) {
                if (OpenfileNames[i].state == 1) {
                    var backgroundFileName = OpenfileNames[i].Name;
                    var backgroundindex = OpenfileNames[i].index;
                }
                if (OpenfileNames[i].state == 2) {
                    var overlayFileName = OpenfileNames[i].Name;
                    var overlayindex = OpenfileNames[i].index;
                }

            }
            for (i = 0; i < OpenFiles.length; i++) {
                if (OpenFiles[i].fileindex == backgroundindex) {
                    bindx = i;
                    OpenFiles[i].disableMenu = true;
                }
                if (OpenFiles[i].fileindex == overlayindex) {

                    oindx = i;
                    OpenFiles[i].disableMenu = true;
                }

            }
            if (bindx != -1 && oindx != -1 && bindx != oindx) {
                DocObj = OpenFiles[oindx];
                DeactivateAll();
                DocObj.SetActive();

                RxCore_HideMarkup();


                CompareObj = new CompareObject(OpenFiles[bindx].pages[OpenFiles[bindx].currentpage], OpenFiles[oindx].pages[OpenFiles[oindx].currentpage]);

                OpenFiles.push(CompareObj);
                CompareObj.fileindex = OpenFiles.length - 1;

                documentcompare = true;
                //DocObj = OpenFiles[OpenFiles.length-2];
                //DocObj.currentpage = 0;
                CompareObj.compareMode = mode;
                CompareObj.invertimages();
                CompareObj.renderPDFscale();
                CompareObj.scaleToBackground(true);
                CompareObj.draw_compare(true);

                var stateobj = {
                    iscompare:documentcompare,
                    numOpenFiles:OpenFiles.length,
                    isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                    is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                    is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                    numpages:DocObj.pages.length,
                    currentpage:DocObj.getcurPage(),
                    activefile : DocObj.bActive
                };
                if (RxCore_GUI_State != undefined) {
                    RxCore_GUI_State.setGUIState(stateobj);
                }

                if (RxCore_GUI_Download != undefined) {
                    RxCore_GUI_Download.setDownload("hide");
                }

                if(Rxcore_GUI_fileLoadComplete != undefined){
                    Rxcore_GUI_fileLoadComplete.loadComplete('compare', true);
                }

                if(RxCore_GUI_CompareDiag != undefined){
                    RxCore_GUI_CompareDiag.CompareDialog();
                }

                set_tool('markupedit', {p1 : false});

                /*if (OpenFiles[bindx].pages[0].usevectorxml && OpenFiles[oindx].pages[0].usevectorxml) {

                }*/
            }


        } else {
            OpenfileNames = [];
        }


        //DocObj.PageDown();


    }

    function RxCore_Overlay(okcancel){
        CreateCompareOverlay(okcancel, 1);
    }

    function RxCore_Compare(okcancel) {

        CreateCompareOverlay(okcancel, 0);

        //DocObj.PageDown();


    }


    function getMarkupfromXML(xmldata){
        var MarkupFilePath = 0;
        var i = 0;

        var xmlDoc = $.parseXML(xmldata).documentElement;

        if (xmlDoc.getElementsByTagName('FileVersion') != null && xmlDoc.getElementsByTagName('FileVersion').length != 0) {
            var fileVersion = xmlDoc.getElementsByTagName('FileVersion')[0].firstChild.nodeValue;
        }

        if (xmlDoc.getElementsByTagName('User') != null && xmlDoc.getElementsByTagName('User').length != 0) {
            var UserID = xmlDoc.getElementsByTagName('User');
            for (i = 0; i < UserID.length; i++) {

                var MarkupUserDispName = UserID[i].getElementsByTagName("Name")[0].firstChild.nodeValue;
                var MarkupUserID = UserID[i].getElementsByTagName("ID")[0].firstChild.nodeValue;

                if (UserID[i].getElementsByTagName("Layer")[0] != undefined) {
                    var MarkupUserLayer = UserID[i].getElementsByTagName("Layer")[0].firstChild.nodeValue;
                } else {
                    MarkupUserLayer = markuplayer;
                }
                if (UserID[i].getElementsByTagName("Color")[0] != undefined) {
                    var MarkupUserColor = UserID[i].getElementsByTagName("Color")[0].firstChild.nodeValue;
                } else {
                    MarkupUserColor = markupcolor;
                }

                if (Userlist[0].Signature == MarkupUserID) {
                    //Userlist[0] = new Users(MarkupUserID,MarkupUserDispName,MarkupUserLayer,MarkupUserColor);
                    //numUsers++;
                } else {
                    Userlist[numUsers] = new Users(MarkupUserID, MarkupUserDispName, MarkupUserLayer, MarkupUserColor);
                    numUsers++;
                }
            }
        } else {
            if (xmlDoc.getElementsByTagName('Name') != null) {
                var sign = xmlDoc.getElementsByTagName('Name');
                if (Userlist[0].Signature != sign[0].firstChild.nodeValue) {

                    Userlist[numUsers] = new Users(sign[0].firstChild.nodeValue, sign[0].firstChild.nodeValue, markuplayer, markupcolor);
                    numUsers++;

                }
            }
        }
        if (xmlDoc.getElementsByTagName('Entity') != null) {
            var markupentityobj = xmlDoc.getElementsByTagName('Entity');

            for (i = 0; i < markupentityobj.length; i++) {
                var markupType = markupentityobj[i].getElementsByTagName("Type")[0].firstChild.nodeValue;
                var markupSubtype = markupentityobj[i].getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                var markupAlternative = markupentityobj[i].getElementsByTagName("Alternative")[0].firstChild.nodeValue;
                var markupID = !markupentityobj[i].getAttribute('ID') ? null : markupentityobj[i].getAttribute('ID');

                if ( markupentityobj[i].getElementsByTagName('HaveLeader')[0] != undefined) {
                    var bhasArrow = (parseInt(markupentityobj[i].getElementsByTagName('HaveLeader')[0].firstChild.nodeValue) == 1);
                }

                if(bhasArrow){
                    if (markupentityobj[i].getElementsByTagName('Entity')[0] != undefined){
                        var arrowleader = markupentityobj[i].getElementsByTagName("Entity")[0];
                        var leadermarkupType = arrowleader.getElementsByTagName("Type")[0].firstChild.nodeValue;
                        var leadermarkupSubtype = arrowleader.getElementsByTagName("Subtype")[0].firstChild.nodeValue;
                        var leadermarkupAlternative = arrowleader.getElementsByTagName("Alternative")[0].firstChild.nodeValue;
                        var leadermarkupID = !arrowleader.getAttribute('ID') ? null : arrowleader.getAttribute('ID');
                        leadermarkupType = parseInt(leadermarkupType);
                        leadermarkupSubtype = parseInt(leadermarkupSubtype);
                        leadermarkupAlternative = parseInt(leadermarkupAlternative);
                        var leaderxmlmarkupobj = new MarkupObject(leadermarkupType, leadermarkupSubtype, leadermarkupAlternative);
                        var blOK = leaderxmlmarkupobj.SetfromXML(DocObj,arrowleader, fileVersion);

                        if(blOK){
                            markupentityobj[i].removeChild(arrowleader);
                            leaderxmlmarkupobj.savemetolistLoad(DocObj,false);

                        }
                    }
                }

                markupType = parseInt(markupType);
                markupSubtype = parseInt(markupSubtype);
                markupAlternative = parseInt(markupAlternative);
                var xmlmarkupobj = new MarkupObject(markupType, markupSubtype, markupAlternative);
                xmlmarkupobj.markupID = markupID;


                var bOK = xmlmarkupobj.SetfromXML(DocObj, markupentityobj[i], fileVersion);
                if (bOK) {
                    if(blOK && bhasArrow && leaderxmlmarkupobj != null){
                        xmlmarkupobj.bhasArrow = bhasArrow;
                        xmlmarkupobj.markupArrowConnected = leaderxmlmarkupobj;

                        leaderxmlmarkupobj.bisTextArrow = true;
                        leaderxmlmarkupobj.textBoxConnected = xmlmarkupobj;


                        blOK = false;
                        bhasArrow = false;
                    }

                    xmlmarkupobj.savemetolistLoad(DocObj);
                }

            }

            /* Andriy call callback only once */

            /*for(var mc = 0; mc < DocObj.markuplist.length; mc++){
                if(DocObj.markuplist[mc].bhasArrow && !isNaN(DocObj.markuplist[mc].markupArrowConnected)){
                    var markupnum = DocObj.markuplist[mc].markupArrowConnected;
                    for(var ac = 0; ac < DocObj.markuplist.length; ac++){
                        if (DocObj.markuplist[ac].markupnumber == markupnum){
                            DocObj.markuplist[mc].markupArrowConnected = DocObj.markuplist[ac];
                        }
                    }
                }
            }*/


            if (xmlmarkupobj) xmlmarkupobj.notify();

            if (markupentityobj.length == 0) {
                if (RxCore_GUI_Markuplist != undefined) {
                    RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist,DocObj.bActive);
                    /* Andriy */
                    // RxCore_GUI_Markuplist.notify();
                }

            }

            drawmarkupAll(cntximg);

        }


    }

    function RxCore_getMarkupXMLData(){
        if (!documentopen || documentcompare) {
            return;
        }

        return createxmlmarkup(true, false,true,signature, DisplayName);
     }

    function RxCore_setMarkupXMLData(xmldata){
        if (!documentopen || documentcompare) {
            return;
        }

        getMarkupfromXML(xmldata);
    }




    function RxCore_xmlurlEx(fileurl){
        getxmlurlEx(fileurl);
    }


    function RxCore_xmlurl(fileurl) {

        getxmlurl(fileurl);
    }

    function RxCore_getAllPageDimensions(){
        if (!documentopen) {
            return;
        }
        return DocObj.getAllPageDim();

    }
    function RxCore_getPageDimensions(pagenum){
        if (!documentopen) {
            return;
        }

        return DocObj.getPageDim(pagenum);

    }

    function RxCore_setPageDimensions(pagenum, height, width,  x, y){
        if (!documentopen) {
            return;
        }

        DocObj.setPageDim(pagenum, height, width,  x, y);


    }



    function RxCore_getPageRotation(){
        var rotation = 0;
        if (!documentopen) {
            rotation = 0;
        }else{
            rotation = DocObj.pages[DocObj.currentpage].drotation;
        }
        return rotation;

    }


    function RxCore_redrawPage(pagenum){
        if (!documentopen) {
            return;
        }

        DocObj.getPageObject(pagenum).redraw();
    }

    function RxCore_suspendDraw(onOff){

        bSuspendDraw = onOff;
        if(!onOff && documentopen){
            //need to get current page.
            var curpage = DocObj.getcurPage();
            DocObj.getPageObject(curpage).redraw();

        }
    }

    function RxCore_RotatePage(pagenum, degrees){
        if (!documentopen) {
            return;
        }

        DocObj.getPageObject(pagenum).rotateimage(degrees);

        if(pagenum == 0){
            DocObj.getPageObject(pagenum).redraw();

        }



    }
    function RxCore_RotateDrawing(cycle, szrotatetool) {
        if (!documentopen) {
            return;
        }

        if (cycle) {
            //unselelectallmarkup();
            //unselecteditmarkupall();
            switch (DocObj.pages[DocObj.currentpage].drotation) {
                case 0:
                    DocObj.pages[DocObj.currentpage].rotateimage(90);
                    break;
                case 90:
                    DocObj.pages[DocObj.currentpage].rotateimage(180);
                    break;
                case 270:
                    DocObj.pages[DocObj.currentpage].rotateimage(0);
                    break;
                case 180:
                    DocObj.pages[DocObj.currentpage].rotateimage(270);
                    break;
            }

        } else {
            if (szrotatetool == '0') {
                DocObj.pages[DocObj.currentpage].rotateimage(0);
            }
            if (szrotatetool == '90') {
                DocObj.pages[DocObj.currentpage].rotateimage(90);
            }
            if (szrotatetool == '180') {
                DocObj.pages[DocObj.currentpage].rotateimage(180);
            }
            if (szrotatetool == '270') {
                DocObj.pages[DocObj.currentpage].rotateimage(270);
            }

        }

    }

    function RxCore_HideMarkup() {
        if (!documentopen) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        if (DocObj.Drawmarkup) {
            DocObj.Drawmarkup = false;
            hidemarkupAll(false);
            drawmarkupAll(cntximg);
            DocObj.bMarkupLocked = true;

        } else {
            DocObj.Drawmarkup = true;
            hidemarkupAll(true);
            drawmarkupAll(cntximg);
            DocObj.bMarkupLocked = false;

        }

    }

    function RxCore_PageLock(onOff){
        if (!documentopen) {
            return;
        }

        DocObj.pagelock(onOff);
    }

    function RxCore_PageonlyMarkup(toggle) {
        if (!documentopen) {
            return;
        }

        if (RxCore_GUI_Markuplist != undefined) {
            if (toggle) {
                if (RxCore_GUI_Markuplist.pageonly) {
                    RxCore_GUI_Markuplist.pageonly = false;
                } else {
                    RxCore_GUI_Markuplist.pageonly = true;
                }

            } else {
                RxCore_GUI_Markuplist.pageonly = true;
            }

            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist,DocObj.bActive);
            /* Andriy */
            // RxCore_GUI_Markuplist.notify();
        }

    }

    function RxCore_MarkupUndo() {
        if (!documentopen || documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        MarkupUndo();
        drawmarkupAll(cntximg);

        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
        }

    }

    function RxCore_CopyMarkup() {
        if (!documentopen || documentcompare) {
            return;
        }
        CopymarkupSelected();
    }

    function RxCore_PasteMarkup() {
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        MarkupFromLocalStorage();
        drawmarkupAll(cntximg);

    }

    function RxCore_NextMarkup() {
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        DocObj.pages[DocObj.currentpage].MarkupZoom();

    }

    function RxCore_ZoomMarkup(dx, dy, dscale) {
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        DocObj.pages[DocObj.currentpage].SetMarkupZoom(dx, dy, dscale);

    }


    function RxCore_FindMarkup() {
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }


        unselelectallmarkup();
        unselecteditmarkupall();
        var markuptext = prompt("Search markup text", "");
        if (markuptext != null && markuptext != "") {
            DocObj.pages[DocObj.currentpage].MarkupFind(markuptext);
        }

    }

    function RxCore_TextSelect(onoff){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        DocObj.enableTextSelect(onoff);

    }


    function RxCore_endTextSearch(){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }
        DocObj.textsearchend();
        /*if (DocObj.pages[DocObj.currentpage].usepdfjs){
            DocObj.textsearchend();
        }*/

    }

    function RxCore_textSearch(text,direction,casesens){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        DocObj.textsearch(text,direction,casesens);



    }

    function RxCore_MarkupOutlined() {
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }
        if (documentcompare) {
            return;
        }
        var tempfillstyle = fillstyle;
        fillstyle = 0;
        ChangeMarkupSelected(3);
        if (!bSetGlobal) {
            fillstyle = tempfillstyle;
        }

    }

    function RxCore_MarkupEdged() {

        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }
        if (documentcompare) {
            return;
        }

        var tempfillstyle = fillstyle;
        fillstyle = 2;

        ChangeMarkupSelected(3);

        if (!bSetGlobal) {
            fillstyle = tempfillstyle;
        }


    }


    function RxCore_MarkupFilled() {
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }
        if (documentcompare) {
            return;
        }

        var tempfillstyle = fillstyle;
        fillstyle = 1;
        ChangeMarkupSelected(3);
        if (!bSetGlobal) {
            fillstyle = tempfillstyle;
        }


    }


    function RxCore_MarkupHatched() {
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }
        if (documentcompare) {
            return;
        }

        var tempfillstyle = fillstyle;
        fillstyle = 3 + HatchStyle;
        ChangeMarkupSelected(3);
        if (!bSetGlobal) {
            fillstyle = tempfillstyle;
        }

    }

    function RxCore_GetFillstyle() {
        return fillstyle;
    }

    function RxCore_GetHatchStyle() {
        return HatchStyle;
    }

    function RxCore_SetMarkupLayer(layer) {
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        markuplayer = layer;
        markupcolor = Layerlist[layer].Color;

        markuplinecolor = markupcolor;
        markuptextcolor = markupcolor;


    }
    function RxCore_ChangeMarkupLayer(layer){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }
        var templayer = markuplayer;
        var tempcolor = markupcolor;
        //var tempfillcolor = markupfillcolor;
        var templinecolor = markuplinecolor;
        var temptextcolor = markuptextcolor;

        markuplayer = layer;
        markupcolor = Layerlist[layer].Color;
        markuplinecolor = markupcolor;
        markuptextcolor = markupcolor;


        ChangeMarkupSelected(0);

        if (!bSetGlobal) {
            markuplayer = templayer;
            markupcolor = tempcolor;
            markuplinecolor = templinecolor;
            markuptextcolor = temptextcolor;

        }


    }


    function RxCore_MarkupLayerdialog() {
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        if (RxCore_GUI_MarkupLayers != undefined) {
            RxCore_GUI_MarkupLayers.setMarkupLayers(Layerlist);
        }


    }

    function RxCore_GetMarkupLayers(){
        return Layerlist;
    }


    function RxCore_getAllSelectedMarkup(){

        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }

        return DocObj.getSelectedMarkup();


    }

    function RxCore_getSelectedMarkup() {
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }

        return getSelectedmarkup();

    }


    function RxCore_GetUsers(){
        return Userlist;
    }

    function RxCore_MarkupTools(selected) {
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        if (!selected) {

            set_tool('markupedit', {p1 : false});

            return;
        }

        unselelectallmarkup();

        set_tool('markupedit', {p1 : false});


        if (RxCore_GUI_Users != undefined) {
            RxCore_GUI_Users.setUserlist(Userlist, DocObj.bActive);
        }

        if (RxCore_GUI_MarkupLayers != undefined) {
            RxCore_GUI_MarkupLayers.setMarkupLayers(Layerlist);
        }


    }


    function RxCore_MarkupUserdialog() {
        if (!documentopen) {
            return;
        }
        //unselelectallmarkup();


        if (RxCore_GUI_Users != undefined) {
            RxCore_GUI_Users.setUserlist(Userlist, DocObj.bActive);
        }


    }

    function RxCore_FileInfodialog() {
        if (!documentopen) {
            return;
        }

        var ImageWidth = Math.floor(DocObj.pages[DocObj.currentpage].MainImageWidth / DocObj.pages[DocObj.currentpage].MainImageScaling);
        var imagewidthunits = getUnitlength(DocObj.pages[DocObj.currentpage].MainImageWidth);
        var ImageHeight = Math.floor(DocObj.pages[DocObj.currentpage].MainImageHeight / DocObj.pages[DocObj.currentpage].MainImageScaling);
        var imageheightunits = getUnitlength(DocObj.pages[DocObj.currentpage].MainImageHeight);

        if (DocObj.pages[DocObj.currentpage].usevectorxml && DocObj.pages[DocObj.currentpage].VectorPageObj) {
            ImageWidth = Math.floor(DocObj.pages[DocObj.currentpage].VectorPageObj.width);
            imagewidthunits = getUnitlength(ImageWidth);
            ImageHeight = Math.floor(DocObj.pages[DocObj.currentpage].VectorPageObj.height);
            imageheightunits = getUnitlength(ImageHeight);

        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            ImageWidth = Math.floor(DocObj.pages[DocObj.currentpage].pdfpagewidth);
            imagewidthunits = getUnitlength(ImageWidth);
            ImageHeight = Math.floor(DocObj.pages[DocObj.currentpage].pdfpageheight);
            imageheightunits = getUnitlength(ImageHeight);

        } else if (DocObj.pages[DocObj.currentpage].usevector3Dxml && DocObj.pages[DocObj.currentpage].Vector3DPageObj) {
            ImageWidth = Math.floor(DocObj.pages[DocObj.currentpage].Vector3DPageObj.w);
            imagewidthunits = getUnitlength(ImageWidth);
            ImageHeight = Math.floor(DocObj.pages[DocObj.currentpage].Vector3DPageObj.h);
            imageheightunits = getUnitlength(ImageHeight);

        } else {

        }

        var OffsetX = DocObj.pages[DocObj.currentpage].OffsetX;
        var OffsetY = DocObj.pages[DocObj.currentpage].OffsetY;
        var OriginalScale = DocObj.pages[DocObj.currentpage].OriginalScale;
        var fileformat = DocObj.Format;
        var fileURL = DocObj.FileName;
        var fileSize = Math.floor(DocObj.FileSizeLow / 1024);
        var fileCompression = DocObj.pages[DocObj.currentpage].Compression;
        var fileDPI = DocObj.pages[DocObj.currentpage].DPI;
        var filePages = DocObj.NumPages;



        var FileInformation = {
            FileFormat:fileformat,
            FileName:fileURL,
            FileSize:fileSize,
            Compression:fileCompression,
            DPI:fileDPI,
            Pages:filePages,
            ImageWidth:ImageWidth,
            imagewidthunits:imagewidthunits,
            ImageHeight:ImageHeight,
            imageheightunits:imageheightunits,
            OffsetX:OffsetX,
            OffsetY:OffsetY,
            OriginalScale:OriginalScale,
            XRefs:DocObj.xrefs,
            Fonts:DocObj.fonts,
            Properties : DocObj.documentproperties
        };

        if (DocObj.CadMeasurement != undefined){
            FileInformation.CADMeasurement = DocObj.CadMeasurement;
        }


        if (documentcompare) {
            FileInformation = {
                FileFormat:'Overlay Composite',
                FileName:CompareObj.pages[0].DocRef.FileName + "-" + CompareObj.pages[1].DocRef.FileName,
                FileSize:"-",
                Compression:"-",
                DPI:"-",
                Pages:"-",
                ImageWidth:"-",
                imagewidthunits:imagewidthunits,
                ImageHeight:"-",
                imageheightunits:imageheightunits,
                OffsetX:"-",
                OffsetY:"-",
                OriginalScale:"-"
            };
        }

        if (RxCore_GUI_FileInfo != undefined) {
            RxCore_GUI_FileInfo.setFileInfo(FileInformation);
        }


    }


    function RxCore_Measuredistance(selected){
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('measuretool', {twoopoints : true});
            //tool = new tools['measuretool']();
        } else {

            set_tool('markupedit', {p1 : false});

        }


    }
    function RxCore_Measure(selected) {
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('measuretool', {twoopoints : false});
            //tool = new tools['measuretool']();
        } else {

            set_tool('markupedit', {p1 : false});

        }
    }

    function RxCore_CloseAll() {
        if (!documentopen) {
            return;
        }
        while (OpenFiles.length > 0) {
            RxCore_Closedocument();

        }
    }


    function CloseCompare() {
        documentcompare = false;

        OpenfileNames = [];

        CompareObj.Close();
        for (var i = 0; i < OpenFiles.length; i++) {
            if (OpenFiles[i].Type == 'Compare') {
                OpenFiles.splice(i, 1);
            }
        }


        CompareObj = {};

        /*DocObj = OpenFiles[OpenFiles.length - 1];
         DocObj.SetActive();*/

        /*if (DocObj.pages[DocObj.currentpage].usevectorxml){
         DocObj.pages[DocObj.currentpage].draw_vector(true);
         }
         drawmarkupAll(cntximg);*/

        //DocObj.SetActive();
    }

    function RxCore_Closedocument(index) {
        var documentObject = OpenFiles[index] || DocObj,fileindex;

        if (!documentopen) {
            return false;
        }

        fileindex = documentObject.fileindex;

        /*if(CompareObj != undefined && documentcompare){
         CloseCompare();
         return;
         }*/

        if(DocObj){
            if (documentObject.bMarkupchanged && !readonlymode) {
                if (bMarkupSavecheck){
                    if (confirm('Save Markup?')) {
                        sendMarkup(xmlurlmarkupsave, signature, DisplayName);
                    } else {
                        //return;
                        //just close
                    }

                }

            }
        }
        if (documentObject === DocObj) {
            context.clearRect(0, 0, canvas.width, canvas.height);
            cntximg.clearRect(0, 0, canvas.width, canvas.height);
            contexto.clearRect(0, 0, canvas.width, canvas.height);

        }


        //CompareObj.Close();
        /*for (var i=0;i< OpenFiles.length;i++){
         if(OpenFiles[i].Type == 'Compare'){
         OpenFiles.splice(i,1);
         }
         }*/

        if (OpenFiles[OpenFiles.length - 1].Type == 'Compare') {
            CloseCompare();

        } else {
            documentObject.Close();
            if (documentObject === DocObj) {
                documentObject = DocObj = null;
            }
            OpenFiles.splice(fileindex, 1);

            //var dindex = DocObj.fileindex;
            //DocObj = {};
            //DocObj = null;
            //OpenFiles.splice(dindex, 1);
            //OpenFiles.pop();
        }


        if(DocObj){
            DocObj.bMarkupchanged = false;
        }

        bUsemarkupbyref = false;
        bUsemarkupbyrefEx = false;

        /*if (Viewer3D != null){
         Viewer3D = null;
         }*/
        /*contexto = canvaso.getContext('2d');
         if (!contexto) {
         alert('Error: failed to getContext!');
         return;
         }*/


        //var szstyle = "width: 200px; height: " + canvasoheight + "px; position:relative; top:-100px; left:15px"
        //setContentThumb("<p>No pages open</p>");
        //ThumbnailpagesContainer.innerHTML = "<p>No pages open</p>";
        //ThumbnailpagesContainer.Close();
        //LayersContainer.setEmpty();
        //BlocksContainer.setEmpty();
        //LayersContainer.innerHTML = "<table><tr><td>Name</td><td>Color</td><td>State</td></tr></table>";
        //BlocksContainer.innerHTML = "<table><tr><td>Name</td><td>State</td></tr></table>";


        if (OpenFiles.length < 1) {
            documentopen = false;
            //DocObj.markuploaded = false;
            imagewidth = splashimage.width;
            imageheight = splashimage.height;

            imagewidth = splashimage.naturalWidth;
            imageheight = splashimage.naturalHeight;

            var yscale = canvasoheight / imageheight;
            var xscale = canvasowidth / imagewidth;
            var dscale = Math.min(xscale, yscale);

            var dx = (canvasowidth - (imagewidth * dscale)) / 2;
            var dy = (canvasoheight - (imageheight * dscale)) / 2;
            numUsers = 0;
            Userlist = [];
            Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
            numUsers++;

            if (RxCore_GUI_Users != undefined) {
                RxCore_GUI_Users.setUserlist(Userlist, true);
            }


            draw_image(splashimage, dx, dy, dscale);

            set_tool('markupedit', {p1 : false});

            var stateobj = {
                iscompare:false,
                numOpenFiles:OpenFiles.length,
                isPDF:false,
                is3D:false,
                is2D:false,
                numpages:0,
                currentpage:0,
                activefile : false
            };
            if (RxCore_GUI_State != undefined) {
                RxCore_GUI_State.setGUIState(stateobj);
            }


        } else {
            if (OpenFiles[OpenFiles.length - 1].Type == 'Compare') {
                CompareObj = OpenFiles[OpenFiles.length - 1];
                DeactivateAll();
                CompareObj.bSopenSilent = false;
                CompareObj.SetActive();


            } else {
                if (!DocObj) {
                    DocObj = OpenFiles[OpenFiles.length - 1];

                }
                DeactivateAll();
                DocObj.bSopenSilent = false;
                DocObj.SetActive();

            }

        }

        // Rebuild fileindex
        for (var i = 0; i < OpenFiles.length; i++) {
            OpenFiles[i].fileindex = i;
        }

        return true;
    }

    function RxCore_Printdocument() {
        if (!documentopen) {
            return;
        }
        var pheight = parseInt(DocObj.pages[DocObj.currentpage].height);
        var pwidth = parseInt(DocObj.pages[DocObj.currentpage].width);

        if (pheight > pwidth) {
            PaperWidth = 210;
            PaperHeight = 297;
        } else {
            PaperWidth = 297;
            PaperHeight = 210;
        }

        MarkupPrintSave();

        if(!documentcompare){
            if(DocObj.checkprintready()){
                printCanvas(PrintPageURL);
            }else{
               //load all pages.
                DocObj.loadAllPages();
            }
        }else{
            CompareObj.print(PrintPageURL);
        }

        /*if(!documentcompare){
            printCanvas(PrintPageURL);
        }else{
            CompareObj.print(PrintPageURL);
        }*/


    }

    function RxCore_getPDFDocobj(){
        if (!documentopen) {
            return null;
        }

        return DocObj.getPDFDocument();

    }

    function RxCore_GetdocInfo() {


        if (!documentopen) {

            return {
                iscompare:false,
                isPDF:false,
                is3D:false,
                is2D:false,
                numpages:0,
                currentpage:0
            }
        } else {
            return {
                iscompare:documentcompare,
                isPDF:DocObj.pages[DocObj.currentpage].usepdfjs,
                is3D:DocObj.pages[DocObj.currentpage].usevector3Dxml,
                is2D:DocObj.pages[DocObj.currentpage].usevectorxml,
                numpages:DocObj.pages.length,
                currentpage:DocObj.getcurPage(),
                type : DocObj.Type
            }

        }


    }

    function RxCore_SetViewMode(OnOff){
        if (!documentopen) {
            return;
        }

        if(documentcompare){
            return;
        }

        DocObj.pages[DocObj.currentpage].setViewMode(OnOff);
    }

    function RxCore_setPDFinitalZoomAll(OnOff){
        bPDFZoomAllinit = OnOff;
    }

    function RxCore_setPDFAnimateRender(OnOff){
        bAnimatePDFrender = OnOff;
    }

    function RxCore_SetScrollZoomKey(OnOff,keys){
        bUseScrollKey = OnOff;
        nScrollKeyNum = keys;

    }

    function RxCore_SetSingleDocument(OnOff) {
        bSingleDocmode = OnOff;

    }

    function PrintCommon(PrintPgURL, PaperSize){


        MarkupPrintSave();

        PaperWidth = PaperSize.width;
        PaperHeight = PaperSize.height;


        if(!documentcompare){
            if(DocObj.checkprintready()){
                printCanvas(PrintPgURL);
            }else{
                //load all pages.
                DocObj.loadAllPages();
            }
        }else{

            CompareObj.print(PrintPgURL,PaperSize);
        }
    }

    function RxCore_PrintOptionsSize(PrintPgURL, PaperSize){
        if (!documentopen) {
            return;
        }
        //auto
        if(PaperSize.mode == 0){
            if (DocObj.pages[DocObj.currentpage].height > DocObj.pages[DocObj.currentpage].width) { // drawing portrait
                if(PaperSize.width > PaperSize.height){
                    var tempwidth = PaperSize.width;
                    PaperSize.width = PaperSize.height;
                    PaperSize.height = tempwidth;
                }

            } else { // drawing landscape
                if(PaperSize.height > PaperSize.width){
                    tempwidth = PaperSize.width;
                    PaperSize.width = PaperSize.height;
                    PaperSize.height = tempwidth;
                }
            }

        }else if(PaperSize.mode == 1) { //force portrait
            if(PaperSize.width > PaperSize.height){
                var tempwidth = PaperSize.width;
                PaperSize.width = PaperSize.height;
                PaperSize.height = tempwidth;
            }

        }else if(PaperSize.mode == 2) { //force landscape
            if(PaperSize.height > PaperSize.width){
                tempwidth = PaperSize.width;
                PaperSize.width = PaperSize.height;
                PaperSize.height = tempwidth;
            }

        }



        PrintCommon(PrintPgURL, PaperSize);
    }

    function RXCore_PrintdocOptions(PrintPgURL) {
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].height > DocObj.pages[DocObj.currentpage].width) {
            var PWidth = 210;
            var PHeight = 297;
        } else {
            PWidth = 297;
            PHeight = 210;
        }

        PrintCommon(PrintPgURL, {width : PWidth, height : PHeight});

        /*if(!documentcompare){
            printCanvas(PrintPgURL);
        }else{
            CompareObj.print(PrintPgURL,{width : PaperWidth,height : PaperHeight});
        }*/


    }

    function RxCore_MoveToBack() {
        if (!documentopen ) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }

        moveToBack();
    }

    function RxCore_MoveToFront() {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        moveToFront();
    }

    function deleteMarkupbyGUID(GUID){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }

        deleteUniqueMarkup(GUID);

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);


    }

    function RxCore_DeleteMarkup() {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        deletemarkup();
    }

    function RxCore_ZoomWindow(selected) {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();

        if (selected) {
            set_tool('zoomwindow', {});
            //tool = new tools['zoomwindow']();
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    /*function RxCore_Zoom(x,y){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        DocObj.pages[DocObj.currentpage].pan_page(x, y,true);
    }*/

    function RxCore_ZoomPageUpdate(zoomparams, type){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        DocObj.pages[DocObj.currentpage].ZoomPageUpdate(zoomparams, type);
    }


    function RxCore_PagePos(x,y){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        DocObj.pages[DocObj.currentpage].pan_page_pos(x, y);
    }

    function RxCore_PanPage(x,y){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        DocObj.pages[DocObj.currentpage].pan_page(x, y,true);
        //DocObj.pages[DocObj.currentpage].pan_page_pos(x, y,true);

    }


    function RxCore_PanWindow(selected) {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('pan', {});
            //tool = new tools['pan']();
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MagnifyGlass(selected) {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            magcanvas.addEventListener('mousemove', ev_canvas, false);
            magcanvas.addEventListener('mousedown', ev_canvas, false);
            magcanvas.addEventListener('mouseup', ev_canvas, false);
            magcanvas.addEventListener('mouseout', ev_canvas, false);
            magcanvas.addEventListener('wheel', ev_canvas, false);
            set_tool('magnify', {});
            //tool = new tools['magnify']();
        } else {
            magcanvas.style.visibility = 'hidden';
            magcanvas.removeEventListener('mousemove', ev_canvas, false);
            magcanvas.removeEventListener('mousedown', ev_canvas, false);
            magcanvas.removeEventListener('mouseup', ev_canvas, false);
            magcanvas.removeEventListener('mouseout', ev_canvas, false);
            magcanvas.removeEventListener('wheel', ev_canvas, false);
            set_tool('markupedit', {p1 : false});

        }
    }

    function RxCore_ZoomFit() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        //unselelectallmarkup();
        //unselecteditmarkupall();
        DocObj.pages[DocObj.currentpage].zoomall();


    }

    function RxCore_ZoomHeight() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        //unselelectallmarkup();
        //unselecteditmarkupall();
        DocObj.pages[DocObj.currentpage].zoomheight();


    }

    function RxCore_ZoomWidth() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        //unselelectallmarkup();
        //unselecteditmarkupall();
        DocObj.pages[DocObj.currentpage].zoomwidth();

    }

    function RxCore_ZoomIn() {
        if (!documentopen) {
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        //unselelectallmarkup();
        //unselecteditmarkupall();
        DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false);


    }

    function belowlimitExtent(zoomscalefactor){
        var belowlimit = true;

        var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();

        var wlimit = canvasowidth - 30;
        var hlimit = canvasoheight - 30;

        if((pagedim.w / zoomscalefactor) < wlimit && (pagedim.h / zoomscalefactor) < hlimit){
            belowlimit = false;
            //scalechanged = false;
            //DocObj.pages[DocObj.currentpage].zoomall();
        }


        /*if (DocObj.pages[DocObj.currentpage].usepdfjs) {

        }else if (DocObj.pages[DocObj.currentpage].usevectorxml) {


            if (DocObj.pages[DocObj.currentpage].initialscale > DocObj.pages[DocObj.currentpage].dscalevector) {
                //scalechanged = false;
                //DocObj.pages[DocObj.currentpage].zoomall();
                belowlimit = false;

            }


        } else {
            if (DocObj.pages[DocObj.currentpage].initialscale > (DocObj.pages[DocObj.currentpage].dscale / DocObj.pages[DocObj.currentpage].bitmapratio)) {
                //scalechanged = false;
                //DocObj.pages[DocObj.currentpage].zoomall();
                belowlimit = false;
            }

        }*/

        if(!bLimitZoomOut){
            belowlimit = true;
        }


        return belowlimit;
    }

    function RxCore_ZoomOut() {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        //unselelectallmarkup();
        //unselecteditmarkupall();

        if (belowlimitExtent(1.1)){
            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false);
        }


    }

    function RxCore_selectRxSpaceEdit(blockId){
        if (!documentopen || documentcompare) {
            return;
        }


        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        var spacemarkup = findSpaceMarkup(blockId);


        if(spacemarkup == undefined){
            return;
        }

        var bselected = spacemarkup.selectedit;

        if(!bMultiselect && !DocObj.getMarkupMultiselected()){
            unselelectallmarkup();
            unselecteditmarkupall();
        }
        if (DocObj.getcurPage() != spacemarkup.pagenumber) {
            DocObj.GotoPage(spacemarkup.pagenumber);
        }

        if (bselected) {

            spacemarkup.selectedit = false;
            var mindex = -1;

            /*if (RxCore_GUI_Markup != undefined) {
                RxCore_GUI_Markup.setMarkupSelected(mindex, {created : false, modified : false, deleted : false});
            }*/



        } else {
            spacemarkup.selectedit = true;
            var mindex = DocObj.getmarkupbynumber(spacemarkup.markupnumber);

            if (RxCore_GUI_Markup != undefined) {
                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[mindex], {created : false, modified : true, deleted : false});
            }


            //spacemarkup.setselect(true);
            //DocObj.markuplist[arrindx].lengthangleCallbackSelect();

        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);



        if(RxCore_GUI_Markuplist != undefined){

            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist);

        }

        //selectSpaceMarkup(blockId, multi);

    }

    function RxCore_selectRxSpace(blockId, multi){
        if (!documentopen || documentcompare) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        selectSpaceMarkup(blockId, multi);


    }


    function RxCore_ZoomToBlock(blockId){
        if (!documentopen || documentcompare) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            return;
        }

        var markupobj = findSpaceMarkup(blockId);

        if(markupobj){
            DocObj.pages[DocObj.currentpage].MarkupZoombyMarkup(markupobj);
            return;
        }

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].ZoomToBlock(blockId);
        }

    }

    function RxCore_NextPage() {
        if (!documentopen || documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        DocObj.PageDown();

        set_tool('markupedit', {p1 : false});


    }

    function RxCore_PrevPage() {
        if (!documentopen || documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        DocObj.PageUp();

        set_tool('markupedit', {p1 : false});

    }

    function RxCore_GetcurPage() {
        var curpage = 0;
        if (!documentopen) {
            curpage = 0;
        } else {
            curpage = DocObj.getcurPage();
        }

        return curpage;
    }

    function RxCore_gotoPage(pagenum) {
        if (!documentopen || documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        DocObj.GotoPage(pagenum);
    }


    function RxCore_MarkupSelect(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }
        var bIsSpace = false;

        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {

            if (bMarkupcrated) {
                var bpointtype = (DocObj.markuplist[nMarkupcreated].type == 1 || DocObj.markuplist[nMarkupcreated].type == 8);
                if(bpointtype){
                    DocObj.markuplist[nMarkupcreated].setselectedit(true);
                }else{
                    DocObj.markuplist[nMarkupcreated].setselect(true);
                }

                var bIsSpace = (DocObj.markuplist[nMarkupcreated].type == 8 && DocObj.markuplist[nMarkupcreated].subtype == 1);
                drawmarkupAll(cntximg);
                DrawMarkupSelected(context);
                bMarkupcrated = false;
                nMarkupcreated = -1;
            }

            set_tool('markupedit', {p1 : bIsSpace});

        } else {

            set_tool('markupedit', {p1 : false});

        }

        //DocObj.setMarkupMultiselected();
    }

    function RxCore_NoteFocus(onOff){
        if (!documentopen) {
            return;
        }

        bNoteFocus = onOff;

    }

    function RxCore_MarkupNote(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {

            set_tool('note', {});
            //tool = new tools['note']();
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupText(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('text', {});
            //tool = new tools['text']();
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupErase(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('pencil', {p1 : 1});
            //tool = new tools['pencil'](1);
        } else {

            if(tool.name == 'pencil' && tool.started){
                tool.apply();
            }

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupSave(unselect) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        if(!unselect) {
            unselelectallmarkup();
            unselecteditmarkupall();
        }
        sendMarkup(xmlurlmarkupsave, signature, DisplayName);
    }

    function RxCore_canvToImage() {
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();

        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            post3DImageData();
        }

    }

    function RxCore_ExportFile(consolidate,format,UPI,paperSize,markupFlag ){
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        exportFile(consolidate,format,UPI,paperSize,markupFlag);

    }

    function RxCore_ExportFileRaster(consolidate,format,UPI,paperSize,markupFlag){
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        exportFileRaster(consolidate,format,UPI,paperSize,markupFlag);


    }

    function RxCore_PDFExport() {
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        PDExportnew();

    }

    function RxCore_moveLabelEnable(onOff){
        if(tool.name == 'markupedit'){
            tool.enableMoveLabel(onOff);
        }

    }

    function RxCore_InsertPoint(){

        if(tool.name == 'markupedit'){
            tool.enablePointInsert();
        }

    }

    function RxCore_DeletePoint(){

        if(tool.name == 'markupedit'){
            tool.enablePointDelete();
        }

    }

    function RxCore_ApplyMarkup(){

        if(tool.anglelengthsupport && tool.started){
            tool.apply();
        }

    }

    function RxCore_applyRadiusSelected(radius){
        RxCore_applyAngleLengthSelected(0,radius);
    }



    function RxCore_applyWidthHeightSelected(w,h){

        var markupobject = getSelectedmarkup();
        if (!markupobject.isempty){
            if(markupobject.widthHeightsupport){
                var curx2 = markupobject.w;
                var cury2 = markupobject.h;

                var secondpoint = markupobject.setWidthHeightEdit(w,h);
                var abspoint = {x : markupobject.x + secondpoint.w, y:markupobject.y + secondpoint.h};
                context.clearRect(0, 0, canvas.width, canvas.height);
                var bWithin = (MousePosdrwext(abspoint));
                if (bWithin){
                    markupobject.w = secondpoint.w;
                    markupobject.h = secondpoint.h;

                    drawmarkupAll(cntximg);
                    DrawMarkupSelected(context);

                    markupobject.lengthangleCallbackSelect();
                }else{
                    drawmarkupAll(cntximg);
                    DrawMarkupSelected(context);

                    if (RxCore_GUI_markupParamsError != undefined){
                        RxCore_GUI_markupParamsError.onDrawError('outside');
                    }

                }


            }
        }

    }


    function RxCore_applyAngleLengthSelected(angle, length, bAdvance, type){
        var markupobject = getSelectedmarkup();
        if (!markupobject.isempty){

            if(markupobject.anglelengthsupport || markupobject.setRadiusSupport){
                var curx2 = markupobject.w;
                var cury2 = markupobject.h;

                var curx1 = markupobject.x;
                var cury1 = markupobject.y;

                var secondpoint = markupobject.setAngleLenghtEdit(length, angle, type);
                context.clearRect(0, 0, canvas.width, canvas.height);

                var bCircle = (markupobject.type == 4 && markupobject.subtype == 1);

                if (bCircle){
                    var bWithin = (MousePosradiusdrwext({x:markupobject.x,y:markupobject.y},{x:secondpoint.w,y:secondpoint.h}));
                }else{
                    bWithin = (MousePosdrwext({x:secondpoint.w,y:secondpoint.h}));
                }

                if (bWithin){

                    markupobject.w = secondpoint.w;
                    markupobject.h = secondpoint.h;
                    //markupobject.AdjustForRotation(true);
                    //markupobject.x = curx1;
                    //markupobject.y = cury1;

                    drawmarkupAll(cntximg);
                    DrawMarkupSelected(context);

                    markupobject.lengthangleCallbackSelect();



                }else{
                    //markupobject.w = curx2;
                    //markupobject.h = cury2;

                    drawmarkupAll(cntximg);
                    DrawMarkupSelected(context);

                    if (RxCore_GUI_markupParamsError != undefined){
                        RxCore_GUI_markupParamsError.onDrawError('outside');
                    }

                }

            }else if (markupobject.setPointSupport){
                var secondpoint = markupobject.setAngleLengthPointsEdit(length, angle, type);
                var bpolyline = (markupobject.type == 1 && (markupobject.subtype == 1 || markupobject.subtype == 3));
                context.clearRect(0, 0, canvas.width, canvas.height);

                if (MousePosdrwext({x:secondpoint.w,y:secondpoint.h})){
                    if (bAdvance){
                        markupobject.movepoint(secondpoint.w, secondpoint.h, secondpoint.p);
                    }else{
                        if(secondpoint.p == 0 && !bpolyline){
                            markupobject.setCurPoint(markupobject.points.length - 1);
                        }else{
                            markupobject.setCurPoint(secondpoint.p - 1);
                        }

                        markupobject.movepoint(secondpoint.w, secondpoint.h, secondpoint.p);

                    }

                    markupobject.lengthangleCallbackPointSelect();

                    //markupobject.

                    drawmarkupAll(cntximg);
                    DrawMarkupSelected(context);

                }else{
                    drawmarkupAll(cntximg);
                    DrawMarkupSelected(context);

                    if (RxCore_GUI_markupParamsError != undefined){
                        RxCore_GUI_markupParamsError.onDrawError('outside');
                    }

                }
                markupobject.findrectangle();
            }

        }

    }


    function RxCore_applyWidthHeight(w,h){
        if(tool.anglelengthsupport && tool.started){
            tool.setWidthHeight(w, h);
        }

    }


    function RxCore_restoreMouseInput(){
        if(tool.anglelengthsupport && tool.started && tool.name == 'area'){
            tool.useMouseInput();
        }
    }

    function RxCore_applyAngleLength(angle, length, bAdvance , type){

        if(tool.anglelengthsupport && tool.started){
            tool.setAngleLength(angle, length, bAdvance,  type);

        }

    }

    function pencilcheck(){
        if(tool.name == 'pencil' && tool.started){
            tool.apply();
        }

    }

    function RxCore_RestrictPan(onOff){
        bRestrictPan = onOff;
    }

    function RxCore_RedactRect(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('rect', {p1 : 3, p2 : 4, redact : true});
        } else {

            set_tool('markupedit', {p1 : false});
        }
    }

    function RxCore_MarkupHighlight(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('rect', {p1 : 3, p2 : 3, redact : false});
            //set_tool('marker', {});
            //tool = new tools['marker']();
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function Rxcore_MarkupSymbol(selected){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();

        if (selected) {
            set_tool('symbol', {});
            //tool = new tools['symbol']();

        }else{

            set_tool('markupedit', {p1 : false});

        }

    }


    function RxCore_MarkupShape(selected, type, subtype) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {

            switch (type) {
                case 0:
                    set_tool('rect', {p1 : 3, p2 : subtype,redact : false});
                    //tool = new tools['rect'](subtype);
                    break;
                case 1:
                    //set_tool('oval', {p1 : subtype});
                    set_tool('rect', {p1 : 4, p2 : subtype, redact : false});

                    //tool = new tools['oval']();
                    break;
                case 2:
                    set_tool('rect', {p1 : 5, p2 : subtype, redact : false});

                    //set_tool('cloud', {});
                    //tool = new tools['cloud']();
                    break;
                case 3:
                    //set_tool('polygon', {});
                    set_tool('area', {p1 : 1, p2 : 2});
                    //tool = new tools['polygon']();
                    break;
            }


        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupLine(selected){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();

        if (selected) {
            set_tool('arrow', {p1 : 9});
            //tool = new tools['arrow'](type);

        } else {

            set_tool('markupedit', {p1 : false});

        }


    }

    function RxCore_MarkupCircle(selected){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();

        if (selected) {
            set_tool('arrow', {p1 : 10});
            //tool = new tools['arrow'](type);

        } else {

            set_tool('markupedit', {p1 : false});

        }

    }
    function RxCore_MarkupArrow(selected, type) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('arrow', {p1 : type});
            //tool = new tools['arrow'](type);

        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupDimension(selected, type) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('measure', {p1 : type});
            //tool = new tools['measure'](type);
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupSpace(selected){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('area', {p1 : 8, p2 : 1});
            //tool = new tools['area']();
        } else {

            set_tool('markupedit', {p1 : false});
        }
    }

    function RxCore_setSpaceID(idvalue){

        var szvalue = idvalue.toString();
        SpaceidAttribute('SpaceID', szvalue);

    }

    function RxCore_MarkupArea(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('area', {p1 : 8, p2 : 0});
            //tool = new tools['area']();
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupMeasurePath(selected){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            //set_tool('polyline', {p1 : 3});
            set_tool('area', {p1 : 1, p2 : 3});
            //tool = new tools['polyline'](3);
        } else {

            set_tool('markupedit', {p1 : false});

        }


    }
    function RxCore_MarkupPolyline(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            //set_tool('polyline', {p1 : 1});
            set_tool('area', {p1 : 1, p2 : 1});
            //tool = new tools['polyline'](1);
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupPolycurve(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            set_tool('Polycurve', {p1 : 1});
            //tool = new tools['Polycurve'](1);
        } else {

            set_tool('markupedit', {p1 : false});

        }

    }

    function RxCore_MarkupFreepen(selected) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();

        if (selected) {
            set_tool('pencil', {p1 : 0});
            //tool = new tools['pencil'](0);
        } else {
            if(tool.name == 'pencil' && tool.started){
                tool.apply();
            }

            set_tool('markupedit', {p1 : false});

        }

    }


    function RxCore_Calibrate(selected) {
        if (!documentopen) {
            return;
        }
        unselelectallmarkup();
        unselecteditmarkupall();
        if (selected) {
            DocObj.pages[DocObj.currentpage].enableSnap(true);
            set_tool('calibrate', {});
            //tool = new tools['calibrate']();
        } else {
            DocObj.pages[DocObj.currentpage].enableSnap(true);

            set_tool('markupedit', {p1 : false});

        }

    }


    function Rxcore_setLargePDFpageLimit(num){
        nLargePDF = num;
    }

    function RxCore_setLabelSize(num){
        var tempsize = nLabelTextsize;
        nLabelTextsize = num;
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(11);
        if (!bSetGlobal) {
            nLabelTextsize = tempsize;
        }


    }
    function RxCore_setArrowSize(num){

        var tempsize = nArrowSize;
        nArrowSize = num;
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(10);
        if (!bSetGlobal) {
            nArrowSize = tempsize;
        }


    }


    function RxCore_animateLineStyle(onoff){

        bAnimateLineStyle = onoff;
        bmarkupLabels = !onoff;

        if(!onoff){
            RxCore_setLineStyleSpace(0, true);
        }

    }


    function RxCore_setLineStyleSpace(linestyle, reset){
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        var curmarkup = 0;

        for (curmarkup = 0; curmarkup < DocObj.markuplist.length; curmarkup++) {
            if (DocObj.markuplist[curmarkup].spaceselected || reset) {
                if(DocObj.markuplist[curmarkup].type == 8 && DocObj.markuplist[curmarkup].subtype == 1){
                    DocObj.markuplist[curmarkup].linestyle = linestyle;
                }


            }
        }


        drawmarkupAll(cntximg);
        drawSpaceSelected(context);
        DrawMarkupSelected(context);

    }
    function RxCore_SetLineStyle(linestyle) {
        /*if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }*/

        var tempstyle = nlinestyle;
        nlinestyle = linestyle;

        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(9);

        if (!bSetGlobal) {
            linewidthvalue = tempstyle;
        }


        /*if (linestyle == '') {
            nlinestyle = 0;

        } //solid
        if (linestyle == '     ') {
            nlinestyle = 1;
        } //dashed
        if (linestyle == '       ') {
            nlinestyle = 2;
        } //dotted
        if (linestyle == '      ') {
            nlinestyle = 3;
        } //dash dot dot dash
        if (linestyle == '      ') {
            nlinestyle = 4;
        } //dash dot*/

    }


    function RxCore_SetLineWidthUnits(value, type){


        var tempwidht = linewidthvalue;

        //var scale = DocObj.pages[DocObj.currentpage].getdscale();
        var fixedscale = DocObj.pages[DocObj.currentpage].fixedScale;

        //value = (value * (scale / fixedscale)) / (scale / fixedscale);

        linewidthvalue = getScreenDim(value, type);
        linewidthvalue *= fixedscale;

        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(2);
        if (!bSetGlobal) {
            linewidthvalue = tempwidht;
        }


    }

    function RxCore_SetDimOffset(value) {
        if (!documentopen) {
            return;
        }

        if(readonlymode){
            return;
        }

        var markupobject = getSelectedmarkup();

        if(!markupobject.isempty && markupobject.type == 7){
            markupobject.leaderoffset = value;
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

    }


    function RxCore_SetLineWidth(value) {

        var tempwidht = linewidthvalue;
        linewidthvalue = value;
        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(2);
        if (!bSetGlobal) {
            linewidthvalue = tempwidht;
        }
    }

    function RxCore_GetLineWidth() {
        return linewidthvalue;
    }

    function RxCore_SetUnit(value) {
        /*for (i=0;i<this.childElementCount;i++){
         if(this.children[i].className == 'selected'){
         var szUnit = this.children[i].textContent;
         }
         }*/
        /*if (value=='Metric'){Unitofmeasure=1;}
         if (value=='Imperial'){Unitofmeasure=2;}
         if (value=='System'){Unitofmeasure=3;}
         if (value=='Custom'){Unitofmeasure=4;}*/
        //var unitdropdwn = document.getElementById('unitdropdown');

        switch (value) {
            case 1:
                Unitlabel = "mm";
                AreaUnitlabel = "mm\u00B2";
                //unitdropdwn.setAttribute('ref','metricunits');
                //unitdropdwn.children[0].value = "Millimeter";
                break;
            case 2:
                Unitlabel = "in.";
                AreaUnitlabel = "sq.in.";
                //unitdropdwn.setAttribute('ref','imperialunits');
                //unitdropdwn.children[0].value = "Inch";
                break;
            case 3:
                Unitlabel = "Units";
                AreaUnitlabel = "Units\u00B2";
                break;
        }
        Unitofmeasure = value;
    }

    function RxCore_allowLayerChange(onoff){

    }

    function RxCore_getUser(){

        //signature = szCurrentUser;
        //DisplayName = szDisplayName;


        getUserInfo();
        //Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);


    }

    function RxCore_setEndPoints(szXmlUrlmarkup,szMarkupSaveUrl,szFileExport,sz3DImage,szgetUserInfo){

        xmlurlmarkup = szXmlUrlmarkup;
        xmlurlmarkupsave = szMarkupSaveUrl;
        PDFExportURL = szFileExport;
        CanvasSaveUrl = sz3DImage;
        userInfoURL = szgetUserInfo;
        bPDFExportfullPath = true;

    }

    function RxCore_SetGlobalStyle(global) {
        bSetGlobal = global;
    }

    function RxCore_SetFontBold(onoff) {
        var tempbold = defaultFont.bold;

        defaultFont.bold ? defaultFont.setBold(false) : defaultFont.setBold(true);
        //defaultFont.setBold(onoff);

        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(4);
        if (!bSetGlobal) {
            defaultFont.setBold(temobold);

        }

    }

    function RxCore_SetFontItalic(onoff) {
        var tempitalic = defaultFont.italic;

        defaultFont.italic ? defaultFont.setItalic(false) : defaultFont.setItalic(true);

        //defaultFont.setItalic(onoff);

        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(4);
        if (!bSetGlobal) {
            defaultFont.setItalic(tempitalic);

        }

    }

    function RxCore_SetFontHeight(value) {
		//console.log('RxCore_SetFontHeight', value);
        var tempheight = defaultFont.height;
        defaultFont.setHeight(value);

        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(4);
        if (!bSetGlobal) {
            defaultFont.setHeight(tempheight);

        }

    }


    function RxCore_SetFont(value) {

        var tempfont = defaultFont.fontName;
        defaultFont.setFontname(value);

        if (!documentopen) {
            return;
        }
        if (readonlymode) {
            return;
        }

        ChangeMarkupSelected(4);
        if (!bSetGlobal) {
            defaultFont.setFontname(tempfont);
            //fontstylevalue = tempfont;
        }


    }

    function RxCore_GetFont() {
        return defaultFont;
    }


    function RxCore_GetFixedScale(){
        if (!documentopen) {
            return 1;
        }


        var scalefactor = DocObj.pages[DocObj.currentpage].dscale;

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            scalefactor = DocObj.pages[DocObj.currentpage].dscalevector; // markupobject.scaling;
        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            scalefactor = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf); // markupobject.scaling;
        } else {
            scalefactor = DocObj.pages[DocObj.currentpage].dscale; // markupobject.scaling;
            if (DocObj.Type == 0) {
                scalefactor = DocObj.pages[0].dscale; // markupobject.scaling;
            }

        }

        var fixedScale = scalefactor / DocObj.pages[DocObj.currentpage].fixedScale;
        if (bUseFixedScale){
            return fixedScale;
        }else{
            return 1;
        }


    }
    function RxCore_MarkupHatch(style) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }
        var tempstyle = HatchStyle;
        HatchStyle = style;
        ChangeMarkupSelected(3);
        if (!bSetGlobal) {
            HatchStyle = tempstyle;
        }


        /*

         if (szhatchpattern == 'Forward Diagonal'){ HatchStyle = 0;}
         if (szhatchpattern == 'Backward Diagonal'){ HatchStyle = 1;}
         if (szhatchpattern == 'Diagonal Cross'){ HatchStyle = 2;}
         if (szhatchpattern == 'Horizontal'){ HatchStyle = 3;}
         if (szhatchpattern == 'vertical'){ HatchStyle = 4;}
         if (szhatchpattern == 'Cross'){ HatchStyle = 5;}
         // change hatch style for selected markup if applicable.


         }*/

    }


    function RxCore_GetMarkupHatch() {
        return HatchStyle;
    }


    function RxCore_MetricUnit(unit) {

        if (unit == 'Millimeter') {
            SubmeasureUnit = 1;
        }
        if (unit == 'Centimeter') {
            SubmeasureUnit = 2;
        }
        if (unit == 'Decimeter') {
            SubmeasureUnit = 3;
        }
        if (unit == 'Meter') {
            SubmeasureUnit = 4;
        }
        if (unit == 'Kilometer') {
            SubmeasureUnit = 5;
        }
        if (unit == 'Nautical Miles') {
            SubmeasureUnit = 6;
        }

        switch (SubmeasureUnit) {
            case 1:
                Unitlabel = "mm";
                AreaUnitlabel = "mm\u00B2";
                unitscale = 1;
                break;
            case 2:
                Unitlabel = "cm";
                AreaUnitlabel = "cm\u00B2";
                unitscale = 10;
                break;
            case 3:
                Unitlabel = "dm";
                AreaUnitlabel = "dm\u00B2";
                unitscale = 100;
                break;
            case 4:
                Unitlabel = "m";
                AreaUnitlabel = "m\u00B2";
                unitscale = 1000;
                break;
            case 5:
                Unitlabel = "km";
                AreaUnitlabel = "km\u00B2";
                unitscale = 1000000;
                break;
            case 6:
                Unitlabel = "nmi";
                AreaUnitlabel = "nmi\u00B2";
                unitscale = 185200000;
                break;

        }

    }

    function RxCore_ImperialUnit(unit) {
        if (unit == 'Inch') {
            SubmeasureUnit = 1;
        }
        if (unit == 'Feet') {
            SubmeasureUnit = 2;
        }
        if (unit == 'Yard') {
            SubmeasureUnit = 3;
        }
        if (unit == 'Mile') {
            SubmeasureUnit = 4;
        }
        if (unit == 'Nautical Miles') {
            SubmeasureUnit = 5;
        }

        switch (SubmeasureUnit) {
            case 1:
                Unitlabel = "in.";
                AreaUnitlabel = "sq.in.";
                unitscale = 1;
                break;
            case 2:
                Unitlabel = "ft.";
                AreaUnitlabel = "sq.ft.";
                unitscale = 12;
                break;
            case 3:
                Unitlabel = "yd.";
                AreaUnitlabel = "sq.yd.";
                unitscale = 36;
                break;
            case 4:
                Unitlabel = "mi.";
                AreaUnitlabel = "sq.mi";
                unitscale = 63360;
                break;
            case 5:
                Unitlabel = "nm";
                AreaUnitlabel = "sq.nm";
                unitscale = 72913.3858;
                break;

        }

    }

    function RxCore_setCalibration(scale){

        if(documentopen){
            DocObj.pages[DocObj.currentpage].setCalibrateScale(scale);
        }

    }

    function RxCore_scale(scale) {
        var numerator = 0;
        var denomintaor = 0;
        /*for (i=0;i<this.childElementCount;i++){
         if(this.children[i].className == 'selected'){
         var szScale = this.children[i].textContent;
         }
         }*/

        if(documentopen){
            DocObj.pages[DocObj.currentpage].setMeasureScale(scale);

        }else{
            if (scale != 'Calibration') {
                var numarr = scale.split(":");
                numerator = numarr[0];
                denomintaor = numarr[1];
                if (bReverseScale) {
                    MeasureScale = denomintaor / numerator;
                } else {
                    MeasureScale = numerator / denomintaor;
                }

            } else {
                MeasureScale = nCalibrateScale;
            }
        }

    }



    function getTextdim(ctx, text, font){

        var textwidth = 0;
        var textheight = font.height;
        var textarray = text.split('\n');
        ctx.save();
        ctx.font = font.fontstringScaled;


        for (var i = 0; i < textarray.length; i++) {
            var dimsel = ctx.measureText(textarray[i]);
            if (textwidth < dimsel.width){
                textwidth = dimsel.width;
            }

        }

        var hpadding = textheight / 2 * i;
        textheight = (textheight * i) + hpadding;
        textwidth += 10;

        ctx.restore();

        return {w:textwidth,h:textheight};
    }

    function RxCore_MarkupAddBlockText(BlockId,height,text,color){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }


        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            var centroid = DocObj.pages[DocObj.currentpage].getBlockCentroid(BlockId);
            var textsize = DocObj.pages[DocObj.currentpage].getpixeldist(height);
            var textsizept = textsize * 0.75; //convert px to pt.

            var textmarkupobj = new MarkupObject(9, 1, 0);

            textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].getdscale();
            textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].getdx();
            textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].getdy();


            textmarkupobj.font.setFontname(defaultFont.fontName);
            textmarkupobj.font.setHeight(textsizept);
            textmarkupobj.font.setBold(defaultFont.bold);
            textmarkupobj.font.setItalic(defaultFont.italic);

            var textdim = getTextdim(cntximg,text, textmarkupobj.font);

            textmarkupobj.linewidth = 0.5;
            textmarkupobj.w = textdim.w;
            textmarkupobj.h = textdim.h;

            textmarkupobj.x = centroid.x - (textmarkupobj.w/2);
            textmarkupobj.y = centroid.y - (textmarkupobj.h/2);


            textmarkupobj.text = text;



            textmarkupobj.fillcolor = "rgba(255,255,255, 0.9)";
            textmarkupobj.textcolor = color;
            textmarkupobj.strokecolor = color;
            textmarkupobj.pagerotation = DocObj.pages[DocObj.currentpage].drotation;
            textmarkupobj.pagenumber = DocObj.getcurPage();

            textmarkupobj.savemetolistDraw();

        }

        drawmarkupAll(cntximg);


    }


    function CreateTextRect(x, y, w, h, markuparrow, text){
        var sizePos = {
            x : x + w,
            y : y + h
        };

        var startpos = {
            x : x,
            y : y
        };

        var bWithin = MousePosdrwext(startpos);
        if (!bWithin && bLimMarkupExtent) {
            return;
        }

        var bWithin = MousePosdrwext(sizePos);
        if (!bWithin && bLimMarkupExtent) {
            return;
        }



        if(markuparrow != null){
            var textmarkupobj = new MarkupObject(9, 2, 0);

            textmarkupobj.settxtboxArrow(markuparrow);
        }else{
            textmarkupobj = new MarkupObject(9, 1, 0);
        }

        textmarkupobj.x = x;
        textmarkupobj.y = y;

        switch(DocObj.pages[DocObj.currentpage].drotation){
            case 0:
                textmarkupobj.w = w;
                textmarkupobj.h = h;

                break;
            case 90:
                textmarkupobj.w = w;
                textmarkupobj.h = h;

                break;
            case 180:
                textmarkupobj.w = w;
                textmarkupobj.h = h;

                break;
            case 270:
                textmarkupobj.w = w;
                textmarkupobj.h = h;

                break;
        }


        textmarkupobj.pagerotation = DocObj.pages[DocObj.currentpage].drotation;
        textmarkupobj.pagenumber = DocObj.getcurPage();

        textmarkupobj.font.setFontname(defaultFont.fontName);
        textmarkupobj.font.setHeight(defaultFont.height);
        textmarkupobj.font.setBold(defaultFont.bold);
        textmarkupobj.font.setItalic(defaultFont.italic);

        //textmarkupobj.font = defaultFont;
        textmarkupobj.fillcolor = "rgba(255,255,255, 0.9)";

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
            textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
            textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;

        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            textmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
            textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
            textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

        } else {
            textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
            textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
            textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

        }
        textmarkupobj.editaction = 0;
        textmarkupobj.selectedit = true;
        textmarkupobj.setselect(false);
        textmarkupobj.text = text;

        //textmarkupobj.rotation = -(DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180));
        textmarkupobj.savemetolistDraw();

        DocObj.selectedmarkup.id = DocObj.getmarkupbynumber(textmarkupobj.markupnumber);
        DocObj.selectedmarkup.edit = true;
        DocObj.selectedmarkup.selected = true;

    }

    function RxCore_CreateTextRect(x, y, w, h,text){

        CreateTextRect(x, y, w, h,null,text);

        //DocObj.setMarkupMultiselected();

    }

    function textRect(x, y, w, h, markuparrow){


        if (w < 20) {
            w = 20;
        }

        if (h < 12) {
            h = 12;
        }

        var sizePos = {
            x : x + w,
            y : y + h
        };

        var bWithin = MousePosdrwext(sizePos);
        if (!bWithin && bLimMarkupExtent) {
            return;
        }

        CreateTextRect(x, y, w, h, markuparrow,"");

        if (RxCore_GUI_TextInput != undefined) {
            var rect = canvas.getBoundingClientRect();

            x += w*0.5;
            y += h*0.5;

            x += rect.left;
            y += rect.top;

            RxCore_GUI_TextInput.operation.start = true;
            RxCore_GUI_TextInput.operation.create = false;
            RxCore_GUI_TextInput.operation.edit = false;
            RxCore_GUI_TextInput.operation.save = false;

            var txtrect = new Rectangle(x,y,w,h);
            //txtrect.rotation = 0;
            txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;
            RxCore_GUI_TextInput.setTextInput(txtrect);

        }


        //RxCore_TextRect(false);

        set_tool('markupedit', {p1 : false});


        /*if (RxCore_GUI_TextInput != undefined) {
            RxCore_GUI_TextInput.operation.start = false;
            RxCore_GUI_TextInput.operation.create = false;
            RxCore_GUI_TextInput.operation.edit = true;
            RxCore_GUI_TextInput.operation.save = false;
        }*/

    }

    function stampRect(x, y, w, h, Text) {

        if (w < 200) {
            w = 200;
        }

        if (h < 124) {
            h = 124;
        }

        var sizePos = {
            x : x + w,
            y : y + h
        };

        var bWithin = MousePosdrwext(sizePos);
        if (!bWithin && bLimMarkupExtent) {
          return;
        }



        var stamptype = 0;
        for (var i = 0; i < Stamplist.length; i++) {
            if (Stamplist[i] == Text) {
                stamptype = i;
            }
        }
        var stampmarkupobj;
        stampmarkupobj = new MarkupObject(12, stamptype, 1);
        stampmarkupobj.fillcolor = "rgba(255,0,0,0.3)";
        stampmarkupobj.transparency = 30;

        if (stamptype < Stamplist.length - 2) {


            stampmarkupobj.text = Stamplist[stamptype];

        }else{
            if (Stamplist[stamptype] == 'Date') {
                stampmarkupobj.text = stampmarkupobj.GetDateTime(false);
                //ntexwtsize = 90;
            }

            if (Stamplist[stamptype] == 'User Name') {
                stampmarkupobj.text = GetDisplayName(stampmarkupobj.signature);
            }

        }

        stampmarkupobj.w = w;
        stampmarkupobj.h = h;
        var endx = 0;
        var startx = 0;
        var endy = 0;
        var starty = 0;

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            stampmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
            stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
            stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
            endx = DocObj.pages[DocObj.currentpage].endx;
            startx = DocObj.pages[DocObj.currentpage].dxvector;
            endy = DocObj.pages[DocObj.currentpage].endy;
            starty = DocObj.pages[DocObj.currentpage].dyvector;


        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            stampmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
            stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
            stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;
            endx = DocObj.pages[DocObj.currentpage].endx;
            startx = DocObj.pages[DocObj.currentpage].dxpdf;
            endy = DocObj.pages[DocObj.currentpage].endy;
            starty = DocObj.pages[DocObj.currentpage].dypdf;

        } else {
            stampmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
            stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
            stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
            endx = DocObj.pages[DocObj.currentpage].endx;
            startx = DocObj.pages[DocObj.currentpage].dx;
            endy = DocObj.pages[DocObj.currentpage].endy;
            starty = DocObj.pages[DocObj.currentpage].dy;


        }


        stampmarkupobj.font.setFontname("Times New Roman");
        stampmarkupobj.font.setBold(true);

        stampmarkupobj.pagenumber = DocObj.getcurPage();
        stampmarkupobj.editaction = 0;


        if ((stampmarkupobj.w*0.6) >= stampmarkupobj.h){
            //stampmarkupobj.textheight = (stampmarkupobj.h / 4);
            stampmarkupobj.font.setHeight(stampmarkupobj.h / 4);
        }else{
            //stampmarkupobj.textheight = stampmarkupobj.w * 0.16;
            stampmarkupobj.font.setHeight(stampmarkupobj.w * 0.16);
        }


        //stampmarkupobj.textheight = h / 4;
        stampmarkupobj.stampsmalltheight = 16;

        stampmarkupobj.x = x;
        stampmarkupobj.y = y;


        if (!bMultimarkupadd) {

            bMarkupcrated = true;
            //ft 08.08.2018 changed from separate index to direct array length
            //nMarkupcreated = DocObj.nummarkups;
            nMarkupcreated = DocObj.markuplist.length;

        }

        stampmarkupobj.drawme(context);
        stampmarkupobj.savemetolistDraw();

        img_update();
        if(DocObj){
            DocObj.bMarkupchanged = true;
        }


        stampmarkupobj = null;
        if (!bMultimarkupadd) {

            //need to move to connection object.
            //markupcreated();
            if (RxCore_GUI_Markup != undefined) {

                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
            }

        }

    }


    function RxCore_TextRectArrow(selected){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }

        if (selected) {
            unselelectallmarkup();
            unselecteditmarkupall();

            set_tool('arrow', {p1 : 6});
            //set_tool('rectText',{});

            //tool = new tools['rectText']();
        } else {

            set_tool('markupedit',{p1 : false});

        }

    }

    function RxCore_TextRect(selected, callback){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }

        if (selected) {
            unselelectallmarkup();
            unselecteditmarkupall();

            set_tool('rectText',{});

            //tool = new tools['rectText']();
        } else {

            set_tool('markupedit',{p1: false});

        }


        if (RxCore_GUI_TextInput && callback && typeof callback === "function") {
            RxCore_GUI_TextInput.connect(callback);
        }

    }

    function RxCore_setConfiguration(configURL){

        configurationLocation = configURL;
        bUsecustomConfig = true;

    }

    function RxCore_StampMarkup(Text){
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        set_tool('rectStamp', {p1 : Text});
        //tool = new tools['rectStamp'](Text);

    }

    function RxCore_MarkupStamp(Text) {
        if (!documentopen) {
            return;
        }
        if (readonlymode || documentcompare) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();
        var stamptype = 0;
        //var szstamp = Text;

        for (var i = 0; i < Stamplist.length; i++) {
            if (Stamplist[i] == Text) {
                stamptype = i;
            }
        }


        //width of stamp = 200 pixels.
        //1/3 from top of display.
        //height of stamp = 1/4 of width
        //font size = 62 for main text 31 for small text.
        //height of stamp = height of text + 30 percent

        var stampmarkupobj;
        if (stamptype < Stamplist.length - 2) {
            stampmarkupobj = new MarkupObject(12, stamptype, 0);
            stampmarkupobj.w = 200;
            stampmarkupobj.h = 124;
            var endx = 0;
            var startx = 0;
            var endy = 0;
            var starty = 0;

            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                stampmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                endx = DocObj.pages[DocObj.currentpage].endx;
                startx = DocObj.pages[DocObj.currentpage].dxvector;
                endy = DocObj.pages[DocObj.currentpage].endy;
                starty = DocObj.pages[DocObj.currentpage].dyvector;


            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                stampmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;
                endx = DocObj.pages[DocObj.currentpage].endx;
                startx = DocObj.pages[DocObj.currentpage].dxpdf;
                endy = DocObj.pages[DocObj.currentpage].endy;
                starty = DocObj.pages[DocObj.currentpage].dypdf;

            } else {
                stampmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                endx = DocObj.pages[DocObj.currentpage].endx;
                startx = DocObj.pages[DocObj.currentpage].dx;
                endy = DocObj.pages[DocObj.currentpage].endy;
                starty = DocObj.pages[DocObj.currentpage].dy;


            }

            stampmarkupobj.pagenumber = DocObj.getcurPage();
            stampmarkupobj.editaction = 0;


            stampmarkupobj.textheight = 32;
            stampmarkupobj.stampsmalltheight = 16;

            stampmarkupobj.x = (startx + ((endx - startx) / 2)) - (stampmarkupobj.w / 2);
            stampmarkupobj.y = (starty + ((endy - starty) / 2)) - (stampmarkupobj.h / 2);


            if (!bMultimarkupadd) {
                bMarkupcrated = true;
                //ft 08.08.2018 changed from separate index to direct array length
                //nMarkupcreated = DocObj.nummarkups;
                nMarkupcreated = DocObj.markuplist.length;
            }


            stampmarkupobj.drawme(context);
            stampmarkupobj.savemetolistDraw();


        } else {
            stampmarkupobj = new MarkupObject(9, 0, 0);
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                stampmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                stampmarkupobj.x = (DocObj.pages[DocObj.currentpage].dxvector + (DocObj.pages[DocObj.currentpage].endx / 2)) - ntexwtsize; // - (stampmarkupobj.w / 2);
                stampmarkupobj.y = (DocObj.pages[DocObj.currentpage].dyvector + (DocObj.pages[DocObj.currentpage].endy / 2)) + (stampmarkupobj.textheight / 2);


            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                stampmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;
                stampmarkupobj.x = (DocObj.pages[DocObj.currentpage].dxpdf + (DocObj.pages[DocObj.currentpage].endx / 2)) - ntexwtsize; // - (stampmarkupobj.w / 2);
                stampmarkupobj.y = (DocObj.pages[DocObj.currentpage].dypdf + (DocObj.pages[DocObj.currentpage].endy / 2)) + (stampmarkupobj.textheight / 2);


            } else {
                stampmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                stampmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                stampmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                stampmarkupobj.x = (DocObj.pages[DocObj.currentpage].dx + (DocObj.pages[DocObj.currentpage].endx / 2)) - ntexwtsize; // - (stampmarkupobj.w / 2);
                stampmarkupobj.y = (DocObj.pages[DocObj.currentpage].dy + (DocObj.pages[DocObj.currentpage].endy / 2)) + (stampmarkupobj.textheight / 2);


            }
            stampmarkupobj.pagenumber = DocObj.getcurPage();
            stampmarkupobj.editaction = 0;
            stampmarkupobj.textheight = 32;
            var ntexwtsize = 100;
            if (Stamplist[stamptype] == 'Date') {
                stampmarkupobj.text = stampmarkupobj.GetDateTime(false);
                ntexwtsize = 90;
            }

            if (Stamplist[stamptype] == 'User Name') {
                stampmarkupobj.text = GetDisplayName(stampmarkupobj.signature);
            }

            //stampmarkupobj.text = Stamplist[stamptype];

            //stampmarkupobj.w = 200;
            //stampmarkupobj.h = 124;

            //stampmarkupobj.x = (canvas.width / 2)-ntexwtsize;// - (stampmarkupobj.w / 2);
            //stampmarkupobj.y = (canvas.height / 2) + (stampmarkupobj.textheight / 2);

            //stampmarkupobj.stampsmalltheight = 16;


            stampmarkupobj.drawme(context);
            if (!bMultimarkupadd) {

                bMarkupcrated = true;
                //ft 08.08.2018 changed from separate index to direct array length
                //nMarkupcreated = DocObj.nummarkups;
                nMarkupcreated = DocObj.markuplist.length;
            }

            stampmarkupobj.savemetolistDraw();

        }
        img_update();
        if(DocObj){
            DocObj.bMarkupchanged = true;
        }


        stampmarkupobj = null;
        if (!bMultimarkupadd) {

            //need to move to connection object.
            //markupcreated();
            if (RxCore_GUI_Markup != undefined) {

                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
            }

        }


    }

    function RxCore_MSIEeventCheck(onoff){
        bDisableMSIE11Eventcheck = onoff;
    }

    function RxCore_createSpacemarkupAttribsPath(blockid, path, attributes, scalefactor, xoffset, yoffset, mediax, mediay, mediah){
        var absxscaled = (path.points[0] - mediax) * scalefactor;
        var absyscaled = (mediah - path.points[1]) * scalefactor;

        absxscaled += xoffset;
        absyscaled += yoffset;

        var spacemarkup = new MarkupObject(8, 1, 0);
        spacemarkup.linewidth = 1;

        for (var ac=0; ac <  attributes.length ; ac++){
           spacemarkup.AddAttribute(attributes[ac].name, attributes[ac].value);
        }

        spacemarkup.AddAttribute('Rx_Area', '0');
        var spbid = blockid.toString();
        spacemarkup.AddAttribute('SpaceID', spbid);
        spacemarkup.scaling = scalefactor;
        spacemarkup.xoffset = xoffset;
        spacemarkup.yoffset = yoffset;

        spacemarkup.addpoint(absxscaled, absyscaled);

        var relxscaled = 0;
        var relyscaled = 0;

        for (var counter = 2; counter < path.points.length; counter += 2) {

            relxscaled = ((path.points[counter] - mediax) * scalefactor);
            relyscaled = ((mediah - path.points[counter + 1]) * scalefactor);
            relxscaled += xoffset;
            relyscaled += yoffset;
            spacemarkup.addpoint(relxscaled, relyscaled);

        }

        var areapoints = spacemarkup.PolygonArea();
        var temppointarray = [];

        if(path.gotsubpath){
            for (var scount = 0; scount < path.subpaths.length; scount++) {
                for ( counter = 0; counter < path.subpaths[scount].points.length; counter += 2) {

                    relxscaled = ((path.subpaths[scount].points[counter] - mediax) * scalefactor);
                    relyscaled = ((mediah - path.subpaths[scount].points[counter + 1]) * scalefactor);

                    relxscaled += xoffset;
                    relyscaled += yoffset;

                    temppointarray.push({x:relxscaled,y:relyscaled});
                    //spacemarkup.addpoint(relxscaled, relyscaled);
                }

                var parea = getpolygonarea(temppointarray);

                if(parea > areapoints){
                    spacemarkup.points = temppointarray.slice();
                    temppointarray = [];
                    areapoints = parea;
                }

            }
        }


        spacemarkup.findrectangle();

        bMarkupcrated = true;
        nMarkupcreated = DocObj.markuplist.length;

        spacemarkup.markupID = getlastmarkupnumber();
        spacemarkup.savemetolistLoad(DocObj);

        img_update();
        drawmarkupAll(cntximg);

        if (RxCore_GUI_Markup != undefined) {
            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
        }

    }

    function RxCore_createSpacemarkupAttribs(blockid, polypoints, attributes, scalefactor, xoffset, yoffset, mediax, mediay, mediah){

        var absxscaled = (polypoints[0] - mediax) * scalefactor;
        var absyscaled = (mediah - polypoints[1]) * scalefactor;

        absxscaled += xoffset;
        absyscaled += yoffset;

        var spacemarkup = new MarkupObject(8, 1, 0);
            spacemarkup.linewidth = 1;

            for (var ac=0; ac <  attributes.length ; ac++){

                spacemarkup.AddAttribute(attributes[ac].name, attributes[ac].value);

            }

            spacemarkup.AddAttribute('Rx_Area', '0');
            var spbid = blockid.toString();
            spacemarkup.AddAttribute('SpaceID', spbid);
            spacemarkup.scaling = scalefactor;
            spacemarkup.xoffset = xoffset;
            spacemarkup.yoffset = yoffset;

        spacemarkup.addpoint(absxscaled, absyscaled);

        var relxscaled = 0;
        var relyscaled = 0;

        for (var counter = 2; counter < polypoints.length; counter += 2) {

            relxscaled = ((polypoints[counter] - mediax) * scalefactor);
            relyscaled = ((mediah - polypoints[counter + 1]) * scalefactor);
            relxscaled += xoffset;
            relyscaled += yoffset;
            spacemarkup.addpoint(relxscaled, relyscaled);

        }

        spacemarkup.findrectangle();

        bMarkupcrated = true;
        nMarkupcreated = DocObj.markuplist.length;

        spacemarkup.markupID = getlastmarkupnumber();
        spacemarkup.savemetolistLoad(DocObj);

        img_update();
        drawmarkupAll(cntximg);

        if (RxCore_GUI_Markup != undefined) {
            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
        }


    }

    function RxCore_createSpacemarkupPath(path, scalefactor, xoffset, yoffset, mediax, mediay, mediah){

        var absxscaled = (path.points[0] - mediax) * scalefactor;
        var absyscaled = (mediah - path.points[1]) * scalefactor;

        absxscaled += xoffset;
        absyscaled += yoffset;

        var spacemarkupArray = [];

        var spacemarkup = new MarkupObject(8, 1, 0);
        spacemarkup.linewidth = 1;
        spacemarkup.AddAttribute('Rx_Area', '0');
        spacemarkup.AddAttribute('SpaceID', '0');
        spacemarkup.scaling = scalefactor;
        spacemarkup.xoffset = xoffset;
        spacemarkup.yoffset = yoffset;

        spacemarkup.addpoint(absxscaled, absyscaled);

        var relxscaled = 0;
        var relyscaled = 0;

        for (var counter = 2; counter < path.points.length; counter += 2) {

            relxscaled = ((path.points[counter] - mediax) * scalefactor);
            relyscaled = ((mediah - path.points[counter + 1]) * scalefactor);
            relxscaled += xoffset;
            relyscaled += yoffset;
            spacemarkup.addpoint(relxscaled, relyscaled);

        }


        var areapoints = spacemarkup.PolygonArea();

        //areaArray.push(areapoints);


        var temppointarray = [];

        //spacemarkup.points = [];

        if(path.gotsubpath){
            for (var scount = 0; scount < path.subpaths.length; scount++) {
                for ( counter = 0; counter < path.subpaths[scount].points.length; counter += 2) {

                    relxscaled = ((path.subpaths[scount].points[counter] - mediax) * scalefactor);
                    relyscaled = ((mediah - path.subpaths[scount].points[counter + 1]) * scalefactor);

                    relxscaled += xoffset;
                    relyscaled += yoffset;

                    temppointarray.push({x:relxscaled,y:relyscaled});
                    //spacemarkup.addpoint(relxscaled, relyscaled);
                }

                var parea = getpolygonarea(temppointarray);

                if(parea > areapoints){
                    spacemarkup.points = temppointarray.slice();
                    temppointarray = [];
                    areapoints = parea;
                }

            }
        }

        spacemarkup.findrectangle();

        //remove holes for now

        /*var aremovepoints = [];
        var temppointarray = [];

        var mrkscale = scalefactor /spacemarkup.scaling;

        for (var mpcounter = 0; mpcounter < spacemarkup.points.length; mpcounter++) {

            var xscaledpoint = (spacemarkup.points[mpcounter].x - spacemarkup.xoffset) * mrkscale;
            var yscaledpoint = (spacemarkup.points[mpcounter].y - spacemarkup.yoffset) * mrkscale;

            xscaledpoint = xscaledpoint + xoffset;
            yscaledpoint = yscaledpoint + yoffset;

            if(spacemarkup.iswithin(xscaledpoint,yscaledpoint)){
                temppointarray.push(spacemarkup.points[mpcounter]);
            }else{
                aremovepoints.push(mpcounter);
            }
        }

        spacemarkup.points = temppointarray.slice();*/
        //var temppointarray = spacemarkup.points.slice();
        /*for (var rmpcount = 0;rmpcount < aremovepoints.length;rmpcount++){

            spacemarkup.deletepoint(aremovepoints[rmpcount]);
        }*/

        //spacemarkup

        //spacemarkup.findrectangle();

        bMarkupcrated = true;
        nMarkupcreated = DocObj.markuplist.length;

        spacemarkup.savemetolistLoad(DocObj);

        img_update();
        drawmarkupAll(cntximg);

        if (RxCore_GUI_Markup != undefined) {
            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
        }

    }

    function RxCore_createSpacemarkup(polypoints, scalefactor, xoffset, yoffset, mediax, mediay, mediah){

        var absxscaled = (polypoints[0] - mediax) * scalefactor;
        var absyscaled = (mediah - polypoints[1]) * scalefactor;

        absxscaled += xoffset;
        absyscaled += yoffset;

        var spacemarkup = new MarkupObject(8, 1, 0);
            spacemarkup.linewidth = 1;
            spacemarkup.AddAttribute('Rx_Area', '0');
            spacemarkup.AddAttribute('SpaceID', '0');
            spacemarkup.scaling = scalefactor;
            spacemarkup.xoffset = xoffset;
            spacemarkup.yoffset = yoffset;

        spacemarkup.addpoint(absxscaled, absyscaled);

        var relxscaled = 0;
        var relyscaled = 0;

        for (var counter = 2; counter < polypoints.length; counter += 2) {

            relxscaled = ((polypoints[counter] - mediax) * scalefactor);
            relyscaled = ((mediah - polypoints[counter + 1]) * scalefactor);
            relxscaled += xoffset;
            relyscaled += yoffset;
            spacemarkup.addpoint(relxscaled, relyscaled);

        }

        spacemarkup.findrectangle();

        bMarkupcrated = true;
        nMarkupcreated = DocObj.markuplist.length;

        spacemarkup.savemetolistLoad(DocObj);

        img_update();
        drawmarkupAll(cntximg);

        if (RxCore_GUI_Markup != undefined) {
            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
        }



    }

    function RxCore_CreateSpaceFromPolygon(selected){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        if (!selected) {

            set_tool('markupedit', {p1 : false});

            return;
        }

        unselelectallmarkup();
        set_tool('pickPolygon', {p1 : false, p2 : true, p3: true});
        //tool = new tools['pickPolygon'](multi);

    }

    function RxCore_pickRxSpace(selected,multi){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        if (!selected) {

            set_tool('markupedit', {p1 : false});

            return;
        }

        unselelectallmarkup();
        set_tool('pickPolygon', {p1 : multi, p2 :  false, p3: false});


    }


    function RxCore_PickPolygon(selected,multi){
        if (!documentopen) {
            return;
        }
        if (documentcompare) {
            return;
        }

        if (!selected) {

            set_tool('markupedit', {p1 : false});

            return;
        }

        unselelectallmarkup();
        set_tool('pickPolygon', {p1 : multi, p2 :  false, p3: true});
        //tool = new tools['pickPolygon'](multi);
    }


    function RxCore_SpaceEdit(){
        if (!documentopen) {
            return;
        }

        if(DocObj.pages[DocObj.currentpage].usevector3Dxml){
            //can't use this with 3D
            return;
        }



        set_tool('markupedit', {p1 : true});

    }

    function RxCore_default() {
        if (!documentopen) {
            return;
        }

        if(DocObj.pages[DocObj.currentpage].usevector3Dxml){
            //can't use this with 3D
            return;
        }



        set_tool('markupedit', {p1 : false});


    }

    function RxCore_KeepvectorColor(OnOff){
        /*if (!documentopen) {
         return;
         }*/

        bKeepVectorColor = OnOff;

    }



    function RxCore_DrawPoints(){
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usepdfjs) {

            DocObj.pages[DocObj.currentpage].drawpoints(DocObj.pages[DocObj.currentpage].PDFPointArray,DocObj.pages[DocObj.currentpage].pdfSnapScale);

        }


    }

    function Rxcore_BackgroundColor(color){
        backgroundColor = color;
    }

    function RxCore_BackgroundCustomColor(color){
        if (!documentopen) {
            return;
        }

        backgroundCustomColor = color;
        bCustomColor = true;

        DocObj.backgroundColor = backgroundCustomColor;

        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].draw_vector(true);
        }
        drawmarkupAll(cntximg);


    }


    function RxCore_setdisplayBackground(color){
        displayBGColor = color;

        if (documentopen) {
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                DocObj.pages[DocObj.currentpage].draw_vector(true);
            }
            drawmarkupAll(cntximg);

        }

    }


    function RxCore_togglebackground() {
        if (!documentopen) {
            return;
        }


        if (DocObj.pages[DocObj.currentpage].usepdfjs) {
            DocObj.backgroundColor = "#FFFFFF";
        } else {
            if(bCustomColor){
                if (DocObj.backgroundColor == backgroundCustomColor) {
                    DocObj.backgroundColor = "#A0A0A0";
                }else if (DocObj.backgroundColor == "#A0A0A0") {
                    DocObj.backgroundColor = "#FFFFFF";
                } else if (DocObj.backgroundColor == "#FFFFFF") {

                    DocObj.backgroundColor = "#000000";

                } else if (DocObj.backgroundColor == "#000000") {
                    DocObj.backgroundColor = backgroundCustomColor;
                    bKeepVectorColor = !bKeepVectorColor;
                }
            }else{
                if (DocObj.backgroundColor == "#A0A0A0") {
                    DocObj.backgroundColor = "#FFFFFF";
                } else if (DocObj.backgroundColor == "#FFFFFF") {

                    DocObj.backgroundColor = "#000000";

                } else if (DocObj.backgroundColor == "#000000") {
                    DocObj.backgroundColor = "#A0A0A0";
                    bKeepVectorColor = !bKeepVectorColor;
                }

            }

        }
        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
            DocObj.pages[DocObj.currentpage].draw_vector(true);
        }
        drawmarkupAll(cntximg);
    }

    function set3DToolType(selected, type) {
        if (!documentopen) {
            return;
        }
        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            //unselelectallmarkup();
            var toolType = (selected) ? type : DocObj.curcontrol3D;
            //tool = new tools[toolType]();
            set_tool(toolType, {});
        }
    }

    function RxCore_3DSelect(selected) {
        set3DToolType(selected, 'select3d');
    }

    function RxCore_3DToggleVisible(selected) {
        set3DToolType(selected, 'hide3d');
    }

    function RxCore_unSelectAllMarkup(){
        if (!documentopen) {
            return;
        }

        unselelectallmarkup();
        unselecteditmarkupall();

        if(RxCore_GUI_Markuplist != undefined){
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist,DocObj.bActive);
        }


    }

    function RxCore_UseFixedScale(onoff){

        bUseFixedScale = onoff;

    }

    function RxCore_UseFraction(onoff){

        bUseFraction = onoff;

    }

    function RxCore_UseOrtho(onoff, degree){

        bOrthoOn = onoff;
        nOrthoDegree = degree;

    }

    function RxCore_SetGUIDMarkupSelected(){
        if (!documentopen) {
            return;
        }
        if(readonlymode){
            return;
        }

        var markupobject = getSelectedmarkup();

        if(!markupobject.isempty){
            markupobject.setRxUniqueID();
        }


    }

    function RxCore_AutoLoadThumbnails(onoff){
        bAutoloadThumbnails = onoff;
    }



    function RxCore_LoadThumbnails(){
        if (!documentopen) {
            return;
        }

        DocObj.thumbnails = [];

        for(var i = 0; i < DocObj.pages.length; i++){

            DocObj.pages[i].thumbnailobj.source = DocObj.pages[i].ThumbnailImageSRC;
            DocObj.pages[i].thumbloaded = true;
            DocObj.pages[i].thumbload();
            DocObj.thumbnails.push(DocObj.pages[i].getThumbnail);

        }

       if (RxCore_GUI_pagethumbs != undefined) {
            RxCore_GUI_pagethumbs.setThumbnails(DocObj.thumbnails);
       }


    };

    function RxCore_LockMarkupbyGUID(GUID,onOff){
        if (!documentopen) {
            return;
        }

        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            OpenFiles[curdoc].lockMarkupbyGUID(GUID, onOff);
        }


    }


    function RxCore_getMarkupByGUID(GUID){
        if (!documentopen) {
            return;
        }

        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            var markupxml = OpenFiles[curdoc].getmarkupbyGUIDXML(GUID);
        }


    }
    function RxCore_getMarkupXMLByGUID(GUID){
        if (!documentopen) {
            return;
        }

        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            var markupxml = OpenFiles[curdoc].getmarkupbyGUIDXML(GUID);
        }

        return markupxml;
    }

    /*function RxCore_getmarkupbyGUID(GUID){
        if (!documentopen) {
            return;
        }

        for (var curdoc = 0;curdoc < OpenFiles.length;curdoc++){
            var markupxml = OpenFiles[curdoc].getmarkupbyGUIDXML(GUID);
        }



    }*/


    function RxCore_getmarkupobjByGUID(GUID){
        if (!documentopen) {
            return;
        }
        return DocObj.getmarkupobjbyGUID(GUID);

    }

    function RxCore_unSelectMarkupbyGUID(GUID){
        if (!documentopen) {
            return;
        }
        var indx = DocObj.getmarkupbyGUID(GUID);
        var markupnumber = DocObj.markuplist[indx].markupnumber;
        if(indx != -1){
            RxCore_unSelectMarkupbyIndex(markupnumber);



            if(RxCore_GUI_MarkupUnselect != undefined){
                var btextboxleader = (DocObj.markuplist[indx].type == 9 && DocObj.markuplist[indx].subtype == 2);

                if(btextboxleader){
                    RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[indx].markupArrowConnected);
                }else{
                    RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[indx]);
                }

                RxCore_GUI_MarkupUnselect.setMarkupunSelected(DocObj.markuplist[indx]);
            }

        }
    }

    function RxCore_SelectMarkupbyGUID(GUID){
        if (!documentopen) {
            return;
        }

        var indx = DocObj.getmarkupbyGUID(GUID);
        var markupnumber = DocObj.markuplist[indx].markupnumber;
        if(indx != -1){
            RxCore_SelectMarkupbyIndex(markupnumber);
            if (RxCore_GUI_Markup != undefined && DocObj.markuplist[indx] != undefined) {

                var btextboxleader = (DocObj.markuplist[indx].type == 9 && DocObj.markuplist[indx].subtype == 2);

                if(btextboxleader){
                    RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[indx].markupArrowConnected, {created : false, modified : false, deleted : false});
                }else{
                    RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[indx], {created : false, modified : false, deleted : false});
                }

            }


            //RxCore_SelectMarkupIndex(indx);
        }

    }

    function RxCore_unSelectMarkupbyIndex(indx){
        if (!documentopen) {
            return;
        }

        var arrindx = DocObj.getmarkupbynumber(indx);
        if (DocObj.markuplist.length - 1 < arrindx ){
            return;
        }
        if(DocObj.markuplist[arrindx].locked){
            return;
        }

        unselectmarkup(indx);

        if (RxCore_GUI_Markuplist != undefined) {
            RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist, DocObj.bActive);
        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);



    }

    function RxCore_SelectMarkupIndex(indx){
        if (!documentopen) {
            return;
        }

        if (DocObj.markuplist.length - 1 < indx ){
            return;
        }

        /*if(DocObj.markuplist[indx].locked){
            return;
        }*/

        if(consolidateObj.isactive){
            unselectmarkup(indx);
        }else{
            if(!bMultiselect && !DocObj.getMarkupMultiselected()){
                unselelectallmarkup();
            }

        }

        if (DocObj.getcurPage() != DocObj.markuplist[indx].pagenumber) {
            DocObj.GotoPage(DocObj.markuplist[indx].pagenumber);
        }

        if (DocObj.markuplist[indx].selectedit) {
            DocObj.markuplist[indx].setselect(false);
        } else {
            DocObj.markuplist[indx].setselect(true);
            DocObj.markuplist[indx].lengthangleCallbackSelect();
			/* Andriy TODO: Commented as Temporarely fix */
//            DocObj.pages[DocObj.currentpage].SetMarkupZoom(DocObj.markuplist[indx].docdx, DocObj.markuplist[indx].docdy, DocObj.markuplist[indx].docdscale);
            /*if (RxCore_GUI_Markup != undefined) {
                if(DocObj.markuplist[indx].signature == signature){
                    var operation = {created : false, modified : false, deleted : false};
                    var btextboxleader = (DocObj.markuplist[indx].type == 9 &&  DocObj.markuplist[indx].subtype == 2);
                    if(!btextboxleader){
                        //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[indx], operation);
                    }

                }


                /*if(RxCore_GUI_Markuplist != undefined){
                    RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist);
                }*/

                /* Andriy */
                //RxCore_GUI_Markuplist.notify();
            //}
            /*if (RxCore_GUI_Markuplist != undefined) {

                RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist,DocObj.bActive);

            }*/


        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);
    }



    function RxCore_SelectMarkupbyIndex(indx) {
        if (!documentopen) {
            return;
        }

        if (DocObj.markuplist.length - 1 < indx ){
            return;
        }

        var arrindx = DocObj.getmarkupbynumber(indx);

        if(DocObj.markuplist[arrindx].locked){
            return;
        }

        /*if(DocObj.markuplist[indx].markupnumber == indx){
            RxCore_SelectMarkupIndex(indx);
            return;
        }else{


        }*/


        if(consolidateObj.isactive){
            unselectmarkup(indx);
        }else{
            if(!bMultiselect && !DocObj.getMarkupMultiselected()){
                unselelectallmarkup();
            }

        }

        if (DocObj.getcurPage() != DocObj.markuplist[arrindx].pagenumber) {
            DocObj.GotoPage(DocObj.markuplist[arrindx].pagenumber);
        }

        if (DocObj.markuplist[arrindx].selectedit) {
            DocObj.markuplist[arrindx].setselect(false);
        } else {
            DocObj.markuplist[arrindx].setselect(true);
            DocObj.markuplist[arrindx].lengthangleCallbackSelect();

			/* Andriy TODO: Commented as Temporarely fix */
//            DocObj.pages[DocObj.currentpage].SetMarkupZoom(DocObj.markuplist[indx].docdx, DocObj.markuplist[indx].docdy, DocObj.markuplist[indx].docdscale);
            /*if (RxCore_GUI_Markup != undefined) {
                if(DocObj.markuplist[indx].signature == signature){
                    var operation = {created : false, modified : false, deleted : false};
                    var btextboxleader = (DocObj.markuplist[indx].type == 9 &&  DocObj.markuplist[indx].subtype == 2);
                    if(!btextboxleader){
                        //test remove callback to prevent multiple calls
                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[indx], operation);
                    }

                }


                /*if(RxCore_GUI_Markuplist != undefined){
                    RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist);
                }*/

                /* Andriy */
                //RxCore_GUI_Markuplist.notify();
            //}
            /*if (RxCore_GUI_Markuplist != undefined) {

                RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist,DocObj.bActive);

            }*/


        }

        drawmarkupAll(cntximg);
        DrawMarkupSelected(context);

        //DocObj.setMarkupMultiselected();
        /*if(RxCore_GUI_Markuplist != undefined){
         RxCore_GUI_Markuplist.setMarkupList(DocObj.markuplist);
         }*/

        //console.log('selectmarkupbyindex');



    }


    function getTouchPos(canvas, evt, num) {
        var rect = canvas.getBoundingClientRect();

        var x;// = evt.targetTouches[num].pageX - rect.left;
        var y;// = evt.targetTouches[num].pageY - rect.top;

        if(evt && evt.targetTouches && evt.targetTouches[num]) {
            x = evt.targetTouches[num].pageX - rect.left;
            y = evt.targetTouches[num].pageY - rect.top;
        } else if(evt && evt.changedTouches && evt.changedTouches[num]) {
            x = evt.changedTouches[num].pageX - rect.left;
            y = evt.changedTouches[num].pageY - rect.top;
        }

        return {
            x: x,
            y: y

        };
    }

    function getMousePos(canvas, evt) {

        var rect = canvas.getBoundingClientRect();

        return {
            x:evt.clientX - rect.left,
            y:evt.clientY - rect.top
        };
    }


    function getRotPoint(width, height, x, y, anglerad){
        var cosangle = Math.cos(anglerad);
        var sinangle = Math.sin(anglerad);

        var hw = x - width;
        var hh = y - height;

        var newx = (hw * cosangle) - (hh * sinangle);
        var newy = (hw * sinangle) + (hh * cosangle);

        var transpoint = new point(newx, newy);
        transpoint.x = width + transpoint.x;
        transpoint.y = height + transpoint.y;
        return transpoint;


    }

function getMarkupDrawRotPoint(markuprect){
    if (!documentopen) {
        return markuprect;

    }

    var centercanvX = (canvasowidth / 2);
    var centercanvY = (canvasoheight / 2);
    var CanvRotRad =  (90 - DocObj.pages[DocObj.currentpage].drotation) * (Math.PI / 180);


    if (DocObj.pages[DocObj.currentpage].drotation != 0) {
        var startpoint = getRotPoint(centercanvX, centercanvY, markuprect.x, markuprect.y, CanvRotRad);
        markuprect.x = startpoint.x;
        markuprect.y = startpoint.y;
        var endpoint = getRotPoint(centercanvX, centercanvY, markuprect.w, markuprect.h, CanvRotRad);
        markuprect.w = endpoint.x;
        markuprect.y = endpoint.y;

    }


    return markuprect;

}

function getPageRotCorner(cornerpoint){
    if (!documentopen) {
        return cornerpoint;
    }

    var centercanvX = (canvasowidth / 2);
    var centercanvY = (canvasoheight / 2);

    var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

    if (DocObj.pages[DocObj.currentpage].drotation != 0) {
        var rotmousepoint = getRotPoint(centercanvX, centercanvY, cornerpoint.x, cornerpoint.y, CanvRotRad);
        cornerpoint.x = rotmousepoint.x;
        cornerpoint.y = rotmousepoint.y;
    }

    return cornerpoint;
}

function getDocRotMousePoint(mousepoint){

        if (!documentopen) {
            return mousepoint;
        }

        var centercanvX = (canvasowidth / 2);
        var centercanvY = (canvasoheight / 2);

        var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

        switch(DocObj.pages[DocObj.currentpage].drotation){
            case 0:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                break;
            case 90:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation + 180) * (Math.PI / 180);
                break;
            case 270:
                CanvRotRad = (DocObj.pages[DocObj.currentpage].drotation - 180) * (Math.PI / 180);
                break;
            case 180:
                CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);
                break;
        }


        if (DocObj.pages[DocObj.currentpage].drotation != 0) {
            var rotmousepoint = getRotPoint(centercanvX, centercanvY, mousepoint.x, mousepoint.y, CanvRotRad);
            mousepoint.x = rotmousepoint.x;
            mousepoint.y = rotmousepoint.y;
        }

        return mousepoint;

    }


    function drawpoints(ctx, PDFpageRotate, snapPoint){
        if (DocObj.pages[DocObj.currentpage].drotation != 0) {
            var txcanv = (canvasowidth / 2);
            var tycanv = (canvasoheight / 2);
            ctx.translate(txcanv, tycanv);
            ctx.rotate(DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180));
            ctx.translate(-txcanv, -tycanv);

        }
        if(PDFpageRotate != 0){
            var txcanv = (canvasowidth / 2);
            var tycanv = (canvasoheight / 2);
            ctx.translate(txcanv, tycanv);
            ctx.rotate(PDFpageRotate * (Math.PI / 180));
            ctx.translate(-txcanv, -tycanv);
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = 'blue';
        //ctx.clearRect(snapPoint.x - 50,snapPoint.y - 50,100,100);
        ctx.strokeRect(snapPoint.x - 5, snapPoint.y - 5, 10, 10);


    }

    function drawsnap(ctx,snapPoint){
        ctx.save();
        if (DocObj.pages[DocObj.currentpage].drotation != 0) {
            var txcanv = (canvasowidth / 2);
            var tycanv = (canvasoheight / 2);
            ctx.translate(txcanv, tycanv);
            ctx.rotate(DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180));
            ctx.translate(-txcanv, -tycanv);

        }
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'blue';
        ctx.clearRect(snapPoint.x - 50,snapPoint.y - 50,100,100);

        if(snapPoint.type == 1){

            ctx.strokeRect(snapPoint.x - 5, snapPoint.y - 5, 10, 10);
        }
        if(snapPoint.type == 2){
            ctx.beginPath();

            ctx.moveTo(snapPoint.x - 5, snapPoint.y - 5);
            ctx.lineTo(snapPoint.x + 5, snapPoint.y + 5);

            ctx.moveTo(snapPoint.x + 5, snapPoint.y - 5);
            ctx.lineTo(snapPoint.x - 5, snapPoint.y + 5);

            ctx.stroke();
        }

        if(snapPoint.type == 3){
            ctx.beginPath();

            ctx.moveTo(snapPoint.x, snapPoint.y - 5);
            ctx.lineTo(snapPoint.x + 5, snapPoint.y + 5);

            ctx.lineTo(snapPoint.x - 5, snapPoint.y + 5);
            ctx.lineTo(snapPoint.x, snapPoint.y - 5);

            ctx.stroke();
        }


        ctx.restore();

    }


    function set_tool(toolname,params){


        //for (var i = 0; i < params.keys(obj).length; i++);
        if (tool){
            if(tool.name == 'pencil' && tool.started){
                tool.apply();

                unselelectallmarkup();
                unselecteditmarkupall();

            }

        }


        tool = new tools[toolname](params);

    }

    function ev_canvas(ev) {
        //var touch_event = document.getElementById('shape');
        if (ev.layerX || ev.layerY == 0) { // Firefox
            ev._x = ev.layerX;
            ev._y = ev.layerY;
        } else if (ev.offsetX || ev.offsetY == 0) { // Opera
            ev._x = ev.offsetX;
            ev._y = ev.offsetY;
        }

        //touch_event.value = ev.type;
        if (tool == undefined) {
            return;
        }
        // Call the event handler of the tool.
        var func = tool[ev.type];
        if (func) {
            func(ev);
        }
    }

    function webglAvailable() {
        try {
            var canvas = document.createElement('canvas');
            return !!(window.WebGLRenderingContext && (
                canvas.getContext('webgl') ||
                    canvas.getContext('experimental-webgl')));
        } catch (e) {
            return false;
        }
    }

    function instanceReset(){
        initialized = false;
        //defaultLayout.offsetWidth = 0;
        //defaultLayout.offsetHeight = 0;


    }
    // Keep everything in anonymous function, called on window load.
    function initialize (layout,divid,divclass) {

        if (initialized) return;
        initialized = true;


        defaultLayout = layout || defaultLayout;
        msieversion();

        //if (window.addEventListener) {
        $(document).ready(function () {
            //window.addEventListener('load', function () {

            // The active tool instance.
            //var tool;
            //var tool_default = 'pan';

            function init() {

                //find container and get size.
                if(divid != undefined){
                    rxcontainer = document.getElementById(divid);
                }else{
                    rxcontainer = document.getElementById('rxcontainer');
                }

                if (divclass != undefined){
                    rxcontainer.className = divclass;
                }else{
                    rxcontainer.className = 'rxcontainer';
                }

                //var col1 = document.getElementById('leftcol');
                //var colwidth = col1.clientWidth;
                //szcolwidth = szcolwidth.replace("px","");
                //var szcanvwidth = Containerdiv.style.width;
                //var szcanheight = Containerdiv.style.height;
                //szcanvwidth = szcanvwidth.replace("px","");
                //szcanheight = szcanheight.replace("px","");

                //Canvaswidth = szcanvwidth;
                //Canvasheight = szcanheight;

                if ((navigator.userAgent.match(/iPhone/i)) || (navigator.userAgent.match(/iPad/i)) || (navigator.userAgent.match(/Android/i))) {
                    bIsmobile = true;
                    nMaximageArea = nMaximageAreaIPad;
                }


                // Find the canvas element.
                canvaso = document.createElement('canvas');
                if(divid != undefined){
                    canvaso.id = divid + "rxcanvas";
                    canvaso.className = 'rxcanvas';
                }else{
                    canvaso.id = "rxcanvas";
                }


                //canvaso = document.getElementById('imageView');
                if (!canvaso) {
                    alert('Error: I cannot find the canvas element!');
                    return;
                }
                canvaso.innerHTML = "<p>Unfortunately, your browser is currently unsupported by our web \n";
                canvaso.innerHTML += "application.  We are sorry for the inconvenience. Please use one of the\n";
                canvaso.innerHTML += "supported browsers listed below, or draw the image you want using an\n";
                canvaso.innerHTML += "offline tool.</p>\n";

                canvaso.innerHTML += "<p>Supported browsers: <a href='http://www.opera.com'>Opera</a>,\n";
                canvaso.innerHTML += "<a href='http://www.mozilla.com'>Firefox</a>,\n";
                canvaso.innerHTML += "<a href='http://www.apple.com/safari'>Safari</a>, and\n";
                canvaso.innerHTML += "<a href='https://www.google.com/chrome'>Chrome</a>.</p>";

                // canvaso.style.border = "1px solid #000";

                resizeCanvas();


                /*if (Canvaswidth == "" && Canvasheight == ""){

                 }else{
                 canvasowidth  = Canvaswidth;
                 canvasoheight = Canvasheight-bannerheight;
                 }*/

                rxcontainer.appendChild(canvaso);

                if (!canvaso.getContext) {
                    alert('Error: no canvas.getContext!');
                    return;
                }

                canvaso.oncontextmenu = function () {
                    return false;
                };

                // Get the 2D canvas context.
                contexto = canvaso.getContext('2d');
                if (!contexto) {
                    alert('Error: failed to getContext!');
                    return;
                }

                setSmoothingEnabled(false);
                // contexto.imageSmoothingEnabled = false;
                // contexto.mozImageSmoothingEnabled = false;
                // //contexto.webkitImageSmoothingEnabled = false;
                // contexto.msImageSmoothingEnabled = false;


                // Add temporary draw and markup display canvas.
                var container = canvaso.parentNode;
                // Add markup display canvas.

                canvimg = document.createElement('canvas');
                if (!canvimg) {
                    alert('Error: I cannot create a new canvas element!');
                    return;
                }

                if(divid != undefined){
                    canvimg.id = divid + 'imageDisp';
                    canvimg.className = 'imageDisp';
                }else{
                    canvimg.id = 'imageDisp';
                }

                canvimg.width = canvaso.width;
                canvimg.height = canvaso.height;
                container.appendChild(canvimg);

                canvimg.oncontextmenu = function () {
                    return false;
                };


                cntximg = canvimg.getContext('2d');

                //sprite = document.getElementById("sprite");

                // Add the temporary draw canvas.
                canvas = document.createElement('canvas');
                if (!canvas) {
                    alert('Error: I cannot create a new canvas element!');
                    return;
                }

                if(divid != undefined){
                    canvas.id = divid + 'imageTemp';
                    canvas.className = 'imageTemp';
                }else{
                    canvas.id = 'imageTemp';
                }

                canvas.width = canvaso.width;
                canvas.height = canvaso.height;
                container.appendChild(canvas);

                canvas.oncontextmenu = function () {
                    return false;
                };

                context = canvas.getContext('2d');


                /*canvas3D = document.createElement('canvas');
                 if(!canvas3D){
                 alert('Error: I cannot create a new canvas element!');
                 return;
                 }
                 canvas3D.id  = 'canv3D';
                 canvas3D.width  = canvaso.width;
                 canvas3D.height = canvaso.height;
                 container.appendChild(canvas3D);*/


                /*if ( webglAvailable() ) {
                 renderer = new THREE.WebGLRenderer({alpha:true,canvas:canvas3D});
                 //alert('bruker webgl rendering');
                 } else {

                 renderer = new THREE.CanvasRenderer({alpha:true,canvas:canvas3D});
                 //alert('bruker canvas rendering');
                 }*/

                if (webglAvailable()) {
                    //renderer = new THREE.WebGLRenderer({alpha:true,antialias:true,precision:"highp"});
                    renderer = new THREE.WebGLRenderer({
                        alpha:true,
                        antialias:true,
                        precision:"highp",
                        preserveDrawingBuffer:true
                    });

                    renderer.clippingPlanes = Empty; // GUI sets it to globalPlanes
                    renderer.localClippingEnabled = false;


                    console.log('webgl enabled');
                    if(divid != undefined){
                        renderer.domElement.id = divid + 'canv3D';
                        renderer.domElement.className = 'canv3D';

                    }else{
                        renderer.domElement.id = 'canv3D';
                    }


                    //alert('bruker webgl rendering');
                } else {

                    renderer = new THREE.CanvasRenderer({
                        alpha:true
                    });
                    if(divid != undefined){
                        renderer.domElement.id = divid + 'canv3D';
                        renderer.domElement.className = 'canv3D';
                    }else{
                        renderer.domElement.id = 'canv3D';
                    }


                    console.log('using canvas 3D');
                    //alert('bruker canvas rendering');
                }


                container.appendChild(renderer.domElement);

                renderer.domElement.oncontextmenu = function () {
                    return false;
                };

                renderer.setSize(canvaso.width, canvaso.height);

                renderer.domElement.style.visibility = 'hidden';




                //magnify canvas
                magcanvas = document.createElement('canvas');
                if (!magcanvas) {
                    alert('Error: I cannot create a new canvas element!');
                    return;
                }

                if(divid != undefined){
                    magcanvas.id = divid + 'imagemag';
                    magcanvas.className = 'imagemag';
                }else{
                    magcanvas.id = 'imagemag';
                }



                //set magnifyer size
                magcanvas.width = magnifysize.width;
                magcanvas.height = magnifysize.height;

                container.appendChild(magcanvas);



                magcanvas.oncontextmenu = function () {
                    return false;
                };

                magctx = magcanvas.getContext('2d');

                magctx.fillStyle = "white";
                magctx.fillRect(0,0,magnifysize.width,magnifysize.height);

                magcanvas.style.visibility = 'hidden';

                get_splash(splashscreen, splashimage);


                function check() {
                    if (imageloaded) {
                        set_image();
                    } else {
                        window.setTimeout(check, 500);
                    }
                }

                check();

                function set_image() {
                    imagewidth = splashimage.width;
                    imageheight = splashimage.height;

                    imagewidth = splashimage.naturalWidth;
                    imageheight = splashimage.naturalHeight;


                    //calculate zoom to extent initial scaling and offset
                    //zoom to fit
                    var yscale = canvaso.height / imageheight;
                    var xscale = canvaso.width / imagewidth;
                    var dscale = Math.min(xscale, yscale);

                    var dx = (canvaso.width - (imagewidth * dscale)) / 2;
                    var dy = (canvaso.height - (imageheight * dscale)) / 2;

                    if (!documentopen) {
                        draw_image(splashimage, dx, dy, dscale);
                    }


                }

                //SetGUIConnection();


                // Attach the mousedown, mousemove and mouseup event listeners.


                canvas.addEventListener("touchstart", ev_canvas, false);
                renderer.domElement.addEventListener("touchstart", ev_canvas, false);

                canvas.addEventListener("touchmove", ev_canvas, true);
                renderer.domElement.addEventListener("touchmove", ev_canvas, true);

                canvas.addEventListener("touchend", ev_canvas, false);
                canvas.addEventListener("touchcancel", ev_canvas, false);
                renderer.domElement.addEventListener("touchend", ev_canvas, false);
                renderer.domElement.addEventListener("touchcancel", ev_canvas, false);
                canvas.addEventListener("dbltap", ev_canvas, false);
                canvas.addEventListener("dblclick", ev_canvas, false);

                window.addEventListener('keydown', ev_canvas, true);
                window.addEventListener('keyup', ev_canvas, true);
                window.addEventListener('keypress', ev_canvas, true);
                canvas.addEventListener('wheel', ev_canvas, true);
                canvas.addEventListener('mousewheel', ev_canvas, true);
                renderer.domElement.addEventListener('wheel', ev_canvas, true);
                renderer.domElement.addEventListener('mousewheel', ev_canvas, true);
                canvas.addEventListener('DOMMouseScroll', ev_canvas, true);
                renderer.domElement.addEventListener('DOMMouseScroll', ev_canvas, true);
                canvas.addEventListener("drop", ev_canvas, false);
                canvas.addEventListener("dragover", ev_canvas, false);



                if(bDisableMSIE11Eventcheck){

                    canvas.addEventListener('mousemove', ev_canvas, false);
                    renderer.domElement.addEventListener('mousemove', ev_canvas, false);
                    canvas.addEventListener('mousedown', ev_canvas, false);
                    renderer.domElement.addEventListener('mousedown', ev_canvas, false);
                    canvas.addEventListener('mouseup', ev_canvas, false);
                    renderer.domElement.addEventListener('mouseup', ev_canvas, false);
                    canvas.addEventListener('mouseout', ev_canvas, false);
                    renderer.domElement.addEventListener('mouseout', ev_canvas, false);


                }else{
                    if (window.navigator.msPointerEnabled) {
                        canvas.addEventListener('MSPointerMove', ev_canvas, false);
                        renderer.domElement.addEventListener('MSPointerMove', ev_canvas, false);
                        canvas.addEventListener('MSPointerDown', ev_canvas, false);
                        renderer.domElement.addEventListener('MSPointerDown', ev_canvas, false);
                        canvas.addEventListener('MSPointerUp', ev_canvas, false);
                        renderer.domElement.addEventListener('MSPointerUp', ev_canvas, false);

                        canvas.addEventListener('MSPointerOut', ev_canvas, false);
                        renderer.domElement.addEventListener('MSPointerOut', ev_canvas, false);


                    } else {
                        canvas.addEventListener('mousemove', ev_canvas, false);
                        renderer.domElement.addEventListener('mousemove', ev_canvas, false);
                        canvas.addEventListener('mousedown', ev_canvas, false);
                        renderer.domElement.addEventListener('mousedown', ev_canvas, false);
                        canvas.addEventListener('mouseup', ev_canvas, false);
                        renderer.domElement.addEventListener('mouseup', ev_canvas, false);
                        canvas.addEventListener('mouseout', ev_canvas, false);
                        renderer.domElement.addEventListener('mouseout', ev_canvas, false);


                    }
                }


                //canvas.addEventListener("touchcancel", ev_canvas, false);
                //document.body.addEventListener("touchcancel", touchUp, false);
                //draw_image();
                //createLayers();
                //GetLicense();
                if (bGetconfig) {
                    szLocationSearch = location.search;
                    //szLocationSearch = getLocationSearch();

                    if (szLocationSearch != "") {
                        locationSearchSet = true;
                    }
                    getConfiguration(configurationLocation);
                    //getConfigJSON(configurationLocation);
                } else {
                    //set stamp defaults
                    createLayers();
                    Stamplist = ["Approved", "Draft", "Received", "Rejected", "Reviewed", "Revised", "Date", "User Name"];
                    //var stampul = document.getElementById("stamp");
                    //var stampGUIobject = new Stampmenu(stampul);
                    if (RxCore_GUI_Stamps != undefined) {
                        RxCore_GUI_Stamps.setMarkupStamps(Stamplist);
                    }

                    /*if(stampul != undefined){
                     for(i=0;i<Stamplist.length;i++)
                     {

                     if (i==0){
                     stampGUIobject.addstamp(Stamplist[i],true);

                     }else{
                     stampGUIobject.addstamp(Stamplist[i],false);
                     }

                     }

                     }*/
                    //create default user
                    Userlist[0] = new Users(signature, DisplayName, markuplayer, markupcolor);
                    numUsers++;


                }

                if(!bIsmobile){
                    GetLicense();
                }


                console.log('rxcorejs ' + rxcoreversion);

            } //end init


            // The general-purpose event handler. This function just determines the mouse
            // position relative to the canvas element.
            /*function ev_canvas (ev) {
             //var touch_event = document.getElementById('shape');
             if (ev.layerX || ev.layerY == 0) { // Firefox
             ev._x = ev.layerX;
             ev._y = ev.layerY;
             } else if (ev.offsetX || ev.offsetY == 0) { // Opera
             ev._x = ev.offsetX;
             ev._y = ev.offsetY;
             }

             //touch_event.value = ev.type;
             if(tool == undefined){
             return;
             }
             // Call the event handler of the tool.
             var func = tool[ev.type];
             if (func) {
             func(ev);
             }
             }*/


            // This function draws the #imageTemp canvas on top of #imageView, after which
            // #imageTemp is cleared. This function is called each time when the user
            // completes a drawing operation.
            /*function zoom_update (sx,sy,sWide,sHi) {
             var factorwh = canvasoheight / canvasowidth;


             var tempx = 0.0;
             var tempy = 0.0;
             var tempxext = 0.0;
             var tempyext = 0.0;

             var ox1 = sx / dscale;
             var oy1 = sy / dscale;
             var ox2 = (sx + sWide) / dscale;
             var oy2 = (sy + sHi) / dscale;

             var ox1ext = sx / dscaleextent;
             var oy1ext = sy / dscaleextent;
             var ox2ext = (sx + sWide) / dscaleextent;
             var oy2ext = (sy + sHi) / dscaleextent;

             imagesize = 0;
             SetImageDim(myimage);

             var yscale = canvasoheight / imageheight;
             var xscale = canvasowidth / imagewidth;

             // var yscaleext = canvasoheight / imageheight;
             //var xscaleext = canvasowidth / imagewidth;


             tempx=(sx/dscale)-(dx/dscale);
             tempy=(sy/dscale)-(dy/dscale);

             tempxext = (sx/dscaleextent)-(dxextent/dscaleextent);
             tempyext = (sy/dscaleextent)-(dyextent/dscaleextent);


             if(Math.abs(oy2 - oy1) > 0 && Math.abs(ox2 - ox1) > 0 ){
             yscale = dscale * canvasoheight / sHi;
             xscale = dscale * canvasowidth / sWide;
             }

             dscale = Math.min(yscale, xscale);

             //SetImageDim(myimagesmall);
             //yscale = canvasoheight / imageheight;
             //xscale = canvasowidth / imagewidth;


             if(Math.abs(oy2ext - oy1ext) > 0 && Math.abs(ox2ext - ox1ext) > 0 ){
             yscale = dscaleextent * canvasoheight / sHi;
             xscale = dscaleextent * canvasowidth / sWide;
             }
             dscaleextent = Math.min(yscale, xscale);


             dx=-(tempx*dscale);
             dy=-(tempy*dscale);

             dxextent=-(tempxext*dscaleextent);
             dyextent=-(tempyext*dscaleextent);

             switch(imagesize){
             case 0:
             draw_image(myimage);
             break;
             case 1:
             draw_image(myimagesmall);
             break;
             }


             //draw_image(myimage);

             drawmarkupAll(cntximg);

             context.clearRect(0, 0, canvas.width, canvas.height);
             }*/


            /*function pan_update (sx,sy) {

             switch(drotation){
             case 0:
             dx = dx - sx;
             dy = dy - sy;
             dxextent = dxextent - sx;
             dyextent = dyextent - sy;

             break;
             case 90:
             dx = dx - sy;
             dy = dy + sx;
             dxextent = dxextent - sx;
             dyextent = dyextent + sy;
             break;
             case 180:
             dx = dx + sx;
             dy = dy + sy;
             dxextent = dxextent + sx;
             dyextent = dyextent + sy;
             break;
             case 270:
             dx = dx - sy;
             dy = dy - sx;
             dxextent = dxextent - sx;
             dyextent = dyextent - sy;
             break;

             }


             switch(imagesize){
             case 0:
             draw_image(myimage);
             break;
             case 1:
             draw_image(myimagesmall);
             break;
             }

             //draw_image(myimage);

             drawmarkupAll(cntximg);

             }*/
            /*tools.hide3d = function(){
             var tool = this;
             var x=0, y=0, w=0, h=0;
             var prevx=0, prevy=0;
             //Array for MSIE10 touchpoints
             var numtouchpoints = -1;
             var touchpointarr = [];
             this.name = 'hide3d';
             this.mousedown = function (ev) {

             ev.preventDefault();
             ev.stopPropagation();

             ev.target.style.cursor = 'crosshair';

             tool.started = true;
             var mousePos = getMousePos(canvaso, ev);

             if(documentopen){
             if(DocObj.pages[DocObj.currentpage].usevector3Dxml){
             //Viewer3D.mouseX = mousePos.x;
             //Viewer3D.mouseY = mousePos.y;

             var info = Viewer3D.pick(ev.clientX, ev.clientY);
             if (info.mesh != null){
             var meshid = info.mesh.name;
             //DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
             DocObj.pages[DocObj.currentpage].turn3DBlockOnOff(meshid);
             }

             }


             }


             };

             this.mouseup = function (ev) {
             ev.preventDefault();
             ev.stopPropagation();
             ev.target.style.cursor = 'default';
             if (tool.started) {
             tool.started = false;
             }
             };

             this.pointerdown = function(ev){
             tool.MSPointerDown(ev);
             };


             this.MSPointerDown = function(ev){
             ev.preventDefault();
             ev.stopPropagation();

             ev.target.style.cursor = 'crosshair';
             var mousePos = getMousePos(canvas, ev);
             tool.started = true;
             if(documentopen){
             if(DocObj.pages[DocObj.currentpage].usevector3Dxml){
             //Viewer3D.mouseX = mousePos.x;
             //Viewer3D.mouseY = mousePos.y;

             var info = Viewer3D.pick(ev.clientX, ev.clientY);
             if (info.mesh != null){
             var meshid = info.mesh.name;
             //DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
             DocObj.pages[DocObj.currentpage].turn3DBlockOnOff(meshid);
             }

             }


             }


             };

             this.MSPointerUp = function(ev){
             ev.target.style.cursor = 'default';
             if (tool.started) {

             tool.started = false;


             }

             };

             this.touchstart = function (ev) {
             ev.preventDefault();
             tool.started = true;
             //getTouchPos(canvas,ev,0);
             var touchPos = {
             x: ev.targetTouches[0].pageX,
             y: ev.targetTouches[0].pageY
             };




             if(documentopen){
             if(DocObj.pages[DocObj.currentpage].usevector3Dxml){
             //Viewer3D.mouseX = mousePos.x;
             //Viewer3D.mouseY = mousePos.y;

             var info = Viewer3D.pick(touchPos.x, touchPos.y);
             if (info.mesh != null){
             var meshid = info.mesh.name;
             //DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
             DocObj.pages[DocObj.currentpage].turn3DBlockOnOff(meshid);
             }

             }


             }

             };

             this.touchend = function (ev) {
             ev.preventDefault();
             if (tool.started) {

             tool.started = false;
             }
             };


             };*/

            tools.hide3d = function () {
                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                var prevx = 0,
                    prevy = 0;
                //Array for MSIE10 touchpoints
                var numtouchpoints = -1;
                var touchpointarr = [];
                this.name = 'hide3d';
                this.anglelengthsupport = false;

                var raycaster = new THREE.Raycaster();
                var mouse = new THREE.Vector2();
                var mvector = new THREE.Vector3();

                this.mousedown = function (ev) {

                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';

                    tool.started = true;
                    //var mousePos = getMousePos(canvaso, ev);
                    var mousePos = getMousePos(renderer.domElement, ev);

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

                            mouse.x = (mousePos.x / canvasowidth) * 2 - 1;
                            mouse.y = -(mousePos.y / canvasoheight) * 2 + 1;

                            // update the picking ray with the camera and mouse position

                            raycaster.setFromCamera(mouse, DocObj.pages[DocObj.currentpage].camera);

                            // calculate objects intersecting the picking ray
                            var intersects = raycaster.intersectObjects(DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children);

                            if (intersects.length > 0) {
                                for (var i = 0; i < intersects.length; i++) {
                                    if (intersects[i].object.visible) {
                                        var meshid = intersects[i].object.name;
                                        DocObj.pages[DocObj.currentpage].turn3DBlockOnOff(meshid);
                                        break;
                                    }
                                }

                            }


                        }


                    }


                };

                this.mouseup = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.started = false;
                    }
                };

                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };
                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.started = true;
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

                            mouse.x = (mousePos.x / canvasowidth) * 2 - 1;
                            mouse.y = -(mousePos.y / canvasoheight) * 2 + 1;

                            // update the picking ray with the camera and mouse position

                            raycaster.setFromCamera(mouse, DocObj.pages[DocObj.currentpage].camera);

                            // calculate objects intersecting the picking ray
                            var intersects = raycaster.intersectObjects(DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children);

                            if (intersects.length > 0) {
                                for (var i = 0; i < intersects.length; i++) {
                                    if (intersects[i].object.visible) {
                                        var meshid = intersects[i].object.name;
                                        DocObj.pages[DocObj.currentpage].turn3DBlockOnOff(meshid);
                                        break;
                                    }
                                }

                            }

                        }


                    }


                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.started = true;
                    var touchPos = getTouchPos(renderer.domElement, ev, 0);


                    /*var touchPos = {
                     x: ev.targetTouches[0].pageX,
                     y: ev.targetTouches[0].pageY
                     };*/


                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            //Viewer3D.mouseX = mousePos.x;
                            //Viewer3D.mouseY = mousePos.y;
                            mouse.x = (touchPos.x / canvasowidth) * 2 - 1;
                            mouse.y = -(touchPos.y / canvasoheight) * 2 + 1;

                            // update the picking ray with the camera and mouse position

                            raycaster.setFromCamera(mouse, DocObj.pages[DocObj.currentpage].camera);

                            // calculate objects intersecting the picking ray
                            var intersects = raycaster.intersectObjects(DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children);

                            if (intersects.length > 0) {
                                for (var i = 0; i < intersects.length; i++) {
                                    if (intersects[i].object.visible) {
                                        var meshid = intersects[i].object.name;
                                        DocObj.pages[DocObj.currentpage].turn3DBlockOnOff(meshid);
                                        break;
                                    }
                                }

                            }

                            /*var info = Viewer3D.pick(touchPos.x, touchPos.y);
                             if (info.mesh != null){
                             var meshid = info.mesh.name;
                             DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
                             }*/

                        }


                    }

                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {

                        tool.started = false;
                    }

                };
                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {

                        tool.started = false;
                    }
                };


            };


            tools.select3d = function () {
                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                var prevx = 0,
                    prevy = 0;

                var raycaster = new THREE.Raycaster();
                var mouse = new THREE.Vector2();
                var mvector = new THREE.Vector3();

                this.name = 'select3d';
                this.anglelengthsupport = false;

                //Array for MSIE10 touchpoints
                var numtouchpoints = -1;
                var touchpointarr = [];

                this.mousedown = function (ev) {

                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';

                    tool.started = true;
                    //var mousePos = getMousePos(canvaso, ev);
                    var mousePos = getMousePos(renderer.domElement, ev);

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

                            mouse.x = (mousePos.x / canvasowidth) * 2 - 1;
                            mouse.y = -(mousePos.y / canvasoheight) * 2 + 1;

                            // update the picking ray with the camera and mouse position

                            raycaster.setFromCamera(mouse, DocObj.pages[DocObj.currentpage].camera);

                            // calculate objects intersecting the picking ray
                            var intersects = raycaster.intersectObjects(DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children);

                            if (intersects.length > 0) {
                                for (var i = 0; i < intersects.length; i++) {
                                    var bPlaneX = (intersects[i].point.x > -DocObj.pages[DocObj.currentpage].Vector3DPageObj.globalPlaneX.constant);
                                    var bPlaneY = (intersects[i].point.y > -DocObj.pages[DocObj.currentpage].Vector3DPageObj.globalPlaneY.constant);
                                    var bPlaneZ = (intersects[i].point.z < DocObj.pages[DocObj.currentpage].Vector3DPageObj.globalPlaneZ.constant);

                                    if (intersects[i].object.visible && bPlaneX && bPlaneY && bPlaneZ) {
                                        var meshid = intersects[i].object.name;
                                        DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
                                        break;
                                    }
                                }


                            }

                            //intersects[0].object.material.color = new THREE.Color( 0xf781f3 );

                            /*for ( var intersect in intersects ) {

                             var meshid = intersects[intersect].object.name;
                             intersects[intersect].object.material.color = new THREE.Color( 0xf781f3 );

                             }*/


                            /*var info = Viewer3D.pick(ev.clientX, ev.clientY);
                             if (info.mesh != null){
                             var meshid = info.mesh.name;
                             DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
                             }*/

                        }


                    }


                };

                this.mouseup = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.started = false;
                    }
                };

                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.started = true;
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            //Viewer3D.mouseX = mousePos.x;
                            //Viewer3D.mouseY = mousePos.y;

                            mouse.x = (mousePos.x / canvasowidth) * 2 - 1;
                            mouse.y = -(mousePos.y / canvasoheight) * 2 + 1;

                            // update the picking ray with the camera and mouse position

                            raycaster.setFromCamera(mouse, DocObj.pages[DocObj.currentpage].camera);

                            // calculate objects intersecting the picking ray
                            var intersects = raycaster.intersectObjects(DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children);

                            if (intersects.length > 0) {
                                for (var i = 0; i < intersects.length; i++) {
                                    if (intersects[i].object.visible) {
                                        var meshid = intersects[i].object.name;
                                        DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
                                        break;
                                    }
                                }


                            }


                            /*var info = Viewer3D.pick(ev.clientX, ev.clientY);
                             if (info.mesh != null){
                             var meshid = info.mesh.name;
                             DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
                             }*/

                        }


                    }


                };

                this.MSPointerUp = function (ev) {
                    ev.target.style.cursor = 'default';
                    if (tool.started) {

                        tool.started = false;


                    }

                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.started = true;
                    var touchPos = getTouchPos(renderer.domElement, ev, 0);


                    /*var touchPos = {
                     x: ev.targetTouches[0].pageX,
                     y: ev.targetTouches[0].pageY
                     };*/


                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            //Viewer3D.mouseX = mousePos.x;
                            //Viewer3D.mouseY = mousePos.y;
                            mouse.x = (touchPos.x / canvasowidth) * 2 - 1;
                            mouse.y = -(touchPos.y / canvasoheight) * 2 + 1;

                            // update the picking ray with the camera and mouse position

                            raycaster.setFromCamera(mouse, DocObj.pages[DocObj.currentpage].camera);

                            // calculate objects intersecting the picking ray
                            var intersects = raycaster.intersectObjects(DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children);

                            if (intersects.length > 0) {
                                for (var i = 0; i < intersects.length; i++) {
                                    if (intersects[i].object.visible) {
                                        var meshid = intersects[i].object.name;
                                        DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
                                        break;
                                    }
                                }

                            }

                            /*var info = Viewer3D.pick(touchPos.x, touchPos.y);
                             if (info.mesh != null){
                             var meshid = info.mesh.name;
                             DocObj.pages[DocObj.currentpage].select3DBlock(meshid);
                             }*/

                        }


                    }

                };

                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {

                        tool.started = false;
                    }

                };
                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {

                        tool.started = false;
                    }
                };
            };

            tools.Walkthrough3D = function () {

                var scope = this;
                //DocObj.pages[DocObj.currentpage].walkthroughcontrol.

                //this.object = camera;
                //this.domElement = renderer.domElement;

                this.name = 'Walkthrough3D';
                this.anglelengthsupport = false;

                this.started = false;

                DocObj.pages[DocObj.currentpage].walkthroughcontrol.enabled = true;


                //var scope = this;
                var rotateStart = new THREE.Vector2();
                //controls.movementSpeed = 100;
                //controls.domElement = container;
                //controls.rollSpeed = Math.PI / 10;
                //controls.autoForward = false;
                //controls.dragToLook = true;


                //this.movementSpeed = 100.0;
                //this.rollSpeed = Math.PI / 10;

                //this.dragToLook = true;
                //this.autoForward = false;

                //this.tmpQuaternion = new THREE.Quaternion();

                //this.mouseStatus = 0;

                //this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
                //this.moveVector = new THREE.Vector3( 0, 0, 0 );
                //this.rotationVector = new THREE.Vector3( 0, 0, 0 );

                this.keydown = function (ev) {
                    //if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;

                    if (ev.altKey) {
                        return;
                    }

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            switch (ev.keyCode) {

                                //case 16: /* shift */ DocObj.pages[DocObj.currentpage].walkthroughcontrol.movementSpeedMultiplier = .1; break;
                                case 16:
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.mouseMove = true;
                                    break;

                                case 87:
                                    /*W*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = true;
                                    break;
                                case 83:
                                    /*S*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = true;
                                    break;

                                case 65:
                                    /*A*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = true;
                                    break;
                                case 68:
                                    /*D*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = true;
                                    break;

                                case 82:
                                    /*R*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = true;
                                    break;
                                case 70:
                                    /*F*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = true;
                                    break;

                                case 33:
                                    /*up*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = true;
                                    break;
                                case 34:
                                    /*down*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = true;

                                    break;


                                case 38:
                                    /*up*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = true;
                                    break;
                                case 40:
                                    /*down*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = true;
                                    break;
                                //case 38: /*up*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.pitchUp = 1; break;
                                //case 40: /*down*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.pitchDown = 1; break;

                                case 37:
                                    /*left*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = true;
                                    break;
                                case 39:
                                    /*right*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = true;

                                    break;

                                //case 37: /*left*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.yawLeft = 1; break;
                                //case 39: /*right*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.yawRight = 1; break;

                                case 81:
                                    /*Q*/
                                    //DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.rollLeft = 1;
                                    break;
                                case 69:
                                    /*E*/
                                    //DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.rollRight = 1;
                                    break;

                            }
                            //DocObj.pages[DocObj.currentpage].walkthroughcontrol.updateMovementVector();
                            //DocObj.pages[DocObj.currentpage].walkthroughcontrol.updateRotationVector();
                        }
                    }

                };
                this.keyup = function (ev) {
                    //if ( scope.enabled === false || scope.noKeys === true || scope.noPan === true ) return;

                    /*DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                     DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                     DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                     DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                     DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                     DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;*/

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            switch (ev.keyCode) {

                                //case 16: /* shift */ DocObj.pages[DocObj.currentpage].walkthroughcontrol.movementSpeedMultiplier = .1; break;
                                case 16:
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.mouseMove = false;
                                    break;


                                case 87:
                                    /*W*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                                    break;
                                case 83:
                                    /*S*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                                    break;

                                case 65:
                                    /*A*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                                    break;
                                case 68:
                                    /*D*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                                    break;

                                case 82:
                                    /*R*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                                    break;
                                case 70:
                                    /*F*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;
                                    break;

                                case 33:
                                    /*up*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                                    break;
                                case 34:
                                    /*down*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;
                                    break;

                                case 38:
                                    /*up*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                                    break;
                                case 40:
                                    /*down*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;

                                    break;
                                //case 38: /*up*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.pitchUp = 0; break;
                                //case 40: /*down*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.pitchDown = 0; break;

                                case 37:
                                    /*left*/

                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                                    break;
                                case 39:
                                    /*right*/
                                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;

                                    break;
                                //case 37: /*left*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.yawLeft = 0; break;
                                //case 39: /*right*/ DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.yawRight = 0; break;

                                case 81:
                                    /*Q*/
                                    //DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.rollLeft = 0;

                                    break;
                                case 69:
                                    /*E*/
                                    //DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveState.rollRight = 0;
                                    break;

                            }
                            //DocObj.pages[DocObj.currentpage].walkthroughcontrol.updateMovementVector();
                            //DocObj.pages[DocObj.currentpage].walkthroughcontrol.updateRotationVector();
                        }
                    }

                };


                this.mousedown = function (ev) {

                    /*if ( this.domElement !== document ) {

                     this.domElement.focus();

                     }*/

                    ev.preventDefault();
                    //ev.stopPropagation();
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            //var mousePos = getMousePos(renderer.domElement, ev);
                            //DocObj.pages[DocObj.currentpage].walkthroughcontrol.mouseStatus++;
                            //rotateStart.set(mousePos.x,mousePos.y);
                            //DocObj.pages[DocObj.currentpage].walkthroughcontrol.StartRotate(mousePos.x, mousePos.y);
                            if(scope.started){
                                DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseDown(ev.button);
                            }else{
                                DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseDown(ev.button);

                                scope.started = true;
                            }

                        }
                    }

                };

                this.mousemove = function (ev) {

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            var mousePos = getMousePos(renderer.domElement, ev);
                            //DocObj.pages[DocObj.currentpage].walkthroughcontrol.mousemove(mousePos.x, mousePos.y);
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseMove(mousePos.x, mousePos.y);

                        }
                    }
                };

                this.mouseup = function (ev) {

                    ev.preventDefault();
                    //ev.stopPropagation();

                    //if ( this.dragToLook ) {

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseUp(ev.button);

                        }
                    }



                    /*} else {

                     switch ( event.button ) {

                     case 0: this.moveState.forward = 0; break;
                     case 2: this.moveState.back = 0; break;

                     }

                     this.updateMovementVector();

                     }*/


                };
                this.mouseout = function (ev) {
                    ev.preventDefault();


                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;



                        }
                    }


                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            var mousePos = getTouchPos(renderer.domElement, ev, 0);
                            if(scope.started){
                                DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseDown(0);
                            }else{
                                DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseDown(0);
                                DocObj.pages[DocObj.currentpage].walkthroughcontrol.enabled = true;
                                scope.started = true;
                            }

                        }
                    }

                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            var mousePos = getTouchPos(renderer.domElement, ev, 0);

                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseMove(mousePos.x, mousePos.y);

                        }
                    }

                };

                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseUp(0);
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseMove(0, 0);

                        }
                    }

                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseUp(0);
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseMove(0, 0);

                        }
                    }


                };

                this.pointerdown = function (ev) {
                    scope.MSPointerDown(ev);
                };
                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    //ev.stopPropagation();
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            var mousePos = getMousePos(renderer.domElement, ev);
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseDown(ev.button);

                        }
                    }

                };

                this.pointermove = function (ev) {
                    scope.MSPointerMove(ev);
                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            var mousePos = getMousePos(renderer.domElement, ev);

                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseMove(mousePos.x, mousePos.y);

                        }
                    }

                };

                this.pointerup = function (ev) {
                    scope.MSPointerUp(ev);

                };
                this.MSPointerUp = function (ev) {
                    ev.preventDefault();
                    DocObj.pages[DocObj.currentpage].walkthroughcontrol.onMouseUp(ev.button);


                };
                this.pointerout = function (ev) {
                    scope.MSPointerOut(ev);
                };
                this.MSPointerOut = function (ev) {
                    ev.preventDefault();


                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveBackward = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveForward = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveLeft = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveRight = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveUp = false;
                            DocObj.pages[DocObj.currentpage].walkthroughcontrol.moveDown = false;


                        }
                    }

                };
            };

            tools.orbitControl = function () {
                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                var prevx = 0,
                    prevy = 0;
                //Array for MSIE10 touchpoints
                var numtouchpoints = -1;
                var touchpointarr = [];

                this.name = 'orbitControl';
                this.anglelengthsupport = false;

                this.object = DocObj.pages[DocObj.currentpage].camera;
                this.domElement = renderer.domElement;

                //this.domElement = ( domElement !== undefined ) ? domElement : document;

                // API

                // Set to false to disable this control
                this.enabled = true;

                // "target" sets the location of focus, where the control orbits around
                // and where it pans with respect to.
                this.target = new THREE.Vector3();

                // center is old, deprecated; use "target" instead
                this.center = this.target;

                this.noZoom = false;
                this.zoomSpeed = 0.5;

                // Limits to how far you can dolly in and out
                this.minDistance = 0;
                this.maxDistance = Infinity;

                // Set to true to disable this control
                this.noRotate = false;
                this.rotateSpeed = 1.0;

                // Set to true to disable this control
                this.noPan = false;
                this.keyPanSpeed = 7.0; // pixels moved per arrow key push

                // Set to true to automatically rotate around the target
                this.autoRotate = false;
                this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

                // How far you can orbit vertically, upper and lower limits.
                // Range is 0 to Math.PI radians.
                this.minPolarAngle = 0; // radians
                this.maxPolarAngle = Math.PI; // radians

                // Set to true to disable use of the keys
                this.noKeys = false;

                this.keys = {
                    LEFT:37,
                    UP:38,
                    RIGHT:39,
                    BOTTOM:40
                };

                ////////////
                // internals

                var scope = this;

                var EPS = 0.000001;

                var rotateStart = new THREE.Vector2();
                var rotateEnd = new THREE.Vector2();
                var rotateDelta = new THREE.Vector2();

                var panStart = new THREE.Vector2();
                var panEnd = new THREE.Vector2();
                var panDelta = new THREE.Vector2();
                var panOffset = new THREE.Vector3();

                var offset = new THREE.Vector3();

                var dollyStart = new THREE.Vector2();
                var dollyEnd = new THREE.Vector2();
                var dollyDelta = new THREE.Vector2();

                var phiDelta = 0;
                var thetaDelta = 0;
                var scale = 1;
                var pan = new THREE.Vector3();

                var lastPosition = new THREE.Vector3();
                var lastQuaternion = new THREE.Quaternion();

                var STATE = {
                    NONE:-1,
                    ROTATE:0,
                    DOLLY:1,
                    PAN:2,
                    TOUCH_ROTATE:3,
                    TOUCH_DOLLY:4,
                    TOUCH_PAN:5
                };

                var state = STATE.NONE;

                // for reset

                this.target0 = this.target.clone();
                this.position0 = this.object.position.clone();

                // so camera.up is the orbit axis


                var quat = new THREE.Quaternion().setFromUnitVectors(DocObj.pages[DocObj.currentpage].camera.up, new THREE.Vector3(0, 1, 0));
                var quatInverse = quat.clone().inverse();

                var changeEvent = {
                    type:'change'
                };
                var startEvent = {
                    type:'start'
                };
                var endEvent = {
                    type:'end'
                };


                this.rotateLeft = function (angle) {

                    if (angle === undefined) {

                        angle = getAutoRotationAngle();

                    }

                    thetaDelta -= angle;

                };

                this.rotateUp = function (angle) {

                    if (angle === undefined) {

                        angle = getAutoRotationAngle();

                    }

                    phiDelta -= angle;

                };

                // pass in distance in world space to move left
                this.panLeft = function (distance) {

                    var te = this.object.matrix.elements;

                    // get X column of matrix
                    panOffset.set(te[0], te[1], te[2]);
                    panOffset.multiplyScalar(-distance);

                    pan.add(panOffset);

                };

                // pass in distance in world space to move up
                this.panUp = function (distance) {

                    var te = this.object.matrix.elements;

                    // get Y column of matrix
                    panOffset.set(te[4], te[5], te[6]);
                    panOffset.multiplyScalar(distance);

                    pan.add(panOffset);

                };

                // pass in x,y of change desired in pixel space,
                // right and down are positive
                this.pan = function (deltaX, deltaY) {

                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                    if (scope.object.fov !== undefined) {

                        // perspective
                        var position = scope.object.position;
                        var offset = position.clone().sub(scope.target);
                        var targetDistance = offset.length();

                        // half of the fov is center to top of screen
                        targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);

                        // we actually don't use screenWidth, since perspective camera is fixed to screen height
                        scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
                        scope.panUp(2 * deltaY * targetDistance / element.clientHeight);

                    } else if (scope.object.top !== undefined) {

                        // orthographic
                        scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
                        scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);

                    } else {

                        // camera neither orthographic or perspective
                        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');

                    }

                };

                this.dollyIn = function (dollyScale) {

                    if (dollyScale === undefined) {

                        dollyScale = getZoomScale();

                    }

                    scale /= dollyScale;

                };

                this.dollyOut = function (dollyScale) {

                    if (dollyScale === undefined) {

                        dollyScale = getZoomScale();

                    }

                    scale *= dollyScale;

                };

                this.update = function () {


                    var position = this.object.position;

                    offset.copy(position).sub(this.target);
                    //offset.set(0,0,0);
                    //console.log( 'target:', [ this.target.x, this.target.y, this.target.z ] );
                    //console.log( 'offset:', [ offset.x, offset.y, offset.z ] );

                    // rotate offset to "y-axis-is-up" space
                    offset.applyQuaternion(quat);

                    // angle from z-axis around y-axis

                    var theta = Math.atan2(offset.x, offset.z);


                    // angle from y-axis

                    var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);


                    if (this.autoRotate) {

                        this.rotateLeft(getAutoRotationAngle());

                    }

                    theta += thetaDelta;
                    phi += phiDelta;

                    // restrict phi to be between desired limits
                    phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

                    // restrict phi to be betwee EPS and PI-EPS
                    phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

                    var radius = offset.length() * scale;

                    // restrict radius to be between desired limits
                    radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));
                    //console.log( 'radius:', radius );


                    // move target to panned location
                    this.target.add(pan);

                    offset.x = radius * Math.sin(phi) * Math.sin(theta);
                    offset.y = radius * Math.cos(phi);
                    offset.z = radius * Math.sin(phi) * Math.cos(theta);


                    // rotate offset back to "camera-up-vector-is-up" space
                    offset.applyQuaternion(quatInverse);

                    position.copy(this.target).add(offset);

                    //console.log( 'camera:', [ position.x, position.y, position.z ] );

                    this.object.lookAt(this.target);

                    //console.log( 'phi:', phi );
                    //console.log( 'theta:', theta );

                    //console.log( 'camera:', [ this.object.rotation.x, this.object.rotation.y, this.object.rotation.z ] );

                    thetaDelta = 0;
                    phiDelta = 0;
                    scale = 1;
                    pan.set(0, 0, 0);

                    // update condition is:
                    // min(camera displacement, camera rotation in radians)^2 > EPS
                    // using small-angle approximation cos(x/2) = 1 - x^2 / 8

                    if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {

                        //scope.dispatchEvent( changeEvent );

                        lastPosition.copy(this.object.position);
                        lastQuaternion.copy(this.object.quaternion);

                    }

                };

                this.reset = function () {

                    state = STATE.NONE;

                    this.target.copy(this.target0);
                    this.object.position.copy(this.position0);

                    this.update();

                };

                function getAutoRotationAngle() {

                    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

                }

                function getZoomScale() {

                    return Math.pow(0.95, scope.zoomSpeed);

                }


                this.mousedown = function (ev) {
                    if (scope.enabled === false) return;

                    ev.preventDefault();
                    ev.stopPropagation();

                    //ev.target.style.cursor = 'crosshair';

                    tool.started = true;
                    var mousePos = getMousePos(scope.domElement, ev);

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

                            if (ev.button === 0) {
                                if (scope.noRotate === true) return;

                                state = STATE.ROTATE;

                                rotateStart.set(mousePos.x, mousePos.y);

                            } else if (event.button === 1) {
                                if (scope.noZoom === true) return;

                                state = STATE.DOLLY;

                                dollyStart.set(mousePos.x, mousePos.y);

                            } else if (event.button === 2) {
                                if (scope.noPan === true) return;

                                state = STATE.PAN;

                                panStart.set(mousePos.x, mousePos.y);

                            }
                            //scope.dispatchEvent( startEvent );
                        }


                    }


                };

                this.mousemove = function (ev) {
                    if (scope.enabled === false) return;
                    ev.preventDefault();
                    var mousePos = getMousePos(scope.domElement, ev);
                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            if (state === STATE.ROTATE) {

                                if (scope.noRotate === true) return;

                                rotateEnd.set(mousePos.x, mousePos.y);
                                rotateDelta.subVectors(rotateEnd, rotateStart);

                                // rotating across whole screen goes 360 degrees around
                                scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

                                // rotating up and down along whole screen attempts to go 360, but limited to 180
                                scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

                                rotateStart.copy(rotateEnd);

                            } else if (state === STATE.DOLLY) {

                                if (scope.noZoom === true) return;

                                dollyEnd.set(mousePos.x, mousePos.y);
                                dollyDelta.subVectors(dollyEnd, dollyStart);

                                if (dollyDelta.y > 0) {

                                    scope.dollyIn();

                                } else {

                                    scope.dollyOut();

                                }

                                dollyStart.copy(dollyEnd);

                            } else if (state === STATE.PAN) {

                                if (scope.noPan === true) return;

                                panEnd.set(mousePos.x, mousePos.y);
                                panDelta.subVectors(panEnd, panStart);

                                scope.pan(panDelta.x, panDelta.y);

                                panStart.copy(panEnd);

                            }

                            scope.update();
                        }
                    }


                };

                this.mouseup = function (ev) {

                    if (scope.enabled === false) return;
                    ev.preventDefault();
                    ev.stopPropagation();
                    //ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.started = false;
                        state = STATE.NONE;

                    }
                    //scope.dispatchEvent( endEvent );
                };

                this.mousewheel = function(ev){
                    scope.onMouseWheel(ev);
                };

                this.wheel = function (ev) {
                    scope.onMouseWheel(ev)
                };


                this.DOMMouseScroll = function (ev) {
                    //scope.onMouseWheel(ev)
                };

                this.onMouseWheel = function (ev) {
                    if (scope.enabled === false || scope.noZoom === true) return;
                    ev.preventDefault();
                    ev.stopPropagation();


                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            var delta = 0;
                            if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                                delta = ev.wheelDelta;

                            } else if (ev.deltaY !== undefined) { // Firefox

                                delta = -ev.deltaY;

                            }

                            if (delta > 0) {

                                scope.dollyOut();

                            } else {

                                scope.dollyIn();

                            }

                            scope.update();


                        }
                    }
                };

                this.keydown = function (ev) {
                    if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) return;

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            switch (ev.keyCode) {

                                case scope.keys.UP:
                                    scope.pan(0, scope.keyPanSpeed);
                                    scope.update();
                                    break;

                                case scope.keys.BOTTOM:
                                    scope.pan(0, -scope.keyPanSpeed);
                                    scope.update();
                                    break;

                                case scope.keys.LEFT:
                                    scope.pan(scope.keyPanSpeed, 0);
                                    scope.update();
                                    break;

                                case scope.keys.RIGHT:
                                    scope.pan(-scope.keyPanSpeed, 0);
                                    scope.update();
                                    break;

                            }

                        }

                    }

                };


                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    //ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(scope.domElement, ev);


                    numtouchpoints++;
                    touchpointarr[numtouchpoints] = new TouchPoint(ev.pointerId, mousePos.x, mousePos.y);


                    tool.started = true;
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            switch (numtouchpoints) {
                                case 0: //one point only pan and markup labels
                                    if (ev.button === 0) {
                                        if (scope.noRotate === true) return;

                                        state = STATE.ROTATE;

                                        rotateStart.set(mousePos.x, mousePos.y);

                                    } else if (event.button === 1) {
                                        if (scope.noZoom === true) return;

                                        state = STATE.DOLLY;

                                        dollyStart.set(mousePos.x, mousePos.y);

                                    } else if (event.button === 2) {
                                        if (scope.noPan === true) return;

                                        state = STATE.PAN;

                                        panStart.set(mousePos.x, mousePos.y);

                                    }
                                    break;
                                case 1:
                                    if (scope.noZoom === true) return;
                                    state = STATE.TOUCH_DOLLY;

                                    var dx = Math.max(touchpointarr[0].x, touchpointarr[1].x) - Math.min(touchpointarr[0].x, touchpointarr[1].x);
                                    var dy = Math.max(touchpointarr[0].y, touchpointarr[1].y) - Math.min(touchpointarr[0].y, touchpointarr[1].y);

                                    var distance = Math.sqrt(dx * dx + dy * dy);
                                    dollyStart.set(0, distance);


                                    break;
                            }


                        }


                    }


                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };


                this.MSPointerMove = function (ev) {
                    if (!documentopen) {
                        return;
                    }


                    if (scope.enabled === false) return;
                    ev.preventDefault();
                    var mousePos = getMousePos(scope.domElement, ev);
                    var i = -1;
                    while (i < numtouchpoints) {
                        i++;
                        if (touchpointarr[i].pointID == ev.pointerId) {
                            touchpointarr[i].x = mousePos.x;
                            touchpointarr[i].y = mousePos.y;
                        }

                    }

                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            switch (numtouchpoints) {
                                case 0:
                                    if (state === STATE.ROTATE) {

                                        if (scope.noRotate === true) return;

                                        rotateEnd.set(mousePos.x, mousePos.y);
                                        rotateDelta.subVectors(rotateEnd, rotateStart);

                                        // rotating across whole screen goes 360 degrees around
                                        scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

                                        // rotating up and down along whole screen attempts to go 360, but limited to 180
                                        scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

                                        rotateStart.copy(rotateEnd);

                                    } else if (state === STATE.DOLLY) {

                                        if (scope.noZoom === true) return;

                                        dollyEnd.set(mousePos.x, mousePos.y);
                                        dollyDelta.subVectors(dollyEnd, dollyStart);

                                        if (dollyDelta.y > 0) {

                                            scope.dollyIn();

                                        } else {

                                            scope.dollyOut();

                                        }

                                        dollyStart.copy(dollyEnd);

                                    } else if (state === STATE.PAN) {

                                        if (scope.noPan === true) return;

                                        panEnd.set(mousePos.x, mousePos.y);
                                        panDelta.subVectors(panEnd, panStart);

                                        scope.pan(panDelta.x, panDelta.y);

                                        panStart.copy(panEnd);

                                    }

                                    scope.update();

                                    break;
                                case 1:
                                    if (scope.noZoom === true) return;
                                    if (state !== STATE.TOUCH_DOLLY) return;

                                    var dx = Math.max(touchpointarr[0].x, touchpointarr[1].x) - Math.min(touchpointarr[0].x, touchpointarr[1].x);
                                    var dy = Math.max(touchpointarr[0].y, touchpointarr[1].y) - Math.min(touchpointarr[0].y, touchpointarr[1].y);


                                    var distance = Math.sqrt(dx * dx + dy * dy);

                                    dollyEnd.set(0, distance);
                                    dollyDelta.subVectors(dollyEnd, dollyStart);

                                    if (dollyDelta.y > 0) {

                                        scope.dollyOut();

                                    } else if (dollyDelta.y < 0) {

                                        scope.dollyIn();

                                    }

                                    dollyStart.copy(dollyEnd);

                                    scope.update();

                                    break;
                                case 2:
                                    if (scope.noPan === true) return;
                                    if (state !== STATE.TOUCH_PAN) return;

                                    panEnd.set(touchpointarr[0].x, touchpointarr[0].y);
                                    panDelta.subVectors(panEnd, panStart);

                                    scope.pan(panDelta.x, panDelta.y);

                                    panStart.copy(panEnd);

                                    scope.update();

                                    break;
                                default:

                                    state = STATE.NONE;

                            }
                        }
                    }


                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);

                };


                this.MSPointerUp = function (ev) {
                    numtouchpoints--;

                    ev.preventDefault();
                    ev.target.style.cursor = 'default';
                    if (scope.enabled === false) return;
                    state = STATE.NONE;

                    if (tool.started) {
                        tool.started = false;
                    }


                };

                this.touchstart = function (ev) {
                    if (scope.enabled === false) return;
                    ev.preventDefault();
                    tool.started = true;
                    //getTouchPos(canvas,ev,0);
                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                            var touchPos = getTouchPos(renderer.domElement, ev, 0);


                            /*var touchPos = {
                             x: ev.targetTouches[0].pageX,
                             y: ev.targetTouches[0].pageY
                             };*/


                            switch (ev.touches.length) {
                                case 1: // one-fingered touch: rotate

                                    if (scope.noRotate === true) return;

                                    state = STATE.TOUCH_ROTATE;

                                    rotateStart.set(touchPos.x, touchPos.y);
                                    break;
                                case 2: // two-fingered touch: dolly

                                    if (scope.noZoom === true) return;

                                    var touchPos2 = getTouchPos(renderer.domElement, ev, 1);
                                    /*var touchPos2 = {
                                     x: ev.targetTouches[1].pageX,
                                     y: ev.targetTouches[1].pageY
                                     };*/

                                    state = STATE.TOUCH_DOLLY;

                                    //var dx = touchPos.x - touchPos2.x;
                                    //var dy = touchPos.y - touchPos2.y;

                                    var dx = Math.max(touchPos.x, touchPos2.x) - Math.min(touchPos.x, touchPos2.x);
                                    var dy = Math.max(touchPos.y, touchPos2.y) - Math.min(touchPos.y, touchPos2.y);


                                    var distance = Math.sqrt(dx * dx + dy * dy);
                                    dollyStart.set(0, distance);
                                    break;

                                case 3: // three-fingered touch: pan

                                    if (scope.noPan === true) return;

                                    state = STATE.TOUCH_PAN;

                                    panStart.set(touchPos.x, touchPos.y);
                                    break;

                                default:

                                    state = STATE.NONE;

                            }

                        }


                    }

                };

                this.touchmove = function (ev) {
                    if (scope.enabled === false) return;

                    ev.preventDefault();
                    ev.stopPropagation();
                    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

                    if (documentopen) {
                        if (DocObj.pages[DocObj.currentpage].usevector3Dxml) {

                            var touchPos = getTouchPos(renderer.domElement, ev, 0);
                            /*var touchPos = {
                             x: ev.targetTouches[0].pageX,
                             y: ev.targetTouches[0].pageY
                             };*/


                            switch (event.touches.length) {

                                case 1: // one-fingered touch: rotate

                                    if (scope.noRotate === true) return;
                                    if (state !== STATE.TOUCH_ROTATE) return;

                                    rotateEnd.set(touchPos.x, touchPos.y);
                                    rotateDelta.subVectors(rotateEnd, rotateStart);

                                    // rotating across whole screen goes 360 degrees around
                                    scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
                                    // rotating up and down along whole screen attempts to go 360, but limited to 180
                                    scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

                                    rotateStart.copy(rotateEnd);

                                    scope.update();
                                    break;

                                case 2: // two-fingered touch: dolly

                                    var touchPos2 = getTouchPos(renderer.domElement, ev, 1);

                                    /*var touchPos2 = {
                                     x: ev.targetTouches[1].pageX,
                                     y: ev.targetTouches[1].pageY
                                     };*/

                                    if (scope.noZoom === true) return;
                                    if (state !== STATE.TOUCH_DOLLY) return;

                                    //var dx = touchPos.x - touchPos2.x;
                                    //var dy = touchPos.y - touchPos2.y;
                                    var dx = Math.max(touchPos.x, touchPos2.x) - Math.min(touchPos.x, touchPos2.x);
                                    var dy = Math.max(touchPos.y, touchPos2.y) - Math.min(touchPos.y, touchPos2.y);


                                    var distance = Math.sqrt(dx * dx + dy * dy);

                                    dollyEnd.set(0, distance);
                                    dollyDelta.subVectors(dollyEnd, dollyStart);

                                    if (dollyDelta.y > 0) {

                                        scope.dollyOut();

                                    } else if (dollyDelta.y < 0) {

                                        scope.dollyIn();

                                    }

                                    dollyStart.copy(dollyEnd);

                                    scope.update();
                                    break;

                                case 3: // three-fingered touch: pan

                                    if (scope.noPan === true) return;
                                    if (state !== STATE.TOUCH_PAN) return;

                                    panEnd.set(touchPos.x, touchPos.y);
                                    panDelta.subVectors(panEnd, panStart);

                                    scope.pan(panDelta.x, panDelta.y);

                                    panStart.copy(panEnd);

                                    scope.update();
                                    break;

                                default:

                                    state = STATE.NONE;

                            }


                        }
                    }
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();

                    if (scope.enabled === false) return;
                    //scope.dispatchEvent( endEvent );
                    state = STATE.NONE;
                    if (tool.started) {
                        tool.started = false;
                    }

                };
                this.touchend = function (ev) {
                    ev.preventDefault();

                    if (scope.enabled === false) return;
                    //scope.dispatchEvent( endEvent );
                    state = STATE.NONE;
                    if (tool.started) {
                        tool.started = false;
                    }
                };


            };

            tools.magnify = function () {
                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                var prevx = 0,
                    prevy = 0;
                var xcur1 = 0,
                    xcur2 = 0,
                    ycur1 = 0,
                    ycur2 = 0;
                var startx = 0,
                    starty = 0,
                    startx2 = 0,
                    starty2 = 0,
                    startw = 0,
                    starth = 0;
                var startcenterx = 0,
                    startcentery = 0;
                var centerx = 0,
                    centery = 0;
                var prevcenterx = 0,
                    prevcentery = 0;
                var prevh = 0,
                    prevw = 0;
                var startdiagonal = 0;
                var prevdiagonal = 0;
                var initdiagonal = 0;
                this.name = 'magnify';
                this.anglelengthsupport = false;

                this.started = false;

                var magnificationScale = 1.5;
                var magnifyingGlassRadius = 100;
                /*var ImageGlassRadius = 100 / DocObj.pages[DocObj.currentpage].dscaleextent;

                if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                    ImageGlassRadius = 100 / DocObj.pages[DocObj.currentpage].dscalevector;
                }*/
                if (DocObj.pages[DocObj.currentpage].usedincomposite && DocObj.pages[DocObj.currentpage].compositereference != undefined) {
                    //DocObj.pages[DocObj.currentpage].compositereference.drawmagnify(mousepos,ctx,magnificationScale);
                    DocObj.pages[DocObj.currentpage].compositereference.checkPDFmagnify(magnificationScale);
                }else{
                    if (DocObj.pages[DocObj.currentpage].usepdfjs){
                        DocObj.pages[DocObj.currentpage].renderPDFMagnify(magnificationScale);
                    }

                }


                var imageData = null;
                var mrkimageData = null;
                var scrimageData = null;
                var magimage = 1;

                this.drawMagnify = function(mousepos){
                    if (DocObj.pages[DocObj.currentpage].usedincomposite && DocObj.pages[DocObj.currentpage].compositereference != undefined) {
                        DocObj.pages[DocObj.currentpage].compositereference.drawmagnify(mousepos,magctx,magnificationScale);
                    }else{
                        DocObj.pages[DocObj.currentpage].drawmagnify(mousepos,magctx,magnificationScale);
                    }


                };


                this.wheel = function (ev) {
                    if (!tool.started) {
                        return;
                    }
                    if (documentopen) {
                        var delta = 0;
                        if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                            delta = ev.wheelDelta;

                        } else if (ev.deltaY !== undefined) { // Firefox
                            if(bIsMSIE ){
                                delta = -ev.deltaY;
                            }else{
                                delta = -ev.deltaY*50;
                            }
                        }
                        var movey = delta;
                        if (movey < 0) {
                            if (magnificationScale > 1.5) {
                                magnificationScale -= 0.2;
                            }

                        } else {
                            if (magnificationScale < 10) {
                                magnificationScale += 0.2;
                            }
                        }
                        if (magnificationScale < 2.5) {
                            magimage = 1;
                        } else {
                            magimage = 0;
                        }

                        var mousePos = getMousePos(canvas, ev);
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                        if (DocObj.pages[DocObj.currentpage].usedincomposite && DocObj.pages[DocObj.currentpage].compositereference != undefined) {
                            //DocObj.pages[DocObj.currentpage].compositereference.drawmagnify(mousepos,ctx,magnificationScale);
                            DocObj.pages[DocObj.currentpage].compositereference.checkPDFmagnify(magnificationScale);
                        }else{
                            if (DocObj.pages[DocObj.currentpage].usepdfjs){
                                DocObj.pages[DocObj.currentpage].renderPDFMagnify(magnificationScale);
                            }

                        }
                        tool.drawMagnify({x:tool.x0,y:tool.y0},magctx,magnificationScale);

                    }
                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };

                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };

                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.started = true;
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;
                    magcanvas.style.top = mousePos.y - (magcanvas.height / 2) + "px";
                    magcanvas.style.left = mousePos.x - (magcanvas.width / 2) + "px";
                    magcanvas.style.visibility = 'visible';
                };

                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    tool.started = true;
                    var mousePos = getMousePos(canvas, ev);
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;

                    magcanvas.style.top = mousePos.y - (magcanvas.height / 2) + "px";
                    magcanvas.style.left = mousePos.x - (magcanvas.width / 2) + "px";
                    magcanvas.style.visibility = 'visible';
                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.started = true;
                    //var touchPos = getTouchPos(canvas,ev,0);
                    var touchPos0 = getTouchPos(canvas, ev, 0);
                    if(ev.targetTouches.length > 1){
                        var touchPos1 = getTouchPos(canvas, ev, 1);
                    }else{
                        touchPos1 = getTouchPos(canvas, ev, 0);
                    }

                    startx = touchPos0.x;
                    starty = touchPos0.y;
                    startx2 = touchPos1.x;
                    starty2 = touchPos1.y;

                    startw = Math.abs(startx2 - startx);
                    starth = Math.abs(starty2 - starty);

                    var startwsq = Math.pow(startw, 2);
                    var starthsq = Math.pow(starth, 2);

                    startdiagonal = Math.sqrt((startwsq + starthsq));
                    prevdiagonal = startdiagonal;
                    initdiagonal = startdiagonal;

                    startcenterx = startx + (startw / 2);
                    startcentery = starty + (starth / 2);
                    prevcenterx = startcenterx;
                    prevcentery = startcentery;

                    var canvcenterx = touchPos0.x + (magcanvas.width / 2);
                    var canvcentery = touchPos0.y - (magcanvas.height / 2);
                    //magcanvas.style.top = startcentery - (magcanvas.height / 2) + "px";
                    //magcanvas.style.left = startcenterx - (magcanvas.width / 2) + "px";
                    magcanvas.style.top = touchPos0.y - magcanvas.height + "px";
                    magcanvas.style.left = touchPos0.x + "px";
                    magcanvas.style.visibility = 'visible';

                    tool.drawMagnify({x:canvcenterx,y: canvcentery});
                };

                this.MSPointerMove = function (ev) {
                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    magcanvas.style.top = mousePos.y - (magcanvas.height / 2) + "px";
                    magcanvas.style.left = mousePos.x - (magcanvas.width / 2) + "px";

                    tool.drawMagnify(mousePos);
                    prevx = mousePos.x;
                    prevy = mousePos.y;

                };

                this.mousemove = function (ev) {
                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    magcanvas.style.top = mousePos.y - (magcanvas.height / 2) + "px";
                    magcanvas.style.left = mousePos.x - (magcanvas.width / 2) + "px";

                    tool.drawMagnify(mousePos);

                    prevx = mousePos.x;
                    prevy = mousePos.y;

                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    //var touchPos = getTouchPos(canvas,ev,0);
                    var touchPos0 = getTouchPos(canvas, ev, 0);
                    if(ev.targetTouches.length > 1){
                        var touchPos1 = getTouchPos(canvas, ev, 1);
                    }else{
                        touchPos1 = getTouchPos(canvas, ev, 0);
                    }

                    xcur1 = touchPos0.x;
                    ycur1 = touchPos0.y;
                    xcur2 = touchPos1.x;
                    ycur2 = touchPos1.y;

                    x = Math.min(xcur1, xcur2);
                    y = Math.min(ycur1, ycur2);
                    w = Math.abs(xcur2 - xcur1);
                    h = Math.abs(ycur2 - ycur1);


                    centerx = x + (w / 2);
                    centery = y + (h / 2);

                    var canvcenterx = touchPos0.x + (magcanvas.width / 2);
                    var canvcentery = touchPos0.y - (magcanvas.height / 2);

                    //magcanvas.style.top = centery - (magcanvas.height / 2) + "px";
                    //magcanvas.style.left = centerx - (magcanvas.width / 2) + "px";
                    magcanvas.style.top = touchPos0.y - magcanvas.height + "px";
                    magcanvas.style.left = touchPos0.x + "px";

                    tool.drawMagnify({x:canvcenterx,y: canvcentery});

                    var startwsq = Math.pow(w, 2);
                    var starthsq = Math.pow(h, 2);

                    startdiagonal = Math.sqrt((startwsq + starthsq));

                    var diffwidth = prevdiagonal - startdiagonal;

                    if (initdiagonal >= startdiagonal){
                        magnificationScale = 1.5;
                    }else{
                        if (diffwidth > 0 ) {
                            if (magnificationScale > 1.5) {
                                magnificationScale -= 0.2;
                            }

                        } else {
                            if (magnificationScale < 10) {
                                magnificationScale += 0.2;
                            }
                        }

                    }

                    prevdiagonal = startdiagonal;

                    prevcenterx = centerx;
                    prevcentery = centery;
                    prevw = w;
                    prevh = h;
                    //prevx = touchPos.x;
                    //prevy = touchPos.y;

                };

                this.MSPointerUp = function (ev) {
                    ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;
                        //tool.eraseMagnifyingGlass();
                        magcanvas.style.visibility = 'hidden';
                        imageData = null;
                        scrimageData = null;
                        mrkimageData = null;

                        DocObj.pages[DocObj.currentpage].magnifyoff();

                        drawmarkupAll(cntximg);
                    }

                };
                this.mouseup = function (ev) {
                    ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;
                        //tool.eraseMagnifyingGlass();
                        magcanvas.style.visibility = 'hidden';
                        imageData = null;
                        scrimageData = null;
                        mrkimageData = null;

                        DocObj.pages[DocObj.currentpage].magnifyoff();

                        drawmarkupAll(cntximg);

                    }
                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    /*if(ev.targetTouches.length > 1){
                     var touchPos1 = getTouchPos(canvas, ev, 1);
                     }else{
                     touchPos1 = getTouchPos(canvas, ev, 0);
                     }*/

                    if (tool.started && ev.targetTouches.length < 1) {
                        //tool.touchmove(ev);
                        tool.started = false;
                        //tool.eraseMagnifyingGlass();
                        magcanvas.style.visibility = 'hidden';
                        imageData = null;
                        scrimageData = null;
                        mrkimageData = null;

                        DocObj.pages[DocObj.currentpage].magnifyoff();

                        drawmarkupAll(cntximg);

                    }
                };
                this.touchend = function (ev) {
                    ev.preventDefault();
                    /*if(ev.targetTouches.length > 1){
                     var touchPos1 = getTouchPos(canvas, ev, 1);
                     }else{
                     touchPos1 = getTouchPos(canvas, ev, 0);
                     }*/

                    if (tool.started && ev.targetTouches.length < 1) {
                        //tool.touchmove(ev);
                        tool.started = false;
                        //tool.eraseMagnifyingGlass();
                        magcanvas.style.visibility = 'hidden';
                        imageData = null;
                        scrimageData = null;
                        mrkimageData = null;

                        DocObj.pages[DocObj.currentpage].magnifyoff();

                        drawmarkupAll(cntximg);

                    }
                };

            };



            //the note tool
            tools.note = function () {
                var tool = this;
                var prevx = 0,
                    prevy = 0;
                this.started = false;
                this.name = 'note';
                this.anglelengthsupport = false;

                //ft 08.08.2018 changed from separate index to direct array length
                //var curmarkup = DocObj.nummarkups;
                var curmarkup = DocObj.markuplist.length;
                var notemarkupobj;

                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };


                this.MSPointerDown = function (ev) {
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }


                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        return;
                    }

                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;

                    notemarkupobj = new MarkupObject(10, 0, 0);
                    notemarkupobj.pagenumber = DocObj.getcurPage();
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        notemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        notemarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        notemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    notemarkupobj.x = tool.x0;
                    notemarkupobj.y = tool.y0;
                    notemarkupobj.editaction = 0;

                    notemarkupobj.drawme(context);
                    notemarkupobj.savemetolistDraw();
                    //TempID = notemarkupobj.markupnumber;
                    //ft 08.08.2018 changed from markupnumber to array length
                    //DocObj.selectedmarkup.id = notemarkupobj.markupnumber;
                    DocObj.selectedmarkup.id = DocObj.markuplist.length - 1;

                    if (!bMultimarkupadd) {
                        bMarkupcrated = true;
                        //ft 08.08.2018 changed from separate index to direct array length
                        nMarkupcreated = DocObj.markuplist.length - 1;
                        //nMarkupcreated = notemarkupobj.markupnumber;
                    }

                    img_update();
                    tool.started = false;
                    notemarkupobj = null;
                    //setNContent(DocObj.markuplist[TempID].text);
                    //showNDialog(false);
                    if (RxCore_GUI_Notediag != undefined) {
                        RxCore_GUI_Notediag.setNotediag(DocObj.markuplist[nMarkupcreated].text, true);
                    }
                    if (!bMultimarkupadd) {
                        if (RxCore_GUI_Markup != undefined) {
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                            var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], operation);
                        }

                    }

                };
                this.mousedown = function (ev) {

                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }

                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }
                        return;
                    }

                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;

                    notemarkupobj = new MarkupObject(10, 0, 0);
                    notemarkupobj.pagenumber = DocObj.getcurPage();
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        notemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        notemarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        notemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }
                    notemarkupobj.x = tool.x0;
                    notemarkupobj.y = tool.y0;
                    notemarkupobj.editaction = 0;

                    notemarkupobj.drawme(context);
                    notemarkupobj.savemetolistDraw();

                    //ft 08.08.2018 changed from markupnumber to array length
                    //DocObj.selectedmarkup.id = notemarkupobj.markupnumber;
                    DocObj.selectedmarkup.id = DocObj.markuplist.length - 1;
                    //nMarkupcreated = notemarkupobj.markupnumber;
                    nMarkupcreated = DocObj.markuplist.length - 1;
                    if (!bMultimarkupadd) {
                        bMarkupcrated = true;
                        //ft 08.08.2018 changed from separate index to direct array length
                        nMarkupcreated = DocObj.markuplist.length - 1;
                        //nMarkupcreated = notemarkupobj.markupnumber;
                    }

                    img_update();
                    tool.started = false;
                    notemarkupobj = null;
                    if (RxCore_GUI_Notediag != undefined) {
                        RxCore_GUI_Notediag.setNotediag(DocObj.markuplist[nMarkupcreated].text, true);
                    }
                    if (!bMultimarkupadd) {
                        if (RxCore_GUI_Markup != undefined) {
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                            var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], operation);
                        }

                    }
                    //setNContent(DocObj.markuplist[TempID].text);
                    //showNDialog(false);


                };

                this.touchstart = function (ev) {
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }

                    var touchPos = getTouchPos(canvas, ev, 0);

                    var bWithin = MousePosdrwext(touchPos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        return;
                    }

                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;
                    notemarkupobj = new MarkupObject(10, 0, 0);
                    notemarkupobj.pagenumber = DocObj.getcurPage();
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        notemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        notemarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        notemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        notemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        notemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    notemarkupobj.x = tool.x0;
                    notemarkupobj.y = tool.y0;
                    notemarkupobj.editaction = 0;

                    notemarkupobj.drawme(context);
                    notemarkupobj.savemetolistDraw();

                    //ft 08.08.2018 changed from markupnumber to array length
                    //DocObj.selectedmarkup.id = notemarkupobj.markupnumber;
                    DocObj.selectedmarkup.id = DocObj.markuplist.length - 1;


                    if (!bMultimarkupadd) {

                        bMarkupcrated = true;
                        //ft 08.08.2018 changed from separate index to direct array length
                        nMarkupcreated = DocObj.markuplist.length - 1;
                        //nMarkupcreated = notemarkupobj.markupnumber;
                    }

                    img_update();
                    tool.started = false;
                    notemarkupobj = null;
                    //setNContent(DocObj.markuplist[TempID].text);
                    //showNDialog(false);

                    if (RxCore_GUI_Notediag != undefined) {
                        RxCore_GUI_Notediag.setNotediag(DocObj.markuplist[nMarkupcreated].text, true);
                    }

                    if (!bMultimarkupadd) {
                        if (RxCore_GUI_Markup != undefined) {
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                            var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], operation);
                        }

                    }

                };

                this.mouseup = function (ev) {

                };

                this.touchend = function (ev) {

                };

            };

            // the text tool
            tools.text = function () {
                var tool = this;
                var blinker;
                this.name = 'text';
                this.anglelengthsupport = false;

                this.started = false;
                //ft 08.08.2018 changed from separate index to direct array length
                //var curmarkup = DocObj.nummarkups;
                var curmarkup = DocObj.markuplist.length;
                var textmarkupobj;

                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'text';

                    //Draw blinking "cursor" centered on coordinates.
                    tool.started = true;

                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }

                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }
                        ev.target.style.cursor = 'default';
                        return;
                    }

                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    textmarkupobj = new MarkupObject(9, 0, 0);
                    textmarkupobj.pagenumber = DocObj.getcurPage();
                    textmarkupobj.font.setFontname(defaultFont.fontName);
                    //textmarkupobj.fontname = fontstylevalue;
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        textmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    textmarkupobj.x = tool.x0;
                    textmarkupobj.y = tool.y0;
                    textmarkupobj.editaction = 0;
                    var markuptext = "";
                    textmarkupobj.text = markuptext;

                    textmarkupobj.savemetolistDraw();
                    DocObj.selectedmarkup.id = textmarkupobj.markupnumber;
                    //img_update();
                    tool.started = false;
                    textmarkupobj = null;
                    if (RxCore_GUI_Textdiag != undefined) {
                        RxCore_GUI_Textdiag.setTextdiag("");
                    }

                    //setTextContent(DocObj.markuplist[TempID].text);
                    //showTextDialog(false);


                    /*markuptext = prompt("Enter markup text","");
                     if (markuptext != null && markuptext != ""){
                     textmarkupobj.text = markuptext;
                     textmarkupobj.drawme(context);
                     textmarkupobj.savemetolist();
                     img_update();
                     tool.started = false;
                     textmarkupobj = null;
                     }*/

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'text';

                    /*context.beginPath();
                     context.moveTo(ev._x, ev._y);
                     context.strokeStyle = "red";*/
                    //Draw blinking "cursor" centered on coordinates.
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }

                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;
                    }

                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    textmarkupobj = new MarkupObject(9, 0, 0);
                    textmarkupobj.pagenumber = DocObj.getcurPage();
                    textmarkupobj.font.setFontname(defaultFont.fontName);
                    //textmarkupobj.fontname = fontstylevalue;
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        textmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    textmarkupobj.x = tool.x0;
                    textmarkupobj.y = tool.y0;
                    textmarkupobj.editaction = 0;

                    var markuptext = "";

                    textmarkupobj.savemetolistDraw();
                    DocObj.selectedmarkup.id = textmarkupobj.markupnumber;
                    //img_update();
                    tool.started = false;
                    textmarkupobj = null;
                    if (RxCore_GUI_Textdiag != undefined) {
                        RxCore_GUI_Textdiag.setTextdiag("");
                    }

                    //markuptext = prompt("Enter markup text","");

                    /*if (markuptext != null && markuptext != ""){
                     textmarkupobj.text = markuptext;
                     textmarkupobj.drawme(context);
                     textmarkupobj.savemetolist();
                     img_update();
                     tool.started = false;
                     textmarkupobj = null;
                     }*/

                };

                this.touchstart = function (ev) {
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }

                    var touchPos = getTouchPos(canvas, ev, 0);

                    var bWithin = MousePosdrwext(touchPos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        return;
                    }

                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;
                    textmarkupobj = new MarkupObject(9, 0, 0);
                    textmarkupobj.pagenumber = DocObj.getcurPage();
                    textmarkupobj.font.setFontname(defaultFont.fontName);
                    //textmarkupobj.fontname = fontstylevalue;
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        textmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        textmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        textmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        textmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    textmarkupobj.x = tool.x0;
                    textmarkupobj.y = tool.y0;
                    textmarkupobj.editaction = 0;

                    var markuptext = "";

                    textmarkupobj.savemetolistDraw();
                    DocObj.selectedmarkup.id = textmarkupobj.markupnumber;
                    //img_update();
                    tool.started = false;
                    textmarkupobj = null;
                    if (RxCore_GUI_Textdiag != undefined) {
                        RxCore_GUI_Textdiag.setTextdiag("");
                    }


                    /*var markuptext = prompt("Enter markup text","");
                     if (markuptext != null && markuptext != ""){
                     textmarkupobj.text = markuptext;
                     textmarkupobj.drawme(context);
                     textmarkupobj.savemetolist();
                     img_update();
                     tool.started = false;
                     textmarkupobj = null;
                     }*/


                };



                // This is called when you release the mouse button.
                this.mouseup = function (ev) {
                    if (tool.started) {

                    }
                };

                this.touchend = function (ev) {

                };

            };

            // The drawing pencil.
            tools.pencil = function (params) {
                var tool = this;
                this.started = false;
                this.name = 'pencil';
                this.anglelengthsupport = false;

                this.draw = false;
                //ft 08.08.2018 changed from separate index to direct array length
                //var curmarkup = DocObj.nummarkups;
                var curmarkup = DocObj.markuplist.length;
                var pencilmarkupobj;
                var numlines = 0;
                var subtype = params.p1



                this.newpencil = function(subtype,mousePos){

                    pencilmarkupobj = new MarkupObject(0, subtype, 0);
                    pencilmarkupobj.pagenumber = DocObj.getcurPage();
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        pencilmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    pencilmarkupobj.x = mousePos.x;
                    pencilmarkupobj.y = mousePos.y;
                    pencilmarkupobj.editaction = 0;

                };

                // This is called when you start holding down the mouse button.
                // This starts the pencil drawing.

                this.mousedown = function (ev) {

                    var mousePos = getMousePos(canvas, ev);
                    tool.draw = true;

                    if (numlines == 0){
                        tool.newpencil(subtype,mousePos);
                        tool.started = true;
                        pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        pencilmarkupobj.startdraw(context);


                    }else{
                        pencilmarkupobj.addline();
                        tool.started = true;
                        pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        pencilmarkupobj.startdraw(context);

                    }
                    numlines++;


                    // if (subtype == 1) {
                    //     pencilmarkupobj.linewidth = 2;
                    // }

                    /*pencilmarkupobj.pagenumber = DocObj.currentpage;
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        pencilmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }*/

                    //var mousePos = getMousePos(canvas, ev);
                    /*pencilmarkupobj.x = mousePos.x;
                    pencilmarkupobj.y = mousePos.y;
                    pencilmarkupobj.editaction = 0;

                    pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                    tool.started = true;
                    DocObj.bMarkupchanged = true;
                    pencilmarkupobj.startdraw(context);*/
                    //context.beginPath();
                    //context.moveTo(pencilmarkupobj.x, pencilmarkupobj.y);


                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.MSPointerDown = function (ev) {

                    var mousePos = getMousePos(canvas, ev);
                    tool.draw = true;
                    if (numlines == 0){
                        tool.newpencil(subtype,mousePos);
                        tool.started = true;
                        pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        pencilmarkupobj.startdraw(context);


                    }else{
                        pencilmarkupobj.addline();
                        tool.started = true;
                        pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        pencilmarkupobj.startdraw(context);

                    }
                    numlines++;
                    //pencilmarkupobj = new MarkupObject(0, subtype, 0);
                    // if (subtype == 1) {
                    //       pencilmarkupobj.linewidth = 2;
                    //   }

                    /*pencilmarkupobj.pagenumber = DocObj.currentpage;
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        pencilmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }*/

                   /* var mousePos = getMousePos(canvas, ev);
                    pencilmarkupobj.x = mousePos.x;
                    pencilmarkupobj.y = mousePos.y;
                    pencilmarkupobj.editaction = 0;
                    pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                    tool.started = true;
                    DocObj.bMarkupchanged = true;
                    pencilmarkupobj.startdraw(context);*/

                };

                // This function is called every time you move the mouse. Obviously, it only
                // draws if the tool.started state is set to true (when you are holding down
                // the mouse button).
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if (tool.started && tool.draw) {
                        pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                        pencilmarkupobj.drawme(context);
                        //context.lineTo(ev._x, ev._y);
                        //context.stroke();
                    }
                };
                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if (tool.started && tool.draw) {
                        pencilmarkupobj.addpoint(mousePos.x, mousePos.y);
                        pencilmarkupobj.drawme(context);
                    }

                };
                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };

                this.MSPointerUp = function (ev) {
                    ev.preventDefault();
                    tool.draw = false;
                    /*if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;
                        pencilmarkupobj.findrectangle();
                        pencilmarkupobj.savemetolist();
                        pencilmarkupobj = null;

                        img_update();
                    }*/

                };

                // This is called when you release the mouse button.
                this.mouseup = function (ev) {
                    ev.preventDefault();
                    tool.draw = false;
                    /*if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;
                        pencilmarkupobj.findrectangle();
                        pencilmarkupobj.savemetolist();
                        pencilmarkupobj = null;

                        img_update();
                    }*/
                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.draw = true;
                    var touchPos = getTouchPos(canvas, ev, 0);
                    if (numlines == 0){
                        tool.newpencil(subtype,touchPos);
                        tool.started = true;
                        pencilmarkupobj.addpoint(touchPos.x, touchPos.y);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        pencilmarkupobj.startdraw(context);


                    }else{
                        pencilmarkupobj.addline();
                        tool.started = true;
                        pencilmarkupobj.addpoint(touchPos.x, touchPos.y);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        pencilmarkupobj.startdraw(context);

                    }
                    numlines++;


                    /*if (numlines == 0){
                        pencilmarkupobj = new MarkupObject(0, subtype, 0);
                        pencilmarkupobj.pagenumber = DocObj.currentpage;
                        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                            pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                            pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                            pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                            pencilmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                            pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                            pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                        } else {
                            pencilmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                            pencilmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                            pencilmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                        }

                        pencilmarkupobj.x = touchPos.x;
                        pencilmarkupobj.y = touchPos.y;
                        pencilmarkupobj.editaction = 0;
                    }else{
                        pencilmarkupobj.addline();
                    }
                    numlines++;*/

                    //pencilmarkupobj = new MarkupObject(0, subtype, 0);
                    // if (subtype == 1) {
                    //            pencilmarkupobj.linewidth = 2;
                    //        }

                    /*pencilmarkupobj.addpoint(touchPos.x, touchPos.y);
                    tool.started = true;
                    DocObj.bMarkupchanged = true;
                    pencilmarkupobj.startdraw(context);*/

                    //context.strokeStyle = "red";
                    //context.beginPath();
                    //context.moveTo(ev.targetTouches[0].pageX - canvas.offsetLeft, ev.targetTouches[0].pageY - canvas.offsetTop - bannerheight);
                    //tool.started = true;

                };
                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (tool.started && tool.draw) {
                        var touchPos = getTouchPos(canvas, ev, 0);
                        pencilmarkupobj.addpoint(touchPos.x, touchPos.y);
                        pencilmarkupobj.drawme(context);

                        //context.lineTo(, );
                        //context.stroke();
                    }
                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    tool.draw = false;
                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    tool.draw = false;
                    /*if (tool.started) {
                        //add new function to add current pointarray to existing
                        //pencilmakrupobject.

                        pencilmarkupobj.findrectangle();
                        pencilmarkupobj.savemetolist();
                        img_update();
                        //alert("touchend");
                        //tool.touchmove(ev);
                        tool.started = false;

                        pencilmarkupobj = null;
                    }*/
                };

                this.apply = function () {
                    tool.draw = false;
                    if (!bMultimarkupadd) {
                        bMarkupcrated = true;
                        //ft 08.08.2018 changed from separate index to direct array length
                        //nMarkupcreated = DocObj.nummarkups;
                        nMarkupcreated = DocObj.markuplist.length;
                    }

                    pencilmarkupobj.addline();
                    pencilmarkupobj.findrectangle();
                    pencilmarkupobj.savemetolistDraw();
                    img_update();
                    tool.started = false;
                    pencilmarkupobj = null;

                    if (!bMultimarkupadd) {
                        //need to move to connection object.
                        //markupcreated();
                        if (RxCore_GUI_Markup != undefined) {
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                            var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], operation);
                        }

                    }


                };

            };


            // The rectangle tool.
            tools.rect = function (params) {

                var tool = this;
                var prevx = 0,
                    prevy = 0;
                var rectmarkupobj;
                //var drawrectangle = new markuprectangle();
                //ft 08.08.2018 changed from separate index to direct array length
                //var curmarkup = DocObj.nummarkups;
                var curmarkup = DocObj.markuplist.length;
                var havesnap = false;
                var snapPoint;
                this.name = 'rect';
                this.anglelengthsupport = true;
                this.bUsemouseinput = true;

                this.started = false;
                var type = params.p1;
                var subtype = params.p2;
                var redact = params.redact;


                this.setWidthHeight = function(width, height){
                    tool.bUsemouseinput = false;
                    if (rectmarkupobj != undefined){
                        rectmarkupobj.x = tool.x0;
                        rectmarkupobj.y = tool.y0;
                        var curx2 = rectmarkupobj.w;
                        var cury2 = rectmarkupobj.h;

                        var secondpoint = rectmarkupobj.setWidthHeight(width, height);
                        var abspoint = {x : rectmarkupobj.x + secondpoint.w, y:rectmarkupobj.y + secondpoint.h};

                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (MousePosdrwext(abspoint)){
                            rectmarkupobj.w = secondpoint.w;
                            rectmarkupobj.h = secondpoint.h;

                            rectmarkupobj.drawme(context);

                        }else{
                            rectmarkupobj.w = curx2;
                            rectmarkupobj.h = cury2;

                            tool.bUsemouseinput = true;
                            rectmarkupobj.drawme(context);
                            rectmarkupobj.bUsemouseinput = true;
                            if (RxCore_GUI_markupParamsError != undefined){
                                RxCore_GUI_markupParamsError.onDrawError('outside');
                            }

                        }


                    }

                };

                this.apply = function(){
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    rectmarkupobj.drawme(context);
                    tool.endRect();
                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.startRect = function (mousePos) {
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }



                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        tool.x0 = rotatedpoint.x;
                        tool.y0 = rotatedpoint.y;
                    } else {
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                    }


                    rectmarkupobj = new MarkupObject(type, subtype, fillstyle);
                    rectmarkupobj.bRedact = redact;

                    if (subtype == 3){

                        rectmarkupobj.transparency = 30;
                        rectmarkupobj.fillcolor = setTransp(rectmarkupobj.fillcolor,rectmarkupobj.transparency);
                    }

                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        rectmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        rectmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        rectmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        rectmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        rectmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        rectmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        rectmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        rectmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        rectmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    rectmarkupobj.pagenumber = DocObj.getcurPage();
                    rectmarkupobj.editaction = 0;


                };

                this.drawRect = function (mousePos) {
                    if (!tool.bUsemouseinput){
                        return;
                    }

                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        rectmarkupobj.x = Math.min(rotatedpoint.x, tool.x0);
                        rectmarkupobj.y = Math.min(rotatedpoint.y, tool.y0);

                        rectmarkupobj.w = Math.abs(rotatedpoint.x - tool.x0);
                        rectmarkupobj.h = Math.abs(rotatedpoint.y - tool.y0);


                        prevx = rotatedpoint.x;
                        prevy = rotatedpoint.y;


                    } else {
                        rectmarkupobj.x = Math.min(mousePos.x, tool.x0);
                        rectmarkupobj.y = Math.min(mousePos.y, tool.y0);
                        rectmarkupobj.w = Math.abs(mousePos.x - tool.x0);
                        rectmarkupobj.h = Math.abs(mousePos.y - tool.y0);

                        prevx = mousePos.x;
                        prevy = mousePos.y;


                    }
                };

                this.endRect = function () {
                    /*if(rectmarkupobj.w==0 || rectmarkupobj.h==0){
                     return;
                     }*/
                    tool.started = false;

                    if (!bMultimarkupadd) {

                        bMarkupcrated = true;
                        //ft 08.08.2018 changed from separate index to direct array length
                        nMarkupcreated = DocObj.markuplist.length;
                        //nMarkupcreated = DocObj.nummarkups;
                    }

                    rectmarkupobj.savemetolistDraw();
                    rectmarkupobj = null;


                    //tool.started = false;
                    //markuplist.add(drawrectangle);
                    img_update();
                    drawmarkupAll(cntximg);

                    if (!bMultimarkupadd) {
                        //need to move to connection object.
                        //markupcreated();
                        if (RxCore_GUI_Markup != undefined) {
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                            var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], operation);
                        }

                    }


                };

                this.setSnap = function (mousePos) {
                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if(snapPoint == undefined){
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }

                    if (snapPoint.found ) {
                        havesnap = true;
                        drawsnap(context,snapPoint);
                        //context.lineWidth = 1;
                        //context.strokeStyle = 'blue';
                        //context.strokeRect(snapPoint.x - 5, snapPoint.y - 5, 10, 10);
                    } else {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }

                };

                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';

                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }

                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);

                    //mousePos = getDocRotMousePoint(mousePos);

                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;

                    }
                    tool.startRect(mousePos);

                };

                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';

                    if (!tool.started) {
                        tool.started = true;

                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        var mousePos = getMousePos(canvas, ev);
                        var bWithin = MousePosdrwext(mousePos);
                        //mousePos = getDocRotMousePoint(mousePos);

                        if (!bWithin && bLimMarkupExtent) {
                            tool.started = false;
                            if(DocObj){
                                DocObj.bMarkupchanged = false;
                            }
                            ev.target.style.cursor = 'default';
                            return;
                        }
                        //tool.mousemove(ev);
                        tool.startRect(mousePos);

                    }else{
                        tool.mousemove(ev);
                        tool.endRect();

                        tool.started = false;

                    }

                };

                this.touchstart = function (ev) {

                    ev.preventDefault();
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }



                    var touchPos = getTouchPos(canvas, ev, 0);

                    var bWithin = MousePosdrwext(touchPos);
                    //touchPos = getDocRotMousePoint(touchPos);

                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        return;
                    }


                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;


                    rectmarkupobj = new MarkupObject(type, subtype,  fillstyle);
                    rectmarkupobj.bRedact = redact;

                    if (subtype == 3){
                        rectmarkupobj.transparency = 30;
                        rectmarkupobj.fillcolor = setTransp(rectmarkupobj.fillcolor,rectmarkupobj.transparency);
                    }

                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        rectmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        rectmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        rectmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        rectmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        rectmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        rectmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        rectmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        rectmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        rectmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    rectmarkupobj.pagenumber = DocObj.getcurPage();
                    rectmarkupobj.editaction = 0;

                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    tool.setSnap(mousePos);



                    if (!tool.started) {
                        return;
                    }
                    var bWithin = MousePosdrwext(mousePos);
                    //mousePos = getDocRotMousePoint(mousePos);

                    if (bWithin || !bLimMarkupExtent) {
                        tool.drawRect(mousePos);


                    } else {
                        if (tool.bUsemouseinput){

                            rectmarkupobj.x = Math.min(prevx, tool.x0);
                            rectmarkupobj.y = Math.min(prevy, tool.y0);
                            rectmarkupobj.w = Math.abs(prevx - tool.x0);
                            rectmarkupobj.h = Math.abs(prevy - tool.y0);
                        }


                    }
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (havesnap) {
                        drawsnap(context,snapPoint);
                    }

                    if (!rectmarkupobj.w || !rectmarkupobj.h) {
                        return;
                    }
                    rectmarkupobj.drawme(context);

                };

                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    tool.setSnap(mousePos);

                    if (!tool.started) {
                        return;
                    }

                    var bWithin = MousePosdrwext(mousePos);
                    //mousePos = getDocRotMousePoint(mousePos);

                    if (bWithin || !bLimMarkupExtent) {
                        tool.drawRect(mousePos);


                    } else {

                        if (tool.bUsemouseinput){

                            rectmarkupobj.x = Math.min(prevx, tool.x0);
                            rectmarkupobj.y = Math.min(prevy, tool.y0);
                            rectmarkupobj.w = Math.abs(prevx - tool.x0);
                            rectmarkupobj.h = Math.abs(prevy - tool.y0);

                            ev.target.style.cursor = 'default';
                        }



                    }
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (havesnap) {
                        drawsnap(context,snapPoint);
                    }

                    rectmarkupobj.drawme(context);

                    if (!rectmarkupobj.w || !rectmarkupobj.h) {
                        return;
                    }

                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    //touchPos = getDocRotMousePoint(touchPos);
                    if (bWithin || !bLimMarkupExtent) {
                        var x = Math.min(touchPos.x, tool.x0),
                            y = Math.min(touchPos.y, tool.y0),
                            w = Math.abs(touchPos.x - tool.x0),
                            h = Math.abs(touchPos.y - tool.y0);

                        prevx = touchPos.x;
                        prevy = touchPos.y;

                    } else {
                        x = Math.min(prevx, tool.x0);
                        y = Math.min(prevy, tool.y0);
                        w = Math.abs(prevx - tool.x0);
                        h = Math.abs(prevy - tool.y0);

                    }
                    if (tool.bUsemouseinput){
                        rectmarkupobj.x = x;
                        rectmarkupobj.y = y;
                        rectmarkupobj.w = w;
                        rectmarkupobj.h = h;
                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);

                    if (!w || !h) {
                        return;
                    }
                    rectmarkupobj.drawme(context);

                };

                this.MSPointerUp = function (ev) {
                    ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.mousemove(ev);
                        tool.endRect();

                        tool.started = false;


                    }

                };
                this.mouseup = function (ev) {
                    ev.target.style.cursor = 'default';
                    /*if (tool.started) {

                        tool.mousemove(ev);
                        tool.endRect();

                        tool.started = false;


                    }*/
                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {

                        tool.endRect();
                        tool.started = false;

                    }

                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {

                        tool.endRect();
                        tool.started = false;

                    }
                };

            };

            // The symbol tool.
            tools.symbol = function(){
                var tool = this;
                var canvasLeft = canvas.offsetLeft;
                var canvasTop = canvas.offsetTop;
                var startOffsetX = 0;
                var startOffsetY = 0;
                var imagemarkupobj;
                //ft 08.08.2018 changed from separate index to direct array length
                //var curmarkup = DocObj.nummarkups;
                var curmarkup = DocObj.markuplist.length;

                this.name = 'symbol';
                this.anglelengthsupport = false;

                this.started = false;

                //rxcontainer.ondrop = tool.drop;
                //rxcontainer.ondragover = tool.dragover;




                this.dragover = function(ev){
                    ev.preventDefault();
                };

                this.drop = function(ev){
                    ev.preventDefault();

                    var mousePos = getMousePos(canvas, ev);
                    //var dropX = ev.clientX;// - startOffsetX;
                    //var dropY = ev.clientY;// - startOffsetY;

                    imagemarkupobj = new MarkupObject(11, 1, 0);
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        imagemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        imagemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        imagemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        imagemarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        imagemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        imagemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        imagemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        imagemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        imagemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }
                    imagemarkupobj.pagenumber = DocObj.getcurPage();
                    imagemarkupobj.editaction = 0;
                    var bWithin = MousePosdrwext(mousePos);

                    if (bWithin || !bLimMarkupExtent) {
                        var dropdata = JSON.parse(ev.dataTransfer.getData("Text"));
                        imagemarkupobj.x = mousePos.x - (dropdata.width/2);
                        imagemarkupobj.y = mousePos.y - (dropdata.height/2);
                        imagemarkupobj.w = dropdata.width;
                        imagemarkupobj.h = dropdata.height;
                        //var dropdata = ev.dataTransfer.getData("Text");

                        var createimage = new Image();
                        //createimage.src = ev.dataTransfer.getData("Text");
                        createimage.src = dropdata.src;
                        imagemarkupobj.image = createimage;
                        imagemarkupobj.imageloaded = true;
                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (!bMultimarkupadd) {
                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            //nMarkupcreated = DocObj.nummarkups;
                            nMarkupcreated = DocObj.markuplist.length;
                        }

                        imagemarkupobj.savemetolistDraw();

                    }

                    img_update();
                    imagemarkupobj = null;
                    if (!bMultimarkupadd && bWithin) {
                        //need to move to connection object.
                        //markupcreated();
                        if (RxCore_GUI_Markup != undefined) {
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                            var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], operation);
                        }

                    }


                };

                this.mousedown = function (ev) {
                    //var mousePos = getMousePos(canvas, ev);
                    //startOffsetX = mousePos.x;
                    //startOffsetY = mousePos.y;

                };


            };

            //Stamp rectangle tool
            tools.rectText = function (){
                var tool = this;

                this.x = 0;
                this.y = 0;
                this.w = 0;
                this.h = 0;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                this.name = 'rectText';
                this.anglelengthsupport = false;

                this.started = false;
                var zoomcolor = "rgba(175, 175, 175, 0.3)";
                context.lineWidth = 2;
                context.strokeStyle = zoomcolor;
                context.fillStyle = zoomcolor;

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;

                    }


                    if (ev.button != 2) {
                        tool.started = true;
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                    }

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;

                    }

                    if (ev.button != 2) {
                        tool.started = true;
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                    }
                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.started = true;
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;

                    }


                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;

                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);

                    var bWithin = MousePosdrwext(mousePos);
                    if (bWithin || !bLimMarkupExtent) {
                        x = Math.min(mousePos.x, tool.x0);
                        y = Math.min(mousePos.y, tool.y0);
                        w = Math.abs(mousePos.x - tool.x0);
                        h = Math.abs(mousePos.y - tool.y0);

                    } else {
                        x = Math.min(x, tool.x0);
                        y = Math.min(y, tool.y0);
                        w = Math.abs(x - tool.x0);
                        h = Math.abs(y - tool.y0);
                    }
                    /*x = Math.min(mousePos.x, tool.x0);
                    y = Math.min(mousePos.y, tool.y0);
                    w = Math.abs(mousePos.x - tool.x0);
                    h = Math.abs(mousePos.y - tool.y0);*/

                    if (!w || !h) {
                        return;
                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);

                };
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (bWithin || !bLimMarkupExtent) {
                        x = Math.min(mousePos.x, tool.x0);
                        y = Math.min(mousePos.y, tool.y0);
                        w = Math.abs(mousePos.x - tool.x0);
                        h = Math.abs(mousePos.y - tool.y0);

                    } else {
                        x = Math.min(x, tool.x0);
                        y = Math.min(y, tool.y0);
                        w = Math.abs(x - tool.x0);
                        h = Math.abs(y - tool.y0);
                    }


                   /* x = Math.min(mousePos.x, tool.x0);
                    y = Math.min(mousePos.y, tool.y0);
                    w = Math.abs(mousePos.x - tool.x0);
                    h = Math.abs(mousePos.y - tool.y0);*/

                    if (!w || !h) {
                        return;
                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);
                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    if (bWithin || !bLimMarkupExtent) {
                        x = Math.min(touchPos.x, tool.x0);
                        y = Math.min(touchPos.y, tool.y0);
                        w = Math.abs(touchPos.x - tool.x0);
                        h = Math.abs(touchPos.y - tool.y0);

                    } else {
                        x = Math.min(x, tool.x0);
                        y = Math.min(y, tool.y0);
                        w = Math.abs(x - tool.x0);
                        h = Math.abs(y - tool.y0);
                    }



                    /*x = Math.min(touchPos.x, tool.x0);
                    y = Math.min(touchPos.y, tool.y0);
                    w = Math.abs(touchPos.x - tool.x0);
                    h = Math.abs(touchPos.y - tool.y0);*/


                    if (!w || !h) {
                        return;
                    }

                    context.clearRect(0, 0, canvas.width, canvas.height);

                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);

                };

                this.MSPointerUp = function (ev) {
                    ev.preventDefault();

                    ev.target.style.cursor = 'default';

                    if (ev.button != 2) {
                        if (tool.started) {
                            //tool.mousemove(ev);
                            tool.started = false;
                            if (!w || !h) {
                                return;
                            }
                            //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                            textRect(x, y, w, h, null);
                            tool.x = x;
                            tool.y = y;
                            tool.w = w;
                            tool.h = h;

                            context.clearRect(0, 0, canvas.width, canvas.height);
                        }

                    }

                };
                this.mouseup = function (ev) {
                    ev.preventDefault();

                    ev.target.style.cursor = 'default';

                    if (ev.button != 2) {
                        if (tool.started) {
                            //tool.mousemove(ev);
                            tool.started = false;
                            if (!w || !h) {
                                return;
                            }
                            //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                            textRect(x, y, w, h, null);
                            tool.x = x;
                            tool.y = y;
                            tool.w = w;
                            tool.h = h;

                            context.clearRect(0, 0, canvas.width, canvas.height);
                        }

                    }
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {
                        tool.started = false;
                        if (!w || !h) {
                            return;
                        }
                        textRect(x, y, w, h, null);
                        tool.x = x;
                        tool.y = y;
                        tool.w = w;
                        tool.h = h;

                        //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                        //tool.touchmove(ev);

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {
                        tool.started = false;
                        if (!w || !h) {
                            return;
                        }
                        textRect(x, y, w, h, null);
                        tool.x = x;
                        tool.y = y;
                        tool.w = w;
                        tool.h = h;

                        //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                        //tool.touchmove(ev);

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                };
            };


                //Stamp rectangle tool
            tools.rectStamp = function (params){
                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                this.name = 'rectStamp';
                this.anglelengthsupport = false;

                this.started = false;
                var zoomcolor = "rgba(175, 175, 175, 0.3)";
                context.lineWidth = 2;
                context.strokeStyle = zoomcolor;
                context.fillStyle = zoomcolor;
                var Text = params.p1;

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;

                    }


                    if (ev.button != 2) {
                        tool.started = true;
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                    }

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }
                        ev.target.style.cursor = 'default';
                        return;

                    }

                    if (ev.button != 2) {
                        tool.started = true;
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                    }
                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.started = true;
                    var touchPos = getTouchPos(canvas, ev, 0);

                    var bWithin = MousePosdrwext(touchPos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        return;

                    }

                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;

                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (bWithin || !bLimMarkupExtent) {
                        x = Math.min(mousePos.x, tool.x0);
                        y = Math.min(mousePos.y, tool.y0);
                        w = Math.abs(mousePos.x - tool.x0);
                        h = Math.abs(mousePos.y - tool.y0);

                    } else {
                        x = Math.min(x, tool.x0);
                        y = Math.min(y, tool.y0);
                        w = Math.abs(x - tool.x0);
                        h = Math.abs(y - tool.y0);
                    }


                    /*x = Math.min(mousePos.x, tool.x0);
                    y = Math.min(mousePos.y, tool.y0);
                    w = Math.abs(mousePos.x - tool.x0);
                    h = Math.abs(mousePos.y - tool.y0);*/

                    if (!w || !h) {
                        return;
                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);

                };
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (bWithin || !bLimMarkupExtent) {
                        x = Math.min(mousePos.x, tool.x0);
                        y = Math.min(mousePos.y, tool.y0);
                        w = Math.abs(mousePos.x - tool.x0);
                        h = Math.abs(mousePos.y - tool.y0);

                    } else {
                        x = Math.min(x, tool.x0);
                        y = Math.min(y, tool.y0);
                        w = Math.abs(x - tool.x0);
                        h = Math.abs(y - tool.y0);
                    }
                    /*x = Math.min(mousePos.x, tool.x0);
                    y = Math.min(mousePos.y, tool.y0);
                    w = Math.abs(mousePos.x - tool.x0);
                    h = Math.abs(mousePos.y - tool.y0);*/

                    if (!w || !h) {
                        return;
                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);
                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    if (bWithin || !bLimMarkupExtent) {
                        x = Math.min(touchPos.x, tool.x0);
                        y = Math.min(touchPos.y, tool.y0);
                        w = Math.abs(touchPos.x - tool.x0);
                        h = Math.abs(touchPos.y - tool.y0);

                    } else {
                        x = Math.min(x, tool.x0);
                        y = Math.min(y, tool.y0);
                        w = Math.abs(x - tool.x0);
                        h = Math.abs(y - tool.y0);
                    }

                    /*x = Math.min(touchPos.x, tool.x0);
                    y = Math.min(touchPos.y, tool.y0);
                    w = Math.abs(touchPos.x - tool.x0);
                    h = Math.abs(touchPos.y - tool.y0);*/


                    if (!w || !h) {
                        return;
                    }

                    context.clearRect(0, 0, canvas.width, canvas.height);

                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);

                };

                this.MSPointerUp = function (ev) {
                    ev.preventDefault();

                    ev.target.style.cursor = 'default';

                    if (ev.button != 2) {
                        if (tool.started) {
                            //tool.mousemove(ev);
                            tool.started = false;
                            if (!w || !h) {
                                return;
                            }
                            //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                            stampRect(x, y, w, h, Text);
                            context.clearRect(0, 0, canvas.width, canvas.height);
                        }

                    }

                };
                this.mouseup = function (ev) {
                    ev.preventDefault();

                    ev.target.style.cursor = 'default';

                    if (ev.button != 2) {
                        if (tool.started) {
                            //tool.mousemove(ev);
                            tool.started = false;
                            if (!w || !h) {
                                return;
                            }
                            //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                            stampRect(x, y, w, h, Text);
                            context.clearRect(0, 0, canvas.width, canvas.height);
                        }

                    }
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {
                        tool.started = false;
                        if (!w || !h) {
                            return;
                        }
                        stampRect(x, y, w, h, Text);
                        //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                        //tool.touchmove(ev);

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {
                        tool.started = false;
                        if (!w || !h) {
                            return;
                        }
                        stampRect(x, y, w, h, Text);
                        //DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                        //tool.touchmove(ev);

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                };

            };
            // The zoom tool.
            tools.zoomwindow = function () {

                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                this.name = 'zoomwindow';
                this.anglelengthsupport = false;

                this.started = false;
                var zoomcolor = "rgba(175, 175, 175, 0.3)";
                context.lineWidth = 2;
                context.strokeStyle = zoomcolor;
                context.fillStyle = zoomcolor;

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if (ev.button != 2) {
                        tool.started = true;
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                    }

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if (ev.button != 2) {
                        tool.started = true;
                        tool.x0 = mousePos.x;
                        tool.y0 = mousePos.y;
                    }
                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.started = true;
                    var touchPos = getTouchPos(canvas, ev, 0);
                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;

                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    x = Math.min(mousePos.x, tool.x0);
                    y = Math.min(mousePos.y, tool.y0);
                    w = Math.abs(mousePos.x - tool.x0);
                    h = Math.abs(mousePos.y - tool.y0);

                    if (!w || !h) {
                        return;
                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);

                };
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    x = Math.min(mousePos.x, tool.x0);
                    y = Math.min(mousePos.y, tool.y0);
                    w = Math.abs(mousePos.x - tool.x0);
                    h = Math.abs(mousePos.y - tool.y0);

                    if (!w || !h) {
                        return;
                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);
                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    x = Math.min(touchPos.x, tool.x0);
                    y = Math.min(touchPos.y, tool.y0);
                    w = Math.abs(touchPos.x - tool.x0);
                    h = Math.abs(touchPos.y - tool.y0);


                    if (!w || !h) {
                        return;
                    }

                    context.clearRect(0, 0, canvas.width, canvas.height);

                    context.lineWidth = 1;
                    context.strokeStyle = zoomcolor;
                    context.fillRect(x, y, w, h);

                };

                this.MSPointerUp = function (ev) {
                    ev.preventDefault();

                    ev.target.style.cursor = 'default';

                    if (ev.button != 2) {
                        if (tool.started) {
                            //tool.mousemove(ev);
                            tool.started = false;
                            if (!w || !h) {
                                return;
                            }
                            DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                            context.clearRect(0, 0, canvas.width, canvas.height);
                            //RxCore_default();
                        }

                    }


                };
                this.mouseup = function (ev) {
                    ev.preventDefault();

                    ev.target.style.cursor = 'default';

                    if (ev.button != 2) {
                        if (tool.started) {
                            //tool.mousemove(ev);
                            tool.started = false;
                            if (!w || !h) {
                                return;
                            }
                            DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                            context.clearRect(0, 0, canvas.width, canvas.height);
                            //RxCore_default();
                        }

                    }
                };

                this.mouseout = function(ev){
                    ev.preventDefault();
                    ev.target.style.cursor = 'default';

                    if (tool.started) {

                       tool.started = false;
                       if (!w || !h) {
                            return;
                       }

                       DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                       context.clearRect(0, 0, canvas.width, canvas.height);

                    }

                };

                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {
                        tool.started = false;
                        if (!w || !h) {
                            return;
                        }

                        DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                        //tool.touchmove(ev);

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        //RxCore_default();
                    }

                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {
                        tool.started = false;
                        if (!w || !h) {
                            return;
                        }

                        DocObj.pages[DocObj.currentpage].zoom_update(x, y, w, h);
                        //tool.touchmove(ev);

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        //RxCore_default();
                    }
                };

            };


            tools.pickPolygon = function (params) {

                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                var prevx = 0,
                    prevy = 0;
                this.started = false;
                var multi = params.p1;
                this.multiselect = multi;
                this.createSpaceMarkup = params.p2;
                this.allowVectorSelect = params.p3;

                this.name = 'PickPolygon';
                this.anglelengthsupport = false;
                this.curmousepos = {x:0,y:0};


                this.findspace = function(mousePos){
                    var spacefound = findspacemarkup(mousePos.x, mousePos.y, tool.multiselect);

                    if(!spacefound.found){
                        RxCore_animateLineStyle(false);

                    }else{
                        if(!tool.multiselect){
                            DocObj.pages[DocObj.currentpage].unSelectAllBlocks(false);
                        }

                        RxCore_animateLineStyle(true);
                    }

                    if(!spacefound.within && tool.allowVectorSelect){
                        var polyfound = DocObj.pages[DocObj.currentpage].getpolygon(mousePos.x, mousePos.y,tool.multiselect);
                    }

                };

                this.createSpace = function(mousePos){
                    //var polypoints = DocObj.pages[DocObj.currentpage].getpolygonPoints(mousePos.x, mousePos.y);

                    var polygonpath = DocObj.pages[DocObj.currentpage].getpolygonPath(mousePos.x, mousePos.y);



                    if(polygonpath.points.length > 0){
                        if(DocObj.pages[DocObj.currentpage].VectorPageObj){

                            var scalefactor = DocObj.pages[DocObj.currentpage].dscalevector;
                            var xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                            var yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                            var mediax = DocObj.pages[DocObj.currentpage].VectorPageObj.x;
                            var mediay = DocObj.pages[DocObj.currentpage].VectorPageObj.y;
                            var mediah = DocObj.pages[DocObj.currentpage].VectorPageObj.h;

                            //RxCore_createSpacemarkup(polypoints, scalefactor, xoffset, yoffset, mediax, mediay, mediah);
                            RxCore_createSpacemarkupPath(polygonpath, scalefactor, xoffset, yoffset, mediax, mediay, mediah);
                        }


                    }
                };

                this.panlimit = function(){
                    var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();

                    if ((pagedim.w / pagedim.h) < (canvasowidth / canvasoheight)){
                        if ((pagedim.y + pagedim.h) < (canvasoheight - nPanlimit)){
                            RxCore_PagePos(pagedim.x, -nPanlimit);
                            //reset position to -15
                        }

                        if (pagedim.y > nPanlimit){
                            //reset position to 15
                            RxCore_PagePos(pagedim.x, nPanlimit);
                        }

                    }else{
                        if ((pagedim.x + pagedim.w) < (canvasowidth - nPanlimit)){
                            RxCore_PagePos(-nPanlimit, pagedim.y);
                            //reset position to -15
                        }

                        if (pagedim.x > nPanlimit){
                            //reset position to 15
                            RxCore_PagePos(nPanlimit, pagedim.y);
                        }

                    }


                    /*if(pagedim.w >= canvasowidth){
                    }*/

                };

                this.belowlimitExtent = function(zoomscalefactor){
                    var belowlimit = true;


                    var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();

                    var wlimit = canvasowidth - 60;
                    var hlimit = canvasoheight - 60;

                    if((pagedim.w / zoomscalefactor) < wlimit && (pagedim.h / zoomscalefactor) < hlimit){
                        belowlimit = false;
                        //scalechanged = false;
                        //DocObj.pages[DocObj.currentpage].zoomall();
                    }

                    var pagerect = DocObj.pages[DocObj.currentpage].ZoomOutTest(zoomscalefactor, false, tool.curmousepos);

                    var heightlimit = canvasoheight - (nPanlimit*2);
                    var widthlimit = canvasowidth - (nPanlimit*2);
                    //var toplimit = 15;
                    var bottomlimit = ((pagerect.y + pagerect.h) <= heightlimit);
                    var toplimit = (pagerect.y >= nPanlimit);

                    // need to return these to reset the top and bottom positions.scroll|| bottomlimit || toplimit
                    if ((pagerect.w / pagerect.h) < (canvasowidth / canvasoheight)){
                        if(pagerect.h <= heightlimit){
                            belowlimit = false;
                        }

                    }else{
                        if(pagerect.w <= widthlimit){
                            belowlimit = false;
                        }

                    }



                    if(!bLimitZoomOut){
                        belowlimit = true;
                    }

                    return belowlimit;
                };

                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }

                    if (movey < 0) {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1 && !DocObj.pagelocked) {

                            //DocObj.pages[DocObj.currentpage].pan_update(0,-movey);
                            if (DocObj.currentpage == DocObj.pages.length - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);

                            if (DocObj.pages[DocObj.currentpage].pagenumber == DocObj.pages.length - 1 && DocObj.pages[DocObj.currentpage].drotation == 0) {
                                while (DocObj.pages[DocObj.currentpage].endy < canvas.height) {
                                    DocObj.pages[DocObj.currentpage].pan_update(0, -1);
                                }

                            }


                        } else {
                            if(bUseScrollKey){
                                if (tool.scrollkeyOn){
                                    if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){

                                        if(tool.belowlimitExtent(1.1)){

                                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);
                                            if(bRestrictPan){
                                                tool.panlimit();
                                            }

                                        }

                                        //tool.limitExtent(1.1);
                                    }

                                    //DocObj.pages[DocObj.currentpage].ZoomOutmouse(1.1, tool.curmousepos);
                                }

                            }else{
                                if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){

                                    if(tool.belowlimitExtent(1.1)){
                                        DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);
                                        if(bRestrictPan){
                                            tool.panlimit();
                                        }


                                    }



                                    //tool.limitExtent(1.1);

                                }

                                //DocObj.pages[DocObj.currentpage].ZoomOutmouse(1.1, tool.curmousepos);
                            }

                        }


                    } else {
                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1 && !DocObj.pagelocked) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);

                            if (DocObj.pages[DocObj.currentpage].pagenumber == 0 && DocObj.pages[DocObj.currentpage].drotation == 0) {
                                while (DocObj.pages[DocObj.currentpage].starty > 0) {
                                    DocObj.pages[DocObj.currentpage].pan_update(0, 1);
                                }

                            }


                        } else {
                            if(bUseScrollKey){
                                if (tool.scrollkeyOn){
                                    if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){

                                        DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);
                                        //tool.limitExtent(1.1);
                                    }

                                    //DocObj.pages[DocObj.currentpage].ZoomInMouse(1.1, tool.curmousepos);
                                }
                            }else{
                                if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){
                                    DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);
                                    //tool.limitExtent(1.1);
                                }

                                //DocObj.pages[DocObj.currentpage].ZoomInMouse(1.1, tool.curmousepos);
                            }

                        }

                    }

                };


                this.mousewheel = function(ev){
                    tool.wheel(ev);
                };


                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox
                        if(bIsMSIE ){
                            delta = -ev.deltaY;
                        }else{
                            delta = -ev.deltaY*50;

                        }


                    }

                    tool.scrollhandling(delta);

                };


                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };

                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    //ev.target.style.cursor = 'move';
                    var mousePos = getMousePos(canvas, ev);


                    if(tool.createSpaceMarkup){

                        tool.createSpace(mousePos);

                    }else{

                        tool.findspace(mousePos);

                    }

                    tool.started = true;
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;


                    /*var polyfound = DocObj.pages[DocObj.currentpage].getpolygon(mousePos.x, mousePos.y,tool.multiselect);
                    if(!polyfound){
                        var spacefound = findspacemarkup(mousePos.x, mousePos.y, tool.multiselect);
                    }*/
                    //tool.started = true;
                    /*tool.x0 = mousePos.x;
                     tool.y0 = mousePos.y;
                     prevx = tool.x0;
                     prevy = tool.y0;*/

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    //ev.target.style.cursor = 'move';

                    //tool.started = true;
                    var mousePos = getMousePos(canvas, ev);


                    if(tool.createSpaceMarkup){

                        tool.createSpace(mousePos);


                    }else{
                        tool.findspace(mousePos);



                    }

                    tool.started = true;
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;



                    //page.getpolygon(x,y)
                    /*tool.x0 = mousePos.x;
                     tool.y0 = mousePos.y;
                     prevx = tool.x0;
                     prevy = tool.y0;*/

                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    //tool.started = true;
                    var touchPos = getTouchPos(canvas, ev, 0);

                    if(tool.createSpaceMarkup){

                        tool.createSpace(touchPos);

                    }else{
                        tool.findspace(touchPos);

                    }

                    tool.started = true;
                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;
                    x = tool.x0;
                    y = tool.y0;


                    /*var polyfound = DocObj.pages[DocObj.currentpage].getpolygon(touchPos.x, touchPos.y,tool.multiselect);

                    if(!polyfound){
                        var spacefound = findspacemarkup(touchPos.x, touchPos.y, tool.multiselect);
                    }*/

                    /*tool.x0 = touchPos.x;
                     tool.y0 = touchPos.y;
                     prevx = tool.x0;
                     prevy = tool.y0;
                     x = tool.x0;
                     y = tool.y0;*/
                };

                this.MSPointerMove = function (ev) {
                    /*if (!tool.started) {
                     return;
                     }*/
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;
                    if (!tool.started) {
                        return;
                    }

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);

                    prevx = mousePos.x;
                    prevy = mousePos.y;

                    //var xdiff = prevx - mousePos.x;
                    //var ydiff = prevy - mousePos.y;

                    //var polyfound = DocObj.pages[DocObj.currentpage].getpolygon(mousePos.x, mousePos.y);
                    //DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);


                    //prevx = mousePos.x;
                    //prevy = mousePos.y;

                };
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;
                    if (!tool.started) {
                        return;
                    }

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);

                    prevx = mousePos.x;
                    prevy = mousePos.y;
                    /*if (!tool.started) {
                     return;
                     }*/
                    //var mousePos = getMousePos(canvas, ev);
                    //var polyfound = DocObj.pages[DocObj.currentpage].getpolygon(mousePos.x, mousePos.y);
                    //var xdiff = prevx - mousePos.x;
                    //var ydiff = prevy - mousePos.y;


                    //prevx = mousePos.x;
                    //prevy = mousePos.y;

                };

                this.touchmove = function (ev) {

                    ev.preventDefault();
                    /*if (!tool.started) {
                     return;
                     }*/
                    var touchPos = getTouchPos(canvas, ev, 0);
                    tool.curmousepos = touchPos;

                    if (!tool.started) {
                        return;
                    }

                    var xdiff = prevx - touchPos.x;
                    var ydiff = prevy - touchPos.y;

                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);


                    prevx = touchPos.x;
                    prevy = touchPos.y;

                    //var polyfound = DocObj.pages[DocObj.currentpage].getpolygon(touchPos.x, touchPos.y);
                    //var xdiff = prevx - touchPos.x;
                    //var ydiff = prevy - touchPos.y;

                    //prevx = touchPos.x;
                    //prevy = touchPos.y;


                };

                this.MSPointerUp = function (ev) {

                    if (tool.started) {
                        tool.MSPointerMove(ev);
                        tool.started = false;
                    }

                };

                this.mouseup = function (ev) {

                    if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;

                    }
                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {
                        tool.touchmove(ev);
                        tool.started = false;
                    }

                    /*if (tool.started) {
                     tool.touchmove(ev);
                     tool.started = false;
                     }*/
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {
                        tool.touchmove(ev);
                        tool.started = false;
                    }

                };


            };

            tools.pan = function () {

                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                var prevx = 0,
                    prevy = 0;
                this.started = false;
                this.name = 'pan';
                this.anglelengthsupport = false;

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };

                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'move';
                    var mousePos = getMousePos(canvas, ev);
                    tool.started = true;
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'move';

                    tool.started = true;
                    var mousePos = getMousePos(canvas, ev);
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;

                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    tool.started = true;
                    var touchPos = getTouchPos(canvas, ev, 0);
                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;
                    x = tool.x0;
                    y = tool.y0;
                };

                this.MSPointerMove = function (ev) {
                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);


                    prevx = mousePos.x;
                    prevy = mousePos.y;

                };
                this.mousemove = function (ev) {
                    if (!tool.started) {
                        return;
                    }
                    var mousePos = getMousePos(canvas, ev);
                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);


                    prevx = mousePos.x;
                    prevy = mousePos.y;

                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var xdiff = prevx - touchPos.x;
                    var ydiff = prevy - touchPos.y;

                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);


                    prevx = touchPos.x;
                    prevy = touchPos.y;


                };

                this.MSPointerUp = function (ev) {
                    ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;


                    }

                };
                this.mouseup = function (ev) {
                    ev.target.style.cursor = 'default';
                    if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;


                    }
                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {
                        tool.touchmove(ev);
                        tool.started = false;
                    }

                };
                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {
                        tool.touchmove(ev);
                        tool.started = false;
                    }
                };

            };

            tools.markupedit = function (params) {

                var tool = this;
                var x = 0,
                    y = 0,
                    w = 0,
                    h = 0;
                var prevx = 0,
                    prevy = 0;
                var xcur1 = 0,
                    xcur2 = 0,
                    ycur1 = 0,
                    ycur2 = 0;
                var startx = 0,
                    starty = 0,
                    startx2 = 0,
                    starty2 = 0,
                    startw = 0,
                    starth = 0;
                var startwsq = 0.0;
                var starthsq = 0.0;
                var wsq = 0.0;
                var hsq = 0.0;

                var startdiagonal = 0.0;
                var diagonal = 0.0;
                var prevdiagonal = 0.0;
                var prevh = 0,
                    prevw = 0;

                var startcenterx = 0,
                    startcentery = 0;
                var centerx = 0,
                    centery = 0;
                var prevcenterx = 0,
                    prevcentery = 0;

                var id = -1;
                var fmarkup = {};
                var listentrynum = -1;

                var numtouchpoints = -1;
                var touchpointarr = [];
                var mstouchzoom = false;
                var mstouchpan = false;

                var startdeltax = 0;
                var startdeltay = 0;
                var diffangle = 0;
                var startangle = 0;
                var curangle = 0;

                var startscalesmall = 0;
                var startscalelarge = 0;
                var bCanSelectSpace = params.p1;

                this.LastTouchdata = -1;
                this.started = false;
                this.name = 'markupedit';
                this.anglelengthsupport = false;

                this.savestate = true;
                this.changedstate = false;
                this.scrollkeyOn = false;
                this.curmousepos = {x:0,y:0};


                var havesnap = false;
                var snapPoint;

                this.bdeletepoint = false;
                this.binsertpoint = false;

                //dragaction 1 = move, 2 = scale, 3= rotate, 4 = editpoint
                //var dragaction = 1;


                this.enablePointDelete = function(){
                  tool.bdeletepoint = true;
                };

                this.enablePointInsert = function(){
                    tool.binsertpoint = true;
                };

                this.enableMoveLabel = function(onOff){
                    tool.bmovelabel = onOff;
                };

                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }

                    RxCore_hideTextInput();

                    if (movey < 0) {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1 && !DocObj.pagelocked) {

                            //DocObj.pages[DocObj.currentpage].pan_update(0,-movey);
                            if (DocObj.currentpage == DocObj.pages.length - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);

                            if (DocObj.pages[DocObj.currentpage].pagenumber == DocObj.pages.length - 1 && DocObj.pages[DocObj.currentpage].drotation == 0) {
                                while (DocObj.pages[DocObj.currentpage].endy < canvas.height) {
                                    DocObj.pages[DocObj.currentpage].pan_update(0, -1);
                                }

                            }


                        } else {
                            if(bUseScrollKey){
                                if (tool.scrollkeyOn){
                                    if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){

                                        if(tool.belowlimitExtent(1.1)){

                                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);
                                            if(bRestrictPan){
                                                tool.panlimit();
                                            }

                                        }

                                        //tool.limitExtent(1.1);
                                    }

                                    //DocObj.pages[DocObj.currentpage].ZoomOutmouse(1.1, tool.curmousepos);
                                }

                            }else{
                                if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){

                                    if(tool.belowlimitExtent(1.1)){
                                        DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);
                                        if(bRestrictPan){
                                            tool.panlimit();
                                        }


                                    }



                                    //tool.limitExtent(1.1);

                                }

                                //DocObj.pages[DocObj.currentpage].ZoomOutmouse(1.1, tool.curmousepos);
                            }

                        }


                    } else {
                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1 && !DocObj.pagelocked) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);

                            if (DocObj.pages[DocObj.currentpage].pagenumber == 0 && DocObj.pages[DocObj.currentpage].drotation == 0) {
                                while (DocObj.pages[DocObj.currentpage].starty > 0) {
                                    DocObj.pages[DocObj.currentpage].pan_update(0, 1);
                                }

                            }


                        } else {
                            if(bUseScrollKey){
                                if (tool.scrollkeyOn){
                                    if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){

                                        DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);
                                        //tool.limitExtent(1.1);
                                    }

                                    //DocObj.pages[DocObj.currentpage].ZoomInMouse(1.1, tool.curmousepos);
                                }
                            }else{
                                if (!DocObj.pages[DocObj.currentpage].usedincomposite || bScrollZoomOverlay){
                                    DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);
                                    //tool.limitExtent(1.1);
                                }

                                //DocObj.pages[DocObj.currentpage].ZoomInMouse(1.1, tool.curmousepos);
                            }

                        }

                    }

                };

                this.belowlimitExtent = function(zoomscalefactor){
                    var belowlimit = true;


                    var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();

                    var wlimit = canvasowidth - 60;
                    var hlimit = canvasoheight - 60;

                    if((pagedim.w / zoomscalefactor) < wlimit && (pagedim.h / zoomscalefactor) < hlimit){
                        belowlimit = false;
                        //scalechanged = false;
                        //DocObj.pages[DocObj.currentpage].zoomall();
                    }

                    var pagerect = DocObj.pages[DocObj.currentpage].ZoomOutTest(zoomscalefactor, false, tool.curmousepos);

                    var heightlimit = canvasoheight - (nPanlimit*2);
                    var widthlimit = canvasowidth - (nPanlimit*2);
                    //var toplimit = 15;
                    var bottomlimit = ((pagerect.y + pagerect.h) <= heightlimit);
                    var toplimit = (pagerect.y >= nPanlimit);

                    // need to return these to reset the top and bottom positions.scroll|| bottomlimit || toplimit
                    if ((pagerect.w / pagerect.h) < (canvasowidth / canvasoheight)){
                        if(pagerect.h <= heightlimit){
                            belowlimit = false;
                        }

                    }else{
                        if(pagerect.w <= widthlimit){
                            belowlimit = false;
                        }

                    }

                    /*if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        //var curscale = DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf;



                    }else if (DocObj.pages[DocObj.currentpage].usevectorxml) {


                        if (DocObj.pages[DocObj.currentpage].initialscale > DocObj.pages[DocObj.currentpage].dscalevector) {
                            //scalechanged = false;
                            //DocObj.pages[DocObj.currentpage].zoomall();
                            belowlimit = false;

                        }


                    } else {
                        if (DocObj.pages[DocObj.currentpage].initialscale > (DocObj.pages[DocObj.currentpage].dscale / DocObj.pages[DocObj.currentpage].bitmapratio)) {
                            //scalechanged = false;
                            //DocObj.pages[DocObj.currentpage].zoomall();
                            belowlimit = false;
                        }

                    }*/

                    if(!bLimitZoomOut){
                        belowlimit = true;
                    }

                    return belowlimit;
                };


                this.panlimit = function(){
                    var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();

                    if ((pagedim.w / pagedim.h) < (canvasowidth / canvasoheight)){
                        if ((pagedim.y + pagedim.h) < (canvasoheight - nPanlimit)){
                            RxCore_PagePos(pagedim.x, -nPanlimit);
                            //reset position to -15
                        }

                        if (pagedim.y > nPanlimit){
                            //reset position to 15
                            RxCore_PagePos(pagedim.x, nPanlimit);
                        }

                    }else{
                        if ((pagedim.x + pagedim.w) < (canvasowidth - nPanlimit)){
                            RxCore_PagePos(-nPanlimit, pagedim.y);
                            //reset position to -15
                        }

                        if (pagedim.x > nPanlimit){
                            //reset position to 15
                            RxCore_PagePos(nPanlimit, pagedim.y);
                        }

                    }


                    /*if(pagedim.w >= canvasowidth){
                    }*/


                };

                this.limitPan = function(x,y){

                    var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();
                    var direction = {up:false, down:false, left: false, right : false};

                    direction.down = (y < 0);
                    direction.up = (y > 0);
                    direction.left = (x > 0);
                    direction.right = (x < 0);

                    /*switch(pagedim.rotation){
                        case 90:
                            pagedim.y = -((pagedim.y + pagedim.h) - canvasoheight);
                            pagedim.x = -((pagedim.x + pagedim.w) - canvasowidth);
                            break;

                        case 270:
                            pagedim.y = -((pagedim.y + pagedim.h) - canvasoheight);
                            pagedim.x = -((pagedim.x + pagedim.w) - canvasowidth);
                            break;
                    }*/

                    var moveyul = pagedim.y - y;
                    var movexul = pagedim.x - x;
                    var moveylr = moveyul + pagedim.h;
                    var movexlr = movexul + pagedim.w;


                    var allowpan = {x:true,y:true, diffx : x, diffy:y};

                    if(!bRestrictPan){
                        return allowpan;
                    }

                    if(pagedim.h <= canvasoheight - 1){
                        allowpan.y = false;
                    }else{
                        if(pagedim.y > 15 && direction.down){
                            allowpan.y = false;
                        }

                        if(pagedim.y + pagedim.h < (canvasoheight - 15) && direction.up){
                            allowpan.y = false;
                        }

                    }

                    if(pagedim.w <= canvasowidth - 1){
                        allowpan.x = false;
                    }else{

                        if(pagedim.x > 15 && direction.right){
                            allowpan.x = false;
                        }

                        if(pagedim.x + pagedim.w < (canvasowidth - 15) && direction.left){
                            allowpan.x = false;
                        }

                    }

                    /*if (direction.down && moveyul > 15){
                        allowpan.diffy = moveyul - 15;
                    }

                    if(direction.up && moveylr > 15){
                        allowpan.diffy = moveylr - (canvasoheight - 15);
                        allowpan.diffy = moveylr - (canvasoheight - 15);
                    }*/

                    if(direction.up && allowpan.y){

                        if(moveylr < (canvasoheight - 15)){
                            if(y > 0){
                                allowpan.diffy = y - ((canvasoheight - 15) - moveylr);
                            }
                        }

                    }

                    if(direction.down && allowpan.y){
                        if(moveyul > 15){
                            if(y < 0){
                                allowpan.diffy = y + (moveyul - 15);
                            }
                        }


                    }

                    if(direction.left && allowpan.x ){
                        if(movexlr < (canvasowidth - 15)){
                            if(x > 0){
                                allowpan.diffx = x - ((canvasowidth - 15) - movexlr);
                            }
                        }

                    }

                    if(direction.right && allowpan.x){
                        if(movexul > 15){
                            if(x < 0){
                                allowpan.diffx = x + (movexul - 15);
                            }

                        }


                    }

                    return allowpan;

                };

                this.limitExtent = function(zoomscalefactor){

                    if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        //var curscale = DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf;

                        var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();

                        if((pagedim.w * zoomscalefactor) < canvasowidth && (pagedim.h * zoomscalefactor) < canvasoheight){
                            //scalechanged = false;
                            DocObj.pages[DocObj.currentpage].zoomall();
                        }

                        //var cwidth = DocObj.pages[DocObj.currentpage].endx
                        //if (DocObj.pages[DocObj.currentpage].endx - )

                        /*if (DocObj.pages[DocObj.currentpage].initialscale > curscale) {
                            scalechanged = false;
                            DocObj.pages[DocObj.currentpage].zoomall();
                        }*/

                    }else if (DocObj.pages[DocObj.currentpage].usevectorxml) {


                        if (DocObj.pages[DocObj.currentpage].initialscale > DocObj.pages[DocObj.currentpage].dscalevector) {
                            //scalechanged = false;
                            DocObj.pages[DocObj.currentpage].zoomall();

                        }


                    } else {
                        if (DocObj.pages[DocObj.currentpage].initialscale > (DocObj.pages[DocObj.currentpage].dscale / DocObj.pages[DocObj.currentpage].bitmapratio)) {
                            //scalechanged = false;
                            DocObj.pages[DocObj.currentpage].zoomall();
                        }

                    }
                };


                this.DOMMouseScroll = function (ev) {

                    //tool.scrollhandling(1, ev.detail*50);

                };

                this.mousewheel = function(ev){
                    tool.wheel(ev);
                };


                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox
                        if(bIsMSIE ){
                            delta = -ev.deltaY;
                        }else{
                            delta = -ev.deltaY*50;

                        }


                    }

                    tool.scrollhandling(delta);


                };




                this.mousedownhandling = function (ev, mousePos) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }


                    ev.target.style.cursor = 'move';
                    mstouchpan = true;
                    tool.started = true;

                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;

                    /*id = findmarkupHover(mousePos.x,mousePos.y);
                     var listentrynum = DocObj.getmarkupbynumber(id);

                     if (id != -1){
                     if(DocObj.markuplist[listentrynum].type==10){
                     if(RxCore_GUI_Notediag != undefined){
                     RxCore_GUI_Notediag.setNotediag(DocObj.markuplist[listentrynum].text,true);
                     }

                     tool.started = false;
                     }else{

                     }


                     }*/


                };

                this.mouseuphandler = function (ev) {
                    if (!documentopen) {
                        return;
                    }

                    ev.target.style.cursor = 'default';

                    if (tool.started || mstouchpan) {
                        //tool.mousemove(ev);
                        tool.started = false;

                        mstouchpan = false;
                        if (DocObj.Type == 0 && !documentcompare) {
                          if(!DocObj.pagelocked){
                            if (DocObj.currentpage == 0 && DocObj.pages[DocObj.currentpage].drotation == 0) {
                                while (DocObj.pages[DocObj.currentpage].starty > 0) {
                                    DocObj.pages[DocObj.currentpage].pan_update(0, 1);
                                }
                            }
                            if (DocObj.currentpage == DocObj.NumPages - 1 && DocObj.pages[DocObj.currentpage].drotation == 0) {
                                while (DocObj.pages[DocObj.currentpage].endy < canvas.height) {
                                    DocObj.pages[DocObj.currentpage].pan_update(0, -1);
                                }

                            }

                          }
                        }

                    }


                };

                this.movehandler = function (mousePos, ev) {
                    if (!documentopen) {
                        return;
                    }

                    if (!tool.started && !mstouchpan && bmarkupLabels) {

                        cntximg.clearRect(0, 0, canvas.width, canvas.height);
                        context.clearRect(0, 0, canvas.width, canvas.height);


                        id = findmarkupHover(mousePos.x, mousePos.y);
                        var listmnum = DocObj.getmarkupbynumber(id);
                        if (id != -1 && DocObj.markuplist[listmnum].pagenumber == DocObj.getcurPage() && DocObj.markuplist[listmnum].display && DocObj.Drawmarkup) {

                            if (id != -1 && DocObj.markuplist[listmnum].bhaveLink && (DocObj.bMarkupLocked || DocObj.markuplist[listmnum].locked)){
                                ev.target.style.cursor = 'pointer';
                                context.clearRect(0, 0, canvas.width, canvas.height);
                                DocObj.markuplist[listmnum].displayurl(context, mousePos.x, mousePos.y);

                            }else if (id != -1 && DocObj.markuplist[listmnum].type == 10) {

                                ev.target.style.cursor = 'pointer';
                                context.clearRect(0, 0, canvas.width, canvas.height);
                                DocObj.markuplist[listmnum].displaylabel(context, mousePos.x, mousePos.y);

                            } else {
                                ev.target.style.cursor = 'default';
                                context.clearRect(0, 0, canvas.width, canvas.height);
                                DocObj.markuplist[listmnum].displaylabel(context, mousePos.x, mousePos.y);

                            }

                        } else {
                            ev.target.style.cursor = 'default';
                            context.clearRect(0, 0, canvas.width, canvas.height);

                        }
                        return;

                    }


                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    if (DocObj.Type == 0 && !documentcompare && !DocObj.pagelocked) {


                        if (DocObj.pages[DocObj.currentpage].startx < 0 || DocObj.pages[DocObj.currentpage].endx > canvas.width) {
                            DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        } else {
                            if (DocObj.pages[DocObj.currentpage].drotation == 0) {
                                DocObj.pages[DocObj.currentpage].pan_update(0, ydiff);
                            } else {
                                DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                            }

                        }
                        //if(DocObj.pages[DocObj.currentpage].starty > 0)


                    } else {
                        //tool.panhandle(xdiff,ydiff);
                        var allowpan = tool.limitPan(xdiff, ydiff);
                        //var allowpan = {x:true,y:true, diffx : x, diffy:y};
                        var movex = allowpan.x ? allowpan.diffx : 0;
                        var movey = allowpan.y ? allowpan.diffy : 0;
                        DocObj.pages[DocObj.currentpage].pan_update(movex, movey);

                        /*if (allowpan.x && allowpan.y){
                            DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        }else if(allowpan.x && !allowpan.y){
                            DocObj.pages[DocObj.currentpage].pan_update(xdiff, 0);
                        }else if (!allowpan.x && allowpan.y){
                            DocObj.pages[DocObj.currentpage].pan_update(0, ydiff);
                        }else {
                            DocObj.pages[DocObj.currentpage].pan_update(0, 0);
                        }*/


                    }

                    prevx = mousePos.x;
                    prevy = mousePos.y;

                };


                this.panhandle = function(xdiff,ydiff){

                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        if (DocObj.pages[DocObj.currentpage].initialscale < DocObj.pages[DocObj.currentpage].dscalevector) {
                            if(xdiff < 50 && ydiff < 50){
                                //limit check here.
                                DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                            }

                        }

                    } else {
                        if (DocObj.Type == 0) {
                            if (DocObj.pages[DocObj.currentpage].startx < 0 || DocObj.pages[DocObj.currentpage].endx > canvas.width) {
                                if(xdiff < 50 && ydiff < 50){
                                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                }

                            } else {
                                if(documentcompare){
                                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                }else{
                                    DocObj.pages[DocObj.currentpage].pan_update(0, ydiff);
                                }

                            }

                        }
                        if (DocObj.pages[DocObj.currentpage].initialscale < (DocObj.pages[DocObj.currentpage].dscale / DocObj.pages[DocObj.currentpage].bitmapratio)) {
                            if (DocObj.Type == 0) {
                                if(documentcompare){
                                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                }else{
                                    DocObj.pages[DocObj.currentpage].pan_update(0, ydiff);
                                }

                            } else {
                                if(xdiff < 50 && ydiff < 50){
                                    DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                }

                            }

                        }

                    }

                };

                this.labelhandler = function (mousePos, ev) {
                    if(bLabelsOff || !bmarkupLabels){
                        return;
                    }
                    if (!documentopen) {
                        return;
                    }
                    if (tool.started) {
                        return;
                    }

                    id = findmarkupHover(mousePos.x, mousePos.y);
                    var listmnum = DocObj.getmarkupbynumber(id);
                    if (id != -1 && DocObj.markuplist[listmnum].pagenumber == DocObj.getcurPage() && DocObj.markuplist[listmnum].display && DocObj.Drawmarkup) {

                        if (id != -1 && DocObj.markuplist[listmnum].bhaveLink && (DocObj.bMarkupLocked || DocObj.markuplist[listmnum].locked)){
                            ev.target.style.cursor = 'pointer';
                            context.clearRect(0, 0, canvas.width, canvas.height);
                            drawmarkupAll(cntximg);
                            DrawMarkupSelected(context);

                            DocObj.markuplist[listmnum].displayurl(context, mousePos.x, mousePos.y);

                        }else if (id != -1 && DocObj.markuplist[listmnum].type == 10) {
                            ev.target.style.cursor = 'pointer';
                            context.clearRect(0, 0, canvas.width, canvas.height);

                            drawmarkupAll(cntximg);
                            DrawMarkupSelected(context);
                            DocObj.markuplist[listmnum].displaylabel(context, mousePos.x, mousePos.y);

                        } else {
                            ev.target.style.cursor = 'default';
                            context.clearRect(0, 0, canvas.width, canvas.height);

                            drawmarkupAll(cntximg);
                            DrawMarkupSelected(context);
                            DocObj.markuplist[listmnum].displaylabel(context, mousePos.x, mousePos.y);
                        }

                    } else {
                        ev.target.style.cursor = 'default';
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        drawmarkupAll(cntximg);
                        DrawMarkupSelected(context);

                    }
                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    if (!documentopen) {
                        return;
                    }

                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }

                    ev.preventDefault();
                    ev.stopPropagation();

                    tool.started = true;
                    var mousePos = getMousePos(canvas, ev);
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;

                    if(DocObj.bMarkupLocked){
                        //id = -1;
                        fmarkup = findmarkup(tool.x0, tool.y0, bCanSelectSpace);
                        id = fmarkup.id;

                        if(fmarkup.blink){
                            tool.started = false;

                            if (RxCore_GUI_MarkupLink != undefined) {
                                RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                            }
                            return;
                        }
                        listentrynum = DocObj.getmarkupbynumber(id);

                    }else{
                        fmarkup = findmarkup(tool.x0, tool.y0, bCanSelectSpace);
                        id = fmarkup.id;

                        if(fmarkup.locked && fmarkup.blink){
                            tool.started = false;


                            if (RxCore_GUI_MarkupLink != undefined) {
                                RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                            }
                            return;
                        }

                        /*if(fmarkup.blink){
                            tool.started = false;


                            if (RxCore_GUI_MarkupLink != undefined) {
                                RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                            }
                            return;
                        }*/

                        listentrynum = DocObj.getmarkupbynumber(id);

                    }

                    touchpointarr.push(new TouchPoint(ev.pointerId, mousePos.x, mousePos.y));

                    switch (touchpointarr.length) {
                        case 1:
                            if (id == -1) {
                                // tool.started = false;
                                drawmarkupAll(cntximg);
                                DrawMarkupSelected(context);
                                tool.mousedownhandling(ev, mousePos);
                                DocObj.selectedmarkup.selected = false;
                                DocObj.selectedmarkup.edit = false;

                            } else {
                                if (tool.savestate) {
                                    MarkupSaveState(id);
                                }
                                tool.savestate = false;
                                drawmarkupAll(cntximg);
                                DrawMarkupSelected(context);
                                if(DocObj){
                                    DocObj.bMarkupchanged = true;
                                }


                                if (DocObj.markuplist[listentrynum].type == 10) {
                                    DocObj.selectedmarkup.id = listentrynum;
                                    DocObj.selectedmarkup.selected = true;
                                }


                                if (DocObj.markuplist[listentrynum].type == 9) {
                                    if (RxCore_GUI_TextInput != undefined) {
                                        if(DocObj.selectedmarkup.edit){
                                            RxCore_GUI_TextInput.operation.edit = false;
                                            RxCore_GUI_TextInput.operation.start = false;
                                            RxCore_GUI_TextInput.operation.create = false;
                                            RxCore_GUI_TextInput.operation.save = true;

                                            var rect = canvas.getBoundingClientRect();
                                            var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.x + rect.left;
                                            var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.y + rect.top;
                                            //var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                            //var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;

                                            var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                            var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                                            var centercanvX = (canvasowidth / 2);
                                            var centercanvY = (canvasoheight / 2);


                                            var centerx = xrect + (wrect*0.5);
                                            var centery = yrect + (hrect*0.5);

                                            var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

                                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                                var rectcenter = DocObj.markuplist[DocObj.selectedmarkup.id].getRotatedMarkup(centercanvX, centercanvY, centerx, centery, CanvRotRad);
                                                centerx = rectcenter.x;
                                                centery = rectcenter.y;
                                            }

                                            centerx += rect.left;
                                            centery += rect.top;


                                            var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                            txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;
                                            txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;

                                            RxCore_GUI_TextInput.setTextInput(txtrect);


                                            /*var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                            var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;
                                            var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                            var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                                            var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                            RxCore_GUI_TextInput.setTextInput(txtrect);*/

                                            RxCore_GUI_TextInput.operation.edit = false;
                                            DocObj.selectedmarkup.edit = false;
                                        }
                                    }

                                    DocObj.selectedmarkup.id = listentrynum;

                                }

                                if (DocObj.markuplist[listentrynum].editaction == 4 && tool.bdeletepoint) {
                                    DocObj.markuplist[listentrynum].deletepoint(DocObj.markuplist[listentrynum].selectedpoint);
                                    drawmarkupAll(cntximg);
                                    DrawMarkupSelected(context);
                                    tool.bdeletepoint = false;
                                }

                                if (DocObj.markuplist[listentrynum].editaction == 7 && tool.binsertpoint) {
                                    DocObj.markuplist[listentrynum].insertpoint();
                                    drawmarkupAll(cntximg);
                                    DrawMarkupSelected(context);
                                    tool.binsertpoint = false;

                                }

                            }




                            if (ev.button == 1 && !tool.started) {
                                tool.started = true;
                            }
                            break;
                        case 2:
                            mstouchzoom = true;
                            startx = touchpointarr[0].x;
                            starty = touchpointarr[0].y;
                            startx2 = touchpointarr[1].x;
                            starty2 = touchpointarr[1].y;

                            //establish rectangle from the two points.
                            var xmin = Math.min(startx, startx2);
                            var ymin = Math.min(starty, startx2);
                            startw = Math.abs(startx2 - startx);
                            starth = Math.abs(starty2 - starty);

                            //calculate diagonal between points
                            startwsq = Math.pow(startw, 2);
                            starthsq = Math.pow(starth, 2);
                            startdiagonal = Math.sqrt((startwsq + starthsq));
                            prevdiagonal = startdiagonal;

                            startcenterx = xmin + (startw / 2);
                            startcentery = ymin + (starth / 2);
                            prevcenterx = startcenterx;
                            prevcentery = startcentery;
                            prevh = starth;
                            prevw = startw;


                            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                                startscalesmall = DocObj.pages[DocObj.currentpage].dscalevector;
                                startscalelarge = DocObj.pages[DocObj.currentpage].dscalevector;
                            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                                startscalesmall = DocObj.pages[DocObj.currentpage].dscalepdf;
                                startscalelarge = DocObj.pages[DocObj.currentpage].dscalepdf;

                            } else {
                                startscalesmall = DocObj.pages[DocObj.currentpage].dscale;
                                startscalelarge = DocObj.pages[DocObj.currentpage].dscale;

                            }


                            break;

                    }


                };

                this.mousedown = function (ev) {

                    ev.preventDefault();
                    ev.stopPropagation();

                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }


                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }


                    tool.started = true;

                    var mousePos = getMousePos(canvas, ev);
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;
                    prevx = tool.x0;
                    prevy = tool.y0;

                    if(DocObj.bMarkupLocked){
                        //id = -1;
                        fmarkup = findmarkup(tool.x0, tool.y0, bCanSelectSpace);
                        id = fmarkup.id;
                        if(fmarkup.blink){
                            tool.started = false;


                            if (RxCore_GUI_MarkupLink != undefined) {
                                RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                            }
                            return;
                        }

                        listentrynum = DocObj.getmarkupbynumber(id);

                    }else{
                        fmarkup = findmarkup(tool.x0, tool.y0, bCanSelectSpace);
                        id = fmarkup.id;


                        if(fmarkup.locked && fmarkup.blink){
                            tool.started = false;


                            if (RxCore_GUI_MarkupLink != undefined) {
                                RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                            }
                            return;
                        }

                        /*if(fmarkup.blink){
                            tool.started = false;

                            if (RxCore_GUI_MarkupLink != undefined) {
                                RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                            }
                            return;
                        }*/

                        listentrynum = DocObj.getmarkupbynumber(id);



                    }

                    if (id == -1) {
                        tool.started = false;

                        if (RxCore_GUI_Markup != undefined) {
                            RxCore_GUI_Markup.showContext = false;
                        }

                        DocObj.selectedmarkup.edit = false;
                        DocObj.selectedmarkup.selected = false;
                        drawmarkupAll(cntximg);
                        DrawMarkupSelected(context);
                        tool.mousedownhandling(ev, mousePos);

                    } else {
                        if (tool.savestate) {
                            MarkupSaveState(id);
                        }
                        tool.savestate = false;
                        drawmarkupAll(cntximg);
                        DrawMarkupSelected(context);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }



                        if (DocObj.selectedmarkup.id != -1 && DocObj.markuplist[DocObj.selectedmarkup.id] != undefined) {
                            if(DocObj.markuplist[DocObj.selectedmarkup.id].type == 9){
                                if (RxCore_GUI_TextInput != undefined) {
                                    if(DocObj.selectedmarkup.edit){
                                        RxCore_GUI_TextInput.operation.edit = false;
                                        RxCore_GUI_TextInput.operation.start = false;
                                        RxCore_GUI_TextInput.operation.create = false;
                                        RxCore_GUI_TextInput.operation.save = true;

                                        var rect = canvas.getBoundingClientRect();
                                        var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.x + rect.left;
                                        var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.y + rect.top;

                                        //var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                        //var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;
                                        var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                        var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                                        var centercanvX = (canvasowidth / 2);
                                        var centercanvY = (canvasoheight / 2);


                                        var centerx = xrect + (wrect*0.5);
                                        var centery = yrect + (hrect*0.5);

                                        var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);

                                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                            var rectcenter = DocObj.markuplist[DocObj.selectedmarkup.id].getRotatedMarkup(centercanvX, centercanvY, centerx, centery, CanvRotRad);
                                            centerx = rectcenter.x;
                                            centery = rectcenter.y;
                                        }

                                        centerx += rect.left;
                                        centery += rect.top;


                                        var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                        txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;
                                        RxCore_GUI_TextInput.setTextInput(txtrect);


                                        /*var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                         var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;
                                         var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                         var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;
                                         var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                         RxCore_GUI_TextInput.setTextInput(txtrect);*/

                                        DocObj.selectedmarkup.edit = false;
                                    }
                                }
                                DocObj.selectedmarkup.id = listentrynum;

                            }



                        }

                        if (DocObj.markuplist[listentrynum].editaction == 4 && tool.bdeletepoint) {
                            DocObj.markuplist[listentrynum].deletepoint(DocObj.markuplist[listentrynum].selectedpoint);
                            drawmarkupAll(cntximg);
                            DrawMarkupSelected(context);
                            tool.bdeletepoint = false;
                        }

                        if (DocObj.markuplist[listentrynum].editaction == 7 && tool.binsertpoint) {
                            DocObj.markuplist[listentrynum].insertpoint();
                            drawmarkupAll(cntximg);
                            DrawMarkupSelected(context);
                            tool.binsertpoint = false;

                        }

                        if (DocObj.markuplist[listentrynum].type == 10) {
                            DocObj.selectedmarkup.id = listentrynum;
                        }


                    }
                    if (ev.button == 1 && !tool.started) {
                        tool.started = true;
                    }
                    if (ev.button == 2 && tool.started) {
                        //tool.started = true;
                        /*if (RxCore_GUI_Markup != undefined) {
                            RxCore_GUI_Markup.showContext = true;
                            var operation = {created : false, modified : false, deleted : false};
                            var btextboxleader = (DocObj.markuplist[listentrynum].type == 9 &&  DocObj.markuplist[listentrynum].subtype == 2);
                            if(!btextboxleader){
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[listentrynum], operation);
                            }

                        }*/

                    }


                };
                this.dblclick = function (ev) {
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }


                    tool.started = true;
                    var mousePos = getMousePos(canvas, ev);
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;

                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }

                    if(DocObj.bMarkupLocked){
                        id = -1;
                        //id = finddoublemarkup(tool.x0, tool.y0);
                        //listentrynum = DocObj.getmarkupbynumber(id);
                    }else{
                        id = finddoublemarkup(tool.x0, tool.y0);
                        listentrynum = DocObj.getmarkupbynumber(id);


                    }

                    if (id != -1 && !DocObj.markuplist[listentrynum].locked) {
                        MarkupSaveState(id);
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        if (DocObj.markuplist[listentrynum].type == 9) {
                            var curmarkuptext = DocObj.markuplist[listentrynum].text;
                            DocObj.selectedmarkup.id = listentrynum;
                            DocObj.selectedmarkup.edit = true;

                            if (RxCore_GUI_Textdiag != undefined) {
                                RxCore_GUI_Textdiag.setTextdiag(DocObj.markuplist[DocObj.selectedmarkup.id].text);
                            }

                            if (RxCore_GUI_TextInput != undefined) {

                                RxCore_GUI_TextInput.operation.start = false;
                                RxCore_GUI_TextInput.operation.create = false;
                                RxCore_GUI_TextInput.operation.edit = true;
                                RxCore_GUI_TextInput.operation.save = false;

                                var rect = canvas.getBoundingClientRect();

                                var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.x + rect.left;
                                var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.y + rect.top;
                                //var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                //var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;

                                var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                                var centercanvX = (canvasowidth / 2);
                                var centercanvY = (canvasoheight / 2);

                                var centerx = xrect + (wrect*0.5);
                                var centery = yrect + (hrect*0.5);

                                var CanvRotRad = DocObj.pages[DocObj.currentpage].drotation * (Math.PI / 180);



                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rectcenter = DocObj.markuplist[DocObj.selectedmarkup.id].getRotatedMarkup(centercanvX, centercanvY, centerx, centery, CanvRotRad);
                                    centerx = rectcenter.x;
                                    centery = rectcenter.y;

                                }


                                centerx += rect.left;
                                centery += rect.top;


                                //DocObj.pages[DocObj.currentpage].drotation;
                                var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;
                                txtrect.rotation = DocObj.markuplist[DocObj.selectedmarkup.id].pagerotation;

                                RxCore_GUI_TextInput.setTextInput(txtrect);
                                DocObj.selectedmarkup.edit = false;
                            }


                            //setTextContent(DocObj.markuplist[listentrynum].text);
                            //showTextDialog();
                            //MarkupUndoObject.add(textedit,id,oldtext);
                            DrawMarkupSelected(context);
                            drawmarkupAll(cntximg);
                            tool.started = false;


                            //var markuptext = prompt("Edit markup text",curmarkuptext);
                            /*if (markuptext != null && markuptext != ""){
                             //DocObj.markuplist[listentrynum].text = markuptext;
                             }*/

                        }
                        if (DocObj.markuplist[listentrynum].type == 10) {
                            DocObj.selectedmarkup.id = listentrynum;
                            /*DocObj.selectedmarkup.edit = true;
                            if (RxCore_GUI_Notediag != undefined) {
                                RxCore_GUI_Notediag.setNotediag(DocObj.markuplist[listentrynum].text, false);
                            }*/

                            //setNContent(DocObj.markuplist[listentrynum].text);
                            //setNContent(DocObj.markuplist[TempID].text);
                            //showNDialog(false);
                            /*DocObj.markuplist[listentrynum].selected = false;
                            drawmarkupAll(cntximg);
                            DrawMarkupSelected(context);
                            tool.started = false;*/


                        }

                    } else {
                        tool.started = false;

                        tool.savestate = true;

                    }


                };

                this.doubletap = function (touchPos) {
                    //if markup selected go to editmode for polygons and text.
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }


                    if(DocObj.bMarkupLocked){
                        id = -1;
                        //id = finddoublemarkup(touchPos.x, touchPos.y);
                    }else{
                        id = finddoublemarkup(touchPos.x, touchPos.y);
                        listentrynum = DocObj.getmarkupbynumber(id);


                    }

                    if (id == -1 && !DocObj.markuplist[listentrynum].locked) {
                        tool.started = false;

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        tool.savestate = true;
                    } else {
                        if (tool.savestate) {
                            MarkupSaveState(id);
                            if(DocObj){
                                DocObj.bMarkupchanged = true;
                            }

                        }
                        tool.savestate = false;

                        if (DocObj.markuplist[listentrynum].type == 9) {
                            var curmarkuptext = DocObj.markuplist[listentrynum].text;
                            if (RxCore_GUI_TextInput != undefined) {

                                RxCore_GUI_TextInput.operation.start = false;
                                RxCore_GUI_TextInput.operation.create = false;
                                RxCore_GUI_TextInput.operation.edit = true;
                                RxCore_GUI_TextInput.operation.save = false;

                                var rect = canvas.getBoundingClientRect();
                                /*var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;
                                var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                                var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                RxCore_GUI_TextInput.setTextInput(txtrect);*/

                                var xrect = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.x + rect.left;
                                var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.y + rect.top;

                                //var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                //var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;

                                var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                                var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;
                                RxCore_GUI_TextInput.setTextInput(txtrect);

                                DocObj.selectedmarkup.edit = false;

                                //RxCore_GUI_TextInput.setTextInput(xrect,yrect,wrect,hrect);
                            }

                            /*var markuptext = prompt("Edit markup text", curmarkuptext);
                            if (markuptext != null && markuptext != "") {
                                DocObj.markuplist[listentrynum].text = markuptext;
                                drawmarkupAll(cntximg);
                                DrawMarkupSelected(context);
                                tool.started = false;
                            }*/
                        }
                        if (DocObj.markuplist[listentrynum].type == 10) {
                            DocObj.selectedmarkup.id = listentrynum;
                            //setNContent(DocObj.markuplist[listentrynum].text);
                            //showNDialog(false);
                            /*if (RxCore_GUI_Notediag != undefined) {
                                RxCore_GUI_Notediag.setNotediag(DocObj.markuplist[listentrynum].text, false);
                            }*/

                            /*DocObj.markuplist[listentrynum].selected = false;
                            drawmarkupAll(cntximg);
                            DrawMarkupSelected(context);
                            tool.started = false;*/

                        }

                    }
                };

                this.touchstart = function (ev) {
                    if (!documentopen) {
                        return;
                    }
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }


                    ev.preventDefault();
                    tool.started = true;
                    var touchPos0 = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos0.x;
                    var touchy = touchPos0.y;

                    startx = touchPos0.x;
                    starty = touchPos0.y;

                    prevx = touchx;
                    prevy = touchy;
                    x = touchx;
                    y = touchy;

                    var lastTouch = 0;
                    var now = new Date().getTime();
                    if (tool.LastTouchdata == -1) {
                        lastTouch = now + 1;
                    } else {
                        lastTouch = tool.LastTouchdata;
                    }
                    var delta = now - lastTouch;
                    tool.LastTouchdata = now;


                    switch (ev.targetTouches.length) {
                        case 1:
                            if (delta < 500 && delta > 0) {
                                tool.doubletap(touchPos0);
                            } else {

                                if(DocObj.bMarkupLocked){
                                    //id = -1;
                                    fmarkup = findmarkup(touchx, touchy, bCanSelectSpace);
                                    id = fmarkup.id;

                                    if(fmarkup.blink){
                                        tool.started = false;

                                        if (RxCore_GUI_MarkupLink != undefined) {
                                            RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                                        }
                                        return;
                                    }

                                    listentrynum = DocObj.getmarkupbynumber(id);

                                }else{
                                    fmarkup = findmarkup(touchx, touchy, bCanSelectSpace);
                                    id = fmarkup.id;

                                    if(fmarkup.blink && fmarkup.locked){
                                        tool.started = false;

                                        if (RxCore_GUI_MarkupLink != undefined) {
                                            RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                                        }
                                        return;

                                    }
                                    /*if(fmarkup.blink){
                                        tool.started = false;

                                        if (RxCore_GUI_MarkupLink != undefined) {
                                            RxCore_GUI_MarkupLink.markupLink(DocObj.markuplist[fmarkup.index]);
                                        }
                                        return;
                                    }*/

                                    listentrynum = DocObj.getmarkupbynumber(id);

                                }

                                if (id == -1) {
                                    tool.started = false;

                                    //context.clearRect(0, 0, canvas.width, canvas.height);
                                    drawmarkupAll(cntximg);
                                    DrawMarkupSelected(context);
                                    tool.mousedownhandling(ev, touchPos0);

                                    tool.savestate = true;
                                } else {
                                    if (tool.savestate) {
                                        MarkupSaveState(id);
                                        if(DocObj){
                                            DocObj.bMarkupchanged = true;
                                        }

                                    }
                                    tool.savestate = false;

                                    drawmarkupAll(cntximg);
                                    DrawMarkupSelected(context);
                                    if (DocObj.markuplist[listentrynum].type == 9) {
                                        if (RxCore_GUI_TextInput != undefined) {
                                            if(DocObj.selectedmarkup.edit){
                                                RxCore_GUI_TextInput.operation.edit = false;
                                                RxCore_GUI_TextInput.operation.start = false;
                                                RxCore_GUI_TextInput.operation.create = false;
                                                RxCore_GUI_TextInput.operation.save = true;

                                                var rect = canvas.getBoundingClientRect();
                                                var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.x + rect.left;
                                                var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.y + rect.top;
                                                //var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                                //var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;

                                                var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                                var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                                                var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                                txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;
                                                RxCore_GUI_TextInput.setTextInput(txtrect);

                                                /*var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                                                var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;
                                                var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                                                var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;
                                                var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                                                RxCore_GUI_TextInput.setTextInput(txtrect);*/

                                                //RxCore_GUI_TextInput.setTextInput(xrect,yrect,wrect,hrect);
                                            }
                                        }

                                        DocObj.selectedmarkup.id = listentrynum;
                                    }

                                    if (DocObj.markuplist[listentrynum].editaction == 4 && tool.bdeletepoint) {
                                        DocObj.markuplist[listentrynum].deletepoint(DocObj.markuplist[listentrynum].selectedpoint);
                                        drawmarkupAll(cntximg);
                                        DrawMarkupSelected(context);
                                        tool.bdeletepoint = false;
                                    }

                                    if (DocObj.markuplist[listentrynum].editaction == 7 && tool.binsertpoint) {
                                        DocObj.markuplist[listentrynum].insertpoint();
                                        drawmarkupAll(cntximg);
                                        DrawMarkupSelected(context);
                                        tool.binsertpoint = false;

                                    }


                                    if (DocObj.markuplist[listentrynum].type == 10) {
                                        DocObj.selectedmarkup.id = listentrynum;
                                    }

                                }
                            }

                            break;

                        case 2:
                            var touchPos1 = getTouchPos(canvas, ev, 1);
                            startx2 = touchPos1.x;
                            starty2 = touchPos1.y;
                            startw = Math.abs(startx2 - startx);
                            starth = Math.abs(starty2 - starty);
                            startdeltax = startx2 - startx;
                            startdeltay = starty2 - starty;
                            startangle = Math.atan2(startdeltay, startdeltax) * 180 / Math.PI;

                            startwsq = Math.pow(startw, 2);
                            starthsq = Math.pow(starth, 2);

                            startdiagonal = Math.sqrt((startwsq + starthsq));
                            prevdiagonal = startdiagonal;

                            //center of two touchpoints.
                            startcenterx = startx + (startw / 2);
                            startcentery = starty + (starth / 2);
                            prevcenterx = startcenterx;
                            prevcentery = startcentery;
                            prevh = starth;
                            prevw = startw;

                            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                                startscalesmall = DocObj.pages[DocObj.currentpage].dscalevector;
                                startscalelarge = DocObj.pages[DocObj.currentpage].dscalevector;
                            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                                startscalesmall = DocObj.pages[DocObj.currentpage].dscalepdf;
                                startscalelarge = DocObj.pages[DocObj.currentpage].dscalepdf;

                            } else {
                                startscalesmall = DocObj.pages[DocObj.currentpage].dscale;
                                startscalelarge = DocObj.pages[DocObj.currentpage].dscale;

                            }

                            break;
                    }


                };

                this.MSPointerMove = function (ev) {
                    if (!documentopen) {
                        return;
                    }
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }


                    var snapoverride = false;
                    var i = 0;
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;
                    while (i < touchpointarr.length) {

                        if (touchpointarr[i].pointID == ev.pointerId) {
                            touchpointarr[i].x = mousePos.x;
                            touchpointarr[i].y = mousePos.y;
                        }
                        i++;
                    }
                    switch (touchpointarr.length) {
                        case 0:
                            tool.labelhandler(mousePos, ev);
                            if (!tool.started) {
                                return;
                            }

                            break;
                        case 1:
                            if (!tool.started) {
                                return;
                            }
                            var xdiff = prevx - mousePos.x;
                            var ydiff = prevy - mousePos.y;


                            if (ev.buttons == 1) {

                                if (id != -1 && !DocObj.bMarkupLocked && !DocObj.markuplist[listentrynum].locked) {
                                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                                    if (!snapPoint || !snapPoint.found || snapPoint == undefined){
                                        havesnap = false;
                                    }else{
                                        havesnap = snapPoint.found || snapPoint != undefined;
                                    }

                                    if (DocObj.markuplist[listentrynum].editaction == 4) {
                                        if (havesnap) {
                                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                                rotatedpoint = snap_rotated(snapPoint);
                                            }else{
                                                rotatedpoint = snapPoint;
                                            }

                                            xdiff = prevx - rotatedpoint.x;
                                            ydiff = prevy - rotatedpoint.y;
                                            snapoverride = true;
                                        }


                                        var bWithin = MousePosdrwext(mousePos);
                                        if (bWithin || !bLimMarkupExtent) {
                                            DocObj.markuplist[listentrynum].editpoint(xdiff, ydiff, DocObj.markuplist[listentrynum].selectedpoint);

                                            if(RxCore_GUI_MarkupAreaEdit != undefined && DocObj.markuplist[listentrynum].type == 8){
                                                RxCore_GUI_MarkupAreaEdit.onDrawEvent(DocObj.markuplist[listentrynum].dimtext);
                                            }

                                        }

                                        DrawMarkupSelected(context);
                                        //drawmarkupAll(cntximg);
                                        tool.changedstate = true;

                                    }

                                    if (DocObj.markuplist[listentrynum].editaction == 1) {
                                        //modify to allow multiple move
                                        ev.target.style.cursor = 'move';

                                        if (bMultiselect || DocObj.getMarkupMultiselected()){
                                            //new method in document object to move all selected if multi select is on.
                                            DocObj.moveselected(xdiff, ydiff);

                                        }else{
                                            DocObj.markuplist[listentrynum].move(xdiff, ydiff);

                                        }

                                        //drawmarkupAll(cntximg);
                                        DrawMarkupSelected(context);



                                        tool.changedstate = true;


                                    }

                                    if (DocObj.markuplist[listentrynum].editaction == 2) {
                                        if (havesnap) {
                                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                                var rotatedpoint = snap_rotated(snapPoint);
                                            }else{
                                                rotatedpoint = snapPoint;
                                            }

                                            xdiff = prevx - rotatedpoint.x;
                                            ydiff = prevy - rotatedpoint.y;
                                            snapoverride = true;
                                        }

                                        ev.target.style.cursor = 'nw-resize';
                                        DocObj.markuplist[listentrynum].scale(xdiff, ydiff, DocObj.markuplist[listentrynum].scalecorner, context);

                                        DrawMarkupSelected(context);
                                        //drawmarkupAll(cntximg);
                                        tool.changedstate = true;


                                    }
                                    if (DocObj.markuplist[listentrynum].editaction == 3) {
                                        DocObj.markuplist[listentrynum].rotate(mousePos.x, mousePos.y, DocObj.markuplist[listentrynum].scalecorner);
                                        DrawMarkupSelected(context);
                                        //drawmarkupAll(cntximg);
                                        tool.changedstate = true;

                                    }

                                    if(DocObj.markuplist[listentrynum].editaction == 6){
                                        ev.target.style.cursor = 'move';
                                        DocObj.markuplist[listentrynum].dimextend(mousePos.x, mousePos.y);

                                        //drawmarkupAll(cntximg);
                                        DrawMarkupSelected(context);
                                        tool.changedstate = true;

                                    }

                                    if(DocObj.markuplist[listentrynum].editaction == 8 && tool.bmovelabel && !bMarkupNoLabel){
                                        ev.target.style.cursor = 'move';
                                        DocObj.markuplist[listentrynum].movelabel(xdiff, ydiff);

                                        //drawmarkupAll(cntximg);
                                        DrawMarkupSelected(context);
                                        tool.changedstate = true;

                                    }



                                } else {
                                    //cntximg.clearRect(0, 0, canvas.width, canvas.height);
                                    //context.clearRect(0, 0, canvas.width, canvas.height);

                                    tool.movehandler(mousePos, ev);
                                }

                                if (snapoverride && havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }

                                    prevx = rotatedpoint.x;
                                    prevy = rotatedpoint.y;

                                } else {
                                    prevx = mousePos.x;
                                    prevy = mousePos.y;

                                }
                            } else if (ev.buttons == 4) {
                                DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                prevx = mousePos.x;
                                prevy = mousePos.y;
                                DrawMarkupSelected(context);
                            } else {

                            }
                            break;
                        case 2:
                            if (!mstouchzoom) {
                                return;
                            }
                            xcur1 = touchpointarr[0].x;
                            ycur1 = touchpointarr[0].y;
                            xcur2 = touchpointarr[1].x;
                            ycur2 = touchpointarr[1].y;

                            //establish rectangle from two points
                            x = Math.min(xcur1, xcur2);
                            y = Math.min(ycur1, ycur2);
                            w = Math.abs(xcur2 - xcur1);
                            h = Math.abs(ycur2 - ycur1);

                            //calculate diagonal from width and height of rectangle
                            wsq = Math.pow(w, 2);
                            hsq = Math.pow(h, 2);
                            diagonal = Math.sqrt((wsq + hsq));
                            //if previous diagonal smaller than current zoomfactor > 1 else smaller

                            var diffdiagonal = diagonal - prevdiagonal;
                            var diagratio = 1 / prevdiagonal;
                            var zoomscalefactor = diagonal * diagratio;

                            //center of two touchpoints.
                            centerx = x + (w / 2);
                            centery = y + (h / 2);

                            xdiff = prevcenterx - centerx;
                            ydiff = prevcentery - centery;
                            var wdiff = prevw - w;
                            var hdiff = prevh - h;

                            if (diffdiagonal > 2 || diffdiagonal < -2) {
                                DocObj.pages[DocObj.currentpage].ZoomIn(zoomscalefactor, false, false);

                            }


                            prevdiagonal = diagonal;
                            prevcenterx = centerx;
                            prevcentery = centery;
                            prevw = w;
                            prevh = h;
                            break;
                    }


                    //console.log(ev.buttons);
                    //pan_update(xdiff, ydiff);
                    //movemarkup(id,xdiff,ydiff)


                };


                this.mouseout = function(ev){

                    /*var mousePos = getMousePos(canvas, ev);
                    tool.x0 = mousePos.x;
                    tool.y0 = mousePos.y;

                    prevx = tool.x0;
                    prevy = tool.y0;*/
                    id = -1;

                };

                this.mousemove = function (ev) {
                    if (!documentopen) {
                        return;
                    }
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }

                    var bwithinbounds = true;
                    var snapoverride = false;
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;
                    tool.labelhandler(mousePos, ev);


                    if (!tool.started) {
                        return;

                    }

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    if (ev.button == 0) {
                        if (id != -1 && !DocObj.bMarkupLocked && !DocObj.markuplist[listentrynum].locked) {

                            snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);
                            if (!snapPoint || !snapPoint.found || snapPoint == undefined){
                                havesnap = false;
                            }else{
                                havesnap = snapPoint.found || snapPoint != undefined;
                            }

                            if (DocObj.markuplist[listentrynum].editaction == 4) {
                                if (havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }

                                    xdiff = prevx - rotatedpoint.x;
                                    ydiff = prevy - rotatedpoint.y;
                                    //xdiff = snapPoint.x;
                                    //ydiff = snapPoint.y;

                                    snapoverride = true;
                                }

                                var bWithin = MousePosdrwext(mousePos);
                                if (bWithin || !bLimMarkupExtent) {
                                    //xdiff = prevx - mousePos.x;
                                    //ydiff = prevy - mousePos.y;
                                    if(DocObj.pages[DocObj.currentpage].drotation == 0){
                                        DocObj.markuplist[listentrynum].snapTo(mousePos.x, mousePos.y, DocObj.markuplist[listentrynum].selectedpoint);
                                    }else{
                                        var rotmousepoint = mouse_rotated(mousePos.x, mousePos.y);
                                        //function mouse_rotated(x,y){

                                        DocObj.markuplist[listentrynum].snapTo(rotmousepoint.x, rotmousepoint.y, DocObj.markuplist[listentrynum].selectedpoint);

                                    }


                                    if (havesnap) {
                                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                            //rotatedpoint = snap_rotated(snapPoint);
                                            rotatedpoint = snapPoint;
                                        }else{
                                            rotatedpoint = snapPoint;
                                        }
                                        DocObj.markuplist[listentrynum].snapTo(rotatedpoint.x, rotatedpoint.y, DocObj.markuplist[listentrynum].selectedpoint);
                                    }else{
                                        DocObj.markuplist[listentrynum].editpoint(xdiff, ydiff, DocObj.markuplist[listentrynum].selectedpoint);

                                        if(RxCore_GUI_MarkupAreaEdit != undefined && DocObj.markuplist[listentrynum].type == 8){

                                            RxCore_GUI_MarkupAreaEdit.onDrawEvent(DocObj.markuplist[listentrynum].dimtext);
                                        }

                                    }
                                }
                                DrawMarkupSelected(context);
                                //drawmarkupAll(cntximg);
                                tool.changedstate = true;
                            }

                            if (DocObj.markuplist[listentrynum].editaction == 1) {
                                //modify to allow multiple move
                                ev.target.style.cursor = 'move';

                                if (bMultiselect || DocObj.getMarkupMultiselected()){
                                    //new method in document object to move all selected if multi select is on.
                                    DocObj.moveselected(xdiff, ydiff);
                                }else{
                                    DocObj.markuplist[listentrynum].move(xdiff, ydiff);
                                }


                                //drawmarkupAll(cntximg);
                                DrawMarkupSelected(context);




                                tool.changedstate = true;


                            }

                            if (DocObj.markuplist[listentrynum].editaction == 2) {

                                if (havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        var rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }

                                    xdiff = prevx - rotatedpoint.x;
                                    ydiff = prevy - rotatedpoint.y;
                                    snapoverride = true;
                                }

                                if (DocObj.markuplist[listentrynum].scalecorner == 1 || DocObj.markuplist[listentrynum].scalecorner == 4) {
                                    ev.target.style.cursor = 'nw-resize';
                                } else {
                                    ev.target.style.cursor = 'ne-resize';
                                }

                                if (!havesnap){
                                    DocObj.markuplist[listentrynum].scale(xdiff, ydiff, DocObj.markuplist[listentrynum].scalecorner, context);
                                }else{
                                    if (DocObj.markuplist[listentrynum].type == 6 || DocObj.markuplist[listentrynum].type == 7){
                                        DocObj.markuplist[listentrynum].snapToCorner(snapPoint.x, snapPoint.y, DocObj.markuplist[listentrynum].scalecorner);
                                        //new snapto here.
                                    }else{
                                        DocObj.markuplist[listentrynum].scale(xdiff, ydiff, DocObj.markuplist[listentrynum].scalecorner, context);
                                    }

                                }


                                DrawMarkupSelected(context);
                                //drawmarkupAll(cntximg);
                                tool.changedstate = true;


                            }
                            if (DocObj.markuplist[listentrynum].editaction == 3) {
                                DocObj.markuplist[listentrynum].rotate(mousePos.x, mousePos.y, DocObj.markuplist[listentrynum].scalecorner);
                                DrawMarkupSelected(context);
                                //drawmarkupAll(cntximg);
                                tool.changedstate = true;

                            }

                            if(DocObj.markuplist[listentrynum].editaction == 6){
                                ev.target.style.cursor = 'move';
                                DocObj.markuplist[listentrynum].dimextend(mousePos.x, mousePos.y);

                                //drawmarkupAll(cntximg);
                                DrawMarkupSelected(context);
                                tool.changedstate = true;

                            }

                            if(DocObj.markuplist[listentrynum].editaction == 8 && tool.bmovelabel && !bMarkupNoLabel){
                                ev.target.style.cursor = 'move';
                                DocObj.markuplist[listentrynum].movelabel(xdiff, ydiff);

                                //drawmarkupAll(cntximg);
                                DrawMarkupSelected(context);
                                tool.changedstate = true;

                            }


                        } else {

                            //cntximg.clearRect(0, 0, canvas.width, canvas.height);
                            //context.clearRect(0, 0, canvas.width, canvas.height);
                            tool.movehandler(mousePos, ev);
                        }

                        if (snapoverride && havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            prevx = rotatedpoint.x;
                            prevy = rotatedpoint.y;

                        } else {
                            prevx = mousePos.x;
                            prevy = mousePos.y;

                        }
                    } else if (ev.button == 1) {
                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        prevx = mousePos.x;
                        prevy = mousePos.y;
                        DrawMarkupSelected(context);

                    } else {

                    }
                    //pan_update(xdiff, ydiff);
                    //movemarkup(id,xdiff,ydiff)


                    //prevx = mousePos.x;
                    //prevy = mousePos.y;

                };

                this.touchmove = function (ev) {
                    if (!documentopen) {
                        return;
                    }
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }

                    ev.preventDefault();


                    var touchPos0 = getTouchPos(canvas, ev, 0);
                    var eventx = touchPos0.x;
                    var eventy = touchPos0.y;
                    xcur1 = touchPos0.x;
                    ycur1 = touchPos0.y;

                    var xdiff = prevx - xcur1;
                    var ydiff = prevy - ycur1;

                    switch (ev.targetTouches.length) {
                        case 1:
                            if (id != -1 && !DocObj.bMarkupLocked && !DocObj.markuplist[listentrynum].locked) {
                                if (!tool.started) {
                                    return;
                                }
                                if (DocObj.markuplist[listentrynum].editaction == 1) {
                                    //modify to allow multiple move
                                    if (bMultiselect || DocObj.getMarkupMultiselected()){
                                        //new method in document object to move all selected if multi select is on.
                                        DocObj.moveselected(xdiff, ydiff);
                                    }else{
                                        DocObj.markuplist[listentrynum].move(xdiff, ydiff);
                                    }

                                    DrawMarkupSelected(context);


                                    //drawmarkupAll(cntximg);
                                    tool.changedstate = true;
                                }

                                if (DocObj.markuplist[listentrynum].editaction == 2) {
                                    DocObj.markuplist[listentrynum].scale(xdiff, ydiff, DocObj.markuplist[listentrynum].scalecorner, context);
                                    DrawMarkupSelected(context);
                                    //drawmarkupAll(cntximg);
                                    tool.changedstate = true;
                                }
                                if (DocObj.markuplist[listentrynum].editaction == 3) {
                                    DocObj.markuplist[listentrynum].rotate(eventx, eventy, DocObj.markuplist[listentrynum].scalecorner);
                                    DrawMarkupSelected(context);
                                    //drawmarkupAll(cntximg);
                                    tool.changedstate = true;

                                }
                                if (DocObj.markuplist[listentrynum].editaction == 4) {
                                    DocObj.markuplist[listentrynum].editpoint(xdiff, ydiff, DocObj.markuplist[listentrynum].selectedpoint);

                                    if(RxCore_GUI_MarkupAreaEdit != undefined && DocObj.markuplist[listentrynum].type == 8){
                                        RxCore_GUI_MarkupAreaEdit.onDrawEvent(DocObj.markuplist[listentrynum].dimtext);
                                    }


                                    DrawMarkupSelected(context);
                                    //drawmarkupAll(cntximg);
                                    tool.changedstate = true;

                                }
                                if(DocObj.markuplist[listentrynum].editaction == 6){
                                    ev.target.style.cursor = 'move';
                                    DocObj.markuplist[listentrynum].dimextend(touchPos0.x, touchPos0.y);

                                    //drawmarkupAll(cntximg);
                                    DrawMarkupSelected(context);
                                    tool.changedstate = true;

                                }

                                if(DocObj.markuplist[listentrynum].editaction == 8 && tool.bmovelabel && !bMarkupNoLabel){
                                    ev.target.style.cursor = 'move';
                                    DocObj.markuplist[listentrynum].movelabel(xdiff, ydiff);

                                    //drawmarkupAll(cntximg);
                                    DrawMarkupSelected(context);
                                    tool.changedstate = true;

                                }



                            } else {
                                //cntximg.clearRect(0, 0, canvas.width, canvas.height);
                                //context.clearRect(0, 0, canvas.width, canvas.height);
                                //tool.movehandler(touchPos0,ev);
                                //tool.panhandle(xdiff,ydiff);
                                if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                                    if (DocObj.pages[DocObj.currentpage].initialscale < DocObj.pages[DocObj.currentpage].dscalevector) {
                                        if(xdiff < 50 && ydiff < 50){
                                            DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                        }

                                    }

                                } else {
                                    if (DocObj.Type == 0) {
                                        if (DocObj.pages[DocObj.currentpage].startx < 0 || DocObj.pages[DocObj.currentpage].endx > canvas.width) {
                                            if(xdiff < 50 && ydiff < 50){
                                                DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                            }

                                        } else {
                                            if(documentcompare){
                                                DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                            }else{
                                                DocObj.pages[DocObj.currentpage].pan_update(0, ydiff);
                                            }

                                        }

                                    }
                                    if (DocObj.pages[DocObj.currentpage].initialscale < (DocObj.pages[DocObj.currentpage].dscale / DocObj.pages[DocObj.currentpage].bitmapratio)) {
                                        if (DocObj.Type == 0) {
                                            if(documentcompare){
                                                DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                            }else{
                                                DocObj.pages[DocObj.currentpage].pan_update(0, ydiff);
                                            }

                                        } else {
                                            if(xdiff < 50 && ydiff < 50){
                                                DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                                            }

                                        }

                                    }

                                }

                            }


                            prevx = touchPos0.x;
                            prevy = touchPos0.y;
                            break;

                        case 2:
                            var touchPos1 = getTouchPos(canvas, ev, 1);
                            xcur2 = touchPos1.x;
                            ycur2 = touchPos1.y;
                            w = Math.abs(xcur2 - xcur1);
                            h = Math.abs(ycur2 - ycur1);
                            wsq = Math.pow(w, 2);
                            hsq = Math.pow(h, 2);
                            diagonal = Math.sqrt((wsq + hsq));
                            var diffdiagonal = diagonal - prevdiagonal;


                            /* Andriy:: Do we really need scalechanged var? */
                            var scalechanged = false;

                            var diagratio = 1 / prevdiagonal;
                            var zoomscalefactor = diagonal * diagratio;
                            var deltax = xcur2 - xcur1;
                            var deltay = ycur2 - ycur1;
                            curangle = Math.atan2(deltay, deltax) * 180 / Math.PI;
                            diffangle = curangle - startangle;
                            //center of two touchpoints.
                            centerx = xcur1 + (w / 2);
                            centery = ycur1 + (h / 2);
                            var zoomcenter = {x:centerx, y:centery};

                            var wdiff = prevw - w;
                            var hdiff = prevh - h;

                            if (diffdiagonal > 2 || diffdiagonal < -2) {

                                if (zoomscalefactor < 1){
                                    var invertzoomscale = 1 / zoomscalefactor;
                                    var bUseZoomOut = true;
                                }else{
                                    invertzoomscale = zoomscalefactor;
                                    bUseZoomOut = false;
                                }

                                if (bUseZoomOut){
                                    if(tool.belowlimitExtent(invertzoomscale)){
                                        DocObj.pages[DocObj.currentpage].ZoomOut(invertzoomscale, false, false, zoomcenter);
                                        scalechanged = true;
                                    }else{
                                        scalechanged = false;
                                    }
                                }else{
                                    DocObj.pages[DocObj.currentpage].ZoomIn(invertzoomscale, false, false, zoomcenter);
                                }


                                /*if(tool.belowlimitExtent(invertzoomscale)){

                                    scalechanged = true;
                                }else{
                                    scalechanged = false;
                                }*/

                                prevdiagonal = diagonal;
                                //scalechanged = true;
                                /*if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                                    //var curscale = DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf;

                                    var pagedim = DocObj.pages[DocObj.currentpage].getpagedim();

                                    if((pagedim.w * zoomscalefactor) < canvasowidth && (pagedim.h * zoomscalefactor) < canvasoheight){
                                        scalechanged = false;
                                        DocObj.pages[DocObj.currentpage].zoomall();
                                    }

                                    //var cwidth = DocObj.pages[DocObj.currentpage].endx
                                    //if (DocObj.pages[DocObj.currentpage].endx - )



                                }else if (DocObj.pages[DocObj.currentpage].usevectorxml) {


                                    if (DocObj.pages[DocObj.currentpage].initialscale > DocObj.pages[DocObj.currentpage].dscalevector) {
                                        scalechanged = false;
                                        DocObj.pages[DocObj.currentpage].zoomall();

                                    }


                                } else {
                                    if (DocObj.pages[DocObj.currentpage].initialscale > (DocObj.pages[DocObj.currentpage].dscale / DocObj.pages[DocObj.currentpage].bitmapratio)) {
                                        scalechanged = false;
                                        DocObj.pages[DocObj.currentpage].zoomall();
                                    }

                                }*/

                            }
                            if (Math.abs(diffangle) > 10) {
                                // DocObj.pages[DocObj.currentpage].drotation = diffangle;
                            }


                            break;

                    }

                    prevcenterx = centerx;
                    prevcentery = centery;
                    prevw = w;
                    prevh = h;
                    prevx = xcur1;
                    prevy = ycur1;


                };

                this.keyup = function (ev){
                    if (typeof nScrollKeyNum.indexOf === "function"){
                        if (nScrollKeyNum.indexOf(ev.keyCode) >= 0){
                            tool.scrollkeyOn = false;
                        }

                    }


                    switch (ev.keyCode) {
                        case nScrollKeyNum:
                            tool.scrollkeyOn = false;
                            break;

                    }
                };
                this.keydown = function (ev) {
                    //ev.preventDefault();
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }


                    if (!documentopen || DocObj.bMarkupLocked) {
                        return;
                    }

                    if (typeof nScrollKeyNum.indexOf === "function"){
                        if (nScrollKeyNum.indexOf(ev.keyCode) >= 0){
                            tool.scrollkeyOn = true;
                        }
                    }


                    switch (ev.keyCode) {
                        case nScrollKeyNum:
                            tool.scrollkeyOn = true;
                            break;
                        case 13:
                            break;
                        case 8:
                            break;
                        case 46:
                            if(!bMultiselect){
                                if(listentrynum == - 1){
                                    break;
                                }

                                if(DocObj.markuplist[listentrynum] == undefined){
                                    break;
                                }

                            }

                            if(listentrynum != - 1){
                                if(DocObj.markuplist[listentrynum].type == 9 && DocObj.markuplist[listentrynum].selectedit){
                                    break;
                                }
                            }

                            if(bNoteFocus){
                                break;
                            }

                            deletemarkup();
                            break;

                    }

                };

                this.MSPointerUp = function (ev) {
                    if (!documentopen) {
                        return;
                    }

                    ev.target.style.cursor = 'default';
                    touchpointarr.pop();

                    if (tool.started) {
                        //tool.mousemove(ev);
                        if (id != -1) {
                            if (tool.changedstate) {
                                tool.savestate = true;



                            }
                            if (DocObj.markuplist[listentrynum].editaction == 4) {
                                DocObj.markuplist[listentrynum].findrectangle();
                                //drawmarkupAll(cntximg);

                            }
                            tool.started = false;

                        } else {
                            tool.mouseuphandler(ev);
                        }


                    }

                };
                this.mouseup = function (ev) {
                    if (!documentopen) {
                        return;
                    }

                    ev.target.style.cursor = 'default';


                    if (tool.started) {
                        //tool.mousemove(ev);
                        if (id != -1) {
                            if (tool.changedstate) {
                                tool.savestate = true;


                            }
                            if (DocObj.markuplist[listentrynum].editaction == 4) {
                                DocObj.markuplist[listentrynum].findrectangle();
                                //drawmarkupAll(cntximg);

                            }
                            tool.started = false;

                        } else {
                            tool.mouseuphandler(ev);
                        }

                        //tool.started = false;

                    }
                };

                this.touchcancel = function(ev){
                    if (!documentopen) {
                        return;
                    }
                    ev.preventDefault();
                    if (tool.started) {
                        if (id != -1) {
                            if (tool.changedstate) {
                                tool.savestate = true;


                            }
                            if (DocObj.markuplist[listentrynum].editaction == 4) {
                                DocObj.markuplist[listentrynum].findrectangle();
                                //drawmarkupAll(cntximg);

                            }
                            tool.started = false;

                            if (DocObj.Type == 0 && !documentcompare) {

                                if (DocObj.currentpage == 0) {
                                    while (DocObj.pages[DocObj.currentpage].starty > 0) {
                                        DocObj.pages[DocObj.currentpage].pan_update(0, 1);
                                    }


                                }
                                if (DocObj.currentpage == DocObj.NumPages - 1) {
                                    while (DocObj.pages[DocObj.currentpage].endy < canvas.height) {
                                        DocObj.pages[DocObj.currentpage].pan_update(0, -1);
                                    }

                                }
                            }
                        } else {
                            tool.mouseuphandler(ev);
                        }
                        //tool.touchmove(ev);


                    }
                };

                this.touchend = function (ev) {
                    if (!documentopen) {
                        return;
                    }
                    ev.preventDefault();
                    if (tool.started) {
                        if (id != -1) {
                            if (tool.changedstate) {
                                tool.savestate = true;


                            }
                            if (DocObj.markuplist[listentrynum].editaction == 4) {
                                DocObj.markuplist[listentrynum].findrectangle();
                                //drawmarkupAll(cntximg);

                            }
                            tool.started = false;

                            if (DocObj.Type == 0 && !documentcompare) {

                                if (DocObj.currentpage == 0) {
                                    while (DocObj.pages[DocObj.currentpage].starty > 0) {
                                        DocObj.pages[DocObj.currentpage].pan_update(0, 1);
                                    }


                                }
                                if (DocObj.currentpage == DocObj.NumPages - 1) {
                                    while (DocObj.pages[DocObj.currentpage].endy < canvas.height) {
                                        DocObj.pages[DocObj.currentpage].pan_update(0, -1);
                                    }

                                }
                            }
                        } else {
                            tool.mouseuphandler(ev);
                        }
                        //tool.touchmove(ev);


                    }
                };

            };

            // The arrow tool.
            tools.arrow = function (params) {

                var tool = this;
                var prevx = 0,
                    prevy = 0;

                var limprevx = 0,
                    limprevy = 0;

                var arrowmarkupobj;
                //ft 08.08.2018 changed from separate index to direct array length
                var curmarkup = DocObj.markuplist.length;
                //var curmarkup = DocObj.nummarkups;
                this.started = false;
                this.name = 'arrow';


                this.anglelengthsupport = true;

                var havesnap = false;
                var snapPoint;
                var type = params.p1;

                this.startx = 0;
                this.starty = 0;
                this.orgscale = 1.0;
                this.orgdx = 0.0;
                this.orgdy = 0.0;

                this.bUsemouseinput = true;

                this.curmousepos = {x:0,y:0};


                this.setAngleLength = function(angle, length, bAutoAdvance, type){
                    this.bUsemouseinput = false;
                    if (arrowmarkupobj != undefined){

                        arrowmarkupobj.x = tool.x0;
                        arrowmarkupobj.y = tool.y0;
                        var curx2 = arrowmarkupobj.w;
                        var cury2 = arrowmarkupobj.h;

                        var secondpoint = arrowmarkupobj.setAnglelength(length, angle, type);
                        //add state to markup object to change rotate adjustment bUsemouseinput
                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (MousePosdrwext({x:secondpoint.w,y:secondpoint.h})){
                            arrowmarkupobj.w = secondpoint.w;
                            arrowmarkupobj.h = secondpoint.h;
                            tool.setdimoffset(false);
                            arrowmarkupobj.drawme(context);

                        }else{
                            arrowmarkupobj.w = curx2;
                            arrowmarkupobj.h = cury2;

                            this.bUsemouseinput = true;
                            arrowmarkupobj.drawme(context);
                            arrowmarkupobj.bUsemouseinput = true;
                            if (RxCore_GUI_markupParamsError != undefined){
                                RxCore_GUI_markupParamsError.onDrawError('outside');
                            }

                        }

                    }


                };

                this.apply = function(){
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    tool.setdimoffset(false);
                    arrowmarkupobj.drawme(context);
                    if (!bMultimarkupadd) {

                        bMarkupcrated = true;
                        //ft 08.08.2018 changed from separate index to direct array length
                        //nMarkupcreated = DocObj.nummarkups;
                        nMarkupcreated = DocObj.markuplist.length;
                    }

                    arrowmarkupobj.savemetolistDraw();
                    //arrowmarkupobj.savemetolistLoad();
                    arrowmarkupobj = null;
                    tool.started = false;
                    //markupobject.markupnumber = DocObj.nummarkups;         DocObj.markuplist[markupobject.markupnumber] = this;
                    img_update();

                    if (!bMultimarkupadd) {
                        //need to move to connection object.
                        //markupcreated();
                        if (RxCore_GUI_Markup != undefined) {
                            //var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                        }

                    }
                };

                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }

                    if (movey < 0) {


                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == DocObj.NumPages - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {

                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);



                            if(tool.started){

                                tool.setdimoffset(false);

                            }



                        }


                    } else {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {


                            DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);



                            if(tool.started){
                                tool.setdimoffset(false);


                            }

                        }

                    }


                };

                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox

                        delta = -ev.deltaY*50;

                    }

                    tool.scrollhandling(delta);


                };

                this.setdimoffset = function(initial){

                    if(initial){

                        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                            arrowmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                            arrowmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                            arrowmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                            arrowmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                            arrowmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                            arrowmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                        } else {
                            arrowmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                            arrowmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                            arrowmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                        }
                        tool.orgscale = arrowmarkupobj.scaling;
                        tool.orgdx = arrowmarkupobj.xoffset;
                        tool.orgdy = arrowmarkupobj.yoffset;


                    }

                    //move operation to markup object.

                    var curscale = DocObj.pages[DocObj.currentpage].getdscale();
                    var pagedx = DocObj.pages[DocObj.currentpage].getdx();
                    var pagedy = DocObj.pages[DocObj.currentpage].getdy();


                    if(arrowmarkupobj){
                        var scalediff = (curscale / arrowmarkupobj.scaling);
                        var changex = ((arrowmarkupobj.w - pagedx) / scalediff) + arrowmarkupobj.xoffset;
                        var changey = ((arrowmarkupobj.h - pagedy) / scalediff) + arrowmarkupobj.yoffset;
                    }

                    //arrowmarkupobj.w = changex;
                    //arrowmarkupobj.h = changey;

                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);

                    if(ev.button == 0){
                        if (!tool.started) {

                            if (bWithin || !bLimMarkupExtent) {
                              tool.started = true;
                                if(DocObj){
                                    DocObj.bMarkupchanged = true;
                                }


                                if (havesnap) {

                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        var rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }

                                    tool.x0 = rotatedpoint.x;
                                    tool.y0 = rotatedpoint.y;

                                } else {
                                    tool.x0 = mousePos.x;
                                    tool.y0 = mousePos.y;

                                }

                                if (type == 10){
                                    arrowmarkupobj = new MarkupObject(4, 1, fillstyle);
                                }else{
                                    arrowmarkupobj = new MarkupObject(6, type, 0);
                                }




                                arrowmarkupobj.pagenumber = DocObj.getcurPage();
                                tool.setdimoffset(true);
                                tool.startx = tool.x0;
                                tool.starty = tool.y0;
                                arrowmarkupobj.editaction = 0;

                            }

                        } else {
                            //tool.mousemove(ev);
                            var ccentre = {x : tool.x0, y : tool.y0};
                            if (arrowmarkupobj.type == 4 && arrowmarkupobj.subtype == 1){
                                var bWithinradius = MousePosradiusdrwext(ccentre,mousePos);
                            }else{
                                bWithinradius = true;
                            }

                            if ((bWithin && bWithinradius) || !bLimMarkupExtent) {
                                if (havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }
                                    if (tool.bUsemouseinput){
                                        arrowmarkupobj.w = rotatedpoint.x;
                                        arrowmarkupobj.h = rotatedpoint.y;
                                    }

                                } else {
                                    if (tool.bUsemouseinput){
                                        arrowmarkupobj.w = mousePos.x;
                                        arrowmarkupobj.h = mousePos.y;
                                    }

                                }

                                context.clearRect(0, 0, canvas.width, canvas.height);
                                tool.setdimoffset(false);
                                arrowmarkupobj.drawme(context);
                                if (!bMultimarkupadd) {

                                    bMarkupcrated = true;
                                    //ft 08.08.2018 changed from separate index to direct array length
                                    nMarkupcreated = DocObj.markuplist.length;
                                    //nMarkupcreated = DocObj.nummarkups;
                                }
                                if (type == 6){


                                    var textby = arrowmarkupobj.h - ((defaultFont.height / 0.75)*0.5);
                                    var textbh = (defaultFont.height / 0.75);

                                    var textrect = {x : arrowmarkupobj.w, y :  textby, w : 100, h : textbh};
                                }
                                arrowmarkupobj.savemetolistDraw();
                                arrowmarkupobj = null;
                                tool.started = false;

                                img_update();

                                ev.target.style.cursor = 'default';

                                if (type == 6){
                                    textRect(textrect.x, textrect.y, textrect.w, textrect.h, DocObj.markuplist[nMarkupcreated]);
                                }

                                if (!bMultimarkupadd) {
                                    //need to move to connection object.
                                    //markupcreated();
                                    if (RxCore_GUI_Markup != undefined) {
                                        //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                        var operation = {created : true, modified : false, deleted : false};
                                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], operation);
                                    }

                                }
                            }


                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                };

                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    var bWithin = MousePosdrwext(mousePos);

                    if(ev.button == 0){
                        if (!tool.started) {
                            //context.strokeStyle = "red";

                            if (bWithin || !bLimMarkupExtent) {
                                tool.started = true;
                                if(DocObj){
                                    DocObj.bMarkupchanged = true;
                                }

                                if (havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        var rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }

                                    tool.x0 = rotatedpoint.x;
                                    tool.y0 = rotatedpoint.y;

                                } else {
                                    tool.x0 = mousePos.x;
                                    tool.y0 = mousePos.y;

                                }
                                if (type == 10){
                                    //circle
                                    arrowmarkupobj = new MarkupObject(4, 1, fillstyle);


                                }else{
                                    arrowmarkupobj = new MarkupObject(6, type, 0);
                                }




                                arrowmarkupobj.pagenumber = DocObj.getcurPage();
                                tool.setdimoffset(true);

                                tool.startx = tool.x0;
                                tool.starty = tool.y0;


                                arrowmarkupobj.editaction = 0;

                            }

                        } else {
                            var ccentre = {x : tool.x0, y : tool.y0};
                            if (arrowmarkupobj.type == 4 && arrowmarkupobj.subtype == 1){
                                var bWithinradius = MousePosradiusdrwext(ccentre,mousePos);
                            }else{
                                bWithinradius = true;
                            }

                            if ((bWithin && bWithinradius) || !bLimMarkupExtent) {
                                if (havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }
                                    if (tool.bUsemouseinput){
                                        arrowmarkupobj.w = rotatedpoint.x;
                                        arrowmarkupobj.h = rotatedpoint.y;
                                    }

                                } else {
                                    if (tool.bUsemouseinput){
                                        if(DocObj.pages[DocObj.currentpage].drotation != 0 && bOrthoOn){
                                            var rotpoint = ortho_rotate(mousePos);
                                            arrowmarkupobj.w = rotpoint.x;
                                            arrowmarkupobj.h = rotpoint.y;

                                        }else{
                                            arrowmarkupobj.w = mousePos.x;
                                            arrowmarkupobj.h = mousePos.y;

                                        }
                                    }

                                }


                                context.clearRect(0, 0, canvas.width, canvas.height);
                                tool.setdimoffset(false);
                                arrowmarkupobj.drawme(context);
                                if (!bMultimarkupadd) {

                                    bMarkupcrated = true;
                                    //ft 08.08.2018 changed from separate index to direct array length
                                    //nMarkupcreated = DocObj.nummarkups;
                                    nMarkupcreated = DocObj.markuplist.length;
                                }

                                if (type == 6){
                                    var textby = arrowmarkupobj.h - ((defaultFont.height / 0.75)*0.5);
                                    var textbh = (defaultFont.height / 0.75);

                                    var textrect = {x : arrowmarkupobj.w, y :  textby, w : 100, h : textbh};


                                }

                                arrowmarkupobj.savemetolistDraw();
                                arrowmarkupobj = null;
                                tool.started = false;
                                //markupobject.markupnumber = DocObj.nummarkups;         DocObj.markuplist[markupobject.markupnumber] = this;
                                img_update();

                                if (type == 6){
                                    textRect(textrect.x, textrect.y, textrect.w, textrect.h, DocObj.markuplist[nMarkupcreated]);
                                }

                                if (!bMultimarkupadd) {
                                    //need to move to connection object.
                                    //markupcreated();
                                    if (RxCore_GUI_Markup != undefined) {
                                        //var operation = {created : true, modified : false, deleted : false};
                                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                                        //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                    }

                                }

                            }

                        }

                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    //context.strokeStyle = "red";
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }

                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        return;
                    }

                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;


                    if (type == 10){
                        arrowmarkupobj = new MarkupObject(4, 1, fillstyle);
                    }else{
                        arrowmarkupobj = new MarkupObject(6, type, 0);
                    }

                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        arrowmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                        arrowmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                        arrowmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        arrowmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                        arrowmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                        arrowmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                    } else {
                        arrowmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                        arrowmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                        arrowmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;

                    }

                    arrowmarkupobj.pagenumber = DocObj.getcurPage();
                    arrowmarkupobj.editaction = 0;
                };


                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;


                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }

                    if (ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        tool.setdimoffset(false);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                    if (!tool.started) {

                        return;
                    }

                    var bWithin = MousePosdrwext(mousePos);

                    var ccentre = {x : tool.x0, y : tool.y0};
                    if (arrowmarkupobj.type == 4 && arrowmarkupobj.subtype == 1){
                        var bWithinradius = MousePosradiusdrwext(ccentre,mousePos);
                    }else{
                        bWithinradius = true;
                    }


                    if ((bWithin && bWithinradius) || !bLimMarkupExtent) {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        arrowmarkupobj.x = tool.x0;
                        arrowmarkupobj.y = tool.y0;

                        if (havesnap) {

                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            if (tool.bUsemouseinput){
                               arrowmarkupobj.w = rotatedpoint.x;
                               arrowmarkupobj.h = rotatedpoint.y;
                            }

                            limprevx = rotatedpoint.x;
                            limprevy = rotatedpoint.y;

                            //prevx = rotatedpoint.x;
                            //prevy = rotatedpoint.y;
                            drawsnap(context,snapPoint);



                        } else {

                            if (tool.bUsemouseinput){
                                arrowmarkupobj.w = mousePos.x;
                                arrowmarkupobj.h = mousePos.y;
                            }

                            limprevx = mousePos.x;
                            limprevy = mousePos.y;

                            //prevx = mousePos.x;
                            //prevy = mousePos.y;

                        }
                        tool.setdimoffset(false);


                        arrowmarkupobj.drawme(context);


                    } else {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        arrowmarkupobj.x = tool.x0;
                        arrowmarkupobj.y = tool.y0;

                        if (tool.bUsemouseinput){
                            arrowmarkupobj.w = limprevx;
                            arrowmarkupobj.h = limprevy;
                        }

                        tool.setdimoffset(false);




                        arrowmarkupobj.drawme(context);


                    }


                };


                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }

                    if (ev.button == 2 || ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        tool.setdimoffset(false);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                    if (!tool.started) {
                        return;
                    }

                    var bWithin = MousePosdrwext(mousePos);

                    var ccentre = {x : tool.x0, y : tool.y0};
                    if (arrowmarkupobj.type == 4 && arrowmarkupobj.subtype == 1){
                        var bWithinradius = MousePosradiusdrwext(ccentre,mousePos);
                    }else{
                        bWithinradius = true;
                    }

                    if ((bWithin && bWithinradius) || !bLimMarkupExtent) {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        if (tool.bUsemouseinput){
                            arrowmarkupobj.x = tool.x0;
                            arrowmarkupobj.y = tool.y0;

                        }

                        if (havesnap) {

                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            if (tool.bUsemouseinput){
                                arrowmarkupobj.w = rotatedpoint.x;
                                arrowmarkupobj.h = rotatedpoint.y;
                            }

                            limprevx = rotatedpoint.x;
                            limprevy = rotatedpoint.y;
                            //prevx = rotatedpoint.x;
                            //prevy = rotatedpoint.y;
                            drawsnap(context,snapPoint);


                        } else {
                            if (tool.bUsemouseinput){
                                arrowmarkupobj.w = mousePos.x;
                                arrowmarkupobj.h = mousePos.y;

                            }

                            limprevx = mousePos.x;
                            limprevy = mousePos.y;

                            //prevx = mousePos.x;
                            //prevy = mousePos.y;

                        }
                        tool.setdimoffset(false);

                        //comment out test to check problem
                        arrowmarkupobj.drawme(context);




                    } else {
                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (tool.bUsemouseinput){
                            arrowmarkupobj.x = tool.x0;
                            arrowmarkupobj.y = tool.y0;
                        }

                        if (tool.bUsemouseinput){
                            arrowmarkupobj.w = limprevx;
                            arrowmarkupobj.h = limprevy;
                        }

                        tool.setdimoffset(false);

                        //comment out test to check problem
                        arrowmarkupobj.drawme(context);

                        //if (tool.bUsemouseinput){

                        //}

                    }


                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    if (bWithin || !bLimMarkupExtent) {

                        arrowmarkupobj.x = tool.x0;
                        arrowmarkupobj.y = tool.y0;

                        if (tool.bUsemouseinput){
                            arrowmarkupobj.w = touchPos.x;
                            arrowmarkupobj.h = touchPos.y;
                        }


                        prevx = touchPos.x;
                        prevy = touchPos.y;

                    } else {
                        arrowmarkupobj.x = tool.x0;
                        arrowmarkupobj.y = tool.y0;

                        if (tool.bUsemouseinput){
                            arrowmarkupobj.w = prevx;
                            arrowmarkupobj.h = prevy;
                        }


                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    arrowmarkupobj.drawme(context);


                };

                this.MSPointerUp = function (ev) {
                    ev.preventDefault();
                    /*ev.target.style.cursor = 'default';
                     if (tool.started) {
                     tool.mousemove(ev);
                     arrowmarkupobj.savemetolist();
                     arrowmarkupobj = null;
                     tool.started = false;

                     img_update();

                     }*/

                };
                this.mouseup = function (ev) {
                    ev.preventDefault();
                    /* ev.target.style.cursor = 'default';
                     if (tool.started) {
                     tool.mousemove(ev);
                     arrowmarkupobj.savemetolist();
                     arrowmarkupobj = null;
                     tool.started = false;

                     img_update();

                     }*/
                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    if (tool.started) {
                        if (!bMultimarkupadd) {

                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            nMarkupcreated = DocObj.markuplist.length;
                            //nMarkupcreated = DocObj.nummarkups;
                        }

                        if (type == 6){
                            var textby = arrowmarkupobj.h - ((defaultFont.height / 0.75)*0.5);
                            var textbh = (defaultFont.height / 0.75);

                            var textrect = {x : arrowmarkupobj.w, y :  textby, w : 100, h : textbh};


                        }

                        arrowmarkupobj.savemetolistDraw();
                        img_update();
                        tool.touchmove(ev);
                        tool.started = false;
                        arrowmarkupobj = null;

                        if (type == 6){
                            textRect(textrect.x, textrect.y, textrect.w, textrect.h, DocObj.markuplist[nMarkupcreated]);
                        }


                        if (!bMultimarkupadd) {
                            //need to move to connection object.
                            //markupcreated();
                            if (RxCore_GUI_Markup != undefined) {
                                //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            }

                        }

                    }
                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    if (tool.started) {
                        if (!bMultimarkupadd) {

                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            nMarkupcreated = DocObj.markuplist.length;
                            //nMarkupcreated = DocObj.nummarkups;
                        }

                        arrowmarkupobj.savemetolistDraw();
                        img_update();


                        tool.touchmove(ev);

                        if (type == 6){

                            var textby = arrowmarkupobj.h - ((defaultFont.height / 0.75)*0.5);
                            var textbh = (defaultFont.height / 0.75);

                            var textrect = {x : arrowmarkupobj.w, y :  textby, w : 100, h : textbh};


                        }


                        tool.started = false;
                        arrowmarkupobj = null;

                        if (type == 6){
                            textRect(textrect.x, textrect.y, textrect.w, textrect.h, DocObj.markuplist[nMarkupcreated]);
                        }


                        if (!bMultimarkupadd) {
                            //need to move to connection object.
                            //markupcreated();
                            if (RxCore_GUI_Markup != undefined) {
                                //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            }

                        }

                    }
                };


            };


            tools.Polycurve = function (params) {
                var tool = this;
                var prevx = 0,
                    prevy = 0;
                this.started = false;
                this.name = 'Polycurve';
                this.anglelengthsupport = false;

                this.terminated = false;
                this.LastTouchdata = -1;
                //ft 08.08.2018 changed from separate index to direct array length
                //var curmarkup = DocObj.nummarkups;
                var curmarkup = DocObj.markuplist.length;
                var polycurvemarkupobj;
                var subtype = params.p1;

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                /*this.pointerup = function(ev){
                 tool.MSPointerUp(ev);
                 };*/


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;
                    }


                    if (!tool.started) {

                        polycurvemarkupobj = new MarkupObject(2, subtype, 0);
                        polycurvemarkupobj.pagenumber = DocObj.getcurPage();
                        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                            polycurvemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                            polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                            polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                            polycurvemarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                            polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                            polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                        } else {
                            polycurvemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                            polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                            polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                        }

                        polycurvemarkupobj.x = mousePos.x;
                        polycurvemarkupobj.y = mousePos.y;
                        polycurvemarkupobj.editaction = 0;
                        polycurvemarkupobj.addpoint(mousePos.x, mousePos.y);
                        tool.started = true;
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        polycurvemarkupobj.startdraw(context);
                        polycurvemarkupobj.addpoint(mousePos.x, mousePos.y);
                    } else {

                        polycurvemarkupobj.addpoint(mousePos.x, mousePos.y);
                    }

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }

                        ev.target.style.cursor = 'default';
                        return;
                    }

                    if (!tool.started) {
                        polycurvemarkupobj = new MarkupObject(2, subtype, 0);
                        polycurvemarkupobj.pagenumber = DocObj.getcurPage();
                        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                            polycurvemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                            polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                            polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                            polycurvemarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                            polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                            polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                        } else {
                            polycurvemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                            polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                            polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                        }

                        polycurvemarkupobj.x = mousePos.x;
                        polycurvemarkupobj.y = mousePos.y;
                        polycurvemarkupobj.editaction = 0;
                        polycurvemarkupobj.addpoint(mousePos.x, mousePos.y);
                        tool.started = true;
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                        polycurvemarkupobj.startdraw(context);
                        polycurvemarkupobj.addpoint(mousePos.x, mousePos.y);
                    } else {

                        polycurvemarkupobj.addpoint(mousePos.x, mousePos.y);
                    }


                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (!tool.started) {
                        return;
                    }
                    if (bWithin || !bLimMarkupExtent) {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        polycurvemarkupobj.setlastpoint(mousePos.x, mousePos.y);
                        polycurvemarkupobj.drawme(context);

                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    } else {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        polycurvemarkupobj.setlastpoint(prevx, prevy);
                        polycurvemarkupobj.drawme(context);


                    }

                };

                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if (!tool.started) {
                        return;
                    }
                    var bWithin = MousePosdrwext(mousePos);
                    if (bWithin || !bLimMarkupExtent) {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        polycurvemarkupobj.setlastpoint(mousePos.x, mousePos.y);
                        polycurvemarkupobj.drawme(context);

                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    } else {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        polycurvemarkupobj.setlastpoint(prevx, prevy);
                        polycurvemarkupobj.drawme(context);


                    }

                };

                this.mouseup = function (ev) {
                    //polycurvemarkupobj.addpoint(mousePos.x, ev._y);

                };

                this.dblclick = function (ev) {
                    if (tool.started) {
                        tool.mousemove(ev);
                        //tool.started = false;
                        tool.started = false;
                        polycurvemarkupobj.points.splice(polycurvemarkupobj.numpoints - 1, 2);
                        polycurvemarkupobj.findrectangle();
                        polycurvemarkupobj.savemetolistDraw();
                        polycurvemarkupobj = null;
                        img_update();
                        ev.target.style.cursor = 'default';
                    }

                };
                this.doubletap = function (ev) {
                    if (tool.started) {
                        tool.started = false;
                        polycurvemarkupobj.points.splice(polycurvemarkupobj.points.length - 1, 1);
                        polycurvemarkupobj.findrectangle();
                        polycurvemarkupobj.savemetolistDraw();
                        polycurvemarkupobj = null;
                        img_update();

                        //tool.terminated = true;

                    }

                };


                this.touchstart = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;
                    var lastTouch = 0;

                    var now = new Date().getTime();
                    if (tool.LastTouchdata == -1) {
                        lastTouch = now + 1;
                    } else {
                        lastTouch = tool.LastTouchdata;

                    }
                    var delta = now - lastTouch;
                    tool.LastTouchdata = now;

                    if (delta < 500 && delta > 0) {
                        tool.doubletap(ev);


                    } else {
                        var bWithin = MousePosdrwext(touchPos);
                        if (!bWithin && bLimMarkupExtent) {
                            tool.started = false;
                            if(DocObj){
                                DocObj.bMarkupchanged = false;
                            }

                            return;
                        }

                        if (!tool.started) {
                            polycurvemarkupobj = new MarkupObject(2, subtype, 0);
                            polycurvemarkupobj.pagenumber = DocObj.getcurPage();
                            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                                polycurvemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                                polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                                polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                                polycurvemarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                                polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                                polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                            } else {
                                polycurvemarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                                polycurvemarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                                polycurvemarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                            }

                            polycurvemarkupobj.x = touchx;
                            polycurvemarkupobj.y = touchy;
                            polycurvemarkupobj.editaction = 0;
                            polycurvemarkupobj.addpoint(touchx, touchy);
                            polycurvemarkupobj.startdraw(context);
                            polycurvemarkupobj.addpoint(touchx, touchy);
                            tool.started = true;
                            if(DocObj){
                                DocObj.bMarkupchanged = true;
                            }


                        } else {
                            polycurvemarkupobj.addpoint(touchx, touchy);
                            //polygonmarkupobj.setlastpoint(touchx,touchy);
                        }

                    }

                };


                this.touchmove = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;
                    if (!tool.started) {
                        return;
                    }
                    var bWithin = MousePosdrwext(touchPos);
                    if (bWithin || !bLimMarkupExtent) {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        polycurvemarkupobj.setlastpoint(touchPos.x, touchPos.y);
                        polycurvemarkupobj.drawme(context);

                        prevx = touchPos.x;
                        prevy = touchPos.y;

                    } else {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        polycurvemarkupobj.setlastpoint(prevx, prevy);
                        polycurvemarkupobj.drawme(context);


                    }

                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;

                    if (tool.started) {
                        var bWithin = MousePosdrwext(touchPos);
                        if (bWithin || !bLimMarkupExtent) {
                            polycurvemarkupobj.addpoint(touchx, touchy);
                        }

                    }
                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;

                    if (tool.started) {
                        var bWithin = MousePosdrwext(touchPos);
                        if (bWithin || !bLimMarkupExtent) {
                            polycurvemarkupobj.addpoint(touchx, touchy);
                        }

                    }


                };


            };


            tools.area = function (params) {

                var tool = this;
                var prevx = 0,
                    prevy = 0;

                var limprevx = 0,
                    limprevy = 0;

                var havesnap = false;
                var snapPoint;
                //ft 08.08.2018 changed from separate index to direct array length
                var curmarkup = DocObj.markuplist.length;
                //var curmarkup = DocObj.nummarkups;
                var areamarkupobj;

                var type = params.p1;
                var subtype = params.p2;

                this.name = 'area';
                this.anglelengthsupport = true;

                this.bUsemouseinput = true;

                this.started = false;
                this.terminated = false;
                this.LastTouchdata = -1;
                this.startx = 0;
                this.starty = 0;
                this.orgscale = 1.0;
                this.orgdx = 0.0;
                this.orgdy = 0.0;
                this.curmousepos = {x:0,y:0};


                this.setAngleLength = function(angle, length, bAutoAdvance,  type){
                    this.bUsemouseinput = false;

                    var btwoormorepoints = (areamarkupobj.points.length >= 2);

                    if (areamarkupobj != undefined && btwoormorepoints){

                        //replace with points.

                        //areamarkupobj.points[areamarkupobj.points.length - 2].x = tool.x0;
                        //areamarkupobj.points[areamarkupobj.points.length - 2].y = tool.y0;

                        //areamarkupobj.x = tool.x0;
                        //areamarkupobj.y = tool.y0;
                        var curx2 = areamarkupobj.points[areamarkupobj.points.length - 1].x;
                        var cury2 = areamarkupobj.points[areamarkupobj.points.length - 1].y;


                        var secondpoint = areamarkupobj.setAnglelengthPoints(length, angle, type);
                        //add state to markup object to change rotate adjustment bUsemouseinput
                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (MousePosdrwext({x:secondpoint.w,y:secondpoint.h})){

                            //set last point.
                            areamarkupobj.setlastpoint(secondpoint.w, secondpoint.h);
                            if(bAutoAdvance){
                                areamarkupobj.addpoint(secondpoint.w, secondpoint.h);
                            }



                            tool.setdimoffset(false);
                            areamarkupobj.drawme(context);

                        }else{
                            //set last point.
                            areamarkupobj.setlastpoint(curx2, cury2);
                            /*if(bAutoAdvance){
                                areamarkupobj.addpoint(curx2, cury2);
                            }*/


                            this.bUsemouseinput = true;
                            areamarkupobj.drawme(context);
                            areamarkupobj.bUsemouseinput = true;
                            if (RxCore_GUI_markupParamsError != undefined){
                                RxCore_GUI_markupParamsError.onDrawError('outside');
                            }

                        }

                    }

                };

                this.useMouseInput = function(){
                    tool.bUsemouseinput = true;
                };


                this.removelastPoint = function(){
                    context.clearRect(0, 0, canvas.width, canvas.height);
                    areamarkupobj.drawme(context);

                    areamarkupobj.points.splice(areamarkupobj.points.length - 1, 1);
                    areamarkupobj.setlastpoint(tool.curmousepos.x, tool.curmousepos.y);


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    areamarkupobj.drawme(context);

                };
                this.apply = function(){
                    context.clearRect(0, 0, canvas.width, canvas.height);

                    if(!tool.started){
                        return;
                    }

                    tool.started = false;
                    tool.setdimoffset(false);
                    areamarkupobj.drawme(context);
                    areamarkupobj.points.splice(areamarkupobj.points.length - 1, 1);
                    areamarkupobj.findrectangle();
                    areamarkupobj.resetcupoint();


                    if (!bMultimarkupadd) {

                        bMarkupcrated = true;
                        //ft 08.08.2018 changed from separate index to direct array length
                        //nMarkupcreated = DocObj.nummarkups;
                        nMarkupcreated = DocObj.markuplist.length;
                    }


                    areamarkupobj.savemetolistDraw();
                    //arrowmarkupobj.savemetolistLoad();
                    areamarkupobj = null;

                    drawmarkupAll(cntximg);

                    //markupobject.markupnumber = DocObj.nummarkups;         DocObj.markuplist[markupobject.markupnumber] = this;
                    img_update();

                    if (!bMultimarkupadd) {
                        //need to move to connection object.
                        //markupcreated();
                        if (RxCore_GUI_Markup != undefined) {
                            //var operation = {created : true, modified : false, deleted : false};
                            RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                        }

                    }
                };


                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }

                    if (movey < 0) {


                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == DocObj.NumPages - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {

                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);


                            if(tool.started){
                                tool.setdimoffset(false);

                                if (tool.bUsemouseinput){
                                    areamarkupobj.setlastpoint(tool.curmousepos.x, tool.curmousepos.y);
                                }

                                areamarkupobj.drawme(context);

                            }

                        }

                    } else {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {


                            DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);



                            if(tool.started){
                                tool.setdimoffset(false);

                                if (tool.bUsemouseinput){
                                    areamarkupobj.setlastpoint(tool.curmousepos.x, tool.curmousepos.y);
                                }

                                areamarkupobj.drawme(context);

                            }

                        }

                    }


                };

                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox

                        delta = -ev.deltaY*50;

                    }

                    tool.scrollhandling(delta);


                };

                this.setdimoffset = function(initial){

                    if(initial){
                        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                            areamarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                            areamarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                            areamarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                            areamarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                            areamarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                            areamarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                        } else {
                            areamarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                            areamarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                            areamarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                        }


                        tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                        tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                        tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();

                    }

                    var curscale = DocObj.pages[DocObj.currentpage].getdscale();
                    var pagedx = DocObj.pages[DocObj.currentpage].getdx();
                    var pagedy = DocObj.pages[DocObj.currentpage].getdy();

                    if(areamarkupobj){
                        var scalediff = (curscale / areamarkupobj.scaling);
                    }


                    /*if(areamarkupobj.points.length > 0){
                        areamarkupobj.drawme(context);
                    }*/


                    /*if(tool.started){
                        var lastpoint = areamarkupobj.getlastpoint();

                        if(lastpoint){
                            var changex = ((lastpoint.x - pagedx) / scalediff) + areamarkupobj.xoffset;
                            var changey = ((lastpoint.y - pagedy) / scalediff) + areamarkupobj.yoffset;

                            areamarkupobj.setlastpoint(changex, changey);

                        }


                    }*/







                };

                // This is called when you start holding down the mouse button.
                // This starts the pencil drawing.
                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        var bWithin = MousePosdrwext(mousePos);
                        if (!bWithin && bLimMarkupExtent) {
                            return;
                        }

                        if (!tool.started) {
                            areamarkupobj = new MarkupObject(type, subtype, fillstyle);
                            if (subtype == 1){
                                areamarkupobj.linewidth = 1;
                                areamarkupobj.AddAttribute('Rx_Area', '0');
                                areamarkupobj.AddAttribute('SpaceID', '0');
                            }


                            areamarkupobj.pagenumber = DocObj.getcurPage();
                            tool.setdimoffset(true);

                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                areamarkupobj.x = rotatedpoint.x;
                                areamarkupobj.y = rotatedpoint.y;
                                areamarkupobj.editaction = 0;
                                areamarkupobj.addpoint(rotatedpoint.x, rotatedpoint.y);
                                tool.started = true;
                                if(DocObj){
                                    DocObj.bMarkupchanged = true;
                                }
                                areamarkupobj.startdraw(context);
                                areamarkupobj.addpoint(rotatedpoint.x, rotatedpoint.y);


                            } else {
                                areamarkupobj.x = mousePos.x;
                                areamarkupobj.y = mousePos.y;
                                areamarkupobj.editaction = 0;
                                areamarkupobj.addpoint(mousePos.x, mousePos.y);
                                tool.started = true;
                                if(DocObj){
                                    DocObj.bMarkupchanged = true;
                                }
                                areamarkupobj.startdraw(context);
                                areamarkupobj.addpoint(mousePos.x, mousePos.y);

                            }

                        } else {
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                if (tool.bUsemouseinput){
                                    areamarkupobj.addpoint(rotatedpoint.x, rotatedpoint.y);
                                }

                            } else {

                                if (tool.bUsemouseinput){
                                    areamarkupobj.addpoint(mousePos.x, mousePos.y);
                                }

                            }

                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                };

                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        var bWithin = MousePosdrwext(mousePos);
                        if (!bWithin && bLimMarkupExtent) {
                            return;
                        }

                        if (!tool.started) {
                            areamarkupobj = new MarkupObject(type, subtype, fillstyle);

                            if (subtype == 1){
                                areamarkupobj.linewidth = 1;
                                areamarkupobj.AddAttribute('Rx_Area', '0');
                                areamarkupobj.AddAttribute('SpaceID', '0');
                            }

                            areamarkupobj.pagenumber = DocObj.getcurPage();
                            tool.setdimoffset(true);

                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                areamarkupobj.x = rotatedpoint.x;
                                areamarkupobj.y = rotatedpoint.y;
                                areamarkupobj.editaction = 0;
                                areamarkupobj.addpoint(rotatedpoint.x, rotatedpoint.y);
                                tool.started = true;
                                if(DocObj){
                                    DocObj.bMarkupchanged = true;
                                }
                                areamarkupobj.startdraw(context);
                                areamarkupobj.addpoint(rotatedpoint.x, rotatedpoint.y);


                            } else {
                                areamarkupobj.x = mousePos.x;
                                areamarkupobj.y = mousePos.y;
                                areamarkupobj.editaction = 0;
                                areamarkupobj.addpoint(mousePos.x, mousePos.y);
                                tool.started = true;
                                if(DocObj){
                                    DocObj.bMarkupchanged = true;
                                }
                                areamarkupobj.startdraw(context);
                                areamarkupobj.addpoint(mousePos.x, mousePos.y);

                            }

                        } else {
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }
                                if (tool.bUsemouseinput){
                                    areamarkupobj.addpoint(rotatedpoint.x, rotatedpoint.y);
                                }

                            } else {
                                if (tool.bUsemouseinput){
                                    areamarkupobj.addpoint(mousePos.x, mousePos.y);
                                }

                            }


                        }
                    }else{
                       prevx = mousePos.x;
                       prevy = mousePos.y;

                    }


                };

                // This function is called every time you move the mouse. Obviously, it only
                // draws if the tool.started state is set to true (when you are holding down
                // the mouse button).
                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    tool.curmousepos = mousePos;


                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        if (!tool.started) {
                            context.clearRect(0, 0, canvas.width, canvas.height);
                        }

                    } else {
                        havesnap = true;
                        if (!tool.started) {
                            drawsnap(context,snapPoint);
                        }


                    }


                    var bWithin = MousePosdrwext(mousePos);

                    if (ev.button == 2 || ev.buttons == 2) {
                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                        if (tool.started) {
                            tool.setdimoffset(false);
                        }

                    }

                    if (!tool.started) {
                        return;
                    }
                    if (bWithin || !bLimMarkupExtent) {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }
                            drawsnap(context,snapPoint);

                            if (tool.bUsemouseinput){
                                areamarkupobj.setlastpoint(rotatedpoint.x, rotatedpoint.y);
                            }

                            tool.setdimoffset(false);
                            areamarkupobj.drawme(context);

                            limprevx = rotatedpoint.x;
                            limprevy = rotatedpoint.y;

                        } else {

                            if (tool.bUsemouseinput){
                                areamarkupobj.setlastpoint(mousePos.x, mousePos.y);
                            }

                            tool.setdimoffset(false);
                            areamarkupobj.drawme(context);

                            limprevx = mousePos.x;
                            limprevy = mousePos.y;

                        }
                        if (havesnap) {
                            //drawsnap(context,snapPoint);
                        }

                        if (ev.button == 2 || ev.buttons == 2) {

                        }


                    } else {

                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (tool.bUsemouseinput){
                            areamarkupobj.setlastpoint(limprevx, limprevy);
                        }

                        areamarkupobj.drawme(context);


                    }


                };

                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        if (!tool.started) {
                            context.clearRect(0, 0, canvas.width, canvas.height);
                        }

                    } else {
                        havesnap = true;
                        if (!tool.started) {
                            drawsnap(context,snapPoint);
                        }


                    }


                    var bWithin = MousePosdrwext(mousePos);

                    if (ev.button == 2 || ev.buttons == 2) {
                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                        if (tool.started) {
                            tool.setdimoffset(false);
                        }

                    }

                    if (!tool.started) {
                        return;
                    }
                    if (bWithin || !bLimMarkupExtent) {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }
                            drawsnap(context,snapPoint);

                            if (tool.bUsemouseinput){
                                areamarkupobj.setlastpoint(rotatedpoint.x, rotatedpoint.y);
                            }

                            tool.setdimoffset(false);
                            areamarkupobj.drawme(context);

                            prevx = rotatedpoint.x;
                            prevy = rotatedpoint.y;

                        } else {
                            if (tool.bUsemouseinput){
                                areamarkupobj.setlastpoint(mousePos.x, mousePos.y);
                            }

                            tool.setdimoffset(false);
                            areamarkupobj.drawme(context);

                            prevx = mousePos.x;
                            prevy = mousePos.y;

                        }
                        if (havesnap) {
                            //drawsnap(context,snapPoint);
                        }
                        if (ev.button == 2 || ev.buttons == 2) {

                        }



                    } else {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        if (tool.bUsemouseinput){
                            areamarkupobj.setlastpoint(prevx, prevy);
                        }

                        tool.setdimoffset(false);
                        areamarkupobj.drawme(context);


                    }

                };

                // This is called when you release the mouse button.
                this.MSPointerUp = function (ev) {
                    //areamarkupobj.addpoint(mousePos.x, ev._y);
                };
                this.mouseup = function (ev) {
                    //areamarkupobj.addpoint(mousePos.x, ev._y);
                };

                this.completeArea = function(nsplice){

                    if (areamarkupobj == null){
                        return;
                    }
                        //tool.mousemove(ev);
                        //tool.started = false;
                        tool.started = false;
                        if(nsplice > 0){
                            areamarkupobj.points.splice(areamarkupobj.points.length - nsplice, nsplice);
                        }

                        areamarkupobj.findrectangle();
                        if (!bMultimarkupadd) {

                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            nMarkupcreated = DocObj.markuplist.length;
                            //nMarkupcreated = DocObj.nummarkups;
                        }

                        areamarkupobj.savemetolistDraw();
                        areamarkupobj = null;
                        img_update();
                        drawmarkupAll(cntximg);

                        if (!bMultimarkupadd) {
                            //need to move to connection object.
                            //markupcreated();
                            if (RxCore_GUI_Markup != undefined) {
                                //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            }

                        }



                };

                this.dblclick = function (ev) {
                    if (!tool.bUsemouseinput){
                        return;
                    }

                    if (tool.started) {

                        ev.target.style.cursor = 'default';
                        tool.completeArea(2);
                        //tool.mousemove(ev);
                        //tool.started = false;
                        /*tool.started = false;
                        areamarkupobj.points.splice(areamarkupobj.points.length - 2, 2);
                        areamarkupobj.findrectangle();
                        if (!bMultimarkupadd) {

                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            nMarkupcreated = DocObj.markuplist.length;
                            //nMarkupcreated = DocObj.nummarkups;
                        }

                        areamarkupobj.savemetolistDraw();
                        areamarkupobj = null;
                        img_update();
                        drawmarkupAll(cntximg);
                        ev.target.style.cursor = 'default';

                        if (!bMultimarkupadd) {
                            //need to move to connection object.
                            //markupcreated();
                            if (RxCore_GUI_Markup != undefined) {
                                //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            }

                        }*/

                    }

                };


                this.doubletap = function (ev) {

                    if (!tool.bUsemouseinput){
                        return;
                    }

                    if (tool.started) {

                        tool.completeArea(1);

                        /*tool.started = false;
                        areamarkupobj.points.splice(areamarkupobj.points.length - 1, 1);
                        areamarkupobj.findrectangle();
                        if (!bMultimarkupadd) {

                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            nMarkupcreated = DocObj.markuplist.length;
                            //nMarkupcreated = DocObj.nummarkups;
                        }

                        areamarkupobj.savemetolistDraw();
                        areamarkupobj = null;
                        img_update();
                        drawmarkupAll(cntximg);
                        //tool.terminated = true;

                        if (!bMultimarkupadd) {
                            //need to move to connection object.
                            //markupcreated();
                            if (RxCore_GUI_Markup != undefined) {
                                //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            }

                        }*/

                    }

                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;
                    var lastTouch = 0;

                    //doubletap

                    var now = new Date().getTime();
                    if (tool.LastTouchdata == -1) {
                        lastTouch = now + 1;
                    } else {
                        lastTouch = tool.LastTouchdata;

                    }
                    var delta = now - lastTouch;
                    tool.LastTouchdata = now;

                    if (delta < 500 && delta > 0) {
                        tool.doubletap(ev);
                        //alert("double tap");
                        return;
                    }

                    //doubletap

                    var bWithin = MousePosdrwext(touchPos);
                    if (!bWithin && bLimMarkupExtent) {
                        return;
                    }

                    if (!tool.started) {
                        areamarkupobj = new MarkupObject(type, subtype, fillstyle);

                        if (subtype == 1){
                            areamarkupobj.linewidth = 1;
                            areamarkupobj.AddAttribute('Rx_Area', '0');
                            areamarkupobj.AddAttribute('SpaceID', '0');
                        }

                        areamarkupobj.pagenumber = DocObj.getcurPage();
                        tool.setdimoffset(true);

                        areamarkupobj.x = touchx;
                        areamarkupobj.y = touchy;
                        areamarkupobj.editaction = 0;
                        areamarkupobj.addpoint(touchx, touchy);
                        areamarkupobj.startdraw(context);
                        areamarkupobj.addpoint(touchx, touchy);
                        tool.started = true;
                        if(DocObj){
                            DocObj.bMarkupchanged = true;
                        }

                    } else {
                        if (tool.bUsemouseinput){
                            areamarkupobj.addpoint(touchx, touchy);
                        }

                        //polygonmarkupobj.setlastpoint(touchx,touchy);
                    }


                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;
                    if (!tool.started) {
                        return;
                    }
                    var bWithin = MousePosdrwext(touchPos);
                    if (bWithin || !bLimMarkupExtent) {

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        if (tool.bUsemouseinput){
                            areamarkupobj.setlastpoint(touchPos.x, touchPos.y);
                        }

                        areamarkupobj.drawme(context);

                        prevx = touchPos.x;
                        prevy = touchPos.y;

                    } else {

                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (tool.bUsemouseinput){
                            areamarkupobj.setlastpoint(prevx, prevy);
                        }

                        areamarkupobj.drawme(context);


                    }
                    /*if (tool.started) {
                     context.clearRect(0, 0, canvas.width, canvas.height);
                     areamarkupobj.setlastpoint(touchx,touchy);
                     areamarkupobj.drawme(context);

                     }*/
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;

                    if (tool.started) {

                        if (tool.bUsemouseinput){
                            areamarkupobj.addpoint(touchx, touchy);
                        }

                    }

                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;

                    if (tool.started) {
                        if (tool.bUsemouseinput){
                            areamarkupobj.addpoint(touchx, touchy);
                        }

                    }


                };



                this.keydown = function (ev) {
                    //ev.preventDefault();
                    if(readonlymode){
                        DocObj.bMarkupLocked = readonlymode;
                    }


                    if (!documentopen || DocObj.bMarkupLocked) {
                        return;
                    }


                    switch (ev.keyCode) {
                        case 13:
                            ev.stopPropagation();
                        //tool.apply();//complete markup
                            tool.started = false;
                            tool.completeArea(1);
                            ev.target.style.cursor = 'default';

                            break;
                        case 8:
                            tool.removelastPoint();
                            //remove last point
                            break;
                        case 46:
                          //delete last point
                          break;
                    }

                };


                /*this.touchend = function (ev) {
                 ev.preventDefault();
                 if (tool.started) {
                 pencilmarkupobj.findrectangle();
                 pencilmarkupobj.savemetolist();
                 img_update();
                 //alert("touchend");
                 //tool.touchmove(ev);
                 tool.started = false;

                 pencilmarkupobj = null;
                 }
                 };*/


            };

            //the measure tool
            tools.measuretool = function (params) {

                var tool = this;
                this.name = 'measuretool';
                this.anglelengthsupport = false;

                this.started = false;
                var Unit = "mm";
                var AreaUnit = "mm\u00B2";
                this.Area = 0.0;
                this.totaldistance = 0;
                //dialog content html
                this.LastTouchdata = -1;

                var havesnap = false;
                var snapPoint;
                var btwoopoints = params.twoopoints;


                /*this.dialogtextstart = "<p><strong>Measurement Result</strong></p>\n" +
                 "        <div style='height:200px;overflow-y:scroll;border:1px solid #769dc4;padding:0 10px;width:360px;'>\n" +
                 "            <p>\n" +
                 "                <table id='MeasureInfo'>\n" +
                 "                <TR>\n" +
                 "                    <TH nowrap>Points</TH><TH nowrap align='left'>Angle</TH><TH nowrap align='left'>Distance</TH>\n" +
                 "                </TR>\n" +
                 "                <TR>\n";
                 this.tabletext = "";
                 this.dialogtextend = "                </TR>\n" +
                 "            </table>\n" +
                 "            </p>\n" +
                 "            </div>\n";

                 this.dialogfieldtext = "";

                 this.dialogcontent = "";*/
                //dialog content html

                this.points = [];
                this.numpoints = -1;

                this.lines = [];
                this.numlines = -1;

                this.lengths = [];
                this.numlengths = -1;

                this.angles = [];
                this.numangles = -1;
                this.result = {
                    points:[],
                    lines:[],
                    lengths:[],
                    angles:[],
                    numpoints:-1,
                    numlines:-1,
                    numlengths:-1,
                    numangles:-1,
                    area:0,
                    totaldistance:0
                };


                this.addToTable = function () {
                    var lcounter = 0;
                    var point1 = 0;
                    var point2 = 0;
                    var pointstext = "";
                    var angletext = "";
                    var length = 0;
                    var texttotable = "";
                    var trueangle = 0;

                    var markupscalesq = DocObj.pages[DocObj.currentpage].dscale * DocObj.pages[DocObj.currentpage].dscale;
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        markupscalesq = DocObj.pages[DocObj.currentpage].dscalevector * DocObj.pages[DocObj.currentpage].dscalevector;
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        markupscalesq = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf) * (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                    }
                    //tool.tabletext = texttotable;
                    tool.result.area = tool.PolygonArea();
                    tool.result.area = getUnitArea(tool.result.area / markupscalesq);
                    //tool.result.area = tool.result.area.toFixed(2);
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        tool.result.totaldistance = getUnitlength(tool.result.totaldistance / DocObj.pages[DocObj.currentpage].dscalevector);
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        tool.result.totaldistance = getUnitlength(tool.result.totaldistance / (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf));
                    } else {
                        tool.result.totaldistance = getUnitlength(tool.result.totaldistance / DocObj.pages[DocObj.currentpage].dscale);
                    }


                    //Unit = Unitlabel;
                    //  AreaUnit = AreaUnitlabel;


                    /*for(lcounter = 0;lcounter<tool.lengths.length;lcounter++){
                     if(lcounter>0){
                     trueangle = tool.angles[lcounter-1]*( 180 / Math.PI);
                     angletext = trueangle.toFixed(0);
                     angletext = angletext + "&deg;";
                     }else{
                     angletext = "-";
                     }


                     point1 = lcounter + 1;
                     point2 = lcounter + 2;
                     pointstext = point1 + "-" + point2;
                     length = tool.lengths[lcounter];
                     if(DocObj.pages[DocObj.currentpage].usevectorxml){
                     length = getUnitlength(length/DocObj.pages[DocObj.currentpage].dscalevector);
                     } else if (DocObj.pages[DocObj.currentpage].usepdfjs){
                     length = getUnitlength(length/(DocObj.pages[DocObj.currentpage].curpagescale*DocObj.pages[DocObj.currentpage].dscalepdf));
                     } else {
                     length = getUnitlength(length/DocObj.pages[DocObj.currentpage].dscale);
                     }

                     length = length.toFixed(2);

                     texttotable = texttotable + "<TR>";
                     texttotable = texttotable + "                    <TD nowrap>" + pointstext + "</TD>\n";
                     texttotable = texttotable + "                    <TD>\n" + angletext + "</TD>\n";
                     texttotable = texttotable + "                    <TD>\n" + length + Unit + " </TD>\n";
                     texttotable = texttotable + "</TR>";

                     }*/

                    /*var markupscalesq = DocObj.pages[DocObj.currentpage].dscale*DocObj.pages[DocObj.currentpage].dscale;
                     if(DocObj.pages[DocObj.currentpage].usevectorxml){
                     markupscalesq = DocObj.pages[DocObj.currentpage].dscalevector*DocObj.pages[DocObj.currentpage].dscalevector;
                     }else if(DocObj.pages[DocObj.currentpage].usepdfjs){
                     markupscalesq = (DocObj.pages[DocObj.currentpage].curpagescale*DocObj.pages[DocObj.currentpage].dscalepdf)*(DocObj.pages[DocObj.currentpage].curpagescale*DocObj.pages[DocObj.currentpage].dscalepdf);
                     }
                     tool.tabletext = texttotable;
                     tool.Area = tool.PolygonArea();
                     tool.Area = getUnitArea(tool.Area/markupscalesq);
                     tool.Area = tool.Area.toFixed(2);
                     if(DocObj.pages[DocObj.currentpage].usevectorxml){
                     tool.totaldistance = getUnitlength(tool.totaldistance/DocObj.pages[DocObj.currentpage].dscalevector);
                     }else if (DocObj.pages[DocObj.currentpage].usepdfjs){
                     tool.totaldistance = getUnitlength(tool.totaldistance/(DocObj.pages[DocObj.currentpage].curpagescale*DocObj.pages[DocObj.currentpage].dscalepdf));
                     }else{
                     tool.totaldistance = getUnitlength(tool.totaldistance/DocObj.pages[DocObj.currentpage].dscale);
                     }

                     tool.totaldistance = tool.totaldistance.toFixed(2);

                     this.dialogfieldtext = "<br>" +
                     "       <table>" +
                     "        <tr>" +
                     "	     <td>Distance: </td>" + "<td><input type='text' value='" + tool.totaldistance + "'> " + Unit + "</td>\n" +
                     "          </tr>" +
                     "           <tr>" +
                     "	     <td>Area: </td>" + "<td><input type='text' value='" + tool.Area + "'> " + AreaUnit + "</td>\n" +
                     "        </tr>" +
                     "        </table>" +
                     "        <br />\n" +
                     "        <br />\n";*/
                    //"        <button data-dojo-type='dijit/form/Button' data-dojo-props='onClick:hideMDialog'>OK</button>\n";


                };

                this.PolygonArea = function () {
                    var i = 0;
                    var area = 0.0;
                    var n = tool.result.points.length;


                    for (i = 0; i < n - 1; i++) {
                        area += (tool.result.points[i].x * tool.result.points[i + 1].y) - (tool.result.points[i + 1].x * tool.result.points[i].y);
                    }
                    area += (tool.result.points[n - 1].x * tool.result.points[0].y) - (tool.result.points[0].x * tool.result.points[n - 1].y);
                    return Math.abs(area / 2.0);
                };


                this.getdiag = function (width, height) {


                    var dimwsq = Math.pow(width, 2);
                    var dimhsq = Math.pow(height, 2);
                    var dimdiag = Math.sqrt((dimwsq + dimhsq));

                    return dimdiag;

                };


                this.addpoint = function (x, y) {
                    tool.result.points.push(new point(x, y));
                    tool.result.numpoints++;

                    if (btwoopoints && tool.result.numpoints === 2 && RxCore_GUI_Measurediag != undefined) {

                        tool.started = false;

                        tool.result.points.splice(2, 1);
                        tool.result.totaldistance = 0;
                        tool.calculatedistance();
                        tool.addToTable();

                        RxCore_GUI_Measurediag.setMeasureresult(tool.result);

                        tool.result.points = [];
                        tool.result.numpoints = -1;
                        tool.result.lengths = [];
                        tool.result.numlengths = -1;
                        tool.result.angles = [];
                        tool.result.numangles = -1;
                        tool.result.lines = [];
                        tool.result.numlines = -1;

                        context.clearRect(0, 0, canvas.width, canvas.height);
                        RxCore_default();



                    }


                };

                this.setlastpoint = function (x, y) {
                    tool.result.points[tool.result.points.length-1].x = x;
                    tool.result.points[tool.result.points.length-1].y = y;

                };

                this.startdraw = function (ctx) {
                    ctx.beginPath();
                    ctx.moveTo(tool.result.points[tool.result.points.length-1].x, tool.result.points[tool.result.points.length-1].y);

                };


                this.getangleofline = function (startx, starty, endx, endy, useabs) {

                    var width = 0;
                    var height = 0;

                    if (useabs) {
                        width = Math.abs(endx - startx);
                        height = Math.abs(endy - starty);
                    } else {
                        width = endx - startx;
                        height = endy - starty;
                    }

                    return Math.atan2(height, width);
                };


                this.findanglebetweenlines = function () {
                    var counter = 0;
                    var startx = 0;
                    var starty = 0;
                    var endx = 0;
                    var endy = 0;
                    var reangle = false;

                    var startAngle = 0;
                    var endAngle = 0;
                    var sumAngle = 0;

                    for (counter = 0; counter < tool.result.lines.length; counter++) {
                        if (counter > 0) {

                            if (tool.result.lines[counter - 1].height <= 0 && tool.result.lines[counter - 1].width >= 0) {
                                startAngle = tool.result.lines[counter - 1].rewangle;
                            } else if (tool.result.lines[counter - 1].width <= 0 && tool.result.lines[counter - 1].height >= 0) {
                                startAngle = tool.result.lines[counter - 1].rewangle;
                            } else if (tool.result.lines[counter - 1].width >= 0 && tool.result.lines[counter - 1].height >= 0) {
                                startAngle = tool.result.lines[counter - 1].angle;
                            } else if (tool.result.lines[counter - 1].width <= 0 && tool.result.lines[counter - 1].height <= 0) {
                                startAngle = tool.result.lines[counter - 1].angle;
                            }

                            if (tool.result.lines[counter].height <= 0 && tool.result.lines[counter].width >= 0) {

                                endAngle = tool.result.lines[counter].rewangle;
                            } else if (tool.result.lines[counter].width <= 0 && tool.result.lines[counter].height >= 0) {
                                endAngle = tool.result.lines[counter].rewangle;
                            } else if (tool.result.lines[counter].width >= 0 && tool.result.lines[counter].height >= 0) {
                                endAngle = tool.result.lines[counter].angle;
                            } else if (tool.result.lines[counter].width <= 0 && tool.result.lines[counter].height <= 0) {
                                endAngle = tool.result.lines[counter].angle;
                            }

                            sumAngle = Math.PI - Math.abs(startAngle + endAngle);
                            tool.result.angles.push(Math.abs(sumAngle));
                            tool.result.numangles++;


                        }
                    }


                };


                this.calculatedistance = function () {
                    var acounter = 0;
                    var startx = 0;
                    var starty = 0;
                    var endx = 0;
                    var endy = 0;
                    var width = 0;
                    var height = 0;
                    var length = 0;
                    var curline;


                    if (tool.result.points.length >= 2) {
                        startx = tool.result.points[0].x;
                        starty = tool.result.points[0].y;

                        for (acounter = 1; acounter < tool.result.points.length; acounter++) {

                            endx = tool.result.points[acounter].x;
                            endy = tool.result.points[acounter].y;


                            if (acounter != tool.result.points.length) {
                                width = Math.abs(endx - startx);
                                height = Math.abs(endy - starty);
                                length = tool.getdiag(width, height);
                                if (length != 0) {
                                    tool.result.lengths.push(length);
                                    tool.result.numlengths++;
                                    curline = new lineangle(startx, starty, endx, endy);
                                    tool.result.lines.push(curline);
                                    tool.result.numlines++;
                                    tool.result.totaldistance = tool.result.totaldistance + length;
                                }
                            }
                            startx = endx;
                            starty = endy;


                        }
                        if (tool.result.points.length >= 3) {
                            endx = tool.result.points[0].x;
                            endy = tool.result.points[0].y;
                            width = Math.abs(endx - startx);
                            height = Math.abs(endy - starty);
                            length = tool.getdiag(width, height);
                            curline = new lineangle(startx, starty, endx, endy);
                            tool.result.lines.push(curline);
                            tool.result.numlines++;
                            tool.result.lengths.push(length);
                            tool.result.numlengths++;
                            tool.result.totaldistance = tool.result.totaldistance + length;

                        }

                    }


                };

                this.draw = function (ctx) {
                    var counter = 0;
                    var startAngle = 0.0;
                    var endAngle = 0.0;
                    var startx = 0;
                    var starty = 0;
                    var endx = 0;
                    var endy = 0;
                    var width = 0;
                    var height = 0;
                    var arcx = 0;
                    var arcy = 0;
                    var drawangle = false;

                    //var dimarea = 0;

                    ctx.strokeStyle = "red";
                    ctx.beginPath();
                    ctx.moveTo(tool.result.points[0].x, tool.result.points[0].y);

                    for (counter = 1; counter < tool.result.points.length; counter++) {
                        ctx.lineTo(tool.result.points[counter].x, tool.result.points[counter].y);
                        if (counter > 1) {
                            startx = tool.result.points[counter - 1].x;
                            starty = tool.result.points[counter - 1].y;
                            endx = tool.result.points[counter].x;
                            endy = tool.result.points[counter].y;

                            startAngle = tool.getangleofline(startx, starty, endx, endy, false);
                            //startAngle = startAngle;

                            startx = tool.result.points[counter - 2].x;
                            starty = tool.result.points[counter - 2].y;
                            endx = tool.result.points[counter - 1].x;
                            endy = tool.result.points[counter - 1].y;
                            arcx = endx;
                            arcy = endy;

                            endAngle = tool.getangleofline(startx, starty, endx, endy, false);
                            endAngle = endAngle - Math.PI;

                            drawangle = true;


                        }
                    }
                    ctx.strokeStyle = "red";
                    ctx.lineWidth = 1;
                    ctx.closePath();
                    ctx.stroke();
                    if (drawangle) {
                        ctx.beginPath();
                        ctx.arc(arcx, arcy, 50, startAngle, endAngle, false);
                        ctx.strokeStyle = "blue";
                        ctx.lineWidth = 4;
                        ctx.stroke();

                    }


                };


                // This is called when you start holding down the mouse button.
                // This starts the measure area drawing.
                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };

                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if (!tool.started) {

                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            tool.addpoint(rotatedpoint.x, rotatedpoint.y);
                            tool.addpoint(rotatedpoint.x, rotatedpoint.y);
                        } else {
                            tool.addpoint(mousePos.x, mousePos.y);
                            tool.addpoint(mousePos.x, mousePos.y);
                        }
                        tool.started = true;

                    } else {
                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            tool.addpoint(rotatedpoint.x, rotatedpoint.y);
                        } else {
                            tool.addpoint(mousePos.x, mousePos.y);
                        }

                        /*if(tool.points[tool.numpoints].x != mousePos.x && tool.points[tool.numpoints].y != ev._y){
                         tool.addpoint(mousePos.x, ev._y);
                         }*/

                    }

                };
                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    if (!tool.started) {

                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            tool.addpoint(rotatedpoint.x, rotatedpoint.y);
                            tool.addpoint(rotatedpoint.x, rotatedpoint.y);
                        } else {
                            tool.addpoint(mousePos.x, mousePos.y);
                            tool.addpoint(mousePos.x, mousePos.y);
                        }
                        tool.started = true;


                    } else {
                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            tool.addpoint(rotatedpoint.x, rotatedpoint.y);
                        } else {
                            tool.addpoint(mousePos.x, mousePos.y);
                        }


                        /*if(tool.points[tool.numpoints].x != ev._x && tool.points[tool.numpoints].y != ev._y){
                         tool.addpoint(ev._x, ev._y);
                         }*/

                    }


                };

                // This function is called every time you move the mouse. Obviously, it only
                // draws if the tool.started state is set to true (when you are holding down
                // the mouse button).
                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    var mousePos = getMousePos(canvas, ev);
                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }


                    if (tool.started) {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            tool.setlastpoint(rotatedpoint.x, rotatedpoint.y);
                            drawsnap(context,snapPoint);

                        } else {
                            tool.setlastpoint(mousePos.x, mousePos.y);
                        }
                        tool.draw(context);
                    }

                };

                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);

                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }

                    if (tool.started) {
                        context.clearRect(0, 0, canvas.width, canvas.height);

                        if (havesnap) {

                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            tool.setlastpoint(rotatedpoint.x, rotatedpoint.y);
                            drawsnap(context,snapPoint);

                        } else {
                            tool.setlastpoint(mousePos.x, mousePos.y);
                        }


                        tool.draw(context);
                    }

                };

                // This is called when you release the mouse button.
                this.MSPointerUp = function (ev) {
                    //this.addToTable();
                };
                this.mouseup = function (ev) {
                    //this.addToTable();
                };



                this.dblclick = function (ev) {
                    if (tool.started) {
                        tool.mousemove(ev);
                        tool.started = false;

                        tool.result.points.splice(tool.result.numpoints - 1, 2);
                        tool.result.totaldistance = 0;

                        tool.calculatedistance();
                        tool.findanglebetweenlines();
                        tool.addToTable();

                        if (RxCore_GUI_Measurediag != undefined) {
                            RxCore_GUI_Measurediag.setMeasureresult(tool.result);
                        }

                        tool.result.points = [];
                        tool.result.numpoints = -1;
                        tool.result.lengths = [];
                        tool.result.numlengths = -1;
                        tool.result.angles = [];
                        tool.result.numangles = -1;
                        tool.result.lines = [];
                        tool.result.numlines = -1;


                        //show dialog here.
                        //tool.dialogcontent = tool.dialogtextstart + tool.tabletext + tool.dialogtextend  + tool.dialogfieldtext;
                        //setMContent(tool.dialogcontent);

                        context.clearRect(0, 0, canvas.width, canvas.height);

                        ev.target.style.cursor = 'default';

                        //img_update();

                    }

                };

                this.doubletap = function (ev) {
                    if (tool.started) {

                        //img_update();
                        tool.started = false;
                        tool.result.points.splice(tool.result.numpoints - 1, 1);
                        tool.result.totaldistance = 0;

                        tool.calculatedistance();
                        tool.findanglebetweenlines();
                        tool.addToTable();

                        //show dialog here.

                        if (RxCore_GUI_Measurediag != undefined) {
                            RxCore_GUI_Measurediag.setMeasureresult(tool.result);
                        }

                        tool.result.points = [];
                        tool.result.numpoints = -1;
                        tool.result.lengths = [];
                        tool.result.numlengths = -1;
                        tool.result.angles = [];
                        tool.result.numangles = -1;
                        tool.result.lines = [];
                        tool.result.numlines = -1;


                        //tool.dialogcontent = tool.dialogtextstart + tool.tabletext + tool.dialogtextend  + tool.dialogfieldtext;
                        //setMContent(tool.dialogcontent);

                        context.clearRect(0, 0, canvas.width, canvas.height);


                    }


                };

                this.touchstart = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    //alert('touchdown');
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;

                    //double tap
                    var lastTouch = 0;

                    var now = new Date().getTime();

                    if (tool.LastTouchdata == -1) {
                        lastTouch = now + 1;
                    } else {
                        lastTouch = tool.LastTouchdata;

                    }
                    var delta = now - lastTouch;
                    tool.LastTouchdata = now;

                    if (delta < 500 && delta > 0) {
                        tool.doubletap(ev);
                        return;
                        //alert("double tap");
                    }
                    //double tap

                    if (!tool.started) {

                        tool.addpoint(touchPos.x, touchPos.y);
                        //tool.startdraw(context);
                        tool.addpoint(touchPos.x, touchPos.y);
                        tool.started = true;


                    } else {
                        tool.addpoint(touchPos.x, touchPos.y);
                        //tool.addToTable();
                        //areamarkupobj.addpoint(touchx, touchy);
                        //polygonmarkupobj.setlastpoint(touchx,touchy);
                    }


                };

                this.touchmove = function (ev) {
                    ev.preventDefault();

                    var touchPos = getTouchPos(canvas, ev, 0);
                    //var touchx = touchPos.x;
                    //var touchy = touchPos.y;

                    if (tool.started) {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        tool.setlastpoint(touchPos.x, touchPos.y);
                        tool.draw(context);

                    }
                };
                this.touchcancel = function(ev){
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;

                    if (tool.started) {
                        //tool.addToTable();
                        //tool.addpoint(touchx, touchy);
                    }

                };

                this.touchend = function (ev) {
                    ev.preventDefault();
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var touchx = touchPos.x;
                    var touchy = touchPos.y;

                    if (tool.started) {
                        //tool.addToTable();
                        //tool.addpoint(touchx, touchy);
                    }


                };


            };


            // The dimension line tool.
            tools.measure = function (params) {

                var tool = this;
                var prevx = 0,
                    prevy = 0;

                var limprevx = 0,
                    limprevy = 0;

                var dimensionmarkupobj;
                var havesnap = false;
                var snapPoint;
                var subtype = params.p1;
                this.started = false;
                this.name = 'measure';
                this.anglelengthsupport = false;

                this.startx = 0;
                this.starty = 0;
                this.orgscale = 1.0;
                this.orgdx = 0.0;
                this.orgdy = 0.0;

                this.curmousepos = {x:0,y:0};

                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }

                    if (movey < 0) {


                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {
                            //DocObj.pages[DocObj.currentpage].pan_update(0,-movey);
                            if (DocObj.currentpage == DocObj.NumPages - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {

                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);



                            if(tool.started){

                                tool.setdimoffset(false);

                            }



                        }


                    } else {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {


                            DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);



                            if(tool.started){
                                tool.setdimoffset(false);


                            }

                        }

                    }


                };

                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox

                        delta = -ev.deltaY*50;

                    }

                    tool.scrollhandling(delta);


                };

                this.setdimoffset = function(initial){

                    if(initial){

                        if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                            dimensionmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscalevector;
                            dimensionmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxvector;
                            dimensionmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dyvector;
                        } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                            dimensionmarkupobj.scaling = (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf);
                            dimensionmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dxpdf;
                            dimensionmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dypdf;

                        } else {
                            dimensionmarkupobj.scaling = DocObj.pages[DocObj.currentpage].dscale;
                            dimensionmarkupobj.xoffset = DocObj.pages[DocObj.currentpage].dx;
                            dimensionmarkupobj.yoffset = DocObj.pages[DocObj.currentpage].dy;
                        }
                        tool.orgscale = dimensionmarkupobj.scaling;
                        tool.orgdx = dimensionmarkupobj.xoffset;
                        tool.orgdy = dimensionmarkupobj.yoffset;


                    }

                    var curscale = DocObj.pages[DocObj.currentpage].getdscale();
                    var pagedx = DocObj.pages[DocObj.currentpage].getdx();
                    var pagedy = DocObj.pages[DocObj.currentpage].getdy();

                    if(dimensionmarkupobj){

                        var scalediff = (curscale / dimensionmarkupobj.scaling);

                        var changex = ((dimensionmarkupobj.w - pagedx) / scalediff) + dimensionmarkupobj.xoffset;
                        var changey = ((dimensionmarkupobj.h - pagedy) / scalediff) + dimensionmarkupobj.yoffset;

                    }

                    //var newx = (tool.startx - tool.orgdx) * scalediff;
                    //var newy = (tool.starty - tool.orgdy) * scalediff;
                    //newx += pagedx;
                    //newy += pagedy;

                    //this.wscaled = (this.w - this.xoffset) * scalefactor;
                    //this.hscaled = (this.h - this.yoffset) * scalefactor;

                    //this.wscaled += pagedx;
                    //this.hscaled += pagedy;
                    //changex = ((this.wscaled + pagedx) / scalefactor) + this.xoffset;


                    //dimensionmarkupobj.w = changex;
                    //dimensionmarkupobj.h = changey;



                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if(ev.button == 0){
                        if (!tool.started) {
                            tool.started = true;
                            if(DocObj){
                                DocObj.bMarkupchanged = true;
                            }

                            if (!bWithin && bLimMarkupExtent) {
                                tool.started = false;
                                if(DocObj){
                                    DocObj.bMarkupchanged = false;
                                }
                                ev.target.style.cursor = 'default';
                                return;
                            }
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x0 = rotatedpoint.x;
                                tool.y0 = rotatedpoint.y;

                            } else {
                                tool.x0 = mousePos.x;
                                tool.y0 = mousePos.y;
                            }

                            dimensionmarkupobj = new MarkupObject(7, subtype, 0);
                            dimensionmarkupobj.pagenumber = DocObj.getcurPage();
                            dimensionmarkupobj.pagerotation = DocObj.pages[DocObj.currentpage].drotation;

                            tool.setdimoffset(true);
                            tool.startx = tool.x0;
                            tool.starty = tool.y0;

                            dimensionmarkupobj.editaction = 0;

                        } else {
                            if (bWithin || !bLimMarkupExtent) {
                                if (havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }

                                    dimensionmarkupobj.w = rotatedpoint.x;
                                    dimensionmarkupobj.h = rotatedpoint.y;

                                } else {
                                    dimensionmarkupobj.w = mousePos.x;
                                    dimensionmarkupobj.h = mousePos.y;

                                }
                                //tool.mousemove(ev);
                                context.clearRect(0, 0, canvas.width, canvas.height);
                                tool.setdimoffset(false);
                                dimensionmarkupobj.drawme(context);

                                if (!bMultimarkupadd) {

                                    bMarkupcrated = true;
                                    //ft 08.08.2018 changed from separate index to direct array length
                                    //nMarkupcreated = DocObj.nummarkups;
                                    nMarkupcreated = DocObj.markuplist.length;
                                }

                                dimensionmarkupobj.savemetolistDraw();
                                dimensionmarkupobj = null;
                                tool.started = false;
                                img_update();

                                ev.target.style.cursor = 'default';

                                if (!bMultimarkupadd) {
                                    //need to move to connection object.
                                    //markupcreated();
                                    if (RxCore_GUI_Markup != undefined) {
                                        //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                                    }

                                }
                            }


                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                };

                this.mousedown = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);

                    if(ev.button == 0){
                        if (!tool.started) {
                            tool.started = true;
                            if(DocObj){
                                DocObj.bMarkupchanged = true;
                            }


                            if (!bWithin && bLimMarkupExtent) {
                                tool.started = false;
                                if(DocObj){
                                    DocObj.bMarkupchanged = false;
                                }
                                ev.target.style.cursor = 'default';
                                return;
                            }



                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x0 = rotatedpoint.x;
                                tool.y0 = rotatedpoint.y;
                            } else {
                                tool.x0 = mousePos.x;
                                tool.y0 = mousePos.y;
                            }


                            dimensionmarkupobj = new MarkupObject(7, subtype, 0);
                            dimensionmarkupobj.pagenumber = DocObj.getcurPage();
                            dimensionmarkupobj.pagerotation = DocObj.pages[DocObj.currentpage].drotation;
                            tool.setdimoffset(true);

                            tool.startx = tool.x0;
                            tool.starty = tool.y0;

                            dimensionmarkupobj.editaction = 0;

                        } else {
                            if (bWithin || !bLimMarkupExtent) {
                                if (havesnap) {
                                    if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                        rotatedpoint = snap_rotated(snapPoint);
                                    }else{
                                        rotatedpoint = snapPoint;
                                    }

                                    dimensionmarkupobj.w = rotatedpoint.x;
                                    dimensionmarkupobj.h = rotatedpoint.y;

                                } else {
                                    dimensionmarkupobj.w = mousePos.x;
                                    dimensionmarkupobj.h = mousePos.y;

                                }
                                //tool.mousemove(ev);
                                context.clearRect(0, 0, canvas.width, canvas.height);
                                tool.setdimoffset(false);
                                dimensionmarkupobj.drawme(context);

                                if (!bMultimarkupadd) {

                                    bMarkupcrated = true;
                                    //ft 08.08.2018 changed from separate index to direct array length
                                    nMarkupcreated = DocObj.markuplist.length;
                                    //nMarkupcreated = DocObj.nummarkups;
                                }

                                dimensionmarkupobj.savemetolistDraw();
                                dimensionmarkupobj = null;
                                tool.started = false;
                                img_update();

                                ev.target.style.cursor = 'default';

                                if (!bMultimarkupadd) {
                                    //need to move to connection object.
                                    //markupcreated();
                                    if (RxCore_GUI_Markup != undefined) {
                                        //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                        // RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[DocObj.nummarkups], true);
                                        RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                                    }

                                }
                            }


                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                };

                this.touchstart = function (ev) {
                    //context.strokeStyle = "red";
                    tool.started = true;
                    if(DocObj){
                        DocObj.bMarkupchanged = true;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    if (!bWithin && bLimMarkupExtent) {
                        tool.started = false;
                        if(DocObj){
                            DocObj.bMarkupchanged = false;
                        }
                        ev.target.style.cursor = 'default';
                        return;
                    }

                    tool.x0 = touchPos.x;
                    tool.y0 = touchPos.y;
                    dimensionmarkupobj = new MarkupObject(7, 0, 0);
                    dimensionmarkupobj.pagenumber = DocObj.getcurPage();
                    dimensionmarkupobj.pagerotation = DocObj.pages[DocObj.currentpage].drotation;
                    tool.setdimoffset(true);

                    dimensionmarkupobj.editaction = 0;
                };

                this.MSPointerMove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }
                    if (ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        tool.setdimoffset(false);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                    if (!tool.started) {
                        return;
                    }

                    var bWithin = MousePosdrwext(mousePos);
                    if (bWithin || !bLimMarkupExtent) {
                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            dimensionmarkupobj.x = tool.x0;
                            dimensionmarkupobj.y = tool.y0;
                            dimensionmarkupobj.w = rotatedpoint.x;
                            dimensionmarkupobj.h = rotatedpoint.y;


                            limprevx = rotatedpoint.x;
                            limprevy = rotatedpoint.y;

                        } else {
                            dimensionmarkupobj.x = tool.x0;
                            dimensionmarkupobj.y = tool.y0;
                            dimensionmarkupobj.w = mousePos.x;
                            dimensionmarkupobj.h = mousePos.y;


                            limprevx = mousePos.x;
                            limprevy = mousePos.y;

                        }

                    } else {
                        dimensionmarkupobj.x = tool.x0;
                        dimensionmarkupobj.y = tool.y0;
                        dimensionmarkupobj.w = limprevx;
                        dimensionmarkupobj.h = limprevy;


                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);


                    if (havesnap) {
                        drawsnap(context,snapPoint);
                    }

                    if (dimensionmarkupobj.w - dimensionmarkupobj.x != 0) {
                        tool.setdimoffset(false);
                        dimensionmarkupobj.drawme(context);
                    }

                };

                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';
                    var mousePos = getMousePos(canvas, ev);
                    tool.curmousepos = mousePos;

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }
                    if (ev.button == 2 || ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        tool.setdimoffset(false);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                    if (!tool.started) {
                        return;
                    }
                    //var mousePos = getMousePos(canvas, ev);
                    var bWithin = MousePosdrwext(mousePos);
                    if (bWithin || !bLimMarkupExtent) {

                        if (havesnap) {
                            if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                var rotatedpoint = snap_rotated(snapPoint);
                            }else{
                                rotatedpoint = snapPoint;
                            }

                            dimensionmarkupobj.x = tool.x0;
                            dimensionmarkupobj.y = tool.y0;
                            dimensionmarkupobj.w = rotatedpoint.x;
                            dimensionmarkupobj.h = rotatedpoint.y;
                            limprevx = rotatedpoint.x;
                            limprevy = rotatedpoint.y;

                        } else {
                            dimensionmarkupobj.x = tool.x0;
                            dimensionmarkupobj.y = tool.y0;
                            dimensionmarkupobj.w = mousePos.x;
                            dimensionmarkupobj.h = mousePos.y;

                            limprevx = mousePos.x;
                            limprevy = mousePos.y;

                        }


                    } else {
                        dimensionmarkupobj.x = tool.x0;
                        dimensionmarkupobj.y = tool.y0;
                        dimensionmarkupobj.w = limprevx;
                        dimensionmarkupobj.h = limprevy;


                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);


                    if (havesnap) {
                        drawsnap(context,snapPoint);
                    }

                    if (dimensionmarkupobj.w - dimensionmarkupobj.x != 0) {
                        tool.setdimoffset(false);
                        dimensionmarkupobj.drawme(context);
                    }



                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    var touchPos = getTouchPos(canvas, ev, 0);
                    var bWithin = MousePosdrwext(touchPos);
                    if (bWithin || !bLimMarkupExtent) {

                        dimensionmarkupobj.x = tool.x0;
                        dimensionmarkupobj.y = tool.y0;
                        dimensionmarkupobj.w = touchPos.x;
                        dimensionmarkupobj.h = touchPos.y;


                        prevx = touchPos.x;
                        prevy = touchPos.y;

                    } else {
                        dimensionmarkupobj.x = tool.x0;
                        dimensionmarkupobj.y = tool.y0;
                        dimensionmarkupobj.w = prevx;
                        dimensionmarkupobj.h = prevy;


                    }


                    /*dimensionmarkupobj.x = tool.x0;
                     dimensionmarkupobj.y = tool.y0;
                     dimensionmarkupobj.w = touchPos.x;
                     dimensionmarkupobj.h = touchPos.y;*/

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (dimensionmarkupobj.w - dimensionmarkupobj.x != 0) {
                        dimensionmarkupobj.drawme(context);
                    }


                };

                this.MSPointerUp = function (ev) {
                    /*if (tool.started) {
                     tool.mousemove(ev);
                     dimensionmarkupobj.savemetolist();
                     dimensionmarkupobj = null;
                     tool.started = false;
                     img_update();

                     ev.target.style.cursor = 'default';

                     }*/

                };
                this.mouseup = function (ev) {
                    /*if (tool.started) {
                     tool.mousemove(ev);
                     dimensionmarkupobj.savemetolist();
                     dimensionmarkupobj = null;
                     tool.started = false;
                     img_update();
                     drawmarkupAll(cntximg);
                     ev.target.style.cursor = 'default';

                     }*/
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        if (!bMultimarkupadd) {

                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            nMarkupcreated = DocObj.markuplist.length;
                            //nMarkupcreated = DocObj.nummarkups;
                        }

                        dimensionmarkupobj.savemetolistDraw();
                        img_update();
                        //tool.touchmove(ev);
                        dimensionmarkupobj = null;
                        //alert(DocObj.pages[DocObj.currentpage].dscale);
                        if (!bMultimarkupadd) {
                            //need to move to connection object.
                            //markupcreated();
                            if (RxCore_GUI_Markup != undefined) {
                                //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            }

                        }

                    }
                };
                this.touchend = function (ev) {
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        if (!bMultimarkupadd) {

                            bMarkupcrated = true;
                            //ft 08.08.2018 changed from separate index to direct array length
                            nMarkupcreated = DocObj.markuplist.length;
                            //nMarkupcreated = DocObj.nummarkups;
                        }

                        dimensionmarkupobj.savemetolistDraw();
                        img_update();
                        //tool.touchmove(ev);
                        dimensionmarkupobj = null;
                        //alert(DocObj.pages[DocObj.currentpage].dscale);
                        if (!bMultimarkupadd) {
                            //need to move to connection object.
                            //markupcreated();
                            if (RxCore_GUI_Markup != undefined) {
                                //RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[index],true);
                                RxCore_GUI_Markup.setMarkupSelected(DocObj.markuplist[nMarkupcreated], {created : true, modified : false, deleted : false});
                            }

                        }

                    }
                };


            };

            tools.getoverlayscale = function(params){


                var tool = this;
                var page = params.p1;
                var index = params.p2;
                this.started = false;

                this.points = [];
                //this.compareref = Compareobject;
                this.pageobject = page;
                this.pageindex = index;


                this.name = 'getoverlayscale';
                this.anglelengthsupport = false;

                this.startx = 0;
                this.starty = 0;
                this.x = 0;
                this.y = 0;

                this.w = 0;
                this.h = 0;
                this.distance = 0.0;
                this.orgscale = 1.0;
                this.orgdx = 0.0;
                this.orgdy = 0.0;

                var curcanv = document.createElement('canvas');
                curcanv.width = 30;
                curcanv.height = 30;
                var curcntximg = curcanv.getContext('2d');

                curcntximg.strokeStyle = "gray";
                curcntximg.lineWidth = 1;

                curcntximg.strokeRect(0, 0,30,30);

                curcntximg.beginPath();
                curcntximg.moveTo(15, 0);
                curcntximg.lineTo(15, 14);
                curcntximg.moveTo(15, 30);
                curcntximg.lineTo(15, 16);
                curcntximg.moveTo(0, 15);
                curcntximg.lineTo(14, 15);
                curcntximg.moveTo(30, 15);
                curcntximg.lineTo(16, 15);
                curcntximg.closePath();
                curcntximg.stroke();

                var prevx = 0,
                    prevy = 0;

                var Unit = "mm";


                var havesnap = false;
                var snapPoint;


                this.dialogfieldtext = "";


                this.getdiag = function (width, height) {


                    var dimwsq = Math.pow(width, 2);
                    var dimhsq = Math.pow(height, 2);
                    var dimdiag = Math.sqrt((dimwsq + dimhsq));

                    return dimdiag;

                };

                this.getangleofline = function (startx, starty, endx, endy, useabs) {

                    var width = 0;
                    var height = 0;
                    if (useabs) {
                        width = Math.abs(endx - startx);
                        height = Math.abs(endy - starty);
                    } else {
                        width = endx - startx;
                        height = endy - starty;

                    }
                    return Math.atan2(height, width);
                };


                this.dialogtext = function () {
                    var lcounter = 0;
                    var point1 = 0;
                    var point2 = 0;
                    var pointstext = "";
                    var angletext = "";
                    var length = 0;
                    var texttotable = "";
                    var trueangle = 0;

                    Unit = Unitlabel;

                    var dimwidth = tool.w - tool.x;
                    var dimheight = tool.h - tool.y;


                    var dimdiag = tool.getdiag(dimwidth, dimheight);

                    var lineangle = tool.getangleofline(tool.x, tool.y,tool.w,tool.h, false);
                    //console.log((lineangle / (Math.PI / 180)));

                    var xoffset =  tool.x - tool.pageobject.getdx();
                    var yoffset =  tool.y - tool.pageobject.getdy();


                    var pagescale = tool.pageobject.getdscale();
                    tool.distance = dimdiag;

                    /*if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        tool.distance = getUnitlength(dimdiag / DocObj.pages[DocObj.currentpage].dscalevector);
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        tool.distance = getUnitlength(dimdiag / (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf));
                    } else {
                        tool.distance = getUnitlength(dimdiag / DocObj.pages[DocObj.currentpage].dscale);
                    }*/



                    if (tool.pageobject.usevectorxml) {
                        var pagewidth = pagescale * tool.pageobject.VectorPageObj.width;

                        //tool.distance = getUnitlength(dimdiag / tool.pageobject.dscalevector);

                        xoffset /= tool.pageobject.dscalevector;
                        yoffset /= tool.pageobject.dscalevector;


                    } else if (tool.pageobject.usepdfjs) {

                        switch(tool.pageindex){

                            case 0:
                                //pagewidth = tool.compareref.bgpagecanvas.width;

                                break;

                            case 1:
                                //pagewidth = tool.compareref.ovpagecanvas.width;


                                break;

                        }
                        //tool.distance = getUnitlength(dimdiag);
                        //tool.distance = getUnitlength(dimdiag / (tool.pageobject.curpagescale * tool.pageobject.dscalepdf));
                        tool.distance = getUnitlength(dimdiag);
                        //tool.distance *= tool.pageobject.dscalepdf;

                        pagewidth = tool.pageobject.pagecanvas.width;

                        var scaledPageWidth = tool.pageobject.pagecanvas.width * tool.pageobject.dscalepdf;
                        pagewidth = scaledPageWidth;

                        //console.log(tool.pageobject.dscalepdf);
                        //console.log(tool.distance);

                        var curpagescale  = scaledPageWidth / tool.pageobject.pdfpagewidth;
                        xoffset /= curpagescale;
                        yoffset /= curpagescale;


                    } else {
                        pagewidth = pagescale * tool.pageobject.MainImageWidth;
                        xoffset /= tool.pageobject.dscale;
                        yoffset /= tool.pageobject.dscale;


                    }

                    if(RxCore_GUI_CompareMeasure != undefined){
                        RxCore_GUI_CompareMeasure.AlignMeasure(tool.distance,lineangle,{x:xoffset,y:yoffset},pagewidth);
                    }



                };

                this.drawCross = function(ctx,mousePos){
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.strokeStyle = "gray";
                    ctx.lineWidth = 1;

                    ctx.beginPath();
                    ctx.moveTo(0, mousePos.y);
                    ctx.lineTo(mousePos.x - 1, mousePos.y);
                    ctx.moveTo(mousePos.x + 1, mousePos.y);
                    ctx.lineTo(canvas.width, mousePos.y);
                    ctx.moveTo(mousePos.x, 0);
                    ctx.lineTo(mousePos.x, mousePos.y - 1);
                    ctx.moveTo(mousePos.x, mousePos.y + 1);
                    ctx.lineTo(mousePos.x, canvas.height);
                    ctx.closePath();
                    ctx.stroke();

                };


                this.draw = function (ctx) {


                    var arrowangle = 22.5;
                    var arrowlength = nArrowSize;
                    var arrowanglerad = arrowangle / (180 / Math.PI);


                    var dimwidth = tool.w - tool.x;
                    var dimheight = tool.h - tool.y;


                    var dimanglerad = Math.atan2(dimheight, dimwidth);
                    var arrowh = Math.abs(arrowlength / Math.cos(arrowanglerad));




                    ctx.strokeStyle = "blue";
                    ctx.lineWidth = 2;


                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.w, this.h);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.strokeRect(this.x-15, this.y-15,30,30);


                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y-15);
                    ctx.lineTo(this.x, this.y-1);
                    ctx.moveTo(this.x, this.y+15);
                    ctx.lineTo(this.x, this.y+1);
                    ctx.moveTo(this.x-15, this.y);
                    ctx.lineTo(this.x-1, this.y);
                    ctx.moveTo(this.x+15, this.y);
                    ctx.lineTo(this.x+1, this.y);
                    ctx.closePath();
                    ctx.stroke();


                    ctx.strokeRect(this.w-15, this.h-15,30,30);

                    ctx.beginPath();
                    ctx.moveTo(this.w, this.h-15);
                    ctx.lineTo(this.w, this.h-1);
                    ctx.moveTo(this.w, this.h+15);
                    ctx.lineTo(this.w, this.h+1);
                    ctx.moveTo(this.w-15, this.h);
                    ctx.lineTo(this.w-1, this.h);
                    ctx.moveTo(this.w+15, this.h);
                    ctx.lineTo(this.w+1, this.h);
                    ctx.closePath();
                    ctx.stroke();



                };

                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }



                    if (movey < 0) {


                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1 && !DocObj.pagelocked) {
                            //DocObj.pages[DocObj.currentpage].pan_update(0,-movey);
                            if (DocObj.currentpage == DocObj.NumPages - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {

                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false);

                            var curscale = DocObj.pages[DocObj.currentpage].getdscale();
                            var pagedx = DocObj.pages[DocObj.currentpage].getdx();
                            var pagedy = DocObj.pages[DocObj.currentpage].getdy();


                            if(tool.started){

                                var scalediff = (curscale / tool.orgscale);
                                var newx = (tool.startx - tool.orgdx) * scalediff;
                                var newy = (tool.starty - tool.orgdy) * scalediff;
                                newx += pagedx;
                                newy += pagedy;

                                tool.x = newx;
                                tool.y = newy;

                            }



                        }


                    } else {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1 && !DocObj.pagelocked) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {


                            DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false);

                            curscale = DocObj.pages[DocObj.currentpage].getdscale();
                            pagedx = DocObj.pages[DocObj.currentpage].getdx();
                            pagedy = DocObj.pages[DocObj.currentpage].getdy();


                            if(tool.started){
                                scalediff = (curscale / tool.orgscale);
                                newx = (tool.startx - tool.orgdx) * scalediff;
                                newy = (tool.starty - tool.orgdy) * scalediff;
                                newx += pagedx;
                                newy += pagedy;

                                tool.x = newx;
                                tool.y = newy;

                            }

                        }

                    }


                };

                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox

                        delta = -ev.deltaY*50;

                    }

                    tool.scrollhandling(delta);


                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        if (!tool.started) {
                            ev.preventDefault();
                            ev.stopPropagation();

                            ev.target.style.cursor = 'crosshair';
                            //ev.target.style.cursor = 'url(' + curcanv.toDataURL() + ')15 15, auto';

                            tool.started = true;
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x = rotatedpoint.x;
                                tool.y = rotatedpoint.y;
                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.x = mousePos.x;
                                tool.y = mousePos.y;
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }

                            tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                            tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                            tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();
                            tool.startx = tool.x;
                            tool.starty = tool.y;


                        } else {

                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }

                            tool.started = false;

                            tool.dialogtext();

                            context.clearRect(0, 0, canvas.width, canvas.height);
                            ev.target.style.cursor = 'default';


                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                };
                this.mousedown = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        if (!tool.started ) {
                            ev.preventDefault();
                            ev.stopPropagation();

                            //ev.target.style.cursor = 'crosshair';
                            ev.target.style.cursor = 'url(' + curcanv.toDataURL() + ')15 15, auto';

                            tool.started = true;
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x = rotatedpoint.x;
                                tool.y = rotatedpoint.y;
                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.x = mousePos.x;
                                tool.y = mousePos.y;
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }
                            tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                            tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                            tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();
                            tool.startx = tool.x;
                            tool.starty = tool.y;


                        } else {
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }
                            tool.started = false;

                            tool.dialogtext();


                            context.clearRect(0, 0, canvas.width, canvas.height);
                            ev.target.style.cursor = 'default';

                        }
                    }else{

                        prevx = mousePos.x;
                        prevy = mousePos.y;


                    }



                };

                this.touchstart = function (ev) {

                    if (!tool.started) {
                        var touchPos = getTouchPos(canvas, ev, 0);
                        tool.started = true;
                        tool.x = touchPos.x;
                        tool.y = touchPos.y;
                        tool.w = touchPos.x;
                        tool.h = touchPos.y;

                        tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                        tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                        tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();


                    } else {
                        //tool.started = true;
                    }
                };

                this.MSPointerMove = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }


                    if (ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                    if (!tool.started) {
                        return;
                    }

                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        tool.w = rotatedpoint.x;
                        tool.h = rotatedpoint.y;

                    } else {
                        tool.w = mousePos.x;
                        tool.h = mousePos.y;

                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (ev.buttons == 2) {
                        tool.x -= xdiff;
                        tool.y -= ydiff;

                    }

                    if (tool.w - tool.x != 0) {
                        tool.draw(context);
                    }

                };
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'url(' + curcanv.toDataURL() + ')15 15, auto';

                    var mousePos = getMousePos(canvas, ev);

                    tool.drawCross(context,mousePos);

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found) {
                        havesnap = false;
                        //context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }
                    if (ev.button == 2 || ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);

                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                    if (!tool.started) {
                        return;
                    }


                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        tool.w = rotatedpoint.x;
                        tool.h = rotatedpoint.y;

                    } else {
                        tool.w = mousePos.x;
                        tool.h = mousePos.y;

                    }

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (ev.button == 2 || ev.buttons == 2) {
                        tool.x -= xdiff;
                        tool.y -= ydiff;

                    }

                    if (tool.w - tool.x != 0) {
                        tool.draw(context);
                    }

                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }

                    var touchPos = getTouchPos(canvas, ev, 0);
                    tool.w = touchPos.x;
                    tool.h = touchPos.y;

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (tool.w - tool.x != 0) {
                        tool.draw(context);
                    }


                };

                this.MSPointerUp = function (ev) {
                    if (tool.started) {

                    }

                };
                this.mouseup = function (ev) {
                    if (tool.started) {
                    }
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        tool.dialogtext();

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }

                };
                this.touchend = function (ev) {
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        tool.dialogtext();

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                };

            };

            tools.overlayscale = function (params) {

                var tool = this;
                var Compareobject = params.p1;
                this.started = false;

                this.points = [];
                this.compareref = Compareobject;


                this.name = 'overlayscale';
                this.anglelengthsupport = false;

                this.startx = 0;
                this.starty = 0;
                this.x = 0;
                this.y = 0;

                this.w = 0;
                this.h = 0;
                this.distance = 0.0;
                this.orgscale = 1.0;
                this.orgdx = 0.0;
                this.orgdy = 0.0;
                this.curmousepos = {x:0,y:0};

                var curcanv = document.createElement('canvas');
                curcanv.width = 30;
                curcanv.height = 30;
                var curcntximg = curcanv.getContext('2d');

                curcntximg.strokeStyle = "gray";
                curcntximg.lineWidth = 1;

                curcntximg.strokeRect(0, 0,30,30);

                curcntximg.beginPath();
                curcntximg.moveTo(15, 0);
                curcntximg.lineTo(15, 14);
                curcntximg.moveTo(15, 30);
                curcntximg.lineTo(15, 16);
                curcntximg.moveTo(0, 15);
                curcntximg.lineTo(14, 15);
                curcntximg.moveTo(30, 15);
                curcntximg.lineTo(16, 15);
                curcntximg.closePath();
                curcntximg.stroke();

                var prevx = 0,
                    prevy = 0;

                var Unit = "mm";


                var havesnap = false;
                var snapPoint;


                this.dialogfieldtext = "";


                this.getdiag = function (width, height) {


                    var dimwsq = Math.pow(width, 2);
                    var dimhsq = Math.pow(height, 2);
                    var dimdiag = Math.sqrt((dimwsq + dimhsq));

                    return dimdiag;

                };


                this.dialogtext = function () {
                    var lcounter = 0;
                    var point1 = 0;
                    var point2 = 0;
                    var pointstext = "";
                    var angletext = "";
                    var length = 0;
                    var texttotable = "";
                    var trueangle = 0;

                    Unit = Unitlabel;

                    var dimwidth = tool.w - tool.x;
                    var dimheight = tool.h - tool.y;

                    //tool.distance = tool.getdiag(dimwidth, dimheight);
                    var dimdiag = tool.getdiag(dimwidth, dimheight);
                    //var tempscale = MeasureScale;
                    //MeasureScale = 1.0;

                    var xoffset =  tool.x - tool.compareref.pages[tool.compareref.scaleindex].getdx();
                    var yoffset =  tool.y - tool.compareref.pages[tool.compareref.scaleindex].getdy();

                    var pagescale = tool.compareref.pages[tool.compareref.scaleindex].getdscale();
                    tool.distance = dimdiag;

                    if (tool.compareref.pages[tool.compareref.scaleindex].usevectorxml) {
                        //tool.distance = getUnitlength(dimdiag / tool.compareref.pages[tool.compareref.scaleindex].dscalevector);
                        var pagewidth = pagescale * tool.compareref.pages[tool.compareref.scaleindex].VectorPageObj.width;

                        //tool.distance = dimdiag / tool.compareref.pages[tool.compareref.scaleindex].dscalevector;
                        xoffset /= tool.compareref.pages[tool.compareref.scaleindex].dscalevector;
                        yoffset /= tool.compareref.pages[tool.compareref.scaleindex].dscalevector;

                    } else if (tool.compareref.pages[tool.compareref.scaleindex].usepdfjs) {
                        switch(tool.compareref.scaleindex){
                            case 0:
                                pagewidth = tool.compareref.bgpagecanvas.width;

                                break;

                            case 1:
                                pagewidth = tool.compareref.ovpagecanvas.width;


                                break;

                        }
                        pagewidth = tool.compareref.pages[tool.compareref.scaleindex].pagecanvas.width;
                        var curpagescale  = tool.compareref.pages[tool.compareref.scaleindex].pagecanvas.width / tool.compareref.pages[tool.compareref.scaleindex].pdfpagewidth;
                        //tool.distance = getUnitlength(dimdiag / (tool.compareref.pages[tool.compareref.scaleindex].curpagescale * tool.compareref.pages[tool.compareref.scaleindex].dscalepdf));
                        //tool.distance = dimdiag / (tool.compareref.pages[tool.compareref.scaleindex].curpagescale * tool.compareref.pages[tool.compareref.scaleindex].dscalepdf);
                        xoffset /= curpagescale;
                        yoffset /= curpagescale;


                    } else {
                        //tool.distance = getUnitlength(dimdiag / tool.compareref.pages[tool.compareref.scaleindex].dscale);
                        pagewidth = pagescale * tool.compareref.pages[tool.compareref.scaleindex].MainImageWidth;
                        xoffset /= tool.compareref.pages[tool.compareref.scaleindex].dscale;
                        yoffset /= tool.compareref.pages[tool.compareref.scaleindex].dscale;


                    }

                    //nCalibrateMeasured = tool.distance;
                    //MeasureScale = tempscale;

                    //var offsetdiag = tool.getdiag(xoffset, yoffset);



                    tool.compareref.setdistance(tool.distance,{x:xoffset,y:yoffset},pagewidth);

                    //var tempscale = MeasureScale;
                    //MeasureScale = 1.0;


                    //nCalibrateMeasured = tool.distance;
                    //MeasureScale = tempscale;

                };


                this.draw = function (ctx) {


                    var arrowangle = 22.5;
                    var arrowlength = nArrowSize;
                    var arrowanglerad = arrowangle / (180 / Math.PI);


                    var dimwidth = tool.w - tool.x;
                    var dimheight = tool.h - tool.y;


                    var dimanglerad = Math.atan2(dimheight, dimwidth);
                    var arrowh = Math.abs(arrowlength / Math.cos(arrowanglerad));


                    //var dimangleradneg = Math.PI + dimanglerad;
                    //var arrowupperangle = dimangleradneg + arrowanglerad;
                    //var arrowlowerangle = dimangleradneg - arrowanglerad;

                    //var topx = this.w + Math.cos(arrowupperangle) * arrowh;
                    //var topy = this.h + Math.sin(arrowupperangle) * arrowh;
                    //var botx = this.w + Math.cos(arrowlowerangle) * arrowh;
                    //var boty = this.h + Math.sin(arrowlowerangle) * arrowh;

                    //var sarrowupperangle = dimanglerad + arrowanglerad;
                    //var sarrowlowerangle = dimanglerad - arrowanglerad;


                    //var stopx = this.x + Math.cos(sarrowupperangle) * arrowh;
                    //var stopy = this.y + Math.sin(sarrowupperangle) * arrowh;
                    //var sbotx = this.x + Math.cos(sarrowlowerangle) * arrowh;
                    //var sboty = this.y + Math.sin(sarrowlowerangle) * arrowh;


                    ctx.strokeStyle = "blue";
                    ctx.lineWidth = 2;


                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.w, this.h);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.strokeRect(this.x-15, this.y-15,30,30);


                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y-15);
                    ctx.lineTo(this.x, this.y-1);
                    ctx.moveTo(this.x, this.y+15);
                    ctx.lineTo(this.x, this.y+1);
                    ctx.moveTo(this.x-15, this.y);
                    ctx.lineTo(this.x-1, this.y);
                    ctx.moveTo(this.x+15, this.y);
                    ctx.lineTo(this.x+1, this.y);
                    ctx.closePath();
                    ctx.stroke();

                    //arrowlines

                    /*ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(stopx, stopy);
                    ctx.closePath();
                    ctx.stroke();*/

                    /*ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(sbotx, sboty);
                    ctx.closePath();
                    ctx.stroke();*/

                    ctx.strokeRect(this.w-15, this.h-15,30,30);

                    ctx.beginPath();
                    ctx.moveTo(this.w, this.h-15);
                    ctx.lineTo(this.w, this.h-1);
                    ctx.moveTo(this.w, this.h+15);
                    ctx.lineTo(this.w, this.h+1);
                    ctx.moveTo(this.w-15, this.h);
                    ctx.lineTo(this.w-1, this.h);
                    ctx.moveTo(this.w+15, this.h);
                    ctx.lineTo(this.w+1, this.h);
                    ctx.closePath();
                    ctx.stroke();

                    /*ctx.beginPath();
                    ctx.moveTo(this.w, this.h);
                    ctx.lineTo(topx, topy);
                    ctx.closePath();
                    ctx.stroke();*/

                    /*ctx.beginPath();
                    ctx.moveTo(this.w, this.h);
                    ctx.lineTo(botx, boty);
                    ctx.closePath();
                    ctx.stroke();*/


                };

                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }



                    if (movey < 0) {


                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {
                            //DocObj.pages[DocObj.currentpage].pan_update(0,-movey);
                            if (DocObj.currentpage == DocObj.NumPages - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {

                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);

                            var curscale = DocObj.pages[DocObj.currentpage].getdscale();
                            var pagedx = DocObj.pages[DocObj.currentpage].getdx();
                            var pagedy = DocObj.pages[DocObj.currentpage].getdy();


                            if(tool.started){

                                var scalediff = (curscale / tool.orgscale);
                                var newx = (tool.startx - tool.orgdx) * scalediff;
                                var newy = (tool.starty - tool.orgdy) * scalediff;
                                newx += pagedx;
                                newy += pagedy;

                                tool.x = newx;
                                tool.y = newy;

                            }



                        }


                    } else {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {


                            DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);


                            curscale = DocObj.pages[DocObj.currentpage].getdscale();
                            pagedx = DocObj.pages[DocObj.currentpage].getdx();
                            pagedy = DocObj.pages[DocObj.currentpage].getdy();


                            if(tool.started){
                                scalediff = (curscale / tool.orgscale);
                                newx = (tool.startx - tool.orgdx) * scalediff;
                                newy = (tool.starty - tool.orgdy) * scalediff;
                                newx += pagedx;
                                newy += pagedy;

                                tool.x = newx;
                                tool.y = newy;

                            }

                        }

                    }


                };

                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox

                        delta = -ev.deltaY*50;

                    }

                    tool.scrollhandling(delta);


                };

                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        if (!tool.started) {
                            ev.preventDefault();
                            ev.stopPropagation();

                            ev.target.style.cursor = 'crosshair';
                            //ev.target.style.cursor = 'url(' + curcanv.toDataURL() + ')15 15, auto';

                            tool.started = true;
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x = rotatedpoint.x;
                                tool.y = rotatedpoint.y;
                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.x = mousePos.x;
                                tool.y = mousePos.y;
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }

                            tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                            tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                            tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();
                            tool.startx = tool.x;
                            tool.starty = tool.y;


                        } else {

                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }

                            tool.started = false;

                            tool.dialogtext();
                            /*if (RxCore_GUI_Calibratediag != undefined) {
                             RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                             }*/

                            context.clearRect(0, 0, canvas.width, canvas.height);
                            ev.target.style.cursor = 'default';


                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                };
                this.mousedown = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        if (!tool.started ) {
                            ev.preventDefault();
                            ev.stopPropagation();

                            //ev.target.style.cursor = 'crosshair';
                            ev.target.style.cursor = 'url(' + curcanv.toDataURL() + ')15 15, auto';

                            tool.started = true;
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x = rotatedpoint.x;
                                tool.y = rotatedpoint.y;
                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.x = mousePos.x;
                                tool.y = mousePos.y;
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }
                            tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                            tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                            tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();
                            tool.startx = tool.x;
                            tool.starty = tool.y;


                        } else {
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }
                            tool.started = false;

                            tool.dialogtext();

                            /*if (RxCore_GUI_Calibratediag != undefined) {
                             RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                             }*/

                            context.clearRect(0, 0, canvas.width, canvas.height);
                            ev.target.style.cursor = 'default';

                        }
                    }else{

                        prevx = mousePos.x;
                        prevy = mousePos.y;


                    }



                };

                this.touchstart = function (ev) {

                    if (!tool.started) {
                        var touchPos = getTouchPos(canvas, ev, 0);
                        tool.started = true;
                        tool.x = touchPos.x;
                        tool.y = touchPos.y;
                        tool.w = touchPos.x;
                        tool.h = touchPos.y;

                        tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                        tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                        tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();


                    } else {
                        //tool.started = true;
                        //tool.w = ev.targetTouches[0].pageX - canvas.offsetLeft;
                        //tool.h = ev.targetTouches[0].pageY - canvas.offsetTop - bannerheight;
                        //tool.started = false;
                    }
                };

                this.MSPointerMove = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    ev.preventDefault();
                    ev.stopPropagation();

                    ev.target.style.cursor = 'crosshair';
                    //ev.target.style.cursor = 'url(' + curcanv.toDataURL() + ')15 15, auto';
                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }

                    //console.log(ev.buttons);
                    if (ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }


                    if (!tool.started) {
                        return;
                    }

                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        tool.w = rotatedpoint.x;
                        tool.h = rotatedpoint.y;

                    } else {
                        tool.w = mousePos.x;
                        tool.h = mousePos.y;

                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (ev.buttons == 2) {
                        tool.x -= xdiff;
                        tool.y -= ydiff;

                    }

                    if (tool.w - tool.x != 0) {
                        tool.draw(context);
                    }

                };
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    //ev.target.style.cursor = 'crosshair';
                    ev.target.style.cursor = 'url(' + curcanv.toDataURL() + ')15 15, auto';

                    var mousePos = getMousePos(canvas, ev);

                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;


                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }
                    //console.log('button',ev.button);
                    //console.log('buttons',ev.buttons);
                    if (ev.button == 2 || ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);

                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                    if (!tool.started) {
                        return;
                    }


                    //this.x = tool.x0;
                    //dimensionmarkupobj.y = tool.y0;
                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        tool.w = rotatedpoint.x;
                        tool.h = rotatedpoint.y;

                    } else {
                        tool.w = mousePos.x;
                        tool.h = mousePos.y;

                    }

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (ev.button == 2 || ev.buttons == 2) {
                        tool.x -= xdiff;
                        tool.y -= ydiff;

                    }

                    if (tool.w - tool.x != 0) {
                        tool.draw(context);
                    }

                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }

                    var touchPos = getTouchPos(canvas, ev, 0);
                    tool.w = touchPos.x;
                    tool.h = touchPos.y;

                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (tool.w - tool.x != 0) {
                        tool.draw(context);
                    }


                };

                this.MSPointerUp = function (ev) {
                    if (tool.started) {
                        /*tool.mousemove(ev);
                         //dimensionmarkupobj.savemetolist();
                         //dimensionmarkupobj = null;
                         //tool.started = false;
                         //img_update();*/

                    }

                };
                this.mouseup = function (ev) {
                    if (tool.started) {
                        /*tool.mousemove(ev);
                         //dimensionmarkupobj.savemetolist();
                         //dimensionmarkupobj = null;
                         //tool.started = false;
                         //img_update();*/
                    }
                };
                this.touchcancel = function(ev){
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        tool.dialogtext();
                        /*if (RxCore_GUI_Calibratediag != undefined) {
                         RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                         }*/

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }

                };
                this.touchend = function (ev) {
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        tool.dialogtext();
                        /*if (RxCore_GUI_Calibratediag != undefined) {
                         RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                         }*/

                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                };
            };

            tools.calibrate = function () {

                var tool = this;
                var prevx = 0,
                    prevy = 0;
                var Unit = "mm";
                var havesnap = false;
                var snapPoint;

                this.started = false;
                this.name = 'calibrate';
                this.anglelengthsupport = false;

                this.x = 0;
                this.y = 0;

                this.w = 0;
                this.h = 0;
                this.distance = 0.0;



                this.startx = 0;
                this.starty = 0;
                this.orgscale = 1.0;
                this.orgdx = 0.0;
                this.orgdy = 0.0;
                this.curmousepos = {x:0,y:0};


                this.dialogfieldtext = "";

                this.scrollhandling = function (movey) {
                    if (!documentopen || DocObj.pages[DocObj.currentpage].usevector3Dxml) {
                        return;
                    }

                    if (movey < 0) {


                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == DocObj.NumPages - 1) {
                                if (DocObj.pages[DocObj.currentpage].endy <= canvas.height) {
                                    movey = 0;
                                }
                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {

                            DocObj.pages[DocObj.currentpage].ZoomOut(1.1, false, false, tool.curmousepos);


                            if(tool.started){
                                tool.setdimoffset(false);


                            }



                        }


                    } else {

                        if (DocObj.pages[DocObj.currentpage].usepdfjs && DocObj.pages.length > 1) {

                            if (DocObj.currentpage == 0) {
                                if (DocObj.pages[DocObj.currentpage].starty >= 0) {
                                    movey = 0;
                                }

                            }
                            DocObj.pages[DocObj.currentpage].pan_update(0, -movey);


                        } else {


                            DocObj.pages[DocObj.currentpage].ZoomIn(1.1, false, false, tool.curmousepos);



                            if(tool.started){
                                tool.setdimoffset(false);

                            }

                        }

                    }


                };

                this.wheel = function (ev) {

                    var delta = 0;
                    if (ev.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

                        delta = ev.wheelDelta;

                    } else if (ev.deltaY !== undefined) { // Firefox

                        delta = -ev.deltaY*50;

                    }

                    tool.scrollhandling(delta);


                };

                this.setdimoffset = function(initial){

                    if(initial){

                        tool.orgscale = DocObj.pages[DocObj.currentpage].getdscale();
                        tool.orgdx = DocObj.pages[DocObj.currentpage].getdx();
                        tool.orgdy = DocObj.pages[DocObj.currentpage].getdy();
                        tool.startx = tool.x;
                        tool.starty = tool.y;


                    }

                    var curscale = DocObj.pages[DocObj.currentpage].getdscale();
                    var pagedx = DocObj.pages[DocObj.currentpage].getdx();
                    var pagedy = DocObj.pages[DocObj.currentpage].getdy();

                    var scalediff = (curscale / tool.orgscale);

                    if(tool.started){
                        var newx = (tool.startx - tool.orgdx) * scalediff;
                        var newy = (tool.starty - tool.orgdy) * scalediff;
                        newx += pagedx;
                        newy += pagedy;

                        tool.x = newx;
                        tool.y = newy;


                    }




                };
                this.getdiag = function (width, height) {


                    var dimwsq = Math.pow(width, 2);
                    var dimhsq = Math.pow(height, 2);
                    var dimdiag = Math.sqrt((dimwsq + dimhsq));

                    return dimdiag;

                };


                this.dialogtext = function () {
                    var lcounter = 0;
                    var point1 = 0;
                    var point2 = 0;
                    var pointstext = "";
                    var angletext = "";
                    var length = 0;
                    var texttotable = "";
                    var trueangle = 0;

                    Unit = Unitlabel;

                    var dimwidth = tool.w - tool.x;
                    var dimheight = tool.h - tool.y;


                    var dimdiag = tool.getdiag(dimwidth, dimheight);
                    var tempscale = MeasureScale;
                    var tempscale = DocObj.pages[DocObj.currentpage].getMeasureScale();

                    MeasureScale = 1.0;
                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        tool.distance = getUnitlength(dimdiag / DocObj.pages[DocObj.currentpage].dscalevector);
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        tool.distance = getUnitlength(dimdiag / (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf));
                    } else {
                        tool.distance = getUnitlength(dimdiag / DocObj.pages[DocObj.currentpage].dscale);
                    }

                    //tool.distance = tool.distance.toFixed(2);
                    //nCalibrateMeasured = tool.distance;

                    DocObj.pages[DocObj.currentpage].setMeasureScaledirect(1);

                    if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                        nCalibrateMeasured = getUnitlength(dimdiag / DocObj.pages[DocObj.currentpage].dscalevector);
                    } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                        nCalibrateMeasured = getUnitlength(dimdiag / (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf));
                    } else {
                        nCalibrateMeasured = getUnitlength(dimdiag / DocObj.pages[DocObj.currentpage].dscale);
                    }

                    DocObj.pages[DocObj.currentpage].setMeasureScaledirect(tempscale);
                    MeasureScale = tempscale;
                    /*this.dialogfieldtext = "<br>" +
                     "       <table>" +
                     "        <tr >" +
                     "	     <td nowrap>Measured line is: " + "</td>\n" +
                     "        </tr>" +
                     "        <tr >" +
                     "	     <td nowrap>" + "<input type='text' size='10' id='Cval' value='" + tool.distance + "' onChange='SetTempCal(this.value)'> " + Unit + " long</td>\n" +
                     "        </tr>" +
                     "        </table>" +
                     "        <br />\n" +
                     "        <br />\n";*/
                    //"        <button data-dojo-type='dijit/form/Button' data-dojo-props='onClick:hideCDialogOK'>OK</button>\n" +
                    //"        <button data-dojo-type='dijit/form/Button' data-dojo-props='onClick:hideCDialogCancel'>Cancel</button>";

                };


                this.draw = function (ctx) {

                    var curscale = DocObj.pages[DocObj.currentpage].getdscale();
                    var fixedscalefactor = curscale / DocObj.pages[DocObj.currentpage].fixedScale;

                    var arrowangle = 22.5;
                    var arrowlength = nArrowSize * fixedscalefactor;
                    var arrowanglerad = arrowangle / (180 / Math.PI);


                    var dimwidth = tool.w - tool.x;
                    var dimheight = tool.h - tool.y;


                    var dimanglerad = Math.atan2(dimheight, dimwidth);
                    var arrowh = Math.abs(arrowlength / Math.cos(arrowanglerad));


                    var dimangleradneg = Math.PI + dimanglerad;
                    var arrowupperangle = dimangleradneg + arrowanglerad;
                    var arrowlowerangle = dimangleradneg - arrowanglerad;

                    var topx = this.w + Math.cos(arrowupperangle) * arrowh;
                    var topy = this.h + Math.sin(arrowupperangle) * arrowh;
                    var botx = this.w + Math.cos(arrowlowerangle) * arrowh;
                    var boty = this.h + Math.sin(arrowlowerangle) * arrowh;

                    var sarrowupperangle = dimanglerad + arrowanglerad;
                    var sarrowlowerangle = dimanglerad - arrowanglerad;


                    var stopx = this.x + Math.cos(sarrowupperangle) * arrowh;
                    var stopy = this.y + Math.sin(sarrowupperangle) * arrowh;
                    var sbotx = this.x + Math.cos(sarrowlowerangle) * arrowh;
                    var sboty = this.y + Math.sin(sarrowlowerangle) * arrowh;

                    //this.dimtext = getUnitlength(dimdiag);
                    //this.dimtext = this.dimtext.toFixed(2);

                    //this.dimtext = this.dimtext + " " + Unitlabel;


                    //ctx.font = this.measuretextheight + "pt " + "Helvetica";
                    //var dimt = ctx.measureText(this.dimtext);
                    //var dimtextwidth = dimt.width;

                    //var dimtextx = this.x + (dimwidth / 2) - (dimtextwidth / 2);
                    //var dimtexty = this.y + (dimheight / 2)- (this.measuretextheight / 2);

                    //ctx.fillStyle = this.color;
                    //ctx.fillText(this.dimtext, dimtextx, dimtexty);

                    if (DocObj.backgroundColor == "#000000") {
                        ctx.strokeStyle = "white";
                    }else{
                        ctx.strokeStyle = "black";
                    }

                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.w, this.h);
                    ctx.closePath();
                    ctx.stroke();

                    //arrowlines

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(stopx, stopy);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(sbotx, sboty);
                    ctx.closePath();
                    ctx.stroke();


                    ctx.beginPath();
                    ctx.moveTo(this.w, this.h);
                    ctx.lineTo(topx, topy);
                    ctx.closePath();
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(this.w, this.h);
                    ctx.lineTo(botx, boty);
                    ctx.closePath();
                    ctx.stroke();


                };


                this.pointermove = function (ev) {
                    tool.MSPointerMove(ev);
                };
                this.pointerdown = function (ev) {
                    tool.MSPointerDown(ev);
                };

                this.pointerup = function (ev) {
                    tool.MSPointerUp(ev);
                };


                this.MSPointerDown = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        if (!tool.started) {
                            ev.preventDefault();
                            ev.stopPropagation();

                            ev.target.style.cursor = 'crosshair';

                            tool.started = true;
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x = rotatedpoint.x;
                                tool.y = rotatedpoint.y;
                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.x = mousePos.x;
                                tool.y = mousePos.y;
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }
                            tool.setdimoffset(true);
                        } else {

                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }

                            tool.started = false;

                            tool.dialogtext();
                            if (RxCore_GUI_Calibratediag != undefined) {
                                RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                            }

                            //setCContent(tool.dialogfieldtext);
                            context.clearRect(0, 0, canvas.width, canvas.height);
                            ev.target.style.cursor = 'default';


                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }



                };
                this.mousedown = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    if(ev.button == 0){
                        if (!tool.started) {
                            ev.preventDefault();
                            ev.stopPropagation();

                            ev.target.style.cursor = 'crosshair';

                            tool.started = true;
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    var rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.x = rotatedpoint.x;
                                tool.y = rotatedpoint.y;
                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.x = mousePos.x;
                                tool.y = mousePos.y;
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }
                            tool.setdimoffset(true);
                        } else {
                            if (havesnap) {
                                if(DocObj.pages[DocObj.currentpage].drotation != 0){
                                    rotatedpoint = snap_rotated(snapPoint);
                                }else{
                                    rotatedpoint = snapPoint;
                                }

                                tool.w = rotatedpoint.x;
                                tool.h = rotatedpoint.y;

                            } else {
                                tool.w = mousePos.x;
                                tool.h = mousePos.y;

                            }
                            tool.started = false;

                            tool.dialogtext();
                            if (RxCore_GUI_Calibratediag != undefined) {
                                RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                            }

                            //setCContent(tool.dialogfieldtext);
                            context.clearRect(0, 0, canvas.width, canvas.height);
                            ev.target.style.cursor = 'default';


                        }
                    }else{
                        prevx = mousePos.x;
                        prevy = mousePos.y;


                    }




                };

                this.touchstart = function (ev) {
                    //context.strokeStyle = "red";

                    if (!tool.started) {
                        var touchPos = getTouchPos(canvas, ev, 0);
                        tool.started = true;
                        tool.x = touchPos.x;
                        tool.y = touchPos.y;
                        tool.w = touchPos.x;
                        tool.h = touchPos.y;

                    } else {
                        //tool.started = true;
                        //tool.w = ev.targetTouches[0].pageX - canvas.offsetLeft;
                        //tool.h = ev.targetTouches[0].pageY - canvas.offsetTop - bannerheight;
                        //tool.started = false;
                    }
                };

                this.MSPointerMove = function (ev) {
                    var mousePos = getMousePos(canvas, ev);
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    tool.curmousepos = mousePos;
                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;




                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }

                    if (ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);
                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                    if (!tool.started) {
                        return;
                    }

                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        tool.w = rotatedpoint.x;
                        tool.h = rotatedpoint.y;

                    } else {
                        tool.w = mousePos.x;
                        tool.h = mousePos.y;

                    }


                    context.clearRect(0, 0, canvas.width, canvas.height);
                    if (ev.buttons == 2) {
                        tool.x -= xdiff;
                        tool.y -= ydiff;

                    }

                    tool.setdimoffset(false);
                    drawsnap(context,snapPoint);
                    tool.draw(context);


                    /*if (tool.w - tool.x != 0) {
                        tool.setdimoffset(false);
                        tool.draw(context);
                    }*/

                };
                this.mousemove = function (ev) {
                    ev.preventDefault();
                    ev.stopPropagation();
                    ev.target.style.cursor = 'crosshair';

                    var mousePos = getMousePos(canvas, ev);

                    tool.curmousepos = mousePos;
                    var xdiff = prevx - mousePos.x;
                    var ydiff = prevy - mousePos.y;

                    snapPoint = DocObj.pages[DocObj.currentpage].getsnap(mousePos.x, mousePos.y);

                    if (!snapPoint.found || snapPoint == undefined) {
                        havesnap = false;
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    } else {
                        havesnap = true;
                        drawsnap(context,snapPoint);

                    }

                    if (ev.button == 2 || ev.buttons == 2) {

                        DocObj.pages[DocObj.currentpage].pan_update(xdiff, ydiff);

                        prevx = mousePos.x;
                        prevy = mousePos.y;

                    }

                    if (!tool.started) {
                        return;
                    }


                    //this.x = tool.x0;
                    //dimensionmarkupobj.y = tool.y0;
                    if (havesnap) {
                        if(DocObj.pages[DocObj.currentpage].drotation != 0){
                            var rotatedpoint = snap_rotated(snapPoint);
                        }else{
                            rotatedpoint = snapPoint;
                        }

                        tool.w = rotatedpoint.x;
                        tool.h = rotatedpoint.y;

                    } else {
                        tool.w = mousePos.x;
                        tool.h = mousePos.y;

                    }

                    context.clearRect(0, 0, canvas.width, canvas.height);

                    if (ev.button == 2 || ev.buttons == 2) {
                        tool.x -= xdiff;
                        tool.y -= ydiff;

                    }

                    tool.setdimoffset(false);
                    drawsnap(context,snapPoint);
                    tool.draw(context);



                    /*if (tool.w - tool.x != 0) {
                        tool.setdimoffset(false);
                        tool.draw(context);
                        drawsnap(context,snapPoint);
                    }*/

                };

                this.touchmove = function (ev) {
                    ev.preventDefault();
                    if (!tool.started) {
                        return;
                    }
                    //dimensionmarkupobj.x = tool.x0;
                    //dimensionmarkupobj.y = tool.y0;
                    var touchPos = getTouchPos(canvas, ev, 0);
                    tool.w = touchPos.x;
                    tool.h = touchPos.y;

                    context.clearRect(0, 0, canvas.width, canvas.height);

                    tool.draw(context);

                    /*if (tool.w - tool.x != 0) {
                        tool.draw(context);
                    }*/


                };

                this.MSPointerUp = function (ev) {
                    if (tool.started) {
                        /*tool.mousemove(ev);
                         //dimensionmarkupobj.savemetolist();
                         //dimensionmarkupobj = null;
                         //tool.started = false;
                         //img_update();*/

                    }

                };
                this.mouseup = function (ev) {
                    if (tool.started) {
                        /*tool.mousemove(ev);
                         //dimensionmarkupobj.savemetolist();
                         //dimensionmarkupobj = null;
                         //tool.started = false;
                         //img_update();*/
                    }
                };

                this.touchcancel = function(ev){
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        tool.dialogtext();
                        if (RxCore_GUI_Calibratediag != undefined) {
                            RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                        }

                        //setCContent(tool.dialogfieldtext);
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }

                };
                this.touchend = function (ev) {
                    ev.preventDefault();

                    if (tool.started) {
                        tool.started = false;
                        tool.dialogtext();
                        if (RxCore_GUI_Calibratediag != undefined) {
                            RxCore_GUI_Calibratediag.setCalibrate(tool.distance);
                        }

                        //setCContent(tool.dialogfieldtext);
                        context.clearRect(0, 0, canvas.width, canvas.height);
                    }
                };
            };

            function animate() {


                requestAnimationFrame(animate);

                //if(bPDFtemprender && !documentcompare && !DocObj.bLargePDF){
                 if(bPDFtemprender && !documentcompare){
                    if(bAnimatePDFrender){
                        //DocObj.pages[DocObj.currentpage].draw_canvas(true);
                        DocObj.draw_mpagepdf();
                    }

                    //console.log(DocObj.currentpage);
                }

                if(bAnimateLineStyle){
                    nlinestyleinterval ++;

                    if (nlinestyleinterval == 10){
                        RxCore_setLineStyleSpace(5, false);

                    }

                    if (nlinestyleinterval == 20){
                        RxCore_setLineStyleSpace(6, false);
                        nlinestyleinterval = 0;

                    }

                    if (!bAnimateready) {
                        return;
                    }
                }


                if (!documentopen || !DocObj.pages[DocObj.currentpage].usevector3Dxml || !DocObj.pages[DocObj.currentpage].Vector3DPageObj) {
                    return;
                }


                // Read more about requestAnimationFrame at http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/


                //requestAnimationFrame( animate );
                // Render the scene.
                //var cx = camera.position.x;
                //var cy = camera.position.y;
                //var cz = camera.position.z;


                //var campos = camera.position.clone();


                //DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children[0].position.copy(campos);
                //var camoffset = campos.multiplyScalar(4);
                //camoffset.x *= DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                //camoffset.y *= DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;
                //camoffset.x *= DocObj.pages[DocObj.currentpage].Vector3DPageObj.scale;


                //DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.children[0].position.add(camoffset);
                //thispage.Vector3DPageObj.scene.children[1].rotation.set(90 * Math.PI / 180,0,0);


                //DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.__lights[0].position.set(cx,cy,cz+50);
                //DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.__lights[0].position.set(cx,cy,cz);


                //DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.__lights[0].rotation.set(camera.rotation.x,camera.rotation.y,camera.rotation.z,'XYZ');
                //DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene.__lights[0].rotation.set(camera.rotation.x,camera.rotation.y,camera.rotation.z,'XYZ');


                renderer.render(DocObj.pages[DocObj.currentpage].Vector3DPageObj.scene, DocObj.pages[DocObj.currentpage].camera);
                //DocObj.pages[DocObj.currentpage].walkthroughcontrol.update(clock.getDelta());
                DocObj.pages[DocObj.currentpage].walkthroughcontrol.update(DocObj.pages[DocObj.currentpage].clock.getDelta());


                //mesh.rotation.x += 0.01;
                //mesh.rotation.y += 0.02;

                //renderer.render( scene, camera );

            }

            init();
            animate();

            if (RxCore_GUI_Ready != undefined){
                RxCore_GUI_Ready.setupComplete(initialDoc);
            }

            if (RxCore_GUI_Permissions != undefined){
                var permissions = {
                    consolidate : bCanConsolidate
                };

                RxCore_GUI_Permissions.UserPermissions(permissions);
            }


        });

        window.addEventListener('resize', function () {
            /*if (RxCore_GUI_Resize != undefined) {
                var canvasSize = {
                    w:canvasowidth,
                    h:canvasoheight
                };
                RxCore_GUI_Resize.onResize(canvasSize);
            }*/
            doResize(true);
        }, false);
        //}
    };

    function RxCore_setLayout(offsetWidth, offsetHeight) {
        defaultLayout.offsetWidth = defaultLayout.offsetWidth || offsetWidth;
        defaultLayout.offsetHeight = defaultLayout.offsetHeight || offsetHeight;
    }

    function setSmoothingEnabledEx(enabled, ctx){
        if (ctx) {
            ctx.imageSmoothingEnabled = enabled;
            ctx.mozImageSmoothingEnabled = enabled;
            ctx.msImageSmoothingEnabled = enabled;
        }
    }

    function setSmoothingEnabled(enabled) {
        //var context = canvaso.getContext('2d');

        if (contexto) {
            contexto.imageSmoothingEnabled = enabled;
            contexto.mozImageSmoothingEnabled = enabled;
            contexto.msImageSmoothingEnabled = enabled;
        }
    }

    function resizeCanvas(offsetWidth, offsetHeight) {
        //console.log(rxcontainer.clientWidth);
        //console.log(rxcontainer.clientHeight);

        offsetWidth = offsetWidth || defaultLayout.offsetWidth;
        offsetHeight = offsetHeight || defaultLayout.offsetHeight;

        /* offsetParent offsets are 0 when no position:fixed menus available */
        if (rxcontainer.offsetParent){

            offsetWidth += rxcontainer.offsetParent.offsetLeft;
            offsetHeight += rxcontainer.offsetParent.offsetTop;
        }

        canvaso.width = window.innerWidth - offsetWidth;
        canvaso.height = window.innerHeight - offsetHeight;
        canvasowidth = canvaso.width;
        canvasoheight = canvaso.height;

        if (documentopen && !DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            var curwidth = canvaso.width;
            //var curheight = canvaso.height;

            if(DocObj.pages[DocObj.currentpage].usevectorxml){
                var tempdx = DocObj.pages[DocObj.currentpage].dxvector;
                var tempdy = DocObj.pages[DocObj.currentpage].dyvector;
            }

            var scalefactor = (window.innerWidth - offsetWidth) / curwidth;
            //DocObj.pages[DocObj.currentpage].ZoomScale(scalefactor);


            /*if(curwidth < (window.innerWidth - offsetWidth)){

                scalefactor = curwidth / (window.innerWidth - offsetWidth);
                DocObj.pages[DocObj.currentpage].ZoomIn(scalefactor,false);
            }else{
                var scalefactor = (window.innerWidth - offsetWidth) / curwidth;
                DocObj.pages[DocObj.currentpage].ZoomIn(scalefactor,false);
            }*/

            if(DocObj.pages[DocObj.currentpage].usevectorxml){
                //DocObj.pages[DocObj.currentpage].dxvector = tempdx;
                //DocObj.pages[DocObj.currentpage].dyvector = tempdy;

            }

        }


        /*if (rxcontainer.clientWidth && rxcontainer.clientHeight){
            canvaso.width = rxcontainer.clientWidth;
            canvaso.height = rxcontainer.clientHeight;

        }else{

        }*/

        if(documentopen && DocObj.pages[DocObj.currentpage].usepdfjs){
            setSmoothingEnabled(false);
        }else{
            setSmoothingEnabled(true);
        }

    }

    function doResize(binternal , offsetWidth, offsetHeight) {

        // if (offsetWidth && offsetHeight) {
        // 	console.log(offsetWidth, offsetHeight);
        // 	if (offsetWidth === defaultLayout.offsetWidth && offsetHeight === defaultLayout.offsetHeight) {
        // 		console.log('here');
        // 		return;
        // 	}
        // }
        //var col1 = document.getElementById('leftcol');
        //var colwidth = col1.clientWidth;


        if (!canvaso) {
            //alert('Error: I cannot find the canvas element!');
            return;
        }

        resizeCanvas(offsetWidth, offsetHeight);

        if (documentopen && DocObj.pages[DocObj.currentpage].usevector3Dxml) {
            renderer.setSize(canvaso.width, canvaso.height);

            if (DocObj.pages[DocObj.currentpage].camera) {
                DocObj.pages[DocObj.currentpage].camera.aspect = canvaso.width / canvaso.height;
                DocObj.pages[DocObj.currentpage].camera.updateProjectionMatrix();
            }

        }


        //calculate zoom to extent initial scaling and offset
        //zoom to fit centered
        /*var yscale = canvaso.height / imageheight;
         var xscale = canvaso.width / imagewidth;
         dscale = Math.min(xscale,yscale);

         dx = (canvaso.width - (imagewidth*dscale)) / 2;
         dy = (canvaso.height - (imageheight*dscale)) / 2;*/


        //draw_image(myimage);

        canvimg.width = canvaso.width;
        canvimg.height = canvaso.height;

        canvas.width = canvaso.width;
        canvas.height = canvaso.height;

        renderer.domElement.width = canvaso.width;
        renderer.domElement.height = canvaso.height;

        if (documentopen) {
            DocObj.pages[DocObj.currentpage].resize();

        } else {

            imagewidth = splashimage.naturalWidth;
            imageheight = splashimage.naturalHeight;

            var yscale = canvaso.height / imageheight;
            var xscale = canvaso.width / imagewidth;
            var dscale = Math.min(xscale, yscale);

            var dx = (canvaso.width - (imagewidth * dscale)) / 2;
            var dy = (canvaso.height - (imageheight * dscale)) / 2;

            context.clearRect(0, 0, canvas.width, canvas.height);
            cntximg.clearRect(0, 0, canvas.width, canvas.height);
            contexto.clearRect(0, 0, canvas.width, canvas.height);

            //numLayers = 0;

            draw_image(splashimage, dx, dy, dscale);

        }

        if (binternal){
            if (RxCore_GUI_Resize != undefined) {
                var canvasSize = {
                    w:canvaso.width,
                    h:canvaso.height
                };
                RxCore_GUI_Resize.onResize(canvasSize);
            }
        }

        //if(DocObj.pages[DocObj.currentpage] != undefined){
        //DocObj.pages[DocObj.currentpage].resize();
        //}

        //drawmarkupAll(cntximg);
    }

    function RxCore_hideTextInput() {
        if (RxCore_GUI_TextInput != undefined) {
            if(DocObj && DocObj.selectedmarkup && DocObj.selectedmarkup.edit){
                RxCore_GUI_TextInput.operation.edit = false;
                RxCore_GUI_TextInput.operation.start = false;
                RxCore_GUI_TextInput.operation.create = false;
                RxCore_GUI_TextInput.operation.save = true;

                var rect = canvas.getBoundingClientRect();
                var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.x + rect.left;
                var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].rotatedrect.y + rect.top;

                //var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                //var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;

                var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;

                var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                txtrect.rotation = DocObj.pages[DocObj.currentpage].drotation;
                RxCore_GUI_TextInput.setTextInput(txtrect);


                /*var xrect  = DocObj.markuplist[DocObj.selectedmarkup.id].xscaled + rect.left;
                var yrect = DocObj.markuplist[DocObj.selectedmarkup.id].yscaled + rect.top;
                var wrect = DocObj.markuplist[DocObj.selectedmarkup.id].wscaled;
                var hrect = DocObj.markuplist[DocObj.selectedmarkup.id].hscaled;
                var txtrect = new Rectangle(xrect,yrect,wrect,hrect);
                RxCore_GUI_TextInput.setTextInput(txtrect);*/

                DocObj.markuplist[DocObj.selectedmarkup.id].selectedit = false;
                DocObj.markuplist[DocObj.selectedmarkup.id].setselect(false);

                DocObj.selectedmarkup.edit = false;
                //DocObj.setMarkupMultiselected();

            }
        }
    }

    function RxCore_documentOpened() {
        return (typeof documentopen !== 'undefined' && documentopen);
    }

    /*function RxCore_getThumbnails(callback) {
        RxCore_GUI_pagethumbs.callback = callback;
        return RxCore_GUI_pagethumbs.thumbnails;
    }*/

    /*function RxCore_get3DBlocks(callback) {
        RxCore_GUI_3DParts.callback = callback;
        return RxCore_GUI_3DParts.parts;
    }*/

    /*function RxCore_get3DInfo(callback) {
        Rxcore_GUI_3DPartInfo.callback = callback;
        return Rxcore_GUI_3DPartInfo.info;
    }*/

    /*function RxCore_getAnnotations(callback) {
        RxCore_GUI_Markuplist.callback = callback;
        return RxCore_GUI_Markuplist.annotations;
    }*/

    /*function RxCore_getGUIState(callback) {
        RxCore_GUI_State.callback = callback;
        return RxCore_GUI_State.state;
    }*/


    function RxCore_getFileInfo(callback) {
        RxCore_GUI_FileInfo.callback = callback;
        RxCore_FileInfodialog();
        return RxCore_GUI_FileInfo.fileinfo;
    }

    function RxCore_markUpSelected(callback) {
        if (callback && typeof callback === "function") {
            RxCore_GUI_Markup.connect(callback);
        }
        //markUpSelected
        //RxCore_GUI_Markup.callback = callback;
        //RxCore_GUI_Markup.
    }

    /*function RxCore_onMeasureFinished(callback) {
        RxCore_GUI_Measurediag.callback = callback;
    }*/

    /*function RxCore_onCalibrateFinished(callback) {
        RxCore_GUI_Calibratediag.callback = callback;
    }*/

    function RxCore_onTextPlaced(callback) {
        RxCore_GUI_Textdiag.callback = callback;
    }

    function RxCore_setText(text) {
        RxCore_GUI_Textdiag.setText(text);
    }

    /*function RxCore_getNoteInput(callback){

        if (callback && typeof callback === "function") {
            RxCore_GUI_Notediag.connect(callback);
        }

    }*/
    function RxCore_getTextInput(callback) {

        if (callback && typeof callback === "function") {
            connect(callback);
        }


        function connect(callback) {
            RxCore_GUI_TextInput.connect(callback);
        }

        function getText() {
            return RxCore_GUI_TextInput.getText().text
        }

        function setText(text) {
            RxCore_GUI_TextInput.setText(text);
        }

        return {
            getText: getText,
            setText: setText,
            connect: connect
        }
    }

    function RxCore_getNoteDiag(callback) {

        if (callback && typeof callback === "function") {
            connect(callback);
        }


        function connect(callback) {
            RxCore_GUI_Notediag.connect(callback);
        }

        function getText() {
            return RxCore_GUI_Notediag.getText().text;
        }

        function setText(text) {
            RxCore_GUI_Notediag.setText(text);
        }

        return {
            getText: getText,
            setText: setText,
            connect: connect
        }
    }

	function RxCore_getTextInputText() {
		return RxCore_GUI_TextInput.getText().text;
	}

	function RxCore_setTextInputText(text) {
		return RxCore_GUI_TextInput.setText(text);
	}

    function RxCore_onNotePlaced(callback) {
        RxCore_GUI_Notediag.callback = callback;
    }

    function RxCore_setNoteText(text) {
        RxCore_GUI_Notediag.setText(text);
    }

    function RxCore_ScaleonResize(toggle) {
        bDoReScaleOnSize = toggle;
    }

	function RxCore_changeTextColor(color) {
		if(bCanChangeLayer){
            RxCore_ChangeColor(color, 2);
        }

	}

    function RxCore_changeFillColorByIndex(indx,color) {
        RxCore_ChangeColorByIndex(indx,color, 0);
    }



	function RxCore_changeFillColor(color) {
		RxCore_ChangeColor(color, 0);
	}

	function RxCore_changeStrokeColor(color) {
        if(bCanChangeLayer){
            RxCore_ChangeColor(color, 1);
        }

	}

    function RxCore_printhelper() {
        return {
            areaUnitlabel:AreaUnitlabel,
            bMarkupNoLabel : bMarkupNoLabel,
            compareObj:CompareObj,
            docObj:DocObj,
            onPrintpage : RxCore_GUI_printpage,
            onPrintCompare : RxCore_GUI_printCompare,
            documentcompare:documentcompare,
            getDisplayName:GetDisplayName,
            getHatch : getHatch,
            getPageObject:GetPageObject,
            getPaperHeight:GetPaperHeight,
            getPaperWidth:GetPaperWidth,
            markupprintlist:markupprintlist,
            measureScale:MeasureScale,
            printfocus:printfocus,
            stampList:Stamplist,
            Userlist : Userlist,
            unitLabel:Unitlabel,
            unitOfMeasure:Unitofmeasure,
            unitscale:unitscale,
            getUnitArea: getUnitArea,
            xmlurlrel:xmlurlrel,
            bUseCustomrelpath : bUseCustomrelpath,
            xmlurlrelcustom : xmlurlrelcustom,
            noteimage : noteimage,
            bUseFixedScale : bUseFixedScale,
            fixedScale : DocObj.pages[DocObj.currentpage].fixedScale
        };

    }

    function RxCore_getReadOnly(){
        return readonlymode;
    }

    function RxCore_helper() {
        return {
            getUnitLabel:getUnitLabel,
            getAreaUnitLabel:getAreaUnitLabel,
            getLength:getLength

        };

        function getUnitLabel() {
            return Unitlabel;
        }

        function getAreaUnitLabel() {
            return AreaUnitlabel;
        }


        function getLength(length) {
            var res;
            if (DocObj.pages[DocObj.currentpage].usevectorxml) {
                res = getUnitlength(length / DocObj.pages[DocObj.currentpage].dscalevector);
            } else if (DocObj.pages[DocObj.currentpage].usepdfjs) {
                res = getUnitlength(length / (DocObj.pages[DocObj.currentpage].curpagescale * DocObj.pages[DocObj.currentpage].dscalepdf));
            } else {
                res = getUnitlength(length / DocObj.pages[DocObj.currentpage].dscale);
            }
            return res;
        }
    }

    /* Andriy */
    /* Init GUI Connectors */
    RxCore_GUI_2DBlockID = new Rx_2DBlockConn();
    RxCore_GUI_2DBlockInfo = new Rx_2DBlockAttributeConn();
    Rxcore_GUI_3DPartInfo = new Rx_3DPartInfoConn();
    RxCore_GUI_3DParts = new Rx_3DPartsConn();
    RxCore_GUI_Read3DComplete = new Rx_3DPartsReadComplete();
    RxCore_GUI_3DWalkthrough = new Rx_Walkthrough3DConn();
    RxCore_GUI_Calibratediag = new Rx_CalibrateConn();
    RxCore_GUI_CalibrateComplete = new Rx_CalibrateComplete();
    RxCore_GUI_CompareDiag = new Rx_CompareDialogConn();
    RxCore_GUI_CompareAlign = new Rx_CompareAlignConn();
    RxCore_GUI_CompareMeasure = new Rx_CompareMeasureConn();
    RxCore_GUI_Consolidate = new Rx_ConsolidateConn();
    RxCore_GUI_Permissions = new Rx_PermissionsConn();
    RxCore_GUI_PDFBookmarks = new Rx_GUIPDFBookmarsConn();
    RxCore_GUI_Download = new Rx_GUIDownload();
    Rxcore_GUI_exportComplete = new Rx_FileLoadComplete();
    RxCore_GUI_FileInfo = new Rx_FileInfoConn();
    Rxcore_GUI_fileLoadComplete = new Rx_FileLoadComplete();
    Rxcore_GUI_pagedimLoadComplete = new Rx_FileLoadComplete();
    Rxcore_GUI_markupLoadComplete = new Rx_MarkupLoadComplete();
    RxCore_GUI_Markup = new Rx_GUIMarkupConn();
    RxCore_GUI_MarkupLayers = new Rx_MarkupLayerConn();
    RxCore_GUI_Markuplist = new Rx_MarkupListConn();
    RxCore_GUI_MarkupLink = new Rx_GUIMarkupLinkConn();
    RxCore_GUI_MarkupUnselect = new Rx_GUIMarkupUnselectConn();
    RxCore_GUI_Measurediag = new Rx_MeasureConn();
    RxCore_GUI_Notediag = new Rx_NotediagConn();
    Rxcore_GUI_pageLoadComplete = new Rx_PageLoadComplete();
    Rxcore_GUI_PDFRenderComplete = new Rx_PDFRenderComplete();
    RxCore_GUI_pagethumbs = new Rx_PageThumbnailsConn();
    RxCore_GUI_Resize = new Rx_CanvasResize();
    RxCore_GUI_Stamps = new Rx_MarkupStampsConn();
    RxCore_GUI_CustomStamps = new Rx_CustStampGUI();
    RxCore_GUI_Symbols = new Rx_SymbolGUI();
    RxCore_GUI_State = new Rx_GUIStateConn();
    RxCore_GUI_Page = new Rx_GUIPageConn();
    RxCore_GUI_PagePosition = new Rx_PanUpdate();
    RxCore_GUI_PanUpdate = new Rx_PanUpdate();
    RxCore_GUI_PanUpdated = new Rx_PanUpdate();
    RxCore_GUI_Textdiag = new Rx_TextdiagConn();
    RxCore_GUI_TextInput = new Rx_TextInputConn();
    RxCore_GUI_Upload = new Rx_GUIUpload();
    RxCore_GUI_Users = new Rx_UserlistConn();
    RxCore_GUI_VectorBlocks = new Rx_VectorBlocksConn();
    RxCore_GUI_VectorBlocksLoaded = new Rx_VectorBlocksConn();
    RxCore_GUI_VectorLayers = new Rx_VectorLayersConn();
    RxCore_GUI_ZoomUpdate = new Rx_ZoomUpdate();
    RxCore_GUI_ZoomUpdated = new Rx_ZoomUpdate();
    RxCore_GUI_MarkupSave = new Rx_MarkupSave();
    RxCore_GUI_Ready = new Rx_Ready();
    RxCore_GUI_RotatePage = new Rx_RotateEvent();
    RxCore_GUI_HasText = new Rx_GUIhasText();
    RxCore_GUI_NumMathces = new Rx_GUITextFound();
    RxCore_GUI_printpage = new Rx_PrintPageConn();
    RxCore_GUI_printCompare = new RxPrintCompareConn();
    RxCore_GUI_markupdrawParams = new Rx_MarkupDrawEvent();
    RxCore_GUI_MarkupAreaEdit = new Rx_MarkupDrawEvent();
    RxCore_GUI_markupParamsError = new Rx_MarkupDrawErrorEvt();
    RxCore_GUI_getResponsHeaders = new Rx_GUIResponseHeaders();


    return {
        abortPDFload : RxCore_AbortPDFload,
        addMarkup : addMarkup,
        appendCustomBlockAttribute : RxCore_AppendCustomBlockAttribute,
        animateLineStyle : RxCore_animateLineStyle,
        applyAngleLength : RxCore_applyAngleLength,
        applyAngleLengthSelected : RxCore_applyAngleLengthSelected,
        applyMarkup : RxCore_ApplyMarkup,
        applyRadiusSelected : RxCore_applyRadiusSelected,
        applyWidthHeight : RxCore_applyWidthHeight,
        applyWidthHeightSelected : RxCore_applyWidthHeightSelected,
        autoLoadThumbnails : RxCore_AutoLoadThumbnails,
        backgroundColor :Rxcore_BackgroundColor,
        backgroundCustomColor :RxCore_BackgroundCustomColor,
        blockLoadMask : RxCore_BlockLoadMask,
        calibrate:RxCore_Calibrate,
        canvToImage : RxCore_canvToImage,
        change3DVectorBlock:RxCore_Change3DVectorBlock,
        changeFillColor:RxCore_changeFillColor,
        changeFillColorByIndex:RxCore_changeFillColorByIndex,
        changeMarkupLayer : RxCore_ChangeMarkupLayer,
        changeSnapState:RxCore_changeSnapState,
        changeStrokeColor:RxCore_changeStrokeColor,
        changeTextColor:RxCore_changeTextColor,
        changeColor:RxCore_ChangeColor,
        changeLabelTransp : RxCore_changeLabelTransp,
        changeTransp:RxCore_ChangeTransp,
        changeVectorBlock:RxCore_ChangeVectorBlock,
        changeVectorLayer:RxCore_ChangeVectorLayer,
        clearMarkup : RxCore_ClearMarkup,
        clipping3D : RxCore_3dClipping,
        closeAll :RxCore_CloseAll,
        closeDocument:RxCore_Closedocument,
        compare:RxCore_Compare,
        compareDialog : RxCore_Comparediag,
        compareFiles:RxCore_CompareFiles,
        compareMeasure : RxCore_CompareMesure,
        compareNudgeOffset : RxCore_CompareNudgeOffset,
        compareNudgeRotate : RxCore_CompareNudgeRotate,
        compareNudgeScale : RxCore_CompareNudgeScale,
        compareScale :RxCore_compareScale,
        consolidate : RxCore_consolidate,
        consolidatedOnly : RxCore_ConsolidatedOnly,
        //getConsolidateObj : RxCore_consolidateObj,

        copyMarkUp:RxCore_CopyMarkup,
        createCustomStamps : createCustomStamps,
        createTextRect : RxCore_CreateTextRect,
        createSpaceFromPolygon : RxCore_CreateSpaceFromPolygon,
        createSpacefromBlock : RxCore_createSpacefromBlock,
        deleteMarkUp:RxCore_DeleteMarkup,
        deleteMarkupbyGUID : deleteMarkupbyGUID,
        deletePoint : RxCore_DeletePoint,
        documentOpened:RxCore_documentOpened,
        doResize:doResize,
        drawPoints : RxCore_DrawPoints,
        endTextSearch :RxCore_endTextSearch,
        exicompareMeasure : RxCore_exicompareMeasure,
        explode3D:RxCore_3DExplode,
        explode3DDistance:RxCore_3DExplodedistance,
        exportFile : RxCore_ExportFile,
        exportFileRaster : RxCore_ExportFileRaster,
        exportPDF:RxCore_PDFExport,
        fileInfoDialog:RxCore_FileInfodialog,
        fileSelected:fileSelected,
        findBlockByAttr : RxCore_FindBlockByAttr,
        findMarkUp:RxCore_FindMarkup,
        freeLicense : FreeLicense,
        //get3DBlocks:RxCore_get3DBlocks,
        //get3DInfo:RxCore_get3DInfo,
        //getAnnotations:RxCore_getAnnotations,
        get2DVectorBlocks : RxCore_get2DVectorBlocks,
        getAllPageDimensions : RxCore_getAllPageDimensions,
        getBlockAttributes : RxCore_getBlockAttributes,
        getBookMarkPage : RxCore_getBookMarkPage,
        getCacheURL : RxCore_getCacheURL,
        getCanvasSize: RxCore_GetCanvasSize,
        getColor:RxCore_GetColor,
        getCompareColors:RxCore_GetCompareColors,
        getcurPage :RxCore_GetcurPage,
        getDisplayName : GetDisplayName,
        getPDFDocobj : RxCore_getPDFDocobj,
        getdocInfo :RxCore_GetdocInfo,
        getFillColor:RxCore_GetfillColor,
        getFillStyle :RxCore_GetFillstyle,
        getFixedScale : RxCore_GetFixedScale,
        getFont :RxCore_GetFont,
        getFileInfo :RxCore_getFileInfo,
        getLineColor:RxCore_GetlineColor,
        getLineWidth:RxCore_GetLineWidth,
        getMarkupLayers : RxCore_GetMarkupLayers,
        getMarkupXMLData : RxCore_getMarkupXMLData,
        getmarkupobjByGUID : RxCore_getmarkupobjByGUID,
        getMarkupXMLByGUID : RxCore_getMarkupXMLByGUID,
        getNoteDiag:RxCore_getNoteDiag,
        getnumSymbols : RxCore_getnumSymbols,
        getOpenFiles : RxCore_GetOpenFiles,
        getOpenFilesList : RxCore_getOpenFilesList,
        getOriginalPath : RxCore_getOriginalPath,

        getPageDimensions : RxCore_getPageDimensions,
        getPageRotation : RxCore_getPageRotation,
        getReadOnly : RxCore_getReadOnly,
        getAllSelectedMarkup : RxCore_getAllSelectedMarkup,
        getSelectedMarkup : RxCore_getSelectedMarkup,
        getSnapState :RxCore_getSnapState,
        getSymbolLibNum : RxCore_getSymbolLibNum,
        getSymbolLibPNGData : RxCore_getSymbolLibPNGData,
        getSymbolName : RxCore_getSymbolName,

        getTextColor:RxCore_GetTextColor,
        getUser : RxCore_getUser,
        getUsers : RxCore_GetUsers,
        gotoPage : RxCore_gotoPage,
        //getGUIState:RxCore_getGUIState,
        getHatchStyle:RxCore_GetHatchStyle,
        //getThumbnails:RxCore_getThumbnails,
        getTextInput:RxCore_getTextInput,
        helper:RxCore_helper,
        hideMarkUp:RxCore_HideMarkup,
        hideLabels : RxCore_hideLabels,
        hideTextInput: RxCore_hideTextInput,
        imperialUnit:RxCore_ImperialUnit,
        initialize:initialize,
        insertPoint : RxCore_InsertPoint,
        instanceReset : instanceReset,
        keepvectorColor :RxCore_KeepvectorColor,
        loadThumbnails : RxCore_LoadThumbnails,
        lockMarkupbyGUID : RxCore_LockMarkupbyGUID,
        lockMarkup : RxCore_lockMarkup,
        magnifyGlass:RxCore_MagnifyGlass,
        markupAddBlockText : RxCore_MarkupAddBlockText,
        markUpArea:RxCore_MarkupArea,
        markUpArrow:RxCore_MarkupArrow,
        markupChanged : RxCore_MarkupChanged,
        markupCircle : RxCore_MarkupCircle,
        markUpDimension:RxCore_MarkupDimension,
        markUpEdged:RxCore_MarkupEdged,
        markUpErase:RxCore_MarkupErase,
        markUpFilled:RxCore_MarkupFilled,
        markUpFreePen:RxCore_MarkupFreepen,
        markUpHatched:RxCore_MarkupHatched,
        markUpHighlight:RxCore_MarkupHighlight,
        markUpLayerDialog:RxCore_MarkupLayerdialog,
        markupLine :RxCore_MarkupLine,
        markupMeasurePath : RxCore_MarkupMeasurePath,
        markupMultiselect : RxCore_MarkupMultiselect,
        markUpNote:RxCore_MarkupNote,
        markUpOutlined:RxCore_MarkupOutlined,
        markUpPolycurve:RxCore_MarkupPolycurve,
        markUpPolyline:RxCore_MarkupPolyline,
        markUpRedraw : RxCore_MarkupRedraw,
        redactRect : RxCore_RedactRect,
        markUpRotate:RxCore_MarkupRotate,
        markUpSave:RxCore_MarkupSave,
        markupSaveCheck : RxCore_MarkupSaveCheck,
        markUpSelected:RxCore_markUpSelected,
        markUpShape:RxCore_MarkupShape,
        markupSpace : RxCore_MarkupSpace,
        markUpStamp:RxCore_StampMarkup,
        markupSymbol : Rxcore_MarkupSymbol,
        markUpSubType:RxCore_MarkupSubtype,
        markUpText:RxCore_MarkupText,
        markUpTextRect : RxCore_TextRect,
        markUpTextRectArrow : RxCore_TextRectArrow,
        markUpUndo:RxCore_MarkupUndo,
        markUpUserDialog:RxCore_MarkupUserdialog,
        measure:RxCore_Measure,
        measuredistance : RxCore_Measuredistance,
        metricUnit:RxCore_MetricUnit,
        modifyMarkup : modifyMarkup,
        moveLabelEnable : RxCore_moveLabelEnable,
        moveTo3DPart :RxCore_MoveTo3DPart,
        mSIEeventCheck : RxCore_MSIEeventCheck,
        nextMarkup:RxCore_NextMarkup,
        nextPage:RxCore_NextPage,
        noteFocus : RxCore_NoteFocus,
        //onCalibrateFinished:RxCore_onCalibrateFinished,
        //onMeasureFinished:RxCore_onMeasureFinished,
        onNotePlaced:RxCore_onNotePlaced,
        onTextPlaced:RxCore_onTextPlaced,
        openFile:RxCore_OpenFile,
        openFileCustom : RxCore_OpenFileCustom,
        openFilePages : RxCore_OpenFilePages,
        openFilePagesPDFdoc : RxCore_OpenFilePagesPDFdoc,
        openFileSilent : RxCore_OpenFileSilent,
        openMarkup : RxCore_OpenMarkup,
        openRecent:RxCore_OpenRecent,
        orbit3D:RxCore_3DOrbit,
        overlayFiles : RxCore_OverlayFiles,
        overlay : RxCore_Overlay,
        overlaymode : RxCore_overlaymode,
        pageLock :RxCore_PageLock,
        pageOnlyMarkup:RxCore_PageonlyMarkup,
        pagePos : RxCore_PagePos,
        panPage : RxCore_PanPage,
        panWindow:RxCore_PanWindow,
        pasteMarkUp:RxCore_PasteMarkup,
        pickPolygon : RxCore_PickPolygon,
        pickRxSpace : RxCore_pickRxSpace,
        prevPage:RxCore_PrevPage,
        print:RxCore_Printdocument,
        printDoc:getDocObj,
        printEx:RXCore_PrintdocOptions,
        printSizeEx:RxCore_PrintOptionsSize,
        printhelper:RxCore_printhelper,
        redrawPage : RxCore_redrawPage,
        reset3DModel:RxCore_Reset3DModel,
        resetBlocks:RxCore_resetBlocks,
        resetLayers:RxCore_resetLayers,

        restoreBlockStates : RxCore_RestoreBlockStates,
        restoreCamera : RxCore_restoreCamera,
        restoreDefault:RxCore_default,
        restoreMouseInput : RxCore_restoreMouseInput,
        restrictPan : RxCore_RestrictPan,
        rotate:RxCore_RotateDrawing,
        rotatePage : RxCore_RotatePage,
        save3DCamera : RxCore_Save3DCamera,
        scale:RxCore_scale,
        scaleOnResize:RxCore_ScaleonResize,
        select3D:RxCore_3DSelect,
        search3dAttribute : RxCore_Search3dAttribute,
        select3DVectorBlock:RxCore_Select3DVectorBlock,
        selectMarkUp:RxCore_MarkupSelect,

        selectMarkupbyGUID : RxCore_SelectMarkupbyGUID,
        selectMarkUpByIndex:RxCore_SelectMarkupbyIndex,

        selectSymbName :RxCore_selectSymbName,
        selectSymblib : RxCore_selectSymblib,
        selectVectorBlock : RxCore_SelectVectorBlock,
        selectRxSpace : RxCore_selectRxSpace,
        selectRxSpaceEdit : RxCore_selectRxSpaceEdit,
        setActiveFile : RxCore_setActiveFile,
        setArrowSize : RxCore_setArrowSize,

        setBlockColor : RxCore_setBlockColor,
        setCalibration : RxCore_setCalibration,
        setCompareFiles:RxCore_SetCompareFiles,
        setCompareColors : RxCore_setCompareColors,
        changeSpaceCustomLabel : RxCore_changeSpaceCustomLabel,
        setCompareScale : RxCore_setCompareScale,
        setConfiguration:RxCore_setConfiguration,
        setCustomLabelText : RxCore_setCustomLabelText,
        setDimOffset : RxCore_SetDimOffset,
        setdisplayBackground:RxCore_setdisplayBackground,
        setFont:RxCore_SetFont,
        setFontBold:RxCore_SetFontBold,
        setFontHeight:RxCore_SetFontHeight,
        setFontItalic:RxCore_SetFontItalic,
        setGlobalStyle:RxCore_SetGlobalStyle,
        setGUIDMarkupSelected : RxCore_SetGUIDMarkupSelected,
        setLabelSize : RxCore_setLabelSize,
        setLargePDFpageLimit : Rxcore_setLargePDFpageLimit,
        setLayout:RxCore_setLayout,
        setLineStyle:RxCore_SetLineStyle,
        setLineWidth:RxCore_SetLineWidth,
        setLineWidthUnits : RxCore_SetLineWidthUnits,
        setMarkupLayer:RxCore_SetMarkupLayer,
        setMarkupXMLData : RxCore_setMarkupXMLData,
        setPageDimensions : RxCore_setPageDimensions,
        setPDFAnimateRender : RxCore_setPDFAnimateRender,
        setPDFinitalZoomAll : RxCore_setPDFinitalZoomAll,
        setRxSpaceColor : RxCore_setRxSpaceColor,
        setscrollZoomKey : RxCore_SetScrollZoomKey,
        setSingleDocument : RxCore_SetSingleDocument,
        setSpaceID : RxCore_setSpaceID,
        setText:RxCore_setText,
        setUnit:RxCore_SetUnit,
        showMarkupLabels : RxCore_showMarkupLabels,
        spaceEdit : RxCore_SpaceEdit,
        suspendDraw : RxCore_suspendDraw,
        switchPages : RxCore_switchpages,
        textSearch:RxCore_textSearch,
        textSelect : RxCore_TextSelect,
        toggle3DVisible :RxCore_3DToggleVisible,
        toggleBackground :RxCore_togglebackground,
        transparency3D : RxCore_3DTransparency,
        unSelectAllMarkup:RxCore_unSelectAllMarkup,
        unSelectMarkupbyGUID : RxCore_unSelectMarkupbyGUID,
        useCredentials : RxCore_UseCredentials,
        useFixedScale : RxCore_UseFixedScale,
        useFraction : RxCore_UseFraction,
        useOrtho : RxCore_UseOrtho,
        vectorBlocksAll : RxCore_BlocksAll,
        vectorLayersAll : RxCore_LayersAll,
        viewMode : RxCore_SetViewMode,
        walkThrough3D:RxCore_3DWalkThrough,
        xmlurl:RxCore_xmlurl,
        xmlurlEx : RxCore_xmlurlEx,
        zoomToBlock : RxCore_ZoomToBlock,
        zoomFit:RxCore_ZoomFit,
        zoomHeight:RxCore_ZoomHeight,
        zoomWidth:RxCore_ZoomWidth,
        zoomIn:RxCore_ZoomIn,
        zoomOut:RxCore_ZoomOut,
        zoomPageUpdate: RxCore_ZoomPageUpdate,
        zoomWindow:RxCore_ZoomWindow,
        setEndPoints : RxCore_setEndPoints,
        setMarkUpHatch:RxCore_MarkupHatch,
        setNoteText:RxCore_setNoteText,
		setTextInputText: RxCore_setTextInputText,
		getTextInputText: RxCore_getTextInputText,
        setThumbnailctx : RxCore_SetThumbnailctx,
        //setUser : RxCore_SetUser,
        transparent3DOn : RxCore_3DTransparentOn,
        zoomMarkup:RxCore_ZoomMarkup,

        /* GUI connectors */
        GUI_2DBlockID : RxCore_GUI_2DBlockID,
        GUI_2DBlockInfo : RxCore_GUI_2DBlockInfo,
        GUI_3DPartInfo:Rxcore_GUI_3DPartInfo,
        GUI_3DParts:RxCore_GUI_3DParts,
        GUI_3DWalkthrough:RxCore_GUI_3DWalkthrough,
        GUI_Calibratediag:RxCore_GUI_Calibratediag,
        GUI_CalibrateComplete : RxCore_GUI_CalibrateComplete,
        GUI_CompareDiag:RxCore_GUI_CompareDiag,
        GUI_CompareMeasure : RxCore_GUI_CompareMeasure,
        GUI_CompareAlign : RxCore_GUI_CompareAlign,
        GUI_Consolidate : RxCore_GUI_Consolidate,
        GUI_Download:RxCore_GUI_Download,
        GUI_exportComplete : Rxcore_GUI_exportComplete,
        GUI_FileInfo:RxCore_GUI_FileInfo,
        GUI_FileLoadComplete : Rxcore_GUI_fileLoadComplete,

        GUI_getResponsHeaders : RxCore_GUI_getResponsHeaders,
        GUI_HasText : RxCore_GUI_HasText,

        GUI_Markup:RxCore_GUI_Markup,
        GUI_MarkupLayers:RxCore_GUI_MarkupLayers,
        GUI_MarkupLink : RxCore_GUI_MarkupLink,
        GUI_Markuplist:RxCore_GUI_Markuplist,

        GUI_MarkupLoadComplete : Rxcore_GUI_markupLoadComplete,
        GUI_markupdrawParams : RxCore_GUI_markupdrawParams,
        GUI_markupParamsError : RxCore_GUI_markupParamsError,
        GUI_MarkupAreaEdit : RxCore_GUI_MarkupAreaEdit,

        GUI_MarkupSave : RxCore_GUI_MarkupSave,
        GUI_MarkupUnselect : RxCore_GUI_MarkupUnselect,
        GUI_Measurediag:RxCore_GUI_Measurediag,
        GUI_Notediag:RxCore_GUI_Notediag,
        GUI_NumMathces : RxCore_GUI_NumMathces,
        GUI_pageLoadComplete : Rxcore_GUI_pageLoadComplete,
        GUI_pagedimLoadComplete : Rxcore_GUI_pagedimLoadComplete,
        GUI_pagethumbs:RxCore_GUI_pagethumbs,
        GUI_PagePosition : RxCore_GUI_PagePosition,
        GUI_Page : RxCore_GUI_Page,
        GUI_PanUpdate : RxCore_GUI_PanUpdate,
        GUI_PanUpdated : RxCore_GUI_PanUpdated,
        GUI_PDFBookmarks : RxCore_GUI_PDFBookmarks,
        GUI_PDFRenderComplete : Rxcore_GUI_PDFRenderComplete,
        GUI_Permissions : RxCore_GUI_Permissions,
        GUI_Read3DComplete : RxCore_GUI_Read3DComplete,
        GUI_Ready :RxCore_GUI_Ready,
        GUI_RotatePage : RxCore_GUI_RotatePage,
        GUI_Resize : RxCore_GUI_Resize,
        GUI_Stamps:RxCore_GUI_Stamps,
        GUI_CustomStamps : RxCore_GUI_CustomStamps,
        GUI_State:RxCore_GUI_State,
        GUI_Symbols : RxCore_GUI_Symbols,
        GUI_Textdiag:RxCore_GUI_Textdiag,
        GUI_TextInput : RxCore_GUI_TextInput,
        GUI_Upload:RxCore_GUI_Upload,
        GUI_Users:RxCore_GUI_Users,
        GUI_VectorBlocks:RxCore_GUI_VectorBlocks,
        GUI_VectorBlocksLoaded : RxCore_GUI_VectorBlocksLoaded,
        GUI_VectorLayers:RxCore_GUI_VectorLayers,
        GUI_ZoomUpdate : RxCore_GUI_ZoomUpdate,
        GUI_ZoomUpdated : RxCore_GUI_ZoomUpdated
    };
    }
    return RxCore;
})();
var RxCore = RxCoreMulti();
